SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim
Sourced 1 time
Total time:   0.000642000
 Self time:   0.000642000

count     total (s)      self (s)
                            " Vim support file to define the default menus
                            " You can also use this as a start for your own set of menus.
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Note that ":an" (short for ":anoremenu") is often used to make a menu work
                            " in all modes and avoid side effects from mappings defined by the user.
                            
                            " Make sure the '<' and 'C' flags are not included in 'cpoptions', otherwise
                            " <CR> would not be recognized.  See ":help 'cpoptions'".
    1              0.000002000 let s:cpo_save = &cpo
    1              0.000001000 set cpo&vim
                            
                            " Avoid installing the menus twice
    1              0.000002000 if !exists("did_install_default_menus")
                            let did_install_default_menus = 1
                            
                            
                            if exists("v:lang") || &langmenu != ""
                              " Try to find a menu translation file for the current language.
                              if &langmenu != ""
                                if &langmenu =~ "none"
                                  let s:lang = ""
                                else
                                  let s:lang = &langmenu
                                endif
                              else
                                let s:lang = v:lang
                              endif
                              " A language name must be at least two characters, don't accept "C"
                              " Also skip "en_US" to avoid picking up "en_gb" translations.
                              if strlen(s:lang) > 1 && s:lang !~? '^en_us'
                                " When the language does not include the charset add 'encoding'
                                if s:lang =~ '^\a\a$\|^\a\a_\a\a$'
                                  let s:lang = s:lang .. '.' .. &enc
                                endif
                            
                                " We always use a lowercase name.
                                " Change "iso-8859" to "iso_8859" and "iso8859" to "iso_8859", some
                                " systems appear to use this.
                                " Change spaces to underscores.
                                let s:lang = substitute(tolower(s:lang), '\.iso-', ".iso_", "")
                                let s:lang = substitute(s:lang, '\.iso8859', ".iso_8859", "")
                                let s:lang = substitute(s:lang, " ", "_", "g")
                                " Remove "@euro", otherwise "LC_ALL=de_DE@euro gvim" will show English menus
                                let s:lang = substitute(s:lang, "@euro", "", "")
                                " Change "iso_8859-1" and "iso_8859-15" to "latin1", we always use the
                                " same menu file for them.
                                let s:lang = substitute(s:lang, 'iso_8859-15\=$', "latin1", "")
                                menutrans clear
                                exe "runtime! lang/menu_" .. s:lang .. ".vim"
                            
                                if !exists("did_menu_trans")
                                  " There is no exact match, try matching with a wildcard added
                                  " (e.g. find menu_de_de.iso_8859-1.vim if s:lang == de_DE).
                                  let s:lang = substitute(s:lang, '\.[^.]*', "", "")
                                  exe "runtime! lang/menu_" .. s:lang .. "[^a-z]*vim"
                            
                                  if !exists("did_menu_trans") && s:lang =~ '_'
                            	" If the language includes a region try matching without that region.
                            	" (e.g. find menu_de.vim if s:lang == de_DE).
                            	let langonly = substitute(s:lang, '_.*', "", "")
                            	exe "runtime! lang/menu_" .. langonly .. "[^a-z]*vim"
                                  endif
                            
                                  if !exists("did_menu_trans") && strlen($LANG) > 1 && s:lang !~ '^en_us'
                            	" On windows locale names are complicated, try using $LANG, it might
                            	" have been set by set_init_1().  But don't do this for "en" or "en_us".
                            	" But don't match "slovak" when $LANG is "sl".
                            	exe "runtime! lang/menu_" .. tolower($LANG) .. "[^a-z]*vim"
                                  endif
                                endif
                              endif
                            endif
                            
                            
                            " MacVim Window menu (should be next to Help so give it a high priority)
                            if has("gui_macvim")
                              an <silent> 9998.300 Window.Minimize		    <Nop>
                              an <silent> 9998.301 Window.Minimize\ All	    <Nop>
                              an <silent> 9998.310 Window.Zoom		    <Nop>
                              an <silent> 9998.311 Window.Zoom\ All		    <Nop>
                              an 9998.318 Window.-SEP1-			    <Nop>
                              an <silent> 9998.320 Window.Toggle\ Full\ Screen\ Mode :set invfullscreen<CR>
                              tln <silent> 9998.320 Window.Toggle\ Full\ Screen\ Mode <C-W>:set invfullscreen<CR>
                              an 9998.330 Window.-SEP2-			    <Nop>
                              " TODO! Grey out if no tabs are visible.
                              an <silent> 9998.340 Window.Show\ Next\ Tab	    :tabnext<CR>
                              tln <silent> 9998.340 Window.Show\ Next\ Tab	<C-W>:tabnext<CR>
                              an <silent> 9998.350 Window.Show\ Previous\ Tab :tabprevious<CR>
                              tln <silent> 9998.350 Window.Show\ Previous\ Tab <C-W>:tabprevious<CR>
                              an 9998.360 Window.-SEP3-			    <Nop>
                              an <silent> 9998.370 Window.Bring\ All\ To\ Front <Nop>
                              an <silent> 9998.380 Window.Stay\ in\ Front <Nop>
                              an <silent> 9998.390 Window.Stay\ in\ Back <Nop>
                              an <silent> 9998.400 Window.Stay\ Level\ Normal <Nop>
                            endif
                            
                            " Help menu
                            if has("gui_macvim")
                              an 9999.1 &Help.MacVim\ Help		    :h gui_mac<CR>
                              tln 9999.1 &Help.MacVim\ Help		    <C-W>:h gui_mac<CR>
                              an <silent> 9999.2 &Help.MacVim\ Website   <Nop>
                              an 9999.3 &Help.What's\ New        <Nop>
                              tln 9999.3 &Help.What's\ New        <Nop>
                              an 9999.4 &Help.Release\ Notes        <Cmd>silent !open https://github.com/macvim-dev/macvim/releases<CR>
                              tln 9999.4 &Help.Release\ Notes        <Cmd>silent !open https://github.com/macvim-dev/macvim/releases<CR>
                              an 9999.5 &Help.-sep0-		    <Nop>
                            endif
                            if has("gui_macvim")
                              " Run vimtutor in GUI mode. Need to make sure to override the PATH so we use
                              " this app instead of accidentally opening another installed Vim/MacVim.
                              an 9999.6 &Help.Vim\ Tutor       :silent call system('PATH="$VIM/../../bin":/usr/bin:/bin:/usr/sbin:/sbin $VIM/../../bin/vimtutor -g&')<CR>
                              tln 9999.6 &Help.Vim\ Tutor      <C-W>:silent call system('PATH="$VIM/../../bin":/usr/bin:/bin:/usr/sbin:/sbin $VIM/../../bin/vimtutor -g&')<CR>
                              an 9999.7 &Help.-sep-vim-tutor-  <Nop>
                            endif
                            an 9999.10 &Help.&Overview<Tab><F1>	:help<CR>
                            an 9999.20 &Help.&User\ Manual		:help usr_toc<CR>
                            an 9999.30 &Help.&How-To\ Links		:help how-to<CR>
                            an <silent> 9999.40 &Help.&Find\.\.\.	:call <SID>Helpfind()<CR>
                            an 9999.45 &Help.-sep1-			<Nop>
                            an 9999.50 &Help.&Credits		:help credits<CR>
                            an 9999.60 &Help.Co&pying		:help copying<CR>
                            an 9999.70 &Help.&Sponsor/Register	:help sponsor<CR>
                            an 9999.70 &Help.O&rphans		:help kcc<CR>
                            an 9999.75 &Help.-sep2-			<Nop>
                            an 9999.80 &Help.&Version		:version<CR>
                            an 9999.90 &Help.&About			:intro<CR>
                            
                            if exists(':tlmenu')
                              tlnoremenu 9999.10 &Help.&Overview<Tab><F1>		<C-W>:help<CR>
                              tlnoremenu 9999.20 &Help.&User\ Manual		<C-W>:help usr_toc<CR>
                              tlnoremenu 9999.30 &Help.&How-To\ Links		<C-W>:help how-to<CR>
                              tlnoremenu <silent> 9999.40 &Help.&Find\.\.\.		<C-W>:call <SID>Helpfind()<CR>
                              tlnoremenu 9999.45 &Help.-sep1-			<Nop>
                              tlnoremenu 9999.50 &Help.&Credits			<C-W>:help credits<CR>
                              tlnoremenu 9999.60 &Help.Co&pying			<C-W>:help copying<CR>
                              tlnoremenu 9999.70 &Help.&Sponsor/Register		<C-W>:help sponsor<CR>
                              tlnoremenu 9999.70 &Help.O&rphans			<C-W>:help kcc<CR>
                              tlnoremenu 9999.75 &Help.-sep2-			<Nop>
                              tlnoremenu 9999.80 &Help.&Version			<C-W>:version<CR>
                              tlnoremenu 9999.90 &Help.&About			<C-W>:intro<CR>
                            endif
                            
                            def s:Helpfind()
                              if !exists("g:menutrans_help_dialog")
                                g:menutrans_help_dialog = "Enter a command or word to find help on:\n\nPrepend i_ for Input mode commands (e.g.: i_CTRL-X)\nPrepend c_ for command-line editing commands (e.g.: c_<Del>)\nPrepend ' for an option name (e.g.: 'shiftwidth')"
                              endif
                              var h = inputdialog(g:menutrans_help_dialog)
                              if h != ""
                                v:errmsg = ""
                                silent! exe "help " .. h
                                if v:errmsg != ""
                                  echo v:errmsg
                                endif
                              endif
                            enddef
                            
                            " File menu
                            if has("gui_macvim")
                              an <silent> 10.290 &File.New\ Window                          <Nop>
                              an <silent> 10.291 &File.New\ Clean\ Window		        <Nop>
                              an <silent> 10.292 &File.New\ Clean\ Window\ (No\ Defaults)   <Nop>
                              an  10.295 &File.New\ Tab			    :tabnew<CR>
                              tln 10.295 &File.New\ Tab			    <C-W>:tabnew<CR>
                              an <silent> 10.310 &File.Open…		    <Nop>
                              an <silent> 10.325 &File.Open\ Recent		    <Nop>
                              an 10.328 &File.-SEP0-			    <Nop>
                              an <silent> 10.330 &File.Close\ Window<Tab>:qa    :conf qa<CR>
                              tln <silent> 10.330 &File.Close\ Window<Tab>:qa   <C-W>:conf qa<CR>
                              an <silent> 10.332 &File.Close<Tab>:q		    :conf q<CR>
                              tln <silent> 10.332 &File.Close<Tab>:q		    <C-W>:conf q<CR>
                              an <silent> 10.341 &File.Save\ All		    :browse conf wa<CR>
                              an 10.350 &File.Save\ As…<Tab>:sav	    :browse confirm saveas<CR>
                            else
                            endif
                            if !has("gui_macvim")
                              an 10.310 &File.&Open\.\.\.<Tab>:e		:browse confirm e<CR>
                            endif
                            an 10.320 &File.Sp&lit-Open\.\.\.<Tab>:sp	:browse sp<CR>
                            an 10.320 &File.Open\ &Tab\.\.\.<Tab>:tabnew	:browse tabnew<CR>
                            if !has("gui_macvim")
                              an 10.325 &File.&New<Tab>:enew		:confirm enew<CR>
                              an <silent> 10.330 &File.&Close<Tab>:close
                            	\ :if winheight(2) < 0 && tabpagewinnr(2) == 0 <Bar>
                            	\   confirm enew <Bar>
                            	\ else <Bar>
                            	\   confirm close <Bar>
                            	\ endif<CR>
                              tln <silent> 10.330 &File.&Close<Tab>:close
                                  \ <C-W>:if winheight(2) < 0 && tabpagewinnr(2) == 0 <Bar>
                                  \   confirm enew <Bar>
                                  \ else <Bar>
                                  \   confirm close <Bar>
                                  \ endif<CR>
                            endif
                            an 10.335 &File.-SEP1-				<Nop>
                            an <silent> 10.340 &File.&Save<Tab>:w		:if expand("%") == ""<Bar>browse confirm w<Bar>else<Bar>confirm w<Bar>endif<CR>
                            if !has("gui_macvim")
                              an 10.350 &File.Save\ &As\.\.\.<Tab>:sav	:browse confirm saveas<CR>
                            endif
                            
                            if has("diff")
                              an 10.400 &File.-SEP2-			<Nop>
                              an 10.410 &File.Split\ &Diff\ With\.\.\.	:browse vert diffsplit<CR>
                              an 10.420 &File.Split\ Patched\ &By\.\.\.	:browse vert diffpatch<CR>
                            endif
                            
                            if has("printer")
                              an 10.500 &File.-SEP3-			<Nop>
                              an 10.510 &File.&Print			:hardcopy<CR>
                              vunmenu   &File.&Print
                              vnoremenu &File.&Print			:hardcopy<CR>
                            elseif has("unix")
                              an 10.500 &File.-SEP3-			<Nop>
                              an 10.510 &File.&Print			:w !lpr<CR>
                              vunmenu   &File.&Print
                              vnoremenu &File.&Print			:w !lpr<CR>
                            endif
                            if !has("gui_macvim")
                              an 10.600 &File.-SEP4-				<Nop>
                              an 10.610 &File.Sa&ve-Exit<Tab>:wqa		:confirm wqa<CR>
                              an 10.620 &File.E&xit<Tab>:qa			:confirm qa<CR>
                            endif
                            
                            def s:SelectAll()
                              exe "norm! gg" .. (&slm == "" ? "VG" : "gH\<C-O>G")
                            enddef
                            
                            " Edit menu
                            an 20.310 &Edit.&Undo<Tab>u			u
                            an 20.320 &Edit.&Redo<Tab>^R			<C-R>
                            an 20.330 &Edit.Rep&eat<Tab>\.			.
                            
                            an 20.335 &Edit.-SEP1-				<Nop>
                            vnoremenu 20.340 &Edit.Cu&t<Tab>"+x		"+x
                            vnoremenu 20.350 &Edit.&Copy<Tab>"+y		"+y
                            cnoremenu 20.350 &Edit.&Copy<Tab>"+y		<C-Y>
                            if exists(':tlmenu')
                              tlnoremenu 20.350 &Edit.&Copy<Tab>"+y 	<C-W>:<C-Y><CR>
                            endif
                            nnoremenu 20.360 &Edit.&Paste<Tab>"+gP		"+gP
                            cnoremenu	 &Edit.&Paste<Tab>"+gP		<C-R>+
                            if exists(':tlmenu')
                              tlnoremenu	 &Edit.&Paste<Tab>"+gP		<C-W>"+
                            endif
                            exe 'vnoremenu <script> &Edit.&Paste<Tab>"+gP	' .. paste#paste_cmd['v']
                            exe 'inoremenu <script> &Edit.&Paste<Tab>"+gP	' .. paste#paste_cmd['i']
                            nnoremenu 20.370 &Edit.Put\ &Before<Tab>[p	[p
                            inoremenu	 &Edit.Put\ &Before<Tab>[p	<C-O>[p
                            nnoremenu 20.380 &Edit.Put\ &After<Tab>]p	]p
                            inoremenu	 &Edit.Put\ &After<Tab>]p	<C-O>]p
                            if has("win32")
                              vnoremenu 20.390 &Edit.&Delete<Tab>x		x
                            endif
                            noremenu  <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	:<C-U>call <SID>SelectAll()<CR>
                            inoremenu <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	<C-O>:call <SID>SelectAll()<CR>
                            cnoremenu <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	<C-U>call <SID>SelectAll()<CR>
                            
                            an 20.405	 &Edit.-SEP2-				<Nop>
                            if has("win32") || has("gui_gtk") || has("gui_kde") || has("gui_motif")
                              an 20.410	 &Edit.&Find\.\.\.			:promptfind<CR>
                              vunmenu	 &Edit.&Find\.\.\.
                              vnoremenu <silent>	 &Edit.&Find\.\.\.		y:promptfind <C-R>=<SID>FixFText()<CR><CR>
                              an 20.420	 &Edit.Find\ and\ Rep&lace\.\.\.	:promptrepl<CR>
                              vunmenu	 &Edit.Find\ and\ Rep&lace\.\.\.
                              vnoremenu <silent>	 &Edit.Find\ and\ Rep&lace\.\.\. y:promptrepl <C-R>=<SID>FixFText()<CR><CR>
                            elseif has("gui_macvim")
                              an <silent> 20.410.10 &Edit.Find.Find…	:promptfind<CR>
                              vunmenu &Edit.Find.Find…
                              vnoremenu <silent> &Edit.Find.Find…	y:promptfind <C-R>=<SID>FixFText()<CR><CR>
                              an 20.410.20 &Edit.Find.Find\ Next			<Nop>
                              an 20.410.30 &Edit.Find.Find\ Previous		<Nop>
                              vnoremenu 20.410.35 &Edit.Find.Use\ Selection\ for\ Find	<Nop>
                            else
                              an 20.410	 &Edit.&Find<Tab>/			/
                              an 20.420	 &Edit.Find\ and\ Rep&lace<Tab>:%s	:%s/
                              vunmenu	 &Edit.Find\ and\ Rep&lace<Tab>:%s
                              vnoremenu	 &Edit.Find\ and\ Rep&lace<Tab>:s	:s/
                            endif
                            
                            an 20.425	 &Edit.-SEP3-				<Nop>
                            an 20.430	 &Edit.Settings\ &Window		:options<CR>
                            an 20.435	 &Edit.Startup\ &Settings		:call <SID>EditVimrc()<CR>
                            
                            def s:EditVimrc()
                              var fname: string
                              if $MYVIMRC != ''
                                fname = $MYVIMRC
                              elseif has("win32")
                                if $HOME != ''
                                  fname = $HOME .. "/_vimrc"
                                else
                                  fname = $VIM .. "/_vimrc"
                                endif
                              elseif has("amiga")
                                fname = "s:.vimrc"
                              else
                                fname = $HOME .. "/.vimrc"
                              endif
                              fname = fnameescape(fname)
                              if &mod
                                exe "split " .. fname
                              else
                                exe "edit " .. fname
                              endif
                            enddef
                            
                            def s:FixFText(): string
                              # Fix text in nameless register to be used with :promptfind.
                              return substitute(@", "[\r\n]", '\\n', 'g')
                            enddef
                            
                            " Edit/Global Settings
                            an 20.440.100 &Edit.&Global\ Settings.Toggle\ Pattern\ &Highlight<Tab>:set\ hls!	:set hls! hls?<CR>
                            an 20.440.110 &Edit.&Global\ Settings.Toggle\ &Ignoring\ Case<Tab>:set\ ic!	:set ic! ic?<CR>
                            an 20.440.110 &Edit.&Global\ Settings.Toggle\ &Showing\ Matched\ Pairs<Tab>:set\ sm!	:set sm! sm?<CR>
                            
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 1\  :set so=1<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 2\  :set so=2<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 3\  :set so=3<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 4\  :set so=4<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 5\  :set so=5<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 7\  :set so=7<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 10\  :set so=10<CR>
                            an 20.440.120 &Edit.&Global\ Settings.&Context\ Lines.\ 100\  :set so=100<CR>
                            
                            an 20.440.130.40 &Edit.&Global\ Settings.&Virtual\ Edit.Never :set ve=<CR>
                            an 20.440.130.50 &Edit.&Global\ Settings.&Virtual\ Edit.Block\ Selection :set ve=block<CR>
                            an 20.440.130.60 &Edit.&Global\ Settings.&Virtual\ Edit.Insert\ Mode :set ve=insert<CR>
                            an 20.440.130.70 &Edit.&Global\ Settings.&Virtual\ Edit.Block\ and\ Insert :set ve=block,insert<CR>
                            an 20.440.130.80 &Edit.&Global\ Settings.&Virtual\ Edit.Always :set ve=all<CR>
                            an 20.440.140 &Edit.&Global\ Settings.Toggle\ Insert\ &Mode<Tab>:set\ im!	:set im!<CR>
                            an 20.440.145 &Edit.&Global\ Settings.Toggle\ Vi\ C&ompatibility<Tab>:set\ cp!	:set cp!<CR>
                            an <silent> 20.440.150 &Edit.&Global\ Settings.Search\ &Path\.\.\.  :call <SID>SearchP()<CR>
                            an <silent> 20.440.160 &Edit.&Global\ Settings.Ta&g\ Files\.\.\.  :call <SID>TagFiles()<CR>
                            "
                            " GUI options
                            an 20.440.300 &Edit.&Global\ Settings.-SEP1-				<Nop>
                            an <silent> 20.440.310 &Edit.&Global\ Settings.Toggle\ &Toolbar		:call <SID>ToggleGuiOption("T")<CR>
                            an <silent> 20.440.320 &Edit.&Global\ Settings.Toggle\ &Bottom\ Scrollbar :call <SID>ToggleGuiOption("b")<CR>
                            an <silent> 20.440.330 &Edit.&Global\ Settings.Toggle\ &Left\ Scrollbar	:call <SID>ToggleGuiOption("l")<CR>
                            an <silent> 20.440.340 &Edit.&Global\ Settings.Toggle\ &Right\ Scrollbar :call <SID>ToggleGuiOption("r")<CR>
                            
                            def s:SearchP()
                              if !exists("g:menutrans_path_dialog")
                                g:menutrans_path_dialog = "Enter search path for files.\nSeparate directory names with a comma."
                              endif
                              var n = inputdialog(g:menutrans_path_dialog, substitute(&path, '\\ ', ' ', 'g'))
                              if n != ""
                                &path = substitute(n, ' ', '\\ ', 'g')
                              endif
                            enddef
                            
                            def s:TagFiles()
                              if !exists("g:menutrans_tags_dialog")
                                g:menutrans_tags_dialog = "Enter names of tag files.\nSeparate the names with a comma."
                              endif
                              var n = inputdialog(g:menutrans_tags_dialog, substitute(&tags, '\\ ', ' ', 'g'))
                              if n != ""
                                &tags = substitute(n, ' ', '\\ ', 'g')
                              endif
                            enddef
                            
                            def s:ToggleGuiOption(option: string)
                              # If a:option is already set in guioptions, then we want to remove it
                              if match(&guioptions, "\\C" .. option) > -1
                                exec "set go-=" .. option
                              else
                                exec "set go+=" .. option
                              endif
                            enddef
                            
                            " Edit/File Settings
                            
                            " Boolean options
                            an 20.440.100 &Edit.F&ile\ Settings.Toggle\ Line\ &Numbering<Tab>:set\ nu!	:set nu! nu?<CR>
                            an 20.440.105 &Edit.F&ile\ Settings.Toggle\ Relati&ve\ Line\ Numbering<Tab>:set\ rnu!	:set rnu! rnu?<CR>
                            an 20.440.110 &Edit.F&ile\ Settings.Toggle\ &List\ Mode<Tab>:set\ list!	:set list! list?<CR>
                            an 20.440.120 &Edit.F&ile\ Settings.Toggle\ Line\ &Wrapping<Tab>:set\ wrap!	:set wrap! wrap?<CR>
                            an 20.440.130 &Edit.F&ile\ Settings.Toggle\ W&rapping\ at\ Word<Tab>:set\ lbr!	:set lbr! lbr?<CR>
                            an 20.440.160 &Edit.F&ile\ Settings.Toggle\ Tab\ &Expanding<Tab>:set\ et!	:set et! et?<CR>
                            an 20.440.170 &Edit.F&ile\ Settings.Toggle\ &Auto\ Indenting<Tab>:set\ ai!	:set ai! ai?<CR>
                            an 20.440.180 &Edit.F&ile\ Settings.Toggle\ &C-Style\ Indenting<Tab>:set\ cin!	:set cin! cin?<CR>
                            
                            " other options
                            an 20.440.600 &Edit.F&ile\ Settings.-SEP2-		<Nop>
                            an 20.440.610.20 &Edit.F&ile\ Settings.&Shiftwidth.2	:set sw=2 sw?<CR>
                            an 20.440.610.30 &Edit.F&ile\ Settings.&Shiftwidth.3	:set sw=3 sw?<CR>
                            an 20.440.610.40 &Edit.F&ile\ Settings.&Shiftwidth.4	:set sw=4 sw?<CR>
                            an 20.440.610.50 &Edit.F&ile\ Settings.&Shiftwidth.5	:set sw=5 sw?<CR>
                            an 20.440.610.60 &Edit.F&ile\ Settings.&Shiftwidth.6	:set sw=6 sw?<CR>
                            an 20.440.610.80 &Edit.F&ile\ Settings.&Shiftwidth.8	:set sw=8 sw?<CR>
                            
                            an 20.440.620.20 &Edit.F&ile\ Settings.Soft\ &Tabstop.2	:set sts=2 sts?<CR>
                            an 20.440.620.30 &Edit.F&ile\ Settings.Soft\ &Tabstop.3	:set sts=3 sts?<CR>
                            an 20.440.620.40 &Edit.F&ile\ Settings.Soft\ &Tabstop.4	:set sts=4 sts?<CR>
                            an 20.440.620.50 &Edit.F&ile\ Settings.Soft\ &Tabstop.5	:set sts=5 sts?<CR>
                            an 20.440.620.60 &Edit.F&ile\ Settings.Soft\ &Tabstop.6	:set sts=6 sts?<CR>
                            an 20.440.620.80 &Edit.F&ile\ Settings.Soft\ &Tabstop.8	:set sts=8 sts?<CR>
                            
                            an <silent> 20.440.630 &Edit.F&ile\ Settings.Te&xt\ Width\.\.\.  :call <SID>TextWidth()<CR>
                            an <silent> 20.440.640 &Edit.F&ile\ Settings.&File\ Format\.\.\.  :call <SID>FileFormat()<CR>
                            
                            def s:TextWidth()
                              if !exists("g:menutrans_textwidth_dialog")
                                g:menutrans_textwidth_dialog = "Enter new text width (0 to disable formatting): "
                              endif
                              var n = inputdialog(g:menutrans_textwidth_dialog, &tw .. '')
                              if n != ""
                                # Remove leading zeros to avoid it being used as an octal number.
                                # But keep a zero by itself.
                                var tw = substitute(n, "^0*", "", "")
                                &tw = tw == '' ? 0 : str2nr(tw)
                              endif
                            enddef
                            
                            def s:FileFormat()
                              if !exists("g:menutrans_fileformat_dialog")
                                g:menutrans_fileformat_dialog = "Select format for writing the file"
                              endif
                              if !exists("g:menutrans_fileformat_choices")
                                g:menutrans_fileformat_choices = "&Unix\n&Dos\n&Mac\n&Cancel"
                              endif
                              var def_choice: number
                              if &ff == "dos"
                                def_choice = 2
                              elseif &ff == "mac"
                                def_choice = 3
                              else
                                def_choice = 1
                              endif
                              var n = confirm(g:menutrans_fileformat_dialog, g:menutrans_fileformat_choices, def_choice, "Question")
                              if n == 1
                                set ff=unix
                              elseif n == 2
                                set ff=dos
                              elseif n == 3
                                set ff=mac
                              endif
                            enddef
                            
                            let s:did_setup_color_schemes = 0
                            
                            " Setup the Edit.Color Scheme submenu
                            def s:SetupColorSchemes()
                              if s:did_setup_color_schemes
                                return
                              endif
                              s:did_setup_color_schemes = 1
                            
                              var n = globpath(&runtimepath, "colors/*.vim", 1, 1)
                              n += globpath(&packpath, "pack/*/start/*/colors/*.vim", 1, 1)
                              n += globpath(&packpath, "pack/*/opt/*/colors/*.vim", 1, 1)
                            
                              # Ignore case for VMS and windows, sort on name
                              var names = sort(map(n, 'substitute(v:val, "\\c.*[/\\\\:\\]]\\([^/\\\\:]*\\)\\.vim", "\\1", "")'), 'i')
                            
                              # define all the submenu entries
                              var idx = 100
                              for name in names
                                exe "an 20.450." .. idx .. ' &Edit.C&olor\ Scheme.' .. name .. " :colors " .. name .. "<CR>"
                                idx += 10
                              endfor
                              silent! aunmenu &Edit.Show\ C&olor\ Schemes\ in\ Menu
                            enddef
                            
                            if exists("do_no_lazyload_menus")
                              call s:SetupColorSchemes()
                            else
                              an <silent> 20.450 &Edit.Show\ C&olor\ Schemes\ in\ Menu :call <SID>SetupColorSchemes()<CR>
                            endif
                            
                            
                            " Setup the Edit.Keymap submenu
                            if has("keymap")
                              let s:did_setup_keymaps = 0
                            
                              def s:SetupKeymaps()
                                if s:did_setup_keymaps
                                  return
                                endif
                                s:did_setup_keymaps = 1
                            
                                var names = globpath(&runtimepath, "keymap/*.vim", 1, 1)
                                if !empty(names)
                                  var idx = 100
                                  an 20.460.90 &Edit.&Keymap.None :set keymap=<CR>
                                  for name in names
                            	# Ignore case for VMS and windows
                            	var mapname = substitute(name, '\c.*[/\\:\]]\([^/\\:_]*\)\(_[0-9a-zA-Z-]*\)\=\.vim', '\1', '')
                            	exe "an 20.460." .. idx .. ' &Edit.&Keymap.' .. mapname .. " :set keymap=" .. mapname .. "<CR>"
                            	idx += 10
                                  endfor
                                endif
                                silent! aunmenu &Edit.Show\ &Keymaps\ in\ Menu
                              enddef
                            
                              if exists("do_no_lazyload_menus")
                                call s:SetupKeymaps()
                              else
                                an <silent> 20.460 &Edit.Show\ &Keymaps\ in\ Menu :call <SID>SetupKeymaps()<CR>
                              endif
                            endif
                            
                            if has("win32") || has("gui_motif") || has("gui_gtk") || has("gui_kde") || has("gui_photon") || has("gui_mac")
                              an 20.470 &Edit.Select\ Fo&nt\.\.\.	:set guifont=*<CR>
                            elseif has("gui_macvim")
                              an 20.470 &Edit.-SEP4-                       <Nop>
                              an 20.475.10 &Edit.Font.Show\ Fonts          <Nop>
                              an 20.475.20 &Edit.Font.-SEP5-               <Nop>
                              an 20.475.30 &Edit.Font.Bigger               <Nop>
                              an 20.475.40 &Edit.Font.Smaller              <Nop>
                            endif
                            
                            " Programming menu
                            if !exists("g:ctags_command")
                              if has("vms")
                                let g:ctags_command = "mc vim:ctags *.*"
                              else
                                let g:ctags_command = "ctags -R ."
                              endif
                            endif
                            
                            an 40.300 &Tools.&Jump\ to\ This\ Tag<Tab>g^]	g<C-]>
                            vunmenu &Tools.&Jump\ to\ This\ Tag<Tab>g^]
                            vnoremenu &Tools.&Jump\ to\ This\ Tag<Tab>g^]	g<C-]>
                            an 40.310 &Tools.Jump\ &Back<Tab>^T		<C-T>
                            an 40.320 &Tools.Build\ &Tags\ File		:exe "!" .. g:ctags_command<CR>
                            
                            if has("folding") || has("spell")
                              an 40.330 &Tools.-SEP1-						<Nop>
                            endif
                            
                            " Tools.Spelling Menu
                            if has("spell")
                              an 40.335.110 &Tools.&Spelling.&Spell\ Check\ On		:set spell<CR>
                              an 40.335.120 &Tools.&Spelling.Spell\ Check\ &Off		:set nospell<CR>
                              an 40.335.130 &Tools.&Spelling.To\ &Next\ Error<Tab>]s	]s
                              an 40.335.130 &Tools.&Spelling.To\ &Previous\ Error<Tab>[s	[s
                              an 40.335.140 &Tools.&Spelling.Suggest\ &Corrections<Tab>z=	z=
                              an 40.335.150 &Tools.&Spelling.&Repeat\ Correction<Tab>:spellrepall	:spellrepall<CR>
                              an 40.335.200 &Tools.&Spelling.-SEP1-				<Nop>
                              an 40.335.210 &Tools.&Spelling.Set\ Language\ to\ "en"	:set spl=en spell<CR>
                              an 40.335.220 &Tools.&Spelling.Set\ Language\ to\ "en_au"	:set spl=en_au spell<CR>
                              an 40.335.230 &Tools.&Spelling.Set\ Language\ to\ "en_ca"	:set spl=en_ca spell<CR>
                              an 40.335.240 &Tools.&Spelling.Set\ Language\ to\ "en_gb"	:set spl=en_gb spell<CR>
                              an 40.335.250 &Tools.&Spelling.Set\ Language\ to\ "en_nz"	:set spl=en_nz spell<CR>
                              an 40.335.260 &Tools.&Spelling.Set\ Language\ to\ "en_us"	:set spl=en_us spell<CR>
                              an <silent> 40.335.270 &Tools.&Spelling.&Find\ More\ Languages	:call <SID>SpellLang()<CR>
                            
                              let s:undo_spelllang = ['aun &Tools.&Spelling.&Find\ More\ Languages']
                              def s:SpellLang(encChanged = false)
                                for cmd in s:undo_spelllang
                                  exe "silent! " .. cmd
                                endfor
                                s:undo_spelllang = []
                            
                                var enc = &enc == "iso-8859-15" ? "latin1" : &enc
                            
                                # Reset g:menutrans_set_lang_to when called for the EncodingChanged event.
                                if !exists("g:menutrans_set_lang_to") || encChanged
                                  g:menutrans_set_lang_to = 'Set Language to'
                                endif
                            
                                var found = 0
                                var _nm = ''
                                var names = globpath(&runtimepath, "spell/*." .. enc .. ".spl", 1, 1)
                                if !empty(names)
                                  var n = 300
                                  for f in names
                            	var nm = substitute(f, '.*spell[/\\]\(..\)\.[^/\\]*\.spl', '\1', "")
                            	if nm != "en" && nm !~ '/'
                                      _nm = nm
                            	  found += 1
                            	  var menuname = '&Tools.&Spelling.' .. escape(g:menutrans_set_lang_to, "\\. \t|") .. '\ "' .. nm .. '"'
                            	  exe 'an 40.335.' .. n .. ' ' .. menuname .. ' :set spl=' .. nm .. ' spell<CR>'
                            	  s:undo_spelllang += ['aun ' .. menuname]
                            	endif
                            	n += 10
                                  endfor
                                endif
                                if found == 0
                                  echomsg "Could not find other spell files"
                                elseif found == 1
                                  echomsg "Found spell file " .. _nm
                                else
                                  echomsg "Found " .. found .. " more spell files"
                                endif
                            
                                # Need to redo this when 'encoding' is changed.
                                augroup spellmenu
                                au! EncodingChanged * call SpellLang(true)
                                augroup END
                              enddef
                            endif
                            
                            " Tools.Fold Menu
                            if has("folding")
                              " open close folds
                              an 40.340.110 &Tools.&Folding.&Enable/Disable\ Folds<Tab>zi		zi
                              an 40.340.120 &Tools.&Folding.&View\ Cursor\ Line<Tab>zv		zv
                              an 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ Only<Tab>zMzx	zMzx
                              inoremenu 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ Only<Tab>zMzx  <C-O>zM<C-O>zx
                              an 40.340.130 &Tools.&Folding.C&lose\ More\ Folds<Tab>zm		zm
                              an 40.340.140 &Tools.&Folding.&Close\ All\ Folds<Tab>zM		zM
                              an 40.340.150 &Tools.&Folding.O&pen\ More\ Folds<Tab>zr		zr
                              an 40.340.160 &Tools.&Folding.&Open\ All\ Folds<Tab>zR		zR
                              " fold method
                              an 40.340.200 &Tools.&Folding.-SEP1-			<Nop>
                              an 40.340.210 &Tools.&Folding.Fold\ Met&hod.M&anual	:set fdm=manual<CR>
                              an 40.340.210 &Tools.&Folding.Fold\ Met&hod.I&ndent	:set fdm=indent<CR>
                              an 40.340.210 &Tools.&Folding.Fold\ Met&hod.E&xpression :set fdm=expr<CR>
                              an 40.340.210 &Tools.&Folding.Fold\ Met&hod.S&yntax	:set fdm=syntax<CR>
                              an 40.340.210 &Tools.&Folding.Fold\ Met&hod.&Diff	:set fdm=diff<CR>
                              an 40.340.210 &Tools.&Folding.Fold\ Met&hod.Ma&rker	:set fdm=marker<CR>
                              " create and delete folds
                              vnoremenu 40.340.220 &Tools.&Folding.Create\ &Fold<Tab>zf	zf
                              an 40.340.230 &Tools.&Folding.&Delete\ Fold<Tab>zd		zd
                              an 40.340.240 &Tools.&Folding.Delete\ &All\ Folds<Tab>zD	zD
                              " moving around in folds
                              an 40.340.300 &Tools.&Folding.-SEP2-				<Nop>
                              an 40.340.310.10 &Tools.&Folding.Fold\ Col&umn\ Width.\ &0\ 	:set fdc=0<CR>
                              an 40.340.310.20 &Tools.&Folding.Fold\ Col&umn\ Width.\ &2\ 	:set fdc=2<CR>
                              an 40.340.310.30 &Tools.&Folding.Fold\ Col&umn\ Width.\ &3\ 	:set fdc=3<CR>
                              an 40.340.310.40 &Tools.&Folding.Fold\ Col&umn\ Width.\ &4\ 	:set fdc=4<CR>
                              an 40.340.310.50 &Tools.&Folding.Fold\ Col&umn\ Width.\ &5\ 	:set fdc=5<CR>
                              an 40.340.310.60 &Tools.&Folding.Fold\ Col&umn\ Width.\ &6\ 	:set fdc=6<CR>
                              an 40.340.310.70 &Tools.&Folding.Fold\ Col&umn\ Width.\ &7\ 	:set fdc=7<CR>
                              an 40.340.310.80 &Tools.&Folding.Fold\ Col&umn\ Width.\ &8\ 	:set fdc=8<CR>
                            endif  " has folding
                            
                            if has("diff")
                              an 40.350.100 &Tools.&Diff.&Update		:diffupdate<CR>
                              an 40.350.110 &Tools.&Diff.&Get\ Block	:diffget<CR>
                              vunmenu &Tools.&Diff.&Get\ Block
                              vnoremenu &Tools.&Diff.&Get\ Block		:diffget<CR>
                              an 40.350.120 &Tools.&Diff.&Put\ Block	:diffput<CR>
                              vunmenu &Tools.&Diff.&Put\ Block
                              vnoremenu &Tools.&Diff.&Put\ Block		:diffput<CR>
                            endif
                            
                            an 40.358 &Tools.-SEP2-					<Nop>
                            an 40.360 &Tools.&Make<Tab>:make			:make<CR>
                            an 40.370 &Tools.&List\ Errors<Tab>:cl			:cl<CR>
                            an 40.380 &Tools.L&ist\ Messages<Tab>:cl!		:cl!<CR>
                            an 40.390 &Tools.&Next\ Error<Tab>:cn			:cn<CR>
                            an 40.400 &Tools.&Previous\ Error<Tab>:cp		:cp<CR>
                            an 40.410 &Tools.&Older\ List<Tab>:cold			:colder<CR>
                            an 40.420 &Tools.N&ewer\ List<Tab>:cnew			:cnewer<CR>
                            an 40.430.50 &Tools.Error\ &Window.&Update<Tab>:cwin	:cwin<CR>
                            an 40.430.60 &Tools.Error\ &Window.&Open<Tab>:copen	:copen<CR>
                            an 40.430.70 &Tools.Error\ &Window.&Close<Tab>:cclose	:cclose<CR>
                            
                            an 40.520 &Tools.-SEP3-					<Nop>
                            an <silent> 40.530 &Tools.&Convert\ to\ HEX<Tab>:%!xxd
                            	\ :call <SID>XxdConv()<CR>
                            an <silent> 40.540 &Tools.Conve&rt\ Back<Tab>:%!xxd\ -r
                            	\ :call <SID>XxdBack()<CR>
                            
                            " Use a function to do the conversion, so that it also works with 'insertmode'
                            " set.
                            def s:XxdConv()
                              var mod = &mod
                              if has("vms")
                                :%!mc vim:xxd
                              else
                                s:XxdFind()
                                exe ':%!' .. g:xxdprogram
                              endif
                              if getline(1) =~ "^00000000:"		# only if it worked
                                set ft=xxd
                              endif
                              &mod = mod
                            enddef
                            
                            def s:XxdBack()
                              var mod = &mod
                              if has("vms")
                                :%!mc vim:xxd -r
                              else
                                s:XxdFind()
                                exe ':%!' .. g:xxdprogram .. ' -r'
                              endif
                              set ft=
                              if exists('#filetypedetect') && exists('#BufReadPost')
                                doautocmd filetypedetect BufReadPost
                              endif
                              &mod = mod
                            enddef
                            
                            def s:XxdFind()
                              if !exists("g:xxdprogram")
                                # On the PC xxd may not be in the path but in the install directory
                                if has("win32") && !executable("xxd")
                                  g:xxdprogram = $VIMRUNTIME .. (&shellslash ? '/' : '\') .. "xxd.exe"
                                  if g:xxdprogram =~ ' '
                            	g:xxdprogram = '"' .. g:xxdprogram .. '"'
                                  endif
                                else
                                  g:xxdprogram = "xxd"
                                endif
                              endif
                            enddef
                            
                            let s:did_setup_compilers = 0
                            
                            " Setup the Tools.Compiler submenu
                            def s:SetupCompilers()
                              if s:did_setup_compilers
                                return
                              endif
                              s:did_setup_compilers = 1
                            
                              var names = globpath(&runtimepath, "compiler/*.vim", 1, 1)
                              var idx = 100
                              for name in names
                                # Ignore case for VMS and windows
                                var cname = substitute(name, '\c.*[/\\:\]]\([^/\\:]*\)\.vim', '\1', '')
                                exe "an 30.440." .. idx .. ' &Tools.Se&t\ Compiler.' .. cname .. " :compiler " .. cname .. "<CR>"
                                idx += 10
                              endfor
                              silent! aunmenu &Tools.Show\ Compiler\ Se&ttings\ in\ Menu
                            enddef
                            
                            if exists("do_no_lazyload_menus")
                              call s:SetupCompilers()
                            else
                              an <silent> 30.440 &Tools.Show\ Compiler\ Se&ttings\ in\ Menu :call <SID>SetupCompilers()<CR>
                            endif
                            
                            " Load ColorScheme, Compiler Setting and Keymap menus when idle.
                            if !exists("do_no_lazyload_menus")
                              def s:SetupLazyloadMenus()
                                s:SetupColorSchemes()
                                s:SetupCompilers()
                                if has("keymap")
                                  s:SetupKeymaps()
                                endif
                              enddef
                              augroup SetupLazyloadMenus
                                au!
                                au CursorHold,CursorHoldI * call <SID>SetupLazyloadMenus() | au! SetupLazyloadMenus
                              augroup END
                            endif
                            
                            
                            if !exists("no_buffers_menu")
                            
                            " Buffer list menu -- Setup functions & actions
                            
                            " wait with building the menu until after loading 'session' files. Makes
                            " startup faster.
                            let s:bmenu_wait = 1
                            
                            " Dictionary of buffer number to name. This helps prevent problems where a
                            " buffer as renamed and we didn't keep track of that.
                            let s:bmenu_items = {}
                            
                            if !exists("bmenu_priority")
                              let bmenu_priority = 60
                            endif
                            
                            " invoked from a BufCreate or BufFilePost autocommand
                            def s:BMAdd()
                              if s:bmenu_wait == 0
                                # when adding too many buffers, redraw in short format
                                if s:bmenu_count == &menuitems && s:bmenu_short == 0
                                  s:BMShow()
                                else
                                  var name = expand("<afile>")
                                  var num = str2nr(expand("<abuf>"))
                                  if s:BMCanAdd(name, num)
                            	s:BMFilename(name, num)
                            	s:bmenu_count += 1
                                  endif
                                endif
                              endif
                            enddef
                            
                            " invoked from a BufDelete or BufFilePre autocommand
                            def s:BMRemove()
                              if s:bmenu_wait == 0
                                var bufnum = expand("<abuf>")
                                if s:bmenu_items->has_key(bufnum)
                                  var menu_name = s:bmenu_items[bufnum]
                                  exe 'silent! aun &Buffers.' .. menu_name
                                  s:bmenu_count = s:bmenu_count - 1
                                  unlet s:bmenu_items[bufnum]
                                endif
                              endif
                            enddef
                            
                            " Return non-zero if buffer with number "name" / "num" is useful to add in the
                            " buffer menu.
                            def s:BMCanAdd(name: string, num: number): bool
                              # no directory or unlisted buffer
                              if isdirectory(name) || !buflisted(num)
                                return false
                              endif
                            
                              # no name with control characters
                              if name =~ '[\x01-\x1f]'
                                return false
                              endif
                            
                              # no special buffer, such as terminal or popup
                              var buftype = getbufvar(num, '&buftype')
                              if buftype != '' && buftype != 'nofile' && buftype != 'nowrite'
                                return false
                              endif
                            
                              # only existing buffers
                              return bufexists(num)
                            enddef
                            
                            " Create the buffer menu (delete an existing one first).
                            def s:BMShow()
                              s:bmenu_wait = 1
                              s:bmenu_short = 1
                              s:bmenu_count = 0
                              s:bmenu_items = {}
                            
                              # Remove old menu, if it exists; keep one entry to avoid a torn off menu to
                              # disappear.  Use try/catch to avoid setting v:errmsg
                              try 
                                unmenu &Buffers 
                              catch 
                              endtry
                              exe 'noremenu ' .. g:bmenu_priority .. ".1 &Buffers.Dummy l"
                              try 
                                unmenu! &Buffers 
                              catch 
                              endtry
                            
                              # create new menu
                              exe 'an <silent> ' .. g:bmenu_priority .. ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
                              exe 'an ' .. g:bmenu_priority .. ".4 &Buffers.&Delete :confirm bd<CR>"
                              exe 'an ' .. g:bmenu_priority .. ".6 &Buffers.&Alternate :confirm b #<CR>"
                              exe 'an ' .. g:bmenu_priority .. ".7 &Buffers.&Next :confirm bnext<CR>"
                              exe 'an ' .. g:bmenu_priority .. ".8 &Buffers.&Previous :confirm bprev<CR>"
                              exe 'an ' .. g:bmenu_priority .. ".9 &Buffers.-SEP- :"
                              unmenu &Buffers.Dummy
                            
                              # figure out how many buffers there are
                              var buf = 1
                              while buf <= bufnr('$')
                                if s:BMCanAdd(bufname(buf), buf)
                                  s:bmenu_count = s:bmenu_count + 1
                                endif
                                buf += 1
                              endwhile
                              if s:bmenu_count <= &menuitems
                                s:bmenu_short = 0
                              endif
                            
                              # iterate through buffer list, adding each buffer to the menu:
                              buf = 1
                              while buf <= bufnr('$')
                                var name = bufname(buf)
                                if s:BMCanAdd(name, buf)
                                  call s:BMFilename(name, buf)
                                endif
                                buf += 1
                              endwhile
                              s:bmenu_wait = 0
                              aug buffer_list
                                au!
                                au BufCreate,BufFilePost * call s:BMAdd()
                                au BufDelete,BufFilePre * call s:BMRemove()
                              aug END
                            enddef
                            
                            def s:BMHash(name: string): number
                              # Make name all upper case, so that chars are between 32 and 96
                              var nm = substitute(name, ".*", '\U\0', "")
                              var sp: number
                              if has("ebcdic")
                                # HACK: Replace all non alphabetics with 'Z'
                                #       Just to make it work for now.
                                nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                sp = char2nr('A') - 1
                              else
                                sp = char2nr(' ')
                              endif
                              # convert first six chars into a number for sorting:
                              return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)
                            enddef
                            
                            def s:BMHash2(name: string): string
                              var nm = substitute(name, ".", '\L\0', "")
                              if nm[0] < 'a' || nm[0] > 'z'
                                return '&others.'
                              elseif nm[0] <= 'd'
                                return '&abcd.'
                              elseif nm[0] <= 'h'
                                return '&efgh.'
                              elseif nm[0] <= 'l'
                                return '&ijkl.'
                              elseif nm[0] <= 'p'
                                return '&mnop.'
                              elseif nm[0] <= 't'
                                return '&qrst.'
                              else
                                return '&u-z.'
                              endif
                            enddef
                            
                            " Insert a buffer name into the buffer menu.
                            def s:BMFilename(name: string, num: number)
                              var munge = s:BMMunge(name, num)
                              var hash = s:BMHash(munge)
                              var cmd: string
                              if s:bmenu_short == 0
                                s:bmenu_items[num] = munge
                                cmd = 'an ' .. g:bmenu_priority .. '.' .. hash .. ' &Buffers.' .. munge
                              else
                                var menu_name = s:BMHash2(munge) .. munge
                                s:bmenu_items[num] = menu_name
                                cmd = 'an ' .. g:bmenu_priority .. '.' .. hash .. '.' .. hash .. ' &Buffers.' .. menu_name
                              endif
                              exe cmd .. ' :confirm b' .. num .. '<CR>'
                            enddef
                            
                            " Truncate a long path to fit it in a menu item.
                            if !exists("g:bmenu_max_pathlen")
                              let g:bmenu_max_pathlen = 35
                            endif
                            
                            def s:BMTruncName(fname: string): string
                              var name = fname
                              if g:bmenu_max_pathlen < 5
                                name = ""
                              else
                                var len = strlen(name)
                                if len > g:bmenu_max_pathlen
                                  var amountl = (g:bmenu_max_pathlen / 2) - 2
                                  var amountr = g:bmenu_max_pathlen - amountl - 3
                                  var pattern = '^\(.\{,' .. amountl .. '}\).\{-}\(.\{,' .. amountr .. '}\)$'
                                  var left = substitute(name, pattern, '\1', '')
                                  var right = substitute(name, pattern, '\2', '')
                                  if strlen(left) + strlen(right) < len
                            	name = left .. '...' .. right
                                  endif
                                endif
                              endif
                              return name
                            enddef
                            
                            def s:BMMunge(fname: string, bnum: number): string
                              var name = fname
                              if name == ''
                                if !exists("g:menutrans_no_file")
                                  g:menutrans_no_file = "[No Name]"
                                endif
                                name = g:menutrans_no_file
                              else
                                name = fnamemodify(name, ':p:~')
                              endif
                              # detach file name and separate it out:
                              var name2 = fnamemodify(name, ':t')
                              if bnum >= 0
                                name2 = name2 .. ' (' .. bnum .. ')'
                              endif
                              name = name2 .. "\t" .. s:BMTruncName(fnamemodify(name, ':h'))
                              name = escape(name, "\\. \t|")
                              name = substitute(name, "&", "&&", "g")
                              name = substitute(name, "\n", "^@", "g")
                              return name
                            enddef
                            
                            " When just starting Vim, load the buffer menu later.  Don't do this for MacVim
                            " because it makes the menu flicker each time a new editor window is opened.
                            if has("vim_starting") && !has("gui_macvim")
                              augroup LoadBufferMenu
                                au! VimEnter * if !exists("no_buffers_menu") | call <SID>BMShow() | endif
                                au  VimEnter * au! LoadBufferMenu
                              augroup END
                            else
                              call <SID>BMShow()
                            endif
                            
                            endif " !exists("no_buffers_menu")
                            
                            " Window menu
                            if !has("gui_macvim")
                            an 70.300 &Window.&New<Tab>^Wn			<C-W>n
                            an 70.310 &Window.S&plit<Tab>^Ws		<C-W>s
                            an 70.320 &Window.Sp&lit\ To\ #<Tab>^W^^	<C-W><C-^>
                            an 70.330 &Window.Split\ &Vertically<Tab>^Wv	<C-W>v
                            an <silent> 70.332 &Window.Split\ File\ E&xplorer	:call MenuExplOpen()<CR>
                            if !exists("*MenuExplOpen")
                              def MenuExplOpen()
                                if @% == ""
                                  :20vsp .
                                else
                                  exe ":20vsp " .. fnameescape(expand("%:p:h"))
                                endif
                              enddef
                            endif
                            an 70.335 &Window.-SEP1-				<Nop>
                            an 70.340 &Window.&Close<Tab>^Wc			:confirm close<CR>
                            an 70.345 &Window.Close\ &Other(s)<Tab>^Wo		:confirm only<CR>
                            an 70.350 &Window.-SEP2-				<Nop>
                            an 70.355 &Window.Move\ &To.&Top<Tab>^WK		<C-W>K
                            an 70.355 &Window.Move\ &To.&Bottom<Tab>^WJ		<C-W>J
                            an 70.355 &Window.Move\ &To.&Left\ Side<Tab>^WH		<C-W>H
                            an 70.355 &Window.Move\ &To.&Right\ Side<Tab>^WL	<C-W>L
                            an 70.360 &Window.Rotate\ &Up<Tab>^WR			<C-W>R
                            an 70.362 &Window.Rotate\ &Down<Tab>^Wr			<C-W>r
                            an 70.365 &Window.-SEP3-				<Nop>
                            an 70.370 &Window.&Equal\ Size<Tab>^W=			<C-W>=
                            an 70.380 &Window.&Max\ Height<Tab>^W_			<C-W>_
                            an 70.390 &Window.M&in\ Height<Tab>^W1_			<C-W>1_
                            an 70.400 &Window.Max\ &Width<Tab>^W\|			<C-W>\|
                            an 70.410 &Window.Min\ Widt&h<Tab>^W1\|			<C-W>1\|
                            endif " !has("gui_macvim")
                            
                            " The popup menu
                            if has("gui_macvim")
                              vnoremenu 1.05 PopUp.Look\ Up     :<C-U>call macvim#ShowDefinitionSelected()<CR>
                              vnoremenu 1.06 PopUp.-SEPLookUp-      <Nop>
                            endif
                            
                            an 1.10 PopUp.&Undo			u
                            an 1.15 PopUp.-SEP1-			<Nop>
                            vnoremenu 1.20 PopUp.Cu&t		"+x
                            vnoremenu 1.30 PopUp.&Copy		"+y
                            cnoremenu 1.30 PopUp.&Copy		<C-Y>
                            nnoremenu 1.40 PopUp.&Paste		"+gP
                            cnoremenu 1.40 PopUp.&Paste		<C-R>+
                            exe 'vnoremenu <script> 1.40 PopUp.&Paste	' .. paste#paste_cmd['v']
                            exe 'inoremenu <script> 1.40 PopUp.&Paste	' .. paste#paste_cmd['i']
                            vnoremenu 1.50 PopUp.&Delete		x
                            an 1.55 PopUp.-SEP2-			<Nop>
                            vnoremenu 1.60 PopUp.Select\ Blockwise	<C-V>
                            
                            nnoremenu 1.70 PopUp.Select\ &Word	vaw
                            onoremenu 1.70 PopUp.Select\ &Word	aw
                            vnoremenu 1.70 PopUp.Select\ &Word	<C-C>vaw
                            inoremenu 1.70 PopUp.Select\ &Word	<C-O>vaw
                            cnoremenu 1.70 PopUp.Select\ &Word	<C-C>vaw
                            
                            nnoremenu 1.73 PopUp.Select\ &Sentence	vas
                            onoremenu 1.73 PopUp.Select\ &Sentence	as
                            vnoremenu 1.73 PopUp.Select\ &Sentence	<C-C>vas
                            inoremenu 1.73 PopUp.Select\ &Sentence	<C-O>vas
                            cnoremenu 1.73 PopUp.Select\ &Sentence	<C-C>vas
                            
                            nnoremenu 1.77 PopUp.Select\ Pa&ragraph	vap
                            onoremenu 1.77 PopUp.Select\ Pa&ragraph	ap
                            vnoremenu 1.77 PopUp.Select\ Pa&ragraph	<C-C>vap
                            inoremenu 1.77 PopUp.Select\ Pa&ragraph	<C-O>vap
                            cnoremenu 1.77 PopUp.Select\ Pa&ragraph	<C-C>vap
                            
                            nnoremenu 1.80 PopUp.Select\ &Line	V
                            onoremenu 1.80 PopUp.Select\ &Line	<C-C>V
                            vnoremenu 1.80 PopUp.Select\ &Line	<C-C>V
                            inoremenu 1.80 PopUp.Select\ &Line	<C-O>V
                            cnoremenu 1.80 PopUp.Select\ &Line	<C-C>V
                            
                            nnoremenu 1.90 PopUp.Select\ &Block	<C-V>
                            onoremenu 1.90 PopUp.Select\ &Block	<C-C><C-V>
                            vnoremenu 1.90 PopUp.Select\ &Block	<C-C><C-V>
                            inoremenu 1.90 PopUp.Select\ &Block	<C-O><C-V>
                            cnoremenu 1.90 PopUp.Select\ &Block	<C-C><C-V>
                            
                            noremenu  <script> <silent> 1.100 PopUp.Select\ &All	:<C-U>call <SID>SelectAll()<CR>
                            inoremenu <script> <silent> 1.100 PopUp.Select\ &All	<C-O>:call <SID>SelectAll()<CR>
                            cnoremenu <script> <silent> 1.100 PopUp.Select\ &All	<C-U>call <SID>SelectAll()<CR>
                            
                            if has("spell")
                              " Spell suggestions in the popup menu.  Note that this will slow down the
                              " appearance of the menu!
                              def s:SpellPopup()
                                if exists("s:changeitem") && s:changeitem != ''
                                  call s:SpellDel()
                                endif
                            
                                # Return quickly if spell checking is not enabled.
                                if !&spell || &spelllang == ''
                                  return
                                endif
                            
                                var curcol = col('.')
                                var w: string
                                var a: string
                                [w, a] = spellbadword()
                                if col('.') > curcol		# don't use word after the cursor
                                  w = ''
                                endif
                                if w != ''
                                  if a == 'caps'
                            	s:suglist = [substitute(w, '.*', '\u&', '')]
                                  else
                            	s:suglist = spellsuggest(w, 10)
                                  endif
                                  if len(s:suglist) > 0
                            	if !exists("g:menutrans_spell_change_ARG_to")
                            	  g:menutrans_spell_change_ARG_to = 'Change\ "%s"\ to'
                            	endif
                            	s:changeitem = printf(g:menutrans_spell_change_ARG_to, escape(w, ' .'))
                            	s:fromword = w
                            	var pri = 1
                            	for sug in s:suglist
                            	  exe 'anoremenu 1.5.' .. pri .. ' PopUp.' .. s:changeitem .. '.' .. escape(sug, ' .')
                            		\ .. ' :call <SID>SpellReplace(' .. pri .. ')<CR>'
                            	  pri += 1
                            	endfor
                            
                            	if !exists("g:menutrans_spell_add_ARG_to_word_list")
                            	  g:menutrans_spell_add_ARG_to_word_list = 'Add\ "%s"\ to\ Word\ List'
                            	endif
                            	s:additem = printf(g:menutrans_spell_add_ARG_to_word_list, escape(w, ' .'))
                            	exe 'anoremenu 1.6 PopUp.' .. s:additem .. ' :spellgood ' .. w .. '<CR>'
                            
                            	if !exists("g:menutrans_spell_ignore_ARG")
                            	  g:menutrans_spell_ignore_ARG = 'Ignore\ "%s"'
                            	endif
                            	s:ignoreitem = printf(g:menutrans_spell_ignore_ARG, escape(w, ' .'))
                            	exe 'anoremenu 1.7 PopUp.' .. s:ignoreitem .. ' :spellgood! ' .. w .. '<CR>'
                            
                            	anoremenu 1.8 PopUp.-SpellSep- :
                                  endif
                                endif
                                call cursor(0, curcol)	# put the cursor back where it was
                              enddef
                            
                              def s:SpellReplace(n: number)
                                var l = getline('.')
                                # Move the cursor to the start of the word.
                                call spellbadword()
                                call setline('.', strpart(l, 0, col('.') - 1) .. s:suglist[n - 1]
                            	  \ .. strpart(l, col('.') + len(s:fromword) - 1))
                              enddef
                            
                              def s:SpellDel()
                                exe "aunmenu PopUp." .. s:changeitem
                                exe "aunmenu PopUp." .. s:additem
                                exe "aunmenu PopUp." .. s:ignoreitem
                                aunmenu PopUp.-SpellSep-
                                s:changeitem = ''
                              enddef
                            
                              augroup SpellPopupMenu
                                au! MenuPopup * call <SID>SpellPopup()
                              augroup END
                            endif
                            
                            " The GUI toolbar (for MS-Windows and GTK)
                            if has("toolbar")
                              an 1.10 ToolBar.Open			:browse confirm e<CR>
                              an <silent> 1.20 ToolBar.Save		:if expand("%") == ""<Bar>browse confirm w<Bar>else<Bar>confirm w<Bar>endif<CR>
                              an 1.30 ToolBar.SaveAll		:browse confirm wa<CR>
                            
                              if has("printer")
                                an 1.40   ToolBar.Print		:hardcopy<CR>
                                vunmenu   ToolBar.Print
                                vnoremenu ToolBar.Print		:hardcopy<CR>
                              elseif has("unix")
                                an 1.40   ToolBar.Print		:w !lpr<CR>
                                vunmenu   ToolBar.Print
                                vnoremenu ToolBar.Print		:w !lpr<CR>
                              endif
                            
                              an 1.45 ToolBar.-sep1-		<Nop>
                              an 1.50 ToolBar.Undo			u
                              an 1.60 ToolBar.Redo			<C-R>
                            
                              an 1.65 ToolBar.-sep2-		<Nop>
                              vnoremenu 1.70 ToolBar.Cut		"+x
                              vnoremenu 1.80 ToolBar.Copy		"+y
                              cnoremenu 1.80 ToolBar.Copy		<C-Y>
                              nnoremenu 1.90 ToolBar.Paste		"+gP
                              cnoremenu	 ToolBar.Paste		<C-R>+
                              exe 'vnoremenu <script>	 ToolBar.Paste	' .. paste#paste_cmd['v']
                              exe 'inoremenu <script>	 ToolBar.Paste	' .. paste#paste_cmd['i']
                            
                              if !has("gui_athena") && !has("gui_macvim")
                                an 1.95   ToolBar.-sep3-		<Nop>
                                an 1.100  ToolBar.Replace		:promptrepl<CR>
                                vunmenu   ToolBar.Replace
                                vnoremenu ToolBar.Replace		y:promptrepl <C-R>=<SID>FixFText()<CR><CR>
                                an 1.110  ToolBar.FindNext		n
                                an 1.120  ToolBar.FindPrev		N
                              endif
                            
                              if !has("gui_macvim")
                                an 1.215 ToolBar.-sep5-		<Nop>
                              endif
                              an <silent> 1.220 ToolBar.LoadSesn	:call <SID>LoadVimSesn()<CR>
                              an <silent> 1.230 ToolBar.SaveSesn	:call <SID>SaveVimSesn()<CR>
                              an 1.240 ToolBar.RunScript		:browse so<CR>
                            
                              if !has("gui_macvim")
                                an 1.245 ToolBar.-sep6-		<Nop>
                              endif
                              an 1.250 ToolBar.Make			:make<CR>
                              if !has("gui_macvim")
                                an 1.270 ToolBar.RunCtags		:exe "!" .. g:ctags_command<CR>
                                an 1.280 ToolBar.TagJump		g<C-]>
                              endif
                            
                              an 1.295 ToolBar.-sep7-		<Nop>
                              an 1.300 ToolBar.Help			:help<CR>
                              if !has("gui_macvim")
                                an <silent> 1.310 ToolBar.FindHelp	:call <SID>Helpfind()<CR>
                              endif
                            
                            " Only set the tooltips here if not done in a language menu file
                            if exists("*Do_toolbar_tmenu")
                              call Do_toolbar_tmenu()
                            else
                              let did_toolbar_tmenu = 1
                              tmenu ToolBar.Open		Open file
                              tmenu ToolBar.Save		Save current file
                              tmenu ToolBar.SaveAll		Save all files
                              tmenu ToolBar.Print		Print
                              tmenu ToolBar.Undo		Undo
                              tmenu ToolBar.Redo		Redo
                              tmenu ToolBar.Cut		Cut to clipboard
                              tmenu ToolBar.Copy		Copy to clipboard
                              tmenu ToolBar.Paste		Paste from Clipboard
                              if !has("gui_athena")
                                tmenu ToolBar.Replace	Find / Replace...
                                tmenu ToolBar.FindNext	Find Next
                                tmenu ToolBar.FindPrev	Find Previous
                              endif
                              tmenu ToolBar.LoadSesn	Choose a session to load
                              tmenu ToolBar.SaveSesn	Save current session
                              tmenu ToolBar.RunScript	Choose a Vim Script to run
                              tmenu ToolBar.Make		Make current project (:make)
                              tmenu ToolBar.RunCtags	Build tags in current directory tree (!ctags -R .)
                              tmenu ToolBar.TagJump		Jump to tag under cursor
                              tmenu ToolBar.Help		Vim Help
                              tmenu ToolBar.FindHelp	Search Vim Help
                            endif
                            
                            " Select a session to load; default to current session name if present
                            def s:LoadVimSesn()
                              var name: string
                              if strlen(v:this_session) > 0
                                name = fnameescape(v:this_session)
                              else
                                name = "Session.vim"
                              endif
                              execute "browse so " .. name
                            enddef
                            
                            " Select a session to save; default to current session name if present
                            def s:SaveVimSesn()
                              if strlen(v:this_session) == 0
                                v:this_session = "Session.vim"
                              endif
                              execute "browse mksession! " .. fnameescape(v:this_session)
                            enddef
                            
                            endif
                            
                            
                            if has("gui_macvim")
                              "
                              " Set up menu key equivalents (these should always have the 'D' modifier
                              " set), action bindings, and alternate items.
                              "
                              " Note: menu items which should execute an action are bound to <Nop>; the
                              " action message is specified here via the :macmenu command.
                              "
                              macm File.New\ Window				key=<D-n> action=newWindow:
                              macm File.New\ Clean\ Window		        key=<D-N> action=newWindowClean:
                              macm File.New\ Clean\ Window\ (No\ Defaults)  key=<D-M-N> action=newWindowCleanNoDefaults: alt=YES
                              macm File.New\ Tab				key=<D-t>
                              macm File.Open…				key=<D-o> action=fileOpen:
                              macm File.Open\ Tab\.\.\.<Tab>:tabnew		key=<D-T>
                              macm File.Open\ Recent			action=recentFilesDummy:
                              macm File.Close\ Window<Tab>:qa		key=<D-W>
                              macm File.Close				key=<D-w> action=performClose:
                              macm File.Save<Tab>:w				key=<D-s>
                              macm File.Save\ All				key=<D-M-s> alt=YES
                              macm File.Save\ As…<Tab>:sav		key=<D-S>
                              macm File.Print				key=<D-p>
                            
                              macm Edit.Undo<Tab>u				key=<D-z> action=undo:
                              macm Edit.Redo<Tab>^R				key=<D-Z> action=redo:
                              macm Edit.Cut<Tab>"+x				key=<D-x> action=cut:
                              macm Edit.Copy<Tab>"+y			key=<D-c> action=copy:
                              macm Edit.Paste<Tab>"+gP			key=<D-v> action=paste:
                              macm Edit.Select\ All<Tab>ggVG		key=<D-a> action=selectAll:
                              macm Edit.Find.Find…			key=<D-f>
                              macm Edit.Find.Find\ Next			key=<D-g> action=findNext:
                              macm Edit.Find.Find\ Previous			key=<D-G> action=findPrevious:
                              macm Edit.Find.Use\ Selection\ for\ Find	key=<D-e> action=useSelectionForFind:
                              macm Edit.Font.Show\ Fonts			action=orderFrontFontPanel:
                              macm Edit.Font.Bigger				key=<D-=> action=fontSizeUp:
                              macm Edit.Font.Smaller			key=<D--> action=fontSizeDown:
                            
                              macm Tools.Spelling.To\ Next\ Error<Tab>]s	key=<D-;>
                              macm Tools.Spelling.Suggest\ Corrections<Tab>z=   key=<D-:>
                              macm Tools.Make<Tab>:make			key=<D-b>
                              macm Tools.List\ Errors<Tab>:cl		key=<D-l>
                              macm Tools.Next\ Error<Tab>:cn		key=<D-C-Right>
                              macm Tools.Previous\ Error<Tab>:cp		key=<D-C-Left>
                              macm Tools.Older\ List<Tab>:cold		key=<D-C-Up>
                              macm Tools.Newer\ List<Tab>:cnew		key=<D-C-Down>
                            
                              macm Window.Minimize		key=<D-m>	action=performMiniaturize:
                              macm Window.Minimize\ All	key=<D-M-m>	action=miniaturizeAll:	alt=YES
                              macm Window.Zoom		key=<D-C-z>	action=performZoom:
                              macm Window.Zoom\ All		key=<D-M-C-z>	action=zoomAll:		alt=YES
                              macm Window.Toggle\ Full\ Screen\ Mode	key=<D-C-f>
                              macm Window.Show\ Next\ Tab			key=<D-}>
                              macm Window.Show\ Previous\ Tab		key=<D-{>
                              macm Window.Bring\ All\ To\ Front		action=arrangeInFront:
                              macm Window.Stay\ in\ Front 	action=stayInFront:
                              macm Window.Stay\ in\ Back 	action=stayInBack:
                              macm Window.Stay\ Level\ Normal action=stayLevelNormal:
                            
                              macm Help.MacVim\ Help			key=<D-?>
                              macm Help.MacVim\ Website			action=openWebsite:
                              macm Help.What's\ New			    action=showWhatsNew:
                            endif " if has("gui_macvim")
                            
    1              0.000000000 endif " !exists("did_install_default_menus")
                            
                            " Define these items always, so that syntax can be switched on when it wasn't.
                            " But skip them when the Syntax menu was disabled by the user.
    1              0.000001000 if !exists("did_install_syntax_menu")
                              an 50.212 &Syntax.&Manual		:syn manual<CR>
                              an 50.214 &Syntax.A&utomatic		:syn on<CR>
                              an <silent> 50.216 &Syntax.On/Off\ for\ &This\ File :call <SID>SynOnOff()<CR>
                              if !exists("*s:SynOnOff")
                                def s:SynOnOff()
                                  if has("syntax_items")
                            	syn clear
                                  else
                            	if !exists("g:syntax_on")
                            	  syn manual
                            	endif
                            	set syn=ON
                                  endif
                                enddef
                              endif
    1              0.000000000 endif
                            
                            
                            " Install the Syntax menu only when filetype.vim has been loaded or when
                            " manual syntax highlighting is enabled.
                            " Avoid installing the Syntax menu twice.
    1              0.000003000 if (exists("did_load_filetypes") || exists("syntax_on"))
                            	\ && !exists("did_install_syntax_menu")
                              let did_install_syntax_menu = 1
                            
                            " Skip setting up the individual syntax selection menus unless
                            " do_syntax_sel_menu is defined (it takes quite a bit of time).
                            if exists("do_syntax_sel_menu")
                              runtime! synmenu.vim
                            else
                              an <silent> 50.10 &Syntax.&Show\ File\ Types\ in\ Menu	:let do_syntax_sel_menu = 1<Bar>runtime! synmenu.vim<Bar>aunmenu &Syntax.&Show\ File\ Types\ in\ Menu<CR>
                              an 50.195 &Syntax.-SEP1-		<Nop>
                            endif
                            
                            an 50.210 &Syntax.&Off			:syn off<CR>
                            an 50.700 &Syntax.-SEP3-		<Nop>
                            an 50.710 &Syntax.Co&lor\ Test		:sp $VIMRUNTIME/syntax/colortest.vim<Bar>so %<CR>
                            an 50.720 &Syntax.&Highlight\ Test	:runtime syntax/hitest.vim<CR>
                            an 50.730 &Syntax.&Convert\ to\ HTML	:runtime syntax/2html.vim<CR>
                            
                            " Uncomment the next line to compile the functions early to find any mistakes
                            " defcompile
                            
    1              0.000000000 endif " !exists("did_install_syntax_menu")
                            
                            " Restore the previous value of 'cpoptions'.
    1              0.000001000 let &cpo = s:cpo_save
    1              0.000001000 unlet s:cpo_save
                            
                            
    1              0.000001000 if has("touchbar")
                              " Set up default Touch Bar buttons.
                              " 1. Smart fullscreen icon that toggles between going full screen or not.
                            
    1              0.000002000   if !exists("g:macvim_default_touchbar_fullscreen") || g:macvim_default_touchbar_fullscreen
    1              0.000003000     an icon=NSTouchBarEnterFullScreenTemplate 1.20 TouchBar.EnterFullScreen :set fullscreen<CR>
    1              0.000002000     tln icon=NSTouchBarEnterFullScreenTemplate 1.20 TouchBar.EnterFullScreen <C-W>:set fullscreen<CR>
    1              0.000000000   endif
                            
    1              0.000001000   let s:touchbar_fullscreen=0
    1              0.000001000   func! s:SetupFullScreenTouchBar()
                                if &fullscreen && s:touchbar_fullscreen != 1
                                  silent! aun TouchBar.EnterFullScreen
                                  silent! tlun TouchBar.EnterFullScreen
                                  if !exists("g:macvim_default_touchbar_fullscreen") || g:macvim_default_touchbar_fullscreen
                                    an icon=NSTouchBarExitFullScreenTemplate 1.20 TouchBar.ExitFullScreen :set nofullscreen<CR>
                                    tln icon=NSTouchBarExitFullScreenTemplate 1.20 TouchBar.ExitFullScreen <C-W>:set nofullscreen<CR>
                                  endif
                                  let s:touchbar_fullscreen = 1
                                elseif !&fullscreen && s:touchbar_fullscreen != 0
                                  silent! aun TouchBar.ExitFullScreen
                                  silent! tlun TouchBar.ExitFullScreen
                                  if !exists("g:macvim_default_touchbar_fullscreen") || g:macvim_default_touchbar_fullscreen
                                    an icon=NSTouchBarEnterFullScreenTemplate 1.20 TouchBar.EnterFullScreen :set fullscreen<CR>
                                    tln icon=NSTouchBarEnterFullScreenTemplate 1.20 TouchBar.EnterFullScreen <C-W>:set fullscreen<CR>
                                  endif
                                  let s:touchbar_fullscreen = 0
                                endif
                              endfunc
    1              0.000000000   aug FullScreenTouchBar
    1              0.000041000     au!
    1              0.000001000     au VimEnter * call <SID>SetupFullScreenTouchBar()
    1              0.000002000     au OptionSet fullscreen call <SID>SetupFullScreenTouchBar()
    1              0.000001000   aug END
                            
                              " 2. Character (i.e. emojis) picker. Only in modes where user is actively
                              " entering text.
    1              0.000002000   if !exists("g:macvim_default_touchbar_characterpicker") || g:macvim_default_touchbar_characterpicker
    1              0.000002000     inoremenu 1.40 TouchBar.-characterpicker- <Nop>
    1              0.000001000     cnoremenu 1.40 TouchBar.-characterpicker- <Nop>
    1              0.000001000     tlnoremenu 1.40 TouchBar.-characterpicker- <Nop>
    1              0.000001000   endif
    1              0.000000000 endif
                            
                            " vim: set sw=2 tabstop=8 :

SCRIPT  /Users/danbradbury/.vim/bundle/ale/plugin/ale.vim
Sourced 1 time
Total time:   0.002108000
 Self time:   0.002108000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Main entry point for the plugin: sets up prefs and autocommands
                            "   Preferences can be set in vimrc files and so on to configure ale
                            
                            " Sanity Checks
                            
    1              0.000002000 if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')
                                finish
    1              0.000000000 endif
                            
                            " Set a special flag used only by this plugin for preventing doubly
                            " loading the script.
    1              0.000002000 let g:loaded_ale_dont_use_this_in_other_plugins_please = 1
                            
                            " A flag for detecting if the required features are set.
    1              0.000002000 if has('nvim')
                                " We check for Neovim 0.2.0+, but we only officially support NeoVim 0.7.0
                                let s:has_features = has('timers') && has('nvim-0.2.0')
    1              0.000000000 else
                                " Check if Job and Channel functions are available, instead of the
                                " features. This works better on old MacVim versions.
    1              0.000004000     let s:has_features = has('timers') && exists('*job_start') && exists('*ch_close_in')
    1              0.000000000 endif
                            
    1              0.000000000 if !s:has_features
                                " Only output a warning if editing some special files.
                                if index(['', 'gitcommit'], &filetype) == -1
                                    " no-custom-checks
                                    echoerr 'ALE requires NeoVim >= 0.7.0 or Vim 8 with +timers +job +channel'
                                    " no-custom-checks
                                    echoerr 'Please update your editor appropriately.'
                                endif
                            
                                " Stop here, as it won't work.
                                finish
    1              0.000001000 endif
                            
                            " Set this flag so that other plugins can use it, like airline.
    1              0.000001000 let g:loaded_ale = 1
                            
                            " This global variable is used internally by ALE for tracking information for
                            " each buffer which linters are being run against.
    1              0.000001000 let g:ale_buffer_info = {}
                            " This global Dictionary tracks data for fixing code. Don't mess with it.
    1              0.000001000 let g:ale_fix_buffer_data = {}
                            
                            " User Configuration
                            
                            " This option prevents ALE autocmd commands from being run for particular
                            " filetypes which can cause issues.
    1              0.000002000 let g:ale_filetype_blacklist = [
                            \   'dirvish',
                            \   'nerdtree',
                            \   'qf',
                            \   'tags',
                            \   'unite',
                            \]
                            
                            " This Dictionary configures which linters are enabled for which languages.
    1              0.000003000 let g:ale_linters = get(g:, 'ale_linters', {})
                            " This option can be changed to only enable explicitly selected linters.
    1              0.000002000 let g:ale_linters_explicit = get(g:, 'ale_linters_explicit', v:false)
                            " Ignoring linters, for disabling some, or ignoring LSP diagnostics.
    1              0.000002000 let g:ale_linters_ignore = get(g:, 'ale_linters_ignore', {})
                            " Disabling all language server functionality.
    1              0.000001000 let g:ale_disable_lsp = get(g:, 'ale_disable_lsp', 'auto')
                            
                            " This Dictionary configures which functions will be used for fixing problems.
    1              0.000001000 let g:ale_fixers = get(g:, 'ale_fixers', {})
                            
                            " This Dictionary allows users to set up filetype aliases for new filetypes.
    1              0.000001000 let g:ale_linter_aliases = get(g:, 'ale_linter_aliases', {})
                            
                            " This flag can be set with a number of milliseconds for delaying the
                            " execution of a linter when text is changed. The timeout will be set and
                            " cleared each time text is changed, so repeated edits won't trigger the
                            " jobs for linting until enough time has passed after editing is done.
    1              0.000001000 let g:ale_lint_delay = get(g:, 'ale_lint_delay', 200)
                            
                            " This flag can be set to 'never' to disable linting when text is changed.
                            " This flag can also be set to 'always' or 'insert' to lint when text is
                            " changed in both normal and insert mode, or only in insert mode respectively.
    1              0.000002000 let g:ale_lint_on_text_changed = get(g:, 'ale_lint_on_text_changed', 'normal')
                            
                            " This flag can be set to true or 1 to enable linting when leaving insert mode.
    1              0.000002000 let g:ale_lint_on_insert_leave = get(g:, 'ale_lint_on_insert_leave', v:true)
                            
                            " When true or 1 linting is done when a buffer is entered.
    1              0.000001000 let g:ale_lint_on_enter = get(g:, 'ale_lint_on_enter', v:true)
                            
                            " When true or 1 linting is done when a buffer is written.
    1              0.000001000 let g:ale_lint_on_save = get(g:, 'ale_lint_on_save', v:true)
                            
                            " When true or 1 linting is done when the filetype changes.
    1              0.000002000 let g:ale_lint_on_filetype_changed = get(g:, 'ale_lint_on_filetype_changed', v:true)
                            
                            " If set to true or 1, suggestions from LSP servers and tsserver will be shown.
    1              0.000002000 let g:ale_lsp_suggestions = get(g:, 'ale_lsp_suggestions', v:false)
                            
                            " When true or 1 files are automatically fixed on save.
    1              0.000001000 let g:ale_fix_on_save = get(g:, 'ale_fix_on_save', v:false)
                            
                            " When true or 1 ALE linting is enabled.
                            " Disabling ALE linting does not disable fixing of files.
    1              0.000002000 let g:ale_enabled = get(g:, 'ale_enabled', 1)
                            
                            " A Dictionary mapping linter or fixer names to Arrays of two-item Arrays
                            " mapping filename paths from one system to another.
    1              0.000002000 let g:ale_filename_mappings = get(g:, 'ale_filename_mappings', {})
                            
                            " This Dictionary configures the default project roots for various linters.
    1              0.000002000 let g:ale_root = get(g:, 'ale_root', {})
                            
                            " These flags dictates if ale uses the quickfix or the loclist (loclist is the
                            " default, quickfix overrides loclist).
    1              0.000002000 let g:ale_set_loclist = get(g:, 'ale_set_loclist', v:true)
    1              0.000001000 let g:ale_set_quickfix = get(g:, 'ale_set_quickfix', v:false)
                            
                            " This flag can be set to 0 to disable setting signs.
                            " This is enabled by default only if the 'signs' feature exists.
    1              0.000002000 let g:ale_set_signs = get(g:, 'ale_set_signs', has('signs') ? v:true : v:false)
                            
                            " This flag can be set to 0 to disable setting error highlights.
    1              0.000002000 let g:ale_set_highlights = get(g:, 'ale_set_highlights', has('syntax') ? v:true : v:false)
                            
                            " This List can be configured to exclude particular highlights.
    1              0.000001000 let g:ale_exclude_highlights = get(g:, 'ale_exclude_highlights', [])
                            
                            " When set to true or 1 problems on lines are echoed when the cursor moves.
    1              0.000001000 let g:ale_echo_cursor = get(g:, 'ale_echo_cursor', v:true)
                            
                            " If set to true or 1 automatically show errors in the preview window.
    1              0.000002000 let g:ale_cursor_detail = get(g:, 'ale_cursor_detail', v:false)
                            
                            " This flag can be changed to disable/enable virtual text.
    1              0.000007000 let g:ale_virtualtext_cursor = get(g:, 'ale_virtualtext_cursor', (has('nvim-0.3.2') || has('patch-9.0.0297') && has('textprop') && has('popupwin')) ? 'all' : 'disabled')
                            
                            " When set to true or 1 LSP hover messages are shown at the cursor.
    1              0.000001000 let g:ale_hover_cursor = get(g:, 'ale_hover_cursor', v:true)
                            
                            " When true or 1 to close the preview window on entering Insert Mode.
    1              0.000002000 let g:ale_close_preview_on_insert = get(g:, 'ale_close_preview_on_insert', v:false)
                            
                            " When set to true or 1 balloon support is enabled.
    1              0.000004000 let g:ale_set_balloons = get(g:, 'ale_set_balloons', (has('balloon_eval') && has('gui_running')) ? v:true : v:false)
                            
                            " When set to true or 1 use the preview window for showing hover messages.
    1              0.000001000 let g:ale_hover_to_preview = get(g:, 'ale_hover_to_preview', v:false)
                            
                            " When set to true or 1 use floating preview windows in Neovim.
    1              0.000002000 let g:ale_floating_preview = get(g:, 'ale_floating_preview', v:false)
                            
                            " When set to true or 1 show hove messages in floating windows in Neovim.
    1              0.000002000 let g:ale_hover_to_floating_preview = get(g:, 'ale_hover_to_floating_preview', v:false)
                            
                            " When set to true or 1 details are shown in floating windows in Neovim.
    1              0.000002000 let g:ale_detail_to_floating_preview = get(g:, 'ale_detail_to_floating_preview', v:false)
                            
                            " Border setting for floating preview windows
                            "
                            " The elements in the list set the characters for the left, top, top-left,
                            " top-right, bottom-right, bottom-left, right, and bottom of the border
                            " respectively
    1              0.000003000 let g:ale_floating_window_border = get(g:, 'ale_floating_window_border', ['|', '-', '+', '+', '+', '+', '|', '-'])
                            
                            " When set to true or 1 warnings for trailing whitespace are shown.
    1              0.000002000 let g:ale_warn_about_trailing_whitespace = get(g:, 'ale_warn_about_trailing_whitespace', v:true)
                            " When set to true or 1 warnings for trailing blank lines are shown.
    1              0.000002000 let g:ale_warn_about_trailing_blank_lines = get(g:, 'ale_warn_about_trailing_blank_lines', v:true)
                            
                            " When set to true or 1 the command history is logged.
    1              0.000002000 let g:ale_history_enabled = get(g:, 'ale_history_enabled', v:true)
                            
                            " When set to true or 1 the full output of commands is logged.
    1              0.000001000 let g:ale_history_log_output = get(g:, 'ale_history_log_output', v:true)
                            
                            " When set to true or 1 enable ALE's built-in autocompletion functionality.
    1              0.000001000 let g:ale_completion_enabled = get(g:, 'ale_completion_enabled', v:false)
                            
                            " When set to true or 1 enable automatic detection of pipenv for Python.
    1              0.000001000 let g:ale_python_auto_pipenv = get(g:, 'ale_python_auto_pipenv', v:false)
                            
                            " When set to true or 1 enable automatic detection of poetry for Python.
    1              0.000002000 let g:ale_python_auto_poetry = get(g:, 'ale_python_auto_poetry', v:false)
                            
                            " When set to true or 1 enable automatic detection of uv for Python.
    1              0.000002000 let g:ale_python_auto_uv = get(g:, 'ale_python_auto_uv', v:false)
                            
                            " When set to true or 1 enable automatically updating environment variables
                            " for running Python linters from virtualenv directories.
                            "
                            " The variables are set based on ALE's virtualenv detection.
    1              0.000001000 let g:ale_python_auto_virtualenv = get(g:, 'ale_python_auto_virtualenv', v:false)
                            
                            " This variable can be overridden to set the GO111MODULE environment variable.
    1              0.000001000 let g:ale_go_go111module = get(g:, 'ale_go_go111module', '')
                            
                            " The default executable for deno. Must be set before ALE lints any buffers.
    1              0.000001000 let g:ale_deno_executable = get(g:, 'ale_deno_executable', 'deno')
                            
                            " If true or 1, enable a popup menu for commands.
    1              0.000003000 let g:ale_popup_menu_enabled = get(g:, 'ale_popup_menu_enabled', has('gui_running') ? v:true : v:false)
                            
                            " If true or 1, save hidden files when code actions are applied.
    1              0.000001000 let g:ale_save_hidden = get(g:, 'ale_save_hidden', v:false)
                            
                            " If true or 1, disables ALE's built in error display.
                            "
                            " Instead, all errors are piped to the Neovim diagnostics API.
    1              0.000003000 let g:ale_use_neovim_diagnostics_api = get(g:, 'ale_use_neovim_diagnostics_api', has('nvim-0.7') ? v:true : v:false)
                            
    1              0.000001000 if g:ale_use_neovim_diagnostics_api && !has('nvim-0.7')
                                " no-custom-checks
                                echoerr('Setting g:ale_use_neovim_diagnostics_api to true or 1 requires Neovim 0.7+.')
    1              0.000001000 endif
                            
                            " If true or 1, uses Neovim's built-in LSP client to integrate with LSP, which
                            " improves ALE's integration with built-in Neovim tools and other plugins.
    1              0.000003000 let g:ale_use_neovim_lsp_api = get(g:, 'ale_use_neovim_lsp_api', has('nvim-0.8') ? v:true : v:false)
                            
                            " If 1, replaces ALE's use of jobs and channels to connect to language
                            " servers, plus the custom code, and instead hooks ALE into Neovim's built-in
                            " language server tools.
    1              0.000001000 if g:ale_use_neovim_lsp_api && !has('nvim-0.8')
                                " no-custom-checks
                                echoerr('Setting g:ale_use_neovim_lsp_api to true or 1 requires Neovim 0.8+.')
    1              0.000000000 endif
                            
    1              0.000001000 if g:ale_set_balloons || g:ale_set_balloons is# 'hover'
    1              0.001143000     call ale#balloon#Enable()
    1              0.000000000 endif
                            
    1              0.000001000 if g:ale_completion_enabled
                                call ale#completion#Enable()
    1              0.000001000 endif
                            
    1              0.000001000 if g:ale_popup_menu_enabled
    1              0.000369000     call ale#code_action#EnablePopUpMenu()
    1              0.000000000 endif
                            
                            " Define commands for moving through warnings and errors.
    1              0.000003000 command! -bar -nargs=* ALEPrevious
                            \    :call ale#loclist_jumping#WrapJump('before', <q-args>)
    1              0.000002000 command! -bar -nargs=* ALENext
                            \    :call ale#loclist_jumping#WrapJump('after', <q-args>)
                            
    1              0.000002000 command! -bar ALEPreviousWrap :call ale#loclist_jumping#Jump('before', 1)
    1              0.000002000 command! -bar ALENextWrap :call ale#loclist_jumping#Jump('after', 1)
    1              0.000001000 command! -bar ALEFirst :call ale#loclist_jumping#JumpToIndex(0)
    1              0.000001000 command! -bar ALELast :call ale#loclist_jumping#JumpToIndex(-1)
                            
                            " A command for showing error details.
    1              0.000001000 command! -bar ALEDetail :call ale#cursor#ShowCursorDetail()
                            
                            " Define commands for turning ALE on or off.
    1              0.000001000 command! -bar ALEToggle :call ale#toggle#Toggle()
    1              0.000001000 command! -bar ALEEnable :call ale#toggle#Enable()
    1              0.000001000 command! -bar ALEDisable :call ale#toggle#Disable()
    1              0.000001000 command! -bar ALEReset :call ale#toggle#Reset()
                            " Commands for turning ALE on or off for a buffer.
    1              0.000001000 command! -bar ALEToggleBuffer :call ale#toggle#ToggleBuffer(bufnr(''))
    1              0.000002000 command! -bar ALEEnableBuffer :call ale#toggle#EnableBuffer(bufnr(''))
    1              0.000001000 command! -bar ALEDisableBuffer :call ale#toggle#DisableBuffer(bufnr(''))
    1              0.000001000 command! -bar ALEResetBuffer :call ale#toggle#ResetBuffer(bufnr(''))
                            " A command to stop all LSP-like clients, including tsserver.
    1              0.000001000 command! -bar ALEStopAllLSPs :call ale#lsp#reset#StopAllLSPs()
                            " A command to stop a specific language server, or tsseserver.
    1              0.000003000 command! -bar -bang -nargs=1 -complete=customlist,ale#lsp#reset#Complete ALEStopLSP :call ale#lsp#reset#StopLSP(<f-args>, '<bang>')
                            
                            " A command for linting manually.
    1              0.000001000 command! -bar ALELint :call ale#Queue(0, 'lint_file')
                            " Stop current jobs when linting.
    1              0.000001000 command! -bar ALELintStop :call ale#engine#Stop(bufnr(''))
                            
                            " Commands to manually populate the quickfixes.
    1              0.000003000 command! -bar ALEPopulateQuickfix :call ale#list#ForcePopulateErrorList(1)
    1              0.000001000 command! -bar ALEPopulateLocList  :call ale#list#ForcePopulateErrorList(0)
                            
                            " Define a command to get information about current filetype.
    1              0.000001000 command! -bar -nargs=* ALEInfo :call ale#debugging#InfoCommand(<f-args>)
                            " Deprecated and scheduled for removal in 4.0.0.
    1              0.000001000 command! -bar ALEInfoToClipboard :call ale#debugging#InfoToClipboardDeprecatedCommand()
                            " Copy ALE information to a file.
    1              0.000001000 command! -bar -nargs=1 ALEInfoToFile :call ale#debugging#InfoToFile(<f-args>)
                            
                            " Fix problems in files.
    1              0.000002000 command! -bar -bang -nargs=* -complete=customlist,ale#fix#registry#CompleteFixers ALEFix :call ale#fix#Fix(bufnr(''), '<bang>', <f-args>)
                            " Suggest registered functions to use for fixing problems.
    1              0.000002000 command! -bar ALEFixSuggest :call ale#fix#registry#Suggest(&filetype)
                            
                            " Go to definition for tsserver and LSP
    1              0.000002000 command! -bar -nargs=* ALEGoToDefinition :call ale#definition#GoToCommandHandler('', <f-args>)
                            
                            " Go to type definition for tsserver and LSP
    1              0.000002000 command! -bar -nargs=* ALEGoToTypeDefinition :call ale#definition#GoToCommandHandler('type', <f-args>)
                            
                            " Go to implementation for tsserver and LSP
    1              0.000002000 command! -bar -nargs=* ALEGoToImplementation :call ale#definition#GoToCommandHandler('implementation', <f-args>)
                            
                            " Repeat a previous selection in the preview window
    1              0.000002000 command! -bar ALERepeatSelection :call ale#preview#RepeatSelection()
                            
                            " Find references for tsserver and LSP
    1              0.000001000 command! -bar -nargs=* ALEFindReferences :call ale#references#Find(<f-args>)
                            
                            " Show summary information for the cursor.
    1              0.000001000 command! -bar ALEHover :call ale#hover#ShowAtCursor()
                            
                            " Show documentation for the cursor.
    1              0.000002000 command! -bar ALEDocumentation :call ale#hover#ShowDocumentationAtCursor()
                            
                            " Search for appearances of a symbol, such as a type name or function name.
    1              0.000002000 command! -nargs=1 ALESymbolSearch :call ale#symbol#Search(<q-args>)
                            
                            " Complete text with tsserver and LSP
    1              0.000002000 command! -bar ALEComplete :call ale#completion#GetCompletions('ale-manual')
                            
                            " Try to find completions for the current symbol that add additional text.
    1              0.000001000 command! -bar ALEImport :call ale#completion#Import()
                            
                            " Rename symbols using tsserver and LSP
    1              0.000001000 command! -bar -bang ALERename :call ale#rename#Execute()
                            
                            " Rename file using tsserver
    1              0.000002000 command! -bar -bang ALEFileRename :call ale#filerename#Execute()
                            
                            " Apply code actions to a range.
    1              0.000002000 command! -bar -range ALECodeAction :call ale#codefix#Execute(<range>)
                            
                            " Organize import statements using tsserver
    1              0.000004000 command! -bar ALEOrganizeImports :call ale#organize_imports#Execute()
                            
                            " <Plug> mappings for commands
    1              0.000004000 nnoremap <silent> <Plug>(ale_previous) :ALEPrevious<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_previous_wrap) :ALEPreviousWrap<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_previous_error) :ALEPrevious -error<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_previous_wrap_error) :ALEPrevious -wrap -error<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_previous_warning) :ALEPrevious -warning<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_previous_wrap_warning) :ALEPrevious -wrap -warning<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_next) :ALENext<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_next_wrap) :ALENextWrap<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_next_error) :ALENext -error<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_next_wrap_error) :ALENext -wrap -error<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_next_warning) :ALENext -warning<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_next_wrap_warning) :ALENext -wrap -warning<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_first) :ALEFirst<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_last) :ALELast<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_toggle) :ALEToggle<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_enable) :ALEEnable<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_disable) :ALEDisable<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_reset) :ALEReset<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_toggle_buffer) :ALEToggleBuffer<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_enable_buffer) :ALEEnableBuffer<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_disable_buffer) :ALEDisableBuffer<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_reset_buffer) :ALEResetBuffer<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_lint) :ALELint<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_detail) :ALEDetail<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_fix) :ALEFix<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_definition) :ALEGoToDefinition<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_definition_in_tab) :ALEGoToDefinition -tab<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_definition_in_split) :ALEGoToDefinition -split<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_definition_in_vsplit) :ALEGoToDefinition -vsplit<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_go_to_type_definition) :ALEGoToTypeDefinition<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_go_to_type_definition_in_tab) :ALEGoToTypeDefinition -tab<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_type_definition_in_split) :ALEGoToTypeDefinition -split<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_type_definition_in_vsplit) :ALEGoToTypeDefinition -vsplit<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_implementation) :ALEGoToImplementation<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_implementation_in_tab) :ALEGoToImplementation -tab<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_implementation_in_split) :ALEGoToImplementation -split<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_go_to_implementation_in_vsplit) :ALEGoToImplementation -vsplit<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_find_references) :ALEFindReferences<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_hover) :ALEHover<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_documentation) :ALEDocumentation<Return>
    1              0.000003000 inoremap <silent> <Plug>(ale_complete) <C-\><C-O>:ALEComplete<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_import) :ALEImport<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_rename) :ALERename<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_filerename) :ALEFileRename<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_code_action) :ALECodeAction<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_repeat_selection) :ALERepeatSelection<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_info) :ALEInfo<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_info_echo) :ALEInfo -echo<Return>
    1              0.000003000 nnoremap <silent> <Plug>(ale_info_clipboard) :ALEInfo -clipboard<Return>
    1              0.000002000 nnoremap <silent> <Plug>(ale_info_preview) :ALEInfo -preview<Return>
                            
                            " Set up autocmd groups now.
    1              0.000207000 call ale#events#Init()
                            
                            " Housekeeping
                            
    1              0.000001000 augroup ALECleanupGroup
    1              0.000012000     autocmd!
                                " Clean up buffers automatically when they are unloaded.
    1              0.000002000     autocmd BufDelete * if exists('*ale#engine#Cleanup') | call ale#engine#Cleanup(str2nr(expand('<abuf>'))) | endif
    1              0.000001000     autocmd QuitPre * call ale#events#QuitEvent(str2nr(expand('<abuf>')))
                            
    1              0.000002000     if exists('##VimSuspend')
    1              0.000001000         autocmd VimSuspend * if exists('*ale#engine#CleanupEveryBuffer') | call ale#engine#CleanupEveryBuffer() | endif
    1              0.000001000     endif
    1              0.000001000 augroup END

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/balloon.vim
Sourced 1 time
Total time:   0.000162000
 Self time:   0.000162000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: balloonexpr support for ALE.
                            
    1              0.000003000 function! ale#balloon#MessageForPos(bufnr, lnum, col) abort
                                let l:set_balloons = ale#Var(a:bufnr, 'set_balloons')
                                let l:show_problems = 0
                                let l:show_hover = 0
                            
                                if l:set_balloons is 1
                                    let l:show_problems = 1
                                    let l:show_hover = 1
                                elseif l:set_balloons is# 'hover'
                                    let l:show_hover = 1
                                endif
                            
                                " Don't show balloons if they are disabled, or linting is disabled.
                                if !(l:show_problems || l:show_hover)
                                \|| !g:ale_enabled
                                \|| !getbufvar(a:bufnr, 'ale_enabled', 1)
                                    return ''
                                endif
                            
                                if l:show_problems
                                    let l:loclist = get(g:ale_buffer_info, a:bufnr, {'loclist': []}).loclist
                                    let l:index = ale#util#BinarySearch(l:loclist, a:bufnr, a:lnum, a:col)
                                endif
                            
                                " Show the diagnostics message if found, 'Hover' output otherwise
                                if l:show_problems && l:index >= 0
                                    return l:loclist[l:index].text
                                elseif l:show_hover && (
                                \   exists('*balloon_show')
                                \   || getbufvar(
                                \       a:bufnr,
                                \       'ale_set_balloons_legacy_echo',
                                \       get(g:, 'ale_set_balloons_legacy_echo', 0)
                                \   )
                                \)
                                    " Request LSP/tsserver hover information, but only if this version of
                                    " Vim supports the balloon_show function, or if we turned a legacy
                                    " setting on.
                                    call ale#hover#Show(a:bufnr, a:lnum, a:col, {'called_from_balloonexpr': 1})
                                endif
                            
                                return ''
                            endfunction
                            
    1              0.000000000 function! ale#balloon#Expr() abort
                                return ale#balloon#MessageForPos(v:beval_bufnr, v:beval_lnum, v:beval_col)
                            endfunction
                            
    1              0.000000000 function! ale#balloon#Disable() abort
                                if has('balloon_eval')
                                    set noballooneval
                                    set balloonexpr=
                                endif
                            
                                if has('balloon_eval_term')
                                    set noballoonevalterm
                                    set balloonexpr=
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#balloon#Enable() abort
                                if has('balloon_eval')
                                    set ballooneval
                                    set balloonexpr=ale#balloon#Expr()
                                endif
                            
                                if has('balloon_eval_term')
                                    set balloonevalterm
                                    set balloonexpr=ale#balloon#Expr()
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/code_action.vim
Sourced 1 time
Total time:   0.000265000
 Self time:   0.000265000

count     total (s)      self (s)
                            " Author: Jerko Steiner <jerko.steiner@gmail.com>
                            " Description: Code action support for LSP / tsserver
                            
    1              0.000001000 function! ale#code_action#ReloadBuffer() abort
                                let l:buffer = bufnr('')
                            
                                execute 'augroup ALECodeActionReloadGroup' . l:buffer
                                    autocmd!
                                augroup END
                            
                                silent! execute 'augroup! ALECodeActionReloadGroup' . l:buffer
                            
                                call ale#util#Execute(':e!')
                            endfunction
                            
    1              0.000001000 function! ale#code_action#HandleCodeAction(code_action, options) abort
                                let l:current_buffer = bufnr('')
                                let l:changes = a:code_action.changes
                            
                                for l:file_code_edit in l:changes
                                    call ale#code_action#ApplyChanges(
                                    \   l:file_code_edit.fileName,
                                    \   l:file_code_edit.textChanges,
                                    \   a:options,
                                    \)
                                endfor
                            endfunction
                            
    1              0.000002000 function! s:ChangeCmp(left, right) abort
                                if a:left.start.line < a:right.start.line
                                    return -1
                                endif
                            
                                if a:left.start.line > a:right.start.line
                                    return 1
                                endif
                            
                                if a:left.start.offset < a:right.start.offset
                                    return -1
                                endif
                            
                                if a:left.start.offset > a:right.start.offset
                                    return 1
                                endif
                            
                                if a:left.end.line < a:right.end.line
                                    return -1
                                endif
                            
                                if a:left.end.line > a:right.end.line
                                    return 1
                                endif
                            
                                if a:left.end.offset < a:right.end.offset
                                    return -1
                                endif
                            
                                if a:left.end.offset > a:right.end.offset
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000001000 function! ale#code_action#ApplyChanges(filename, changes, options) abort
                                let l:should_save = get(a:options, 'should_save')
                                let l:conn_id = get(a:options, 'conn_id')
                            
                                let l:orig_buffer = bufnr('')
                            
                                " The buffer is used to determine the fileformat, if available.
                                let l:buffer = bufnr(a:filename)
                            
                                if l:buffer != l:orig_buffer
                                    call ale#util#Execute('silent edit ' . a:filename)
                                    let l:buffer = bufnr('')
                                endif
                            
                                let l:lines = getbufline(l:buffer, 1, '$')
                            
                                " Add empty line if there's trailing newline, like readfile() does.
                                if getbufvar(l:buffer, '&eol')
                                    let l:lines += ['']
                                endif
                            
                                let l:pos = getpos('.')[1:2]
                            
                                " Changes have to be sorted so we apply them from bottom-to-top
                                for l:code_edit in reverse(sort(copy(a:changes), function('s:ChangeCmp')))
                                    let l:line = l:code_edit.start.line
                                    let l:column = l:code_edit.start.offset
                                    let l:end_line = l:code_edit.end.line
                                    let l:end_column = l:code_edit.end.offset
                                    let l:text = l:code_edit.newText
                            
                                    let l:insertions = split(l:text, '\n', 1)
                            
                                    " Fix invalid columns
                                    let l:column = l:column > 0 ? l:column : 1
                                    let l:end_column = l:end_column > 0 ? l:end_column : 1
                            
                                    " Clamp start to BOF
                                    if l:line < 1
                                        let [l:line, l:column] = [1, 1]
                                    endif
                            
                                    " Clamp start to EOF
                                    if l:line > len(l:lines) || l:line == len(l:lines) && l:column > len(l:lines[-1]) + 1
                                        let [l:line, l:column] = [len(l:lines), len(l:lines[-1]) + 1]
                                    " Special case when start is after EOL
                                    elseif l:line < len(l:lines) && l:column > len(l:lines[l:line - 1]) + 1
                                        let [l:line, l:column] = [l:line + 1, 1]
                                    endif
                            
                                    " Adjust end: clamp if invalid and/or adjust if we moved start
                                    if l:end_line < l:line || l:end_line == l:line && l:end_column < l:column
                                        let [l:end_line, l:end_column] = [l:line, l:column]
                                    endif
                            
                                    " Clamp end to EOF
                                    if l:end_line > len(l:lines) || l:end_line == len(l:lines) && l:end_column > len(l:lines[-1]) + 1
                                        let [l:end_line, l:end_column] = [len(l:lines), len(l:lines[-1]) + 1]
                                    " Special case when end is after EOL
                                    elseif l:end_line < len(l:lines) && l:end_column > len(l:lines[l:end_line - 1]) + 1
                                        let [l:end_line, l:end_column] = [l:end_line + 1, 1]
                                    endif
                            
                                    " Careful, [:-1] is not an empty list
                                    let l:start = l:line is 1 ? [] : l:lines[: l:line - 2]
                                    let l:middle = l:column is 1 ? [''] : [l:lines[l:line - 1][: l:column - 2]]
                            
                                    let l:middle[-1] .= l:insertions[0]
                                    let l:middle     += l:insertions[1:]
                                    let l:middle[-1] .= l:lines[l:end_line - 1][l:end_column - 1 :]
                            
                                    let l:end_line_len = len(l:lines[l:end_line - 1])
                                    let l:lines_before_change = len(l:lines)
                                    let l:lines = l:start + l:middle + l:lines[l:end_line :]
                            
                                    let l:current_line_offset = len(l:lines) - l:lines_before_change
                                    let l:column_offset = len(l:middle[-1]) - l:end_line_len
                            
                                    " Keep cursor where it was (if outside of changes) or move it after
                                    " the changed text (if inside), but don't touch it when the change
                                    " spans the entire buffer, in which case we have no clue and it's
                                    " better to not do anything.
                                    if l:line isnot 1 || l:column isnot 1
                                    \|| l:end_line < l:lines_before_change
                                    \|| l:end_line == l:lines_before_change && l:end_column <= l:end_line_len
                                        let l:pos = s:UpdateCursor(l:pos,
                                        \ [l:line, l:column],
                                        \ [l:end_line, l:end_column],
                                        \ [l:current_line_offset, l:column_offset])
                                    endif
                                endfor
                            
                                " Make sure to add a trailing newline if and only if it should be added.
                                if l:lines[-1] is# '' && getbufvar(l:buffer, '&eol')
                                    call remove(l:lines, -1)
                                else
                                    call setbufvar(l:buffer, '&eol', 0)
                                endif
                            
                                call ale#util#SetBufferContents(l:buffer, l:lines)
                            
                                call ale#lsp#NotifyForChanges(l:conn_id, l:buffer)
                            
                                if l:should_save
                                    call ale#util#Execute('silent w!')
                                endif
                            
                                call setpos('.', [0, l:pos[0], l:pos[1], 0])
                            
                                if l:orig_buffer != l:buffer && bufexists(l:orig_buffer)
                                    call ale#util#Execute('silent buf ' . string(l:orig_buffer))
                                endif
                            endfunction
                            
    1              0.000001000 function! s:UpdateCursor(cursor, start, end, offset) abort
                                let l:cur_line = a:cursor[0]
                                let l:cur_column = a:cursor[1]
                                let l:line = a:start[0]
                                let l:column = a:start[1]
                                let l:end_line = a:end[0]
                                let l:end_column = a:end[1]
                                let l:line_offset = a:offset[0]
                                let l:column_offset = a:offset[1]
                            
                                if l:end_line < l:cur_line
                                    " both start and end lines are before the cursor. only line offset
                                    " needs to be updated
                                    let l:cur_line += l:line_offset
                                elseif l:end_line == l:cur_line
                                    " end line is at the same location as cursor, which means
                                    " l:line <= l:cur_line
                                    if l:line < l:cur_line || l:column <= l:cur_column
                                        " updates are happening either before or around the cursor
                                        if l:end_column < l:cur_column
                                            " updates are happening before the cursor, update the
                                            " column offset for cursor
                                            let l:cur_line += l:line_offset
                                            let l:cur_column += l:column_offset
                                        else
                                            " updates are happening around the cursor, move the cursor
                                            " to the end of the changes
                                            let l:cur_line += l:line_offset
                                            let l:cur_column = l:end_column + l:column_offset
                                        endif
                                    " else is not necessary, it means modifications are happening
                                    " after the cursor so no cursor updates need to be done
                                    endif
                                else
                                    " end line is after the cursor
                                    if l:line < l:cur_line || l:line == l:cur_line && l:column <= l:cur_column
                                        " changes are happening around the cursor, move the cursor
                                        " to the end of the changes
                                        let l:cur_line = l:end_line + l:line_offset
                                        let l:cur_column = l:end_column + l:column_offset
                                    " else is not necessary, it means modifications are happening
                                    " after the cursor so no cursor updates need to be done
                                    endif
                                endif
                            
                                return [l:cur_line, l:cur_column]
                            endfunction
                            
    1              0.000001000 function! ale#code_action#GetChanges(workspace_edit) abort
                                if a:workspace_edit is v:null
                                    return {}
                                endif
                            
                                let l:changes = {}
                            
                                if has_key(a:workspace_edit, 'changes') && !empty(a:workspace_edit.changes)
                                    return a:workspace_edit.changes
                                elseif has_key(a:workspace_edit, 'documentChanges')
                                    let l:document_changes = []
                            
                                    if type(a:workspace_edit.documentChanges) is v:t_dict
                                    \ && has_key(a:workspace_edit.documentChanges, 'edits')
                                        call add(l:document_changes, a:workspace_edit.documentChanges)
                                    elseif type(a:workspace_edit.documentChanges) is v:t_list
                                        let l:document_changes = a:workspace_edit.documentChanges
                                    endif
                            
                                    for l:text_document_edit in l:document_changes
                                        let l:filename = l:text_document_edit.textDocument.uri
                                        let l:edits = l:text_document_edit.edits
                                        let l:changes[l:filename] = l:edits
                                    endfor
                                endif
                            
                                return l:changes
                            endfunction
                            
    1              0.000001000 function! ale#code_action#BuildChangesList(changes_map) abort
                                let l:changes = []
                            
                                for l:file_name in keys(a:changes_map)
                                    let l:text_edits = a:changes_map[l:file_name]
                                    let l:text_changes = []
                            
                                    for l:edit in l:text_edits
                                        let l:range = l:edit.range
                                        let l:new_text = l:edit.newText
                            
                                        call add(l:text_changes, {
                                        \ 'start': {
                                        \   'line': l:range.start.line + 1,
                                        \   'offset': l:range.start.character + 1,
                                        \ },
                                        \ 'end': {
                                        \   'line': l:range.end.line + 1,
                                        \   'offset': l:range.end.character + 1,
                                        \ },
                                        \ 'newText': l:new_text,
                                        \})
                                    endfor
                            
                                    call add(l:changes, {
                                    \   'fileName': ale#util#ToResource(l:file_name),
                                    \   'textChanges': l:text_changes,
                                    \})
                                endfor
                            
                                return l:changes
                            endfunction
                            
    1              0.000000000 function! s:EscapeMenuName(text) abort
                                return substitute(a:text, '\\\| \|\.\|&', '\\\0', 'g')
                            endfunction
                            
    1              0.000000000 function! s:UpdateMenu(data, menu_items) abort
                                silent! aunmenu PopUp.Refactor\.\.\.
                            
                                if empty(a:data)
                                    return
                                endif
                            
                                for [l:type, l:item] in a:menu_items
                                    let l:name = l:type is# 'tsserver' ? l:item.name : l:item.title
                                    let l:func_name = l:type is# 'tsserver'
                                    \   ? 'ale#codefix#ApplyTSServerCodeAction'
                                    \   : 'ale#codefix#ApplyLSPCodeAction'
                            
                                    execute printf(
                                    \   'anoremenu <silent> PopUp.&Refactor\.\.\..%s'
                                    \       . ' :call %s(%s, %s)<CR>',
                                    \   s:EscapeMenuName(l:name),
                                    \   l:func_name,
                                    \   string(a:data),
                                    \   string(l:item),
                                    \)
                                endfor
                            
                                if empty(a:menu_items)
                                    silent! anoremenu PopUp.Refactor\.\.\..(None) :silent
                                endif
                            endfunction
                            
    1              0.000001000 function! s:GetCodeActions(linter, options) abort
                                let l:buffer = bufnr('')
                                let [l:line, l:column] = getpos('.')[1:2]
                                let l:column = min([l:column, len(getline(l:line))])
                            
                                let l:location = {
                                \   'buffer': l:buffer,
                                \   'line': l:line,
                                \   'column': l:column,
                                \   'end_line': l:line,
                                \   'end_column': l:column,
                                \}
                                let l:Callback = function('s:OnReady', [l:location, a:options])
                                call ale#lsp_linter#StartLSP(l:buffer, a:linter, l:Callback)
                            endfunction
                            
    1              0.000001000 function! ale#code_action#GetCodeActions(options) abort
                                silent! aunmenu PopUp.Rename
                                silent! aunmenu PopUp.Refactor\.\.\.
                            
                                " Only display the menu items if there's an LSP server.
                                if len(ale#lsp_linter#GetEnabled(bufnr(''))) > 0
                                    if !empty(expand('<cword>'))
                                        silent! anoremenu <silent> PopUp.Rename :ALERename<CR>
                                    endif
                            
                                    silent! anoremenu <silent> PopUp.Refactor\.\.\..(None) :silent<CR>
                            
                                    call ale#codefix#Execute(
                                    \   mode() is# 'v' || mode() is# "\<C-V>",
                                    \   function('s:UpdateMenu')
                                    \)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:Setup(enabled) abort
                                augroup ALECodeActionsGroup
                                    autocmd!
                            
                                    if a:enabled
                                        autocmd MenuPopup * :call ale#code_action#GetCodeActions({})
                                    endif
                                augroup END
                            
                                if !a:enabled
                                    silent! augroup! ALECodeActionsGroup
                            
                                    silent! aunmenu PopUp.Rename
                                    silent! aunmenu PopUp.Refactor\.\.\.
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#code_action#EnablePopUpMenu() abort
                                call s:Setup(1)
                            endfunction
                            
    1              0.000001000 function! ale#code_action#DisablePopUpMenu() abort
                                call s:Setup(0)
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/events.vim
Sourced 1 time
Total time:   0.000085000
 Self time:   0.000085000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: ALE functions for autocmd events.
                            
                            " Get the number of milliseconds since some vague, but consistent, point in
                            " the past.
                            "
                            " This function can be used for timing execution, etc.
                            "
                            " The time will be returned as a Number.
    1              0.000001000 function! ale#events#ClockMilliseconds() abort
                                return float2nr(reltimefloat(reltime()) * 1000)
                            endfunction
                            
    1              0.000001000 function! ale#events#QuitEvent(buffer) abort
                                " Remember when ALE is quitting for BufWrite, etc.
                                call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())
                            endfunction
                            
    1              0.000001000 function! ale#events#QuitRecently(buffer) abort
                                let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
                                return l:time && ale#events#ClockMilliseconds() - l:time < 1000
                            endfunction
                            
    1              0.000001000 function! ale#events#SaveEvent(buffer) abort
                                let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
                                if l:should_lint
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 1)
                                endif
                            
                                if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
                                if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#events#LintOnEnter(buffer) abort
                                " Unmark a file as being changed outside of Vim after we try to check it.
                                call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
                                if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#events#ReadOrEnterEvent(buffer) abort
                                " Apply pattern options if the variable is set.
                                if get(g:, 'ale_pattern_options_enabled', 1)
                                \&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
                                endif
                            
                                " When entering a buffer, we are no longer quitting it.
                                call setbufvar(a:buffer, 'ale_quitting', 0)
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
                                if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#events#FileTypeEvent(buffer, new_filetype) abort
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
                                let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
                                if l:old_filetype isnot v:null
                                \&& !empty(a:new_filetype)
                                \&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
                                    call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
                                    if g:ale_lint_on_filetype_changed
                                        call ale#Queue(300, 'lint_file', a:buffer)
                                    endif
                                endif
                            endfunction
                            
    1              0.000000000 function! ale#events#FileChangedEvent(buffer) abort
                                call setbufvar(a:buffer, 'ale_file_changed', 1)
                            
                                if bufnr('') == a:buffer
                                    call ale#events#LintOnEnter(a:buffer)
                                endif
                            endfunction
                            
                            " A timer for emulating InsertLeave.
                            "
                            " We only need a single timer, and we'll lint the last buffer we entered
                            " insert mode on.
    1              0.000002000 if !exists('s:insert_leave_timer')
    1              0.000002000     let s:insert_leave_timer = -1
    1              0.000000000 endif
                            
                            " True if the ModeChanged event exists.
                            " In this case, ModeChanged will be used instead of InsertLeave emulation.
    1              0.000002000 let s:mode_changed_exists = exists('##ModeChanged')
                            
    1              0.000001000 function! ale#events#EmulateInsertLeave(buffer) abort
                                if mode() is# 'n'
                                    call timer_stop(s:insert_leave_timer)
                                    call ale#Queue(0, '', a:buffer)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#events#InsertEnterEvent(buffer) abort
                                if g:ale_close_preview_on_insert && exists('*ale#preview#CloseIfTypeMatches')
                                    call ale#preview#CloseIfTypeMatches('ale-preview')
                                endif
                            
                                " Start a repeating timer if the use might not trigger InsertLeave, so we
                                " can emulate its behavior.
                                " If the ModeChanged autocmd exists, it will be used instead of this
                                " timer; as ModeChanged will be sent regardless of how the insert mode is
                                " exited, including <Esc>, <C-c> and <C-]>.
                                if ale#Var(a:buffer, 'lint_on_insert_leave')
                                \&& maparg("\<C-c>", 'i') isnot# '<Esc>'
                                \&& !s:mode_changed_exists
                                    call timer_stop(s:insert_leave_timer)
                                    let s:insert_leave_timer = timer_start(
                                    \   100,
                                    \   {-> ale#events#EmulateInsertLeave(a:buffer) },
                                    \   {'repeat': -1}
                                    \)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#events#InsertLeaveEvent(buffer) abort
                                " Kill the InsertLeave emulation if the event fired.
                                " If the ModeChanged event is available, it will be used instead of
                                " a timer.
                                if !s:mode_changed_exists
                                    call timer_stop(s:insert_leave_timer)
                                endif
                            
                                if ale#Var(a:buffer, 'lint_on_insert_leave')
                                    call ale#Queue(0, '', a:buffer)
                                endif
                            
                                " Look for a warning to echo as soon as we leave Insert mode.
                                " The script's position variable used when moving the cursor will
                                " not be changed here.
                                "
                                " We don't echo this message in emulated insert leave mode, as the user
                                " may want less work to happen on pressing <C-c> versus <Esc>
                                if exists('*ale#engine#Cleanup')
                                    call ale#cursor#EchoCursorWarning()
                            
                                    if g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor is# 1 || g:ale_virtualtext_cursor is# '1'
                                        " Show a virtualtext message if enabled.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                                endif
                            endfunction
                            
    1              0.000000000 function! ale#events#Init() abort
                                " This value used to be a Boolean as a Number, and is now a String.
                                let l:text_changed = '' . g:ale_lint_on_text_changed
                            
                                augroup ALEEvents
                                    autocmd!
                            
                                    " These events always need to be set up.
                                    autocmd BufEnter,BufRead * call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
                                    autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))
                            
                                    if g:ale_enabled
                                        if l:text_changed is? 'always'
                                        \|| l:text_changed is# '1'
                                        \|| g:ale_lint_on_text_changed is v:true
                                            autocmd TextChanged,TextChangedI * call ale#Queue(ale#Var(str2nr(expand('<abuf>')), 'lint_delay'))
                                        elseif l:text_changed is? 'normal'
                                            autocmd TextChanged * call ale#Queue(ale#Var(str2nr(expand('<abuf>')), 'lint_delay'))
                                        elseif l:text_changed is? 'insert'
                                            autocmd TextChangedI * call ale#Queue(ale#Var(str2nr(expand('<abuf>')), 'lint_delay'))
                                        endif
                            
                                        if g:ale_lint_on_enter
                                            autocmd BufWinEnter * call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
                                            " Track when the file is changed outside of Vim.
                                            autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))
                                        endif
                            
                                        if g:ale_lint_on_filetype_changed
                                            " Only start linting if the FileType actually changes after
                                            " opening a buffer. The FileType will fire when buffers are opened.
                                            autocmd FileType * call ale#events#FileTypeEvent(
                                            \   str2nr(expand('<abuf>')),
                                            \   expand('<amatch>')
                                            \)
                                        endif
                            
                                        " Add an InsertEnter event if we need to close the preview window
                                        " on entering insert mode, or if we want to run ALE on leaving
                                        " insert mode and <C-c> is not the same as <Esc>.
                                        "
                                        " We will emulate leaving insert mode for users that might not
                                        " trigger InsertLeave.
                                        "
                                        " If the ModeChanged event is available, this timer will not
                                        " be used.
                                        if g:ale_close_preview_on_insert
                                        \|| (g:ale_lint_on_insert_leave && maparg("\<C-c>", 'i') isnot# '<Esc>' && !s:mode_changed_exists)
                                            autocmd InsertEnter * call ale#events#InsertEnterEvent(str2nr(expand('<abuf>')))
                                        endif
                            
                                        let l:add_insert_leave_event = g:ale_lint_on_insert_leave
                            
                                        if g:ale_echo_cursor || g:ale_cursor_detail
                                            " We need to make the message display on InsertLeave
                                            let l:add_insert_leave_event = 1
                            
                                            autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
                                        endif
                            
                                        if g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor is# 1 || g:ale_virtualtext_cursor is# '1'
                                            " We need to make the message display on InsertLeave
                                            let l:add_insert_leave_event = 1
                            
                                            autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarningWithDelay() | endif
                                        endif
                            
                                        if l:add_insert_leave_event
                                            if s:mode_changed_exists
                                                " If the ModeChanged event is available, handle any
                                                " transition from the Insert mode to any other mode.
                                                autocmd ModeChanged i*:* call ale#events#InsertLeaveEvent(str2nr(expand('<abuf>')))
                                            else
                                                " If ModeChanged is not available, handle InsertLeave events.
                                                autocmd InsertLeave * call ale#events#InsertLeaveEvent(str2nr(expand('<abuf>')))
                                            endif
                                        endif
                            
                                        if g:ale_hover_cursor
                                            autocmd CursorHold * if exists('*ale#lsp#Send') | call ale#hover#ShowTruncatedMessageAtCursor() | endif
                                        endif
                                    endif
                                augroup END
                            
                                augroup AleURISchemes
                                    autocmd!
                            
                                    autocmd BufNewFile,BufReadPre jdt://** call ale#uri#jdt#ReadJDTLink(expand('<amatch>'))
                                augroup END
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-boxdraw/plugin/boxdraw.vim
Sourced 1 time
Total time:   0.000148000
 Self time:   0.000148000

count     total (s)      self (s)
    1              0.000002000 vim9script
                            
                            # A plugin to draw boxes, tables, etc.
                            
    1              0.000004000 const devmode = exists("g:module_export")
                            
    1              0.000001000 final boxdraw_mod: dict<func> = {}
                            
    1              0.000001000 if devmode
                              g:module_export->filter('0')
                              source <script>:p:h/../autoload/boxdraw.vim
                              boxdraw_mod->filter('0')
                              boxdraw_mod->extend({
                                BoxDraw: g:module_export.BoxDraw,
                              })
                              command! -nargs=* BoxDraw boxdraw_mod.BoxDraw(<f-args>)
                              echo "autoload/boxdraw.vim reloaded"
    1              0.000000000 else
    1              0.000023000   import autoload "../autoload/boxdraw.vim"
    1              0.000002000   command! -nargs=* BoxDraw boxdraw.BoxDraw(<f-args>)
    1              0.000000000 endif
                            
    1              0.000002000 if get(g:, "boxdraw_skip_mappings") == 0
    1              0.000006000   if mapcheck("<Leader>b", "v")->empty() || devmode
                                # Not-forced not-emptied boxes
                                vnoremap <Leader>bs <Esc><Cmd>BoxDraw single<CR>
                                vnoremap <Leader>bd <Esc><Cmd>BoxDraw double<CR>
                                vnoremap <Leader>br <Esc><Cmd>BoxDraw rounded<CR>
                                vnoremap <Leader>ba <Esc><Cmd>BoxDraw ascii<CR>
                                vnoremap <Leader>bc <Esc><Cmd>BoxDraw clear<CR>
                                vnoremap <Leader>bb <Esc><Cmd>BoxDraw<CR>
                            
                                # Not-forced emptied boxes
                                vnoremap <Leader>bes <Esc><Cmd>BoxDraw single false true<CR>
                                vnoremap <Leader>bed <Esc><Cmd>BoxDraw double false true<CR>
                                vnoremap <Leader>ber <Esc><Cmd>BoxDraw rounded false true<CR>
                                vnoremap <Leader>bea <Esc><Cmd>BoxDraw ascii false true<CR>
                                vnoremap <Leader>bec <Esc><Cmd>BoxDraw clear false true<CR>
                            
                                # Diagonals (always 'single' style)
                                vnoremap <Leader>b/ <Esc><Cmd>BoxDraw DIAGONAL_FORWARD<CR>
                                vnoremap <Leader>b\ <Esc><Cmd>BoxDraw DIAGONAL_BACKWARD<CR>
                            
                                # Selection
                                vnoremap <Leader>bl <Esc><Cmd>BoxDraw SELECTBOX<CR>
    1              0.000000000   endif
                            
    1              0.000004000   if mapcheck("<Leader>B", "v")->empty() || devmode
                                # Forced not-emptied boxes
    1              0.000004000     vnoremap <Leader>BS <Esc><Cmd>BoxDraw single true<CR>
    1              0.000003000     vnoremap <Leader>BD <Esc><Cmd>BoxDraw double true<CR>
    1              0.000003000     vnoremap <Leader>BR <Esc><Cmd>BoxDraw rounded true<CR>
    1              0.000003000     vnoremap <Leader>BA <Esc><Cmd>BoxDraw ascii true<CR>
    1              0.000003000     vnoremap <Leader>BC <Esc><Cmd>BoxDraw clear true<CR>
    1              0.000002000     vnoremap <Leader>BB <Esc><Cmd>BoxDraw IBID true<CR>
                            
                                # Forced emptied boxes
    1              0.000003000     vnoremap <Leader>BES <Esc><Cmd>BoxDraw single true true<CR>
    1              0.000003000     vnoremap <Leader>BED <Esc><Cmd>BoxDraw double true true<CR>
    1              0.000003000     vnoremap <Leader>BER <Esc><Cmd>BoxDraw rounded true true<CR>
    1              0.000003000     vnoremap <Leader>BEA <Esc><Cmd>BoxDraw ascii true true<CR>
    1              0.000003000     vnoremap <Leader>BEC <Esc><Cmd>BoxDraw clear true true<CR>
    1              0.000000000   endif
                            
                              # Normal mode selection
    1              0.000004000   if mapcheck("<Leader><Leader>bl", "n")->empty() || devmode
    1              0.000003000     nnoremap <Leader><Leader>bl <Cmd>BoxDraw SELECTBOX<CR>
    1              0.000000000   endif
                            
                              # One-key meta shortcuts
    1              0.000004000   if mapcheck("<M-b>", "v")->empty() || devmode
    1              0.000003000     vnoremap <M-b> <Esc><Cmd>BoxDraw<CR>
    1              0.000000000   endif
    1              0.000004000   if mapcheck("<M-B>", "v")->empty() || devmode
    1              0.000003000     vnoremap <M-B> <Esc><Cmd>BoxDraw IBID true<CR>
    1              0.000000000   endif
    1              0.000004000   if mapcheck("<M-L>", "v")->empty() || devmode
    1              0.000003000     vnoremap <M-L> <Esc><Cmd>BoxDraw SELECTBOX<CR>
    1              0.000001000   endif
    1              0.000004000   if mapcheck("<M-L>", "n")->empty() || devmode
    1              0.000003000     nnoremap <M-L> <Cmd>BoxDraw SELECTBOX<CR>
    1              0.000000000   endif
                            
    1              0.000002000 endif  # boxdraw_skip_mappings

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/plugin/vader.vim
Sourced 1 time
Total time:   0.000028000
 Self time:   0.000028000

count     total (s)      self (s)
                            " Copyright (c) 2015 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000002000 if exists('g:loaded_vader')
                              finish
    1              0.000000000 endif
                            
    1              0.000001000 if &compatible
                              function! s:vader(...) range
                                echoerr 'Cannot run Vader in compatible mode'
                              endfunction
    1              0.000000000 else
    1              0.000001000   let g:loaded_vader = 1
                            
    1              0.000000000   function! s:vader(...) range
                                if a:lastline - a:firstline > 0 && a:0 > 1
                                  echoerr 'Range and file arguments are mutually exclusive'
                                  return
                                endif
                                execute printf("%d,%dcall vader#run(%s)", a:firstline, a:lastline, string(a:000)[1:-2])
                              endfunction
    1              0.000001000 endif
                            
    1              0.000005000 command! -bang -nargs=* -range -complete=file Vader <line1>,<line2>call s:vader(<bang>0, <f-args>)

SCRIPT  /Users/danbradbury/.vim/bundle/modes.vim/plugin/modes.vim
Sourced 1 time
Total time:   0.000079000
 Self time:   0.000079000

count     total (s)      self (s)
    1              0.000001000 vim9script
    1              0.000033000 import autoload 'modes.vim' as base
                            
    1              0.000002000 if exists('g:loaded_modes')
                              finish
    1              0.000001000 endif
    1              0.000001000 g:loaded_modes = 1
                            
    1              0.000000000 g:modes_pending_operator = ''
                            
    1              0.000003000 nnoremap <expr> d base.TrackOperator('delete')
    1              0.000002000 nnoremap <expr> y base.TrackOperator('yank')
    1              0.000002000 nnoremap <expr> r base.TrackOperator('replace')
                            
    1              0.000001000 augroup Modes
    1              0.000013000   autocmd!
    1              0.000002000   autocmd CursorMoved * if g:modes_pending_operator !=# '' | call base.OnOperatorComplete() | endif
    1              0.000002000   autocmd InsertEnter * call base.SetInsertModeCursorline()
    1              0.000001000   autocmd InsertLeave * call base.SetNormalModeCursorline()
    1              0.000001000   autocmd CmdlineEnter : call base.SetNormalModeCursorline()
                            
    1              0.000002000   autocmd ModeChanged *:v call base.SetVisualHighlight()
    1              0.000001000   autocmd ModeChanged v:* call base.SetNormalHighlight()
    1              0.000001000   autocmd ModeChanged *:V call base.SetVisualHighlight()
    1              0.000001000   autocmd ModeChanged V:* call base.SetNormalHighlight()
    1              0.000001000   autocmd ModeChanged *:R call base.SetReplaceHighlight()
    1              0.000002000   autocmd ModeChanged *:Rv call base.SetReplaceHighlight()
    1              0.000001000 augroup END

SCRIPT  /Users/danbradbury/.vim/bundle/modes.vim/autoload/modes.vim
Sourced 1 time
Total time:   0.000849000
 Self time:   0.000849000

count     total (s)      self (s)
    1              0.000020000 vim9script
    1              0.000341000 import autoload 'modes/color.vim' as color
                            
    1              0.000011000 g:modes_pending_operator = ''
                            
    1              0.000005000 g:modes_colors = {
                              'insert': { 'gui': '#78ccc5', 'term': 74 },
                              'yank': { 'gui': '#f5c359', 'term': 221 },
                              'delete': { 'gui': '#c75c6a', 'term': 174 },
                              'replace': { 'gui': '#d75f00', 'term': 166 },
                              'visual': { 'gui': '#9745be', 'term': 135 }
                            }
    1              0.000017000 var cterm_blend = 35
    1              0.000003000 var gui_blend = 35
                            
    1              0.000028000 if exists('g:modes_custom_colors')
                              for [mode, settings] in items(g:modes_custom_colors)
                                for [col, val] in items(settings)
                                  echom col
                                  g:modes_colors[mode][col] = val
                                endfor
                              endfor
    1              0.000003000 endif
                            
    1              0.000023000 export def TrackOperator(op: string): string
                              if op ==# 'yank'
                                g:modes_pending_operator = 'yank'
                                var ctbg = color.ComputeBlendedColorCterm(g:modes_colors.yank.term, cterm_blend)
                                var gbg = color.ComputeBlendedColor(g:modes_colors.yank.gui, gui_blend)
                                execute $'highlight CursorLine guibg={gbg} ctermbg={ctbg}'
                                return 'y'
                              elseif op ==# 'delete'
                                g:modes_pending_operator = 'delete'
                                var ctbg = color.ComputeBlendedColorCterm(g:modes_colors.delete.term, cterm_blend)
                                execute $'highlight CursorLine guibg={color.ComputeBlendedColor(g:modes_colors.delete.gui, gui_blend)} ctermbg={ctbg}'
                                return 'd'
                              elseif op ==# 'replace'
                                g:modes_pending_operator = 'replace'
                                execute $'highlight CursorLine guibg={color.ComputeBlendedColor(g:modes_colors.replace.gui, gui_blend)} cterm=underline ctermul={g:modes_colors.replace.term}'
                                return 'r'
                              endif
                              return ''
                            enddef
                            
    1              0.000009000 export def OnOperatorComplete()
                              g:modes_pending_operator = ''
                              highlight clear CursorLine
                            enddef
                            
    1              0.000006000 export def SetVisualHighlight()
                              var blended = color.ComputeBlendedColor(g:modes_colors.visual.gui, gui_blend)
                              var ctbg = color.ComputeBlendedColorCterm(g:modes_colors.visual.term, cterm_blend)
                              execute $'highlight Visual guibg={blended} ctermfg={ctbg}'
                            enddef
                            
    1              0.000007000 export def SetNormalHighlight()
                              highlight CursorLine guibg=NONE
                              highlight LineNr guibg=NONE
                            enddef
                            
    1              0.000007000 export def SetInsertModeCursorline()
                              var blended = color.ComputeBlendedColor(g:modes_colors.insert.gui, gui_blend)
                              execute $'highlight CursorLine guibg={blended} cterm=underline ctermul={g:modes_colors.insert.term}'
                            enddef
                            
    1              0.000006000 export def SetReplaceHighlight()
                              var blended = color.ComputeBlendedColor(g:modes_colors.replace.gui, gui_blend)
                              execute $'highlight CursorLine guibg={blended} cterm=underline ctermul={g:modes_colors.replace.term}'
                            enddef
                            
    1              0.000006000 export def SetNormalModeCursorline()
                              highlight CursorLine guibg=NONE ctermbg=NONE cterm=NONE
                              highlight LineNr guibg=NONE ctermbg=NONE
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/github-actions.vim/plugin/github_actions.vim
Sourced 1 time
Total time:   0.000048000
 Self time:   0.000048000

count     total (s)      self (s)
    1              0.000001000 vim9script
    1              0.000001000 scriptencoding utf-8
                            
    1              0.000038000 import autoload 'github_actions.vim' as base
                            
    1              0.000002000 if exists('g:loaded_github_actions')
                              finish
    1              0.000001000 endif
    1              0.000000000 g:loaded_github_actions = 1
                            
    1              0.000002000 command! -nargs=0 GithubActions base.OpenPopup()

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/plugin/copilot_chat.vim
Sourced 1 time
Total time:   0.000328000
 Self time:   0.000328000

count     total (s)      self (s)
    1              0.000001000 vim9script
    1              0.000001000 scriptencoding utf-8
                            
    1              0.000039000 import autoload 'copilot_chat.vim' as copilot
    1              0.000041000 import autoload 'copilot_chat/api.vim' as api
    1              0.000038000 import autoload 'copilot_chat/buffer.vim' as _buffer
    1              0.000040000 import autoload 'copilot_chat/config.vim' as config
    1              0.000041000 import autoload 'copilot_chat/history.vim' as history
    1              0.000040000 import autoload 'copilot_chat/models.vim' as models
                            
    1              0.000001000 if exists('g:loaded_copilot_chat')
                              finish
    1              0.000000000 endif
    1              0.000001000 g:loaded_copilot_chat = 1
                            
    1              0.000001000 g:copilot_chat_prompts = {}
    1              0.000001000 g:copilot_chat_active_buffer = -1
    1              0.000007000 g:copilot_chat_data_dir = get(g:, 'copilot_chat_data_dir', expand('~/.vim/copilot-chat', 1))
    1              0.000001000 g:copilot_chat_zombie_buffer = -1
    1              0.000002000 g:copilot_reuse_active_chat = get(g:, 'copilot_reuse_active_chat', 0)
    1              0.000002000 g:copilot_chat_create_on_add_selection = get(g:, 'copilot_chat_create_on_add_selection', 1)
    1              0.000002000 g:copilot_chat_jump_to_chat_on_add_selection = get(g:, 'copilot_chat_jump_to_chat_on_add_selection', 1)
    1              0.000002000 g:copilot_chat_message_history_limit = get(g:, 'copilot_chat_message_history_limit', 20)
    1              0.000002000 g:copilot_chat_syntax_debounce_ms = get(g:, 'copilot_chat_syntax_debounce_ms', 300)
    1              0.000001000 g:copilot_chat_file_cache_timeout = get(g:, 'copilot_chat_file_cache_timeout', 5)
                            
    1              0.000001000 command! -nargs=0 CopilotChatOpen copilot.OpenChat()
    1              0.000001000 command! -nargs=1 CopilotChat copilot.StartChat(<q-args>)
    1              0.000001000 command! -nargs=0 CopilotChatFocus _buffer.FocusActiveChat()
    1              0.000001000 command! -nargs=0 CopilotChatSubmit copilot.SubmitMessage()
    1              0.000001000 command! -nargs=0 CopilotChatConfig config.View()
    1              0.000001000 command! -nargs=0 CopilotChatModels models.Select()
    1              0.000001000 command! -nargs=? CopilotChatSave history.Save(<q-args>)
    1              0.000001000 command! -nargs=? -complete=customlist,history.Complete CopilotChatLoad history.Load(<q-args>)
    1              0.000001000 command! -nargs=0 CopilotChatList history.List()
    1              0.000001000 command! -nargs=0 CopilotChatReset copilot.ResetChat()
    1              0.000002000 command! -nargs=? CopilotChatSetActive _buffer.SetActive(<q-args>)
    1              0.000001000 command! -nargs=0 CopilotChatToggle _buffer.ToggleActiveChat()
                            
    1              0.000004000 vnoremap <silent> <Plug>CopilotChatAddSelection :<C-u>call _buffer.AddSelection()<CR>
                            
                            #requires a wrapper for use in autocmds
    1              0.000002000 def OnDeleteWrapper(a: string): void
                              _buffer.OnDelete(str2nr(a))
                            enddef
                            
    1              0.000001000 def ApplyCodeBlockSyntaxWrapper(): void
                              _buffer.ApplyCodeBlockSyntax()
                            enddef
                            
    1              0.000002000 def CheckForMacroWrapper(): void
                              _buffer.CheckForMacro()
                            enddef
                            
    1              0.000001000 def ResizeWrapper(): void
                              _buffer.Resize()
                            enddef
                            
    1              0.000001000 augroup CopilotChat
    1              0.000012000   autocmd!
    1              0.000003000   autocmd FileType copilot_chat autocmd BufDelete <buffer> _buffer.OnDelete(expand('<abuf>'))
    1              0.000001000   autocmd FileType copilot_chat autocmd BufEnter,TextChanged,TextChangedI <buffer> _buffer.ApplyCodeBlockSyntax()
    1              0.000001000   autocmd FileType copilot_chat autocmd TextChangedI <buffer> _buffer.CheckForMacro()
    1              0.000003000   if has('patch-9.0.0917')
    1              0.000002000     autocmd VimResized,WinResized * _buffer.Resize()
                              else
                                autocmd VimResized * _buffer.Resize()
    1              0.000000000   endif
    1              0.000001000 augroup END

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat.vim
Sourced 1 time
Total time:   0.000505000
 Self time:   0.000505000

count     total (s)      self (s)
    1              0.000005000 vim9script
    1              0.000004000 scriptencoding utf-8
                            
    1              0.000151000 import autoload 'copilot_chat/auth.vim' as auth
    1              0.000106000 import autoload 'copilot_chat/buffer.vim' as _buffer
    1              0.000102000 import autoload 'copilot_chat/api.vim' as api
                            
    1              0.000007000 export def OpenChat(): void
                              if auth.VerifySignin() != v:null
                                if _buffer.HasActiveChat() && g:copilot_reuse_active_chat == 1
                                  _buffer.FocusActiveChat()
                                else
                                  _buffer.Create()
                                  normal G
                                endif
                              endif
                            enddef
                            
    1              0.000005000 export def StartChat(message: string)
                              OpenChat()
                              _buffer.AppendMessage(message)
                              api.AsyncRequest([{'content': message, 'role': 'user'}], [])
                            enddef
                            
    1              0.000003000 export def ResetChat()
                              if g:copilot_chat_active_buffer == -1 || !bufexists(g:copilot_chat_active_buffer)
                                echom 'No active chat window to reset'
                                return
                              endif
                            
                              var current_buf = bufnr('%')
                            
                              # Switch to the active chat buffer if not already there
                              if current_buf != g:copilot_chat_active_buffer
                                execute 'buffer ' .. g:copilot_chat_active_buffer
                              endif
                            
                              silent! %delete _
                            
                              _buffer.WelcomeMessage()
                            
                              normal G
                            
                              if current_buf != g:copilot_chat_active_buffer && bufexists(current_buf)
                                execute 'buffer ' .. current_buf
                              endif
                            enddef
                            
    1              0.000002000 export def SubmitMessage()
                              var messages = []
                              var pattern = ' ━\+$'
                              var all_file_lists = []
                              cursor(1, 1)
                            
                              while search(pattern, 'W') > 0
                                var header_line = getline('.')
                                var role = 'user'
                                # Check separator icon to determine message role
                                # Separator with  icon indicates assistant response, otherwise user message
                                if stridx(header_line, ' ') != -1
                                  role = 'assistant'
                                endif
                                var end_line: number = search(pattern, 'W')
                                if end_line == 0
                                  end_line = line('$')
                                else
                                  end_line -= 1
                                  cursor(line('.') - 1, col('.'))
                                endif
                            
                                var lines: list<string> = getline(line('.') + 1, end_line)
                                var file_list: list<string> = []
                            
                                for i in range(len(lines))
                                  var line: string = lines[i]
                                  if line =~? '^> \(\w\+\)'
                                    var text: string = matchstr(line, '^> \(\w\+\)')
                                    text = substitute(text, '^> ', '', '')
                                    if has_key(g:copilot_chat_prompts, text)
                                      lines[i] = g:copilot_chat_prompts[text]
                                    endif
                                  elseif line =~? '^#file: '
                                    var filename: string = matchstr(line, '^#file: \s*\zs.*\ze$')
                                    add(file_list, filename)
                                  endif
                                endfor
                                var message: string = join(lines, "\n")
                            
                                add(messages, {'content': message, 'role': role})
                                add(all_file_lists, file_list)
                                cursor(line('.'), col('.') + 1)
                              endwhile
                            
                              # Limit message history to improve performance
                              # Only send the most recent messages based on configuration
                              var limit: number = g:copilot_chat_message_history_limit
                              if len(messages) > limit && limit > 0
                                var start_idx: number = len(messages) - limit
                                messages = messages[start_idx : ]
                                all_file_lists = all_file_lists[start_idx : ]
                              endif
                            
                              # Consolidate file lists from recent messages
                              # O(n) consolidation using dictionary for O(1) duplicate detection (improved from O(n²))
                              var consolidated_files: list<string> = []
                              var seen: dict<any> = {}
                              for files in all_file_lists
                                for file in files
                                  if !has_key(seen, file)
                                    seen[file] = 1
                                    add(consolidated_files, file)
                                  endif
                                endfor
                              endfor
                            
                              api.AsyncRequest(messages, consolidated_files)
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/api.vim
Sourced 1 time
Total time:   0.000277000
 Self time:   0.000277000

count     total (s)      self (s)
    1              0.000004000 vim9script
    1              0.000003000 scriptencoding utf-8
                            
    1              0.000047000 import autoload 'copilot_chat/auth.vim' as auth
    1              0.000050000 import autoload 'copilot_chat/buffer.vim' as _buffer
    1              0.000051000 import autoload 'copilot_chat/models.vim' as models
                            
    1              0.000001000 var curl_output: list<string> = []
                            
    1              0.000005000 export def AsyncRequest(messages: list<any>, file_list: list<any>): job
                              var chat_token: string = auth.VerifySignin()
                              curl_output = []
                              var url: string = 'https://api.githubcopilot.com/chat/completions'
                            
                              # for knowledge bases its just an attachment as the content
                              # {'content': '<attachment id="kb:Name">\n#kb:\n</attachment>', 'role': 'user'}
                              # for files similar
                              for file in file_list
                                var file_content: list<string> = readfile(file)
                                var full_path: string = fnamemodify(file, ': p')
                                # TODO: get the filetype instead of just markdown
                                var attachment_content: string = '<attachment id="' .. file .. '">\n````markdown\n<!-- filepath: ' .. full_path .. ' -->\n' .. join(file_content, "\n") .. '\n```</attachment>'
                                add(messages, {'content': attachment_content, 'role': 'user'})
                              endfor
                            
                              var data: string = json_encode({
                                'intent': false,
                                'model': models.Current(),
                                'temperature': 0,
                                'top_p': 1,
                                'n': 1,
                                'stream': true,
                                'messages': messages
                              })
                            
                              var tmpfile: string = tempname()
                              writefile([data], tmpfile)
                            
                              var curl_cmd: list<string> = [
                                'curl',
                                '-s',
                                '-X',
                                'POST',
                                '-H',
                                'Content-Type: application/json',
                                '-H', 'Authorization: Bearer ' .. chat_token,
                                '-H', 'Editor-Version: vscode/1.80.1',
                                '-d',
                                $'@{tmpfile}',
                                url
                              ]
                            
                              var job: job = job_start(curl_cmd, {
                                 'out_cb': function('HandleJobOutput'),
                                 'exit_cb': function('HandleJobClose'),
                                 'err_cb': function('HandleJobError')
                                 })
                            
                              _buffer.WaitingForResponse()
                            
                              return job
                            enddef
                            
    1              0.000004000 def HandleJobOutput(channel: any, msg: any): void
                              if type(msg) == v:t_list
                                for data in msg
                                  if data =~? '^data: {'
                                    add(curl_output, data)
                                  endif
                                endfor
                              else
                                add(curl_output, msg)
                              endif
                            enddef
                            
    1              0.000002000 def HandleJobClose(channel: any, msg: any)
                              deletebufline(g:copilot_chat_active_buffer, '$')
                              var result = ''
                              for line in curl_output
                                if line =~? '^data: {'
                                  var json_completion = json_decode(strcharpart(line, 6))
                                  try
                                    var content = json_completion.choices[0].delta.content
                                    if type(content) != type(v:null)
                                      result ..= content
                                    endif
                                  catch
                                    result ..= "\n"
                                  endtry
                                elseif line =~? 'error'
                                  result ..= line
                                endif
                              endfor
                            
                              var response = split(result, "\n")
                              var width = winwidth(0) - 2 - getwininfo(win_getid())[0].textoff
                              var separator = ' '
                              separator ..= repeat('━', width)
                              var response_start = line('$') + 1
                            
                              _buffer.AppendMessage(separator)
                              _buffer.AppendMessage(response)
                              _buffer.AddInputSeparator()
                            
                              var wrap_width = width + 2
                              var softwrap_lines = 0
                              for line in response
                                if strwidth(line) > wrap_width
                                  softwrap_lines += float2nr(ceil(strwidth(line) / wrap_width))
                                else
                                  softwrap_lines += 1
                                endif
                              endfor
                            
                              var total_response_length = softwrap_lines + 2
                              var height = winheight(0)
                              if total_response_length >= height
                                execute 'normal ' .. response_start .. 'Gzt'
                              else
                                execute 'normal G'
                              endif
                              setcursorcharpos(0, 3)
                            enddef
                            
    1              0.000002000 def HandleJobError(channel: any, msg: list<any>)
                              if type(msg) == v:t_list
                                var filtered_errors = filter(copy(msg), '!empty(v:val)')
                                if len(filtered_errors) > 0
                                  echom filtered_errors
                                endif
                              else
                                echom msg
                              endif
                            enddef
                            
    1              0.000002000 export def FetchModels(chat_token: string): list<string>
                              var chat_headers = [
                                'Content-Type: application/json',
                                $'Authorization: Bearer {chat_token}',
                                'Editor-Version: vscode/1.80.1'
                              ]
                            
                              var response = Http('GET', 'https://api.githubcopilot.com/models', chat_headers, {})
                              var model_list = []
                              var json_response = json_decode(response)
                              for item in json_response.data
                                if has_key(item, 'id')
                                  add(model_list, item.id)
                                endif
                              endfor
                              return model_list
                            enddef
                            
    1              0.000005000 export def Http(method: string, url: string, headers: list<any>, body: any): string
                              var response = ''
                              if has('win32')
                                var ps_cmd = 'powershell -Command "'
                                ps_cmd ..= '$headers = @{'
                                for header in headers
                                  var parts = split(header, ': ')
                                  var key = parts[0]
                                  var value = parts[1]
                                  ps_cmd ..= "'" .. key .. "'='" .. value .. "';"
                                endfor
                                ps_cmd ..= '};'
                                if method !=# 'GET'
                                  ps_cmd ..= '$body = ConvertTo-Json @{'
                                  for obj in keys(body)
                                    ps_cmd ..= obj .. "='" .. body[obj] .. "';"
                                  endfor
                                  ps_cmd ..= '};'
                                endif
                                ps_cmd ..= "Invoke-WebRequest -Uri '" .. url .. "' -Method " .. method .. " -Headers $headers -Body $body -ContentType 'application/json' | Select-Object -ExpandProperty Content"
                                ps_cmd ..= '"'
                                response = system(ps_cmd)
                              else
                                var token_data = json_encode(body)
                            
                                var curl_cmd = 'curl -s -X ' .. method .. ' --compressed '
                                for header in headers
                                  curl_cmd ..= '-H "' .. header .. '" '
                                endfor
                                curl_cmd ..= "-d '" .. token_data .. "' " .. url
                            
                                response = system(curl_cmd)
                                if v:shell_error != 0
                                  echom 'Error: ' .. v:shell_error
                                  return ''
                                endif
                              endif
                              return response
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim
Sourced 1 time
Total time:   0.002003000
 Self time:   0.002003000

count     total (s)      self (s)
    1              0.000026000 vim9script
    1              0.000012000 scriptencoding utf-8
                            
    1              0.000249000 import autoload 'copilot_chat/config.vim' as config
                            
    1              0.000044000 var colors_gui: list<string> = ['#33FF33', '#4DFF33', '#66FF33', '#80FF33', '#99FF33', '#B3FF33', '#CCFF33', '#E6FF33', '#FFFF33']
    1              0.000013000 var colors_cterm: list<number> = [46, 118, 154, 190, 226, 227, 228, 229, 230]
    1              0.000010000 var color_index: number = 0
    1              0.000007000 var chat_count: number = 1
    1              0.000008000 var completion_active: number = 0
    1              0.000011000 var syntax_timer: number = -1
    1              0.000008000 var file_completion_timer: number = -1
    1              0.000008000 var file_list_cache: list<string> = []
    1              0.000008000 var file_list_cache_time: number = 0
    1              0.000026000 var copilot_list_chat_buffer: number = get(g:, 'copilot_list_chat_buffer', 0)
    1              0.000019000 var copilot_chat_open_on_toggle: number = get(g:, 'copilot_chat_open_on_toggle', 1)
    1              0.000002000 var waiting_timer: number = 0
                            
    1              0.000017000 def WindowSplit()
                              var position: string = config.GetValue('window_position', 'right')
                              if exists('g:copilot_chat_window_position')
                                position = g:copilot_chat_window_position
                              endif
                            
                              # Create split based on position
                              if position ==# 'right'
                                rightbelow vsplit
                              elseif position ==# 'left'
                                leftabove vsplit
                              elseif position ==# 'top'
                                topleft split
                              elseif position ==# 'bottom'
                                botright split
                              endif
                            enddef
                            
    1              0.000004000 export def Create(): any
                              WindowSplit()
                            
                              enew
                            
                              setlocal buftype=nofile
                              setlocal bufhidden=hide
                              setlocal noswapfile
                              setlocal filetype=copilot_chat
                              if copilot_list_chat_buffer == 0
                                setlocal nobuflisted
                              endif
                            
                              # Set buffer name
                              execute 'file CopilotChat-' .. chat_count
                              chat_count += 1
                            
                              # Save buffer number for reference
                              g:copilot_chat_active_buffer = bufnr('%')
                              b:added_syntaxes = []
                              WelcomeMessage()
                              return g:copilot_chat_active_buffer
                            enddef
                            
    1              0.000003000 export def HasActiveChat(): number
                              if g:copilot_chat_active_buffer == -1
                                return 0
                              endif
                            
                              if !bufexists(g:copilot_chat_active_buffer)
                                return 0
                              endif
                            
                              var buf: list<dict<any>> = getbufinfo(g:copilot_chat_active_buffer)
                              if empty(buf)
                                return 0
                              endif
                            
                              return 1
                            enddef
                            
    1              0.000003000 export def FocusActiveChat()
                              var current_buf = bufnr('%')
                              if copilot_chat#buffer#has_active_chat() == 0
                                return
                              endif
                            
                              if current_buf == g:copilot_chat_active_buffer
                                return
                              endif
                              var windows = getwininfo()
                              for win in range(len(windows))
                                var win_info = windows[win]
                                if win_info.bufnr != g:copilot_chat_active_buffer ||
                            	     (win_info.height == 0 && win_info.width == 0)
                                  continue
                                endif
                                # We found an active chat buffer in the current window display, so
                                # switch to it.
                                execute win_info.winnr .. ' wincmd w'
                                return
                              endfor
                            
                              # Not found in current visible windows, so create a new split
                              WindowSplit()
                              execute 'buffer ' .. g:copilot_chat_active_buffer
                            enddef
                            
    1              0.000003000 def ToggleActiveChat(): number
                              if HasActiveChat() == 0
                                if copilot_chat_open_on_toggle == 1
                                  Create()
                                endif
                                return
                              endif
                            
                              if bufnr('%') == g:copilot_chat_active_buffer
                                close
                              else
                                FocusActiveChat()
                              endif
                            enddef
                            
    1              0.000003000 export def AddInputSeparator(): void
                              var width: number = winwidth(0) - 2 - getwininfo(win_getid())[0].textoff
                              var separator: string = ' ' .. repeat('━', width)
                              AppendMessage(separator)
                              AppendMessage('')
                            enddef
                            
    1              0.000003000 export def WaitingForResponse(): void
                              AppendMessage('Waiting for response')
                              #waiting_timer = timer_start(500, { -> UpdateWaitingDots()}, {'repeat': -1})
                              waiting_timer = timer_start(500, function('UpdateWaitingDots'), {'repeat': -1})
                            enddef
                            
                            
    1              0.000008000 def UpdateWaitingDots(timer: any): number
                              if !bufexists(g:copilot_chat_active_buffer)
                                timer_stop(waiting_timer)
                                return 0
                              endif
                            
                              var lines: list<string> = getbufline(g:copilot_chat_active_buffer, '$')
                              if empty(lines)
                                timer_stop(waiting_timer)
                                return 0
                              endif
                            
                              var current_text = lines[0]
                              if current_text =~? '^Waiting for response'
                                  var dots = len(matchstr(current_text, '\..*$'))
                                  var new_dots = (dots % 3) + 1
                                  setbufline(g:copilot_chat_active_buffer, '$', $'Waiting for response{repeat('.', new_dots)}')
                                color_index = (color_index + 1) % len(colors_gui)
                                execute 'highlight CopilotWaiting guifg=' .. colors_gui[color_index] .. ' ctermfg=' .. colors_cterm[color_index]
                              endif
                              return 1
                            enddef
                            
    1              0.000004000 export def AddSelection()
                              if HasActiveChat() == 0
                                if g:copilot_chat_create_on_add_selection == 0
                                  return
                                endif
                                # TODO: copilot_chat#buffer#create should take an argument to
                                # indicate if it should make the new buffer active or not.
                                Create()
                                execute winnr() .. 'wincmd w'
                              endif
                            
                              # Save the current register and selection type
                              var save_reg: string = @"
                              var save_regtype: string = getregtype('"')
                              var filetype: string = &filetype
                            
                              # Get the visual selection
                              normal gv"xy
                            
                              # Get the content of the visual selection
                              var selection: string = getreg('x')
                            
                              # Restore the original register and selection type
                              setreg('"', save_reg, save_regtype)
                              AppendMessage('```' .. filetype)
                              AppendMessage(split(selection, "\n"))
                              AppendMessage('```')
                            
                              # Goto to the active chat buffer, either old or newly created.
                              if g:copilot_chat_jump_to_chat_on_add_selection == 1
                                FocusActiveChat()
                              endif
                            enddef
                            
    1              0.000006000 export def AppendMessage(message: any): void
                              appendbufline(g:copilot_chat_active_buffer, '$', message)
                            enddef
                            
    1              0.000003000 export def WelcomeMessage(): void
                              appendbufline(g:copilot_chat_active_buffer, 0, 'Welcome to Copilot Chat! Type your message below:')
                              AddInputSeparator()
                            enddef
                            
    1              0.000005000 export def SetActive(bufnr: number): void
                              if bufnr ==# ''
                                bufnr = bufnr('%')
                              endif
                            
                              if g:copilot_chat_active_buffer == bufnr
                                return
                              endif
                            
                              var bufinfo = getbufinfo(bufnr)
                              if empty(bufinfo)
                                echom 'Invlid buffer number'
                                return
                              endif
                            
                              # Check if the buffer is valid
                              if getbufvar(bufnr, '&filetype') !=# 'copilot_chat'
                                echom 'Buffer is not a Copilot Chat buffer'
                                return
                              endif
                            
                              # Set the active chat buffer to the current buffer
                              g:copilot_chat_active_buffer = bufnr
                            enddef
                            
    1              0.000005000 export def OnDelete(bufnr_string: string)
                              var bufnr: number = str2nr(bufnr_string)
                              if g:copilot_chat_zombie_buffer != -1
                                var bufinfo = getbufinfo(g:copilot_chat_zombie_buffer)
                                if !empty(bufinfo) # Check if the buffer wasn't wiped out by the user
                                  execute 'bwipeout' .. g:copilot_chat_zombie_buffer
                                endif
                                g:copilot_chat_zombie_buffer = -1
                              endif
                            
                              if g:copilot_chat_active_buffer != bufnr
                                return
                              endif
                              # Unset the active chat buffer
                              g:copilot_chat_zombie_buffer = g:copilot_chat_active_buffer
                              g:copilot_chat_active_buffer = -1
                            enddef
                            
    1              0.000002000 export def Resize(): void
                              if g:copilot_chat_active_buffer == -1
                                return
                              endif
                            
                              for tabnr in range(1, tabpagenr('$'))
                                exec 'normal ' tabnr .. 'gt'
                            
                                for winnr in range(1, winnr('$'))
                                  exec $':{winnr}wincmd w'
                                  if &filetype !=# 'copilot_chat'
                                    continue
                                  endif
                                  var width: number = winwidth(0) - 2 - getwininfo(win_getid())[0].textoff
                                  exec ':%s/^ ━\+/ ' .. repeat('━', width) .. '/ge'
                                  exec ':%s/^ ━\+/ ' .. repeat('━', width) .. '/ge'
                                  setpos('.', getcurpos())
                                endfor
                            
                                exec ':' .. winnr() .. 'wincmd w'
                              endfor
                            
                              exec 'normal ' .. tabpagenr() .. 'gt'
                            enddef
                            
    1              0.000004000 export def ApplyCodeBlockSyntax(): void
                              # Debounce syntax highlighting to avoid excessive recalculations
                              if syntax_timer != -1
                                timer_stop(syntax_timer)
                              endif
                              syntax_timer = timer_start(g:copilot_chat_syntax_debounce_ms, function('ApplyCodeBlockSyntaxImpl'))
                            enddef
                            
    1              0.000006000 def ApplyCodeBlockSyntaxImpl(opt: any): void
                              syntax_timer = -1
                            
                              var lines: list<string> = getline(1, '$')
                              var in_code_block: bool = false
                              var current_lang: string = ''
                              var start_line: number = 0
                              var block_count: number = 0
                            
                              for linenum in range(len(lines))
                                var line: string = lines[linenum]
                            
                                if !in_code_block && line =~# '^```\s*\([a-zA-Z0-9_+-]\+\)$'
                                  in_code_block = true
                                  current_lang = matchstr(line, '^```\s*\zs[a-zA-Z0-9_+-]\+\ze$')
                                  start_line = linenum + 1  # Start on next line
                            
                                elseif in_code_block && line =~# '^```\s*$'
                                  var end_line: number = linenum
                            
                                  if start_line < end_line
                                    HighlightCodeBlock(start_line, end_line, current_lang, block_count)
                                    block_count += 1
                                  endif
                            
                                  in_code_block = false
                                  current_lang = ''
                                endif
                              endfor
                              redraw
                            enddef
                            
    1              0.000013000 def HighlightCodeBlock(start_line: number, end_line: number, lang_arg: string, block_id: number): void
                              var lang: string = lang_arg
                              if lang ==# 'js'
                                lang = 'javascript'
                              elseif lang ==# 'ts'
                                lang = 'typescript'
                              elseif lang ==# 'py'
                                lang = 'python'
                              endif
                            
                              var syntax_file: string = findfile('syntax/' .. lang .. '.vim', &runtimepath)
                              if !syntax_file->empty()
                                if index(b:added_syntaxes, '@' .. lang) == -1
                                  if exists('b:current_syntax')
                                    unlet b:current_syntax
                                  endif
                                  execute $'syntax include @{lang} syntax/{lang}.vim'
                            
                                  add(b:added_syntaxes, '@' .. lang)
                                endif
                                # Define syntax region for this specific code block
                                var cmd: string = $'syntax region CopilotCode_{lang}_{block_id}'
                                cmd ..= ' start=/\%' .. (start_line + 1) .. 'l/'
                                cmd ..= ' end=/\%' .. (end_line + 1) .. 'l/'
                                cmd ..= ' contains=@' .. lang
                                execute cmd
                              endif
                            enddef
                            
    1              0.000002000 export def CheckForMacro(): void
                              var current_line: string = getline('.')
                              var cursor_pos: number = col('.')
                              var before_cursor: string = strpart(current_line, 0, cursor_pos)
                              if current_line =~# '/tab all'
                                # Get the position where the pattern starts
                                var pattern_start: number = match(before_cursor, '/tab all')
                            
                                # Delete the pattern
                                cursor(line('.'), pattern_start + 1)
                                exec 'normal d' .. len('/tab all') .. 'l'
                            
                                # Generate list of tabs with #file: prefix, excluding current buffer
                                var tab_list: list<string> = []
                                for i in range(1, tabpagenr('$'))
                                  var buffers: list<number> = tabpagebuflist(i)
                                  for buf in buffers
                                    var filename: string = bufname(buf)
                                    # Only add if it's not the current buffer and has a filename
                                    if filename !=# '' && filename !~# 'CopilotChat'
                                      # Use the relative path format instead of just the base filename
                                      add(tab_list, $'#file: {filename}')
                                    endif
                                  endfor
                                  #let winnr = tabpagewinnr(i)
                                  #let buf_nr = buflist[winnr - 1]
                                  #let filename = bufname(buf_nr)
                            
                                endfor
                            
                                # Insert the tab list at cursor position, one per line
                                if len(tab_list) > 0
                                  # Add a newline at the end of the text to be inserted
                                  var tabs_text: string = join(tab_list, "\n") .. "\n"
                                  exec 'normal i' .. tabs_text
                                else
                                  exec "normal iNo other tabs found\n"
                                endif
                            
                                # Position cursor on the empty line
                                cursor(line('.'), 1)
                              elseif current_line =~# '#file: '
                                if completion_active == 1 && !pumvisible()
                                  completion_active = 0
                                endif
                                if completion_active == 0
                                  # TODO: should be resetting this after we do this
                                  # let saved_completeopt = &completeopt
                                  # timer_start(0, {-> execute('let &completeopt = "' . saved_completeopt . '"')})
                                  set completeopt=menu,menuone,noinsert,noselect
                                  var line: string = getline('.')
                                  var start: number = match(line, '#file: ') + 6
                                  var typed: string = strpart(line, start, col('.') - start - 1)
                                  if typed !=# '' && filereadable(typed) && !isdirectory(typed)
                                    return
                                  endif
                            
                                  # Cache file list to avoid repeated git/glob calls
                                  var current_time: number = localtime()
                                  var cache_expired: bool = file_list_cache_time == 0 || (current_time - file_list_cache_time) > g:copilot_chat_file_cache_timeout
                                  if empty(file_list_cache) || cache_expired
                                    system('git rev-parse --is-inside-work-tree 2>/dev/null')
                            
                                    if v:shell_error == 0  # We are in a git repo
                                      file_list_cache = systemlist('git ls-files --cached --others --exclude-standard')
                                    else
                                      file_list_cache = glob('**/*', 0, 1)
                                    endif
                                    file_list_cache_time = current_time
                                  endif
                            
                                  # Filter out directories and prepare completion items
                                  var matches: list<string> = []
                                  for file in file_list_cache
                                    if !isdirectory(file) && file =~? typed
                                      add(matches, file)
                                    endif
                                  endfor
                            
                                  # Show the completion menu
                                  complete(start + 1, matches)
                                  completion_active = 1
                                endif
                              endif
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/config.vim
Sourced 1 time
Total time:   0.000852000
 Self time:   0.000852000

count     total (s)      self (s)
    1              0.000013000 vim9script
    1              0.000007000 scriptencoding utf-8
                            
                            # Generic configuration functionality
                            # -----------------------------------
    1              0.000011000 var chat_config_file: string = g:copilot_chat_data_dir .. '/config.json'
                            
                            # Read the config file on load
    1              0.000009000 var config: dict<any> = {}
    1              0.000376000 if filereadable(chat_config_file)
    1              0.000283000   var config_raw_data: string = join(readfile(chat_config_file), "\n")
    1              0.000033000   config = json_decode(config_raw_data)
    1              0.000004000 endif
                            
    1              0.000007000 export def CreateDataDir(): void
                              if !isdirectory(g:copilot_chat_data_dir)
                                mkdir(g:copilot_chat_data_dir, 'p')
                              endif
                            enddef
                            
    1              0.000004000 def SaveConfigFile(): void
                              CreateDataDir()
                              writefile([json_encode(config)], chat_config_file)
                            enddef
                            
    1              0.000008000 export def GetValue(key: string, default: any): any
                              return get(config, key, default)
                            enddef
                            
    1              0.000005000 export def SetValue(key: string, value: any)
                              config[key] = value
                              SaveConfigFile()
                            enddef
                            
    1              0.000002000 export def View()
                              execute 'vsplit ' .. chat_config_file
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/history.vim
Sourced 1 time
Total time:   0.000692000
 Self time:   0.000692000

count     total (s)      self (s)
    1              0.000003000 vim9script
    1              0.000002000 scriptencoding utf-8
                            
    1              0.000106000 import autoload 'copilot_chat.vim' as base
    1              0.000082000 import autoload 'copilot_chat/buffer.vim' as _buffer
                            
    1              0.000014000 var history_dir: string = expand('~/.vim/copilot-chat/history', 1)
                            
    1              0.000006000 export def Save(name: string): string
                              if !isdirectory(history_dir)
                                mkdir(history_dir, 'p')
                              endif
                            
                              # Default to current date/time if no name provided
                              var filename: string = empty(name) ? strftime('%Y%m%d_%H%M%S'): name
                              history_file = history_dir .. '/' .. filename .. '.json'
                            
                              # Get chat content
                              var chat_content: list<string> = []
                              var in_user_message: number = 0
                              var in_assistant_message: number = 0
                              var current_message: dict<any> = {'role': '', 'content': ''}
                            
                              for line in getbufline(g:copilot_chat_active_buffer, 1, '$')
                                # Skip welcome message and waiting lines
                                if line =~? '^Welcome to Copilot Chat' || line =~? '^Waiting for response'
                                  continue
                                endif
                            
                                # Detect separator lines
                                if line =~? ' ━\+$'
                                  if !empty(current_message.content) && !empty(current_message.role)
                                    add(chat_content, current_message)
                                    current_message = {'role': '', 'content': ''}
                                  endif
                            
                                  # Toggle between user and assistant messages
                                  if in_user_message
                                    in_user_message = 0
                                    in_assistant_message = 1
                                    current_message.role = 'assistant'
                                  else
                                    in_user_message = 1
                                    in_assistant_message = 0
                                    current_message.role = 'user'
                                  endif
                                  continue
                                endif
                            
                                # Add content to current message if we're in a message
                                if in_user_message || in_assistant_message
                                  # Skip empty lines at the start of messages
                                  if empty(current_message.content) && empty(line)
                                    continue
                                  endif
                                  current_message.content ..= (empty(current_message.content) ? '': "\n") .. line
                                endif
                              endfor
                            
                              # Add the last message if it exists
                              if !empty(current_message.content) && !empty(current_message.role)
                                add(chat_content, current_message)
                              endif
                            
                              # Save as JSON file
                              writefile([json_encode(chat_content)], history_file)
                              echo 'Chat history saved to ' .. history_file
                              return filename
                            enddef
                            
    1              0.000003000 export def Load(name: string): number
                              if !isdirectory(history_dir)
                                mkdir(history_dir, 'p')
                                echo 'No chat history found'
                                return 0
                              endif
                            
                              # If no name provided, show available histories
                              if empty(name)
                                List()
                                return 0
                              endif
                            
                              history_file = history_dir .. '/' .. name .. '.json'
                            
                              if !filereadable(history_file)
                                echo 'Chat history "' .. name .. '" not found'
                                return 0
                              endif
                            
                              # Load the history file
                              var chat_content: dict<any> = json_decode(join(readfile(history_file), "\n"))
                            
                              # Create a new chat buffer
                              base.OpenChat()
                            
                              # Add all messages to the buffer
                              var first_message: bool = true
                              for message in chat_content
                                if first_message
                                  first_message = false
                                else
                                  var width: number = winwidth(0) - 2
                                  var separator: string = ' ' .. repeat('━', width)
                                  appendbufline(g:copilot_chat_active_buffer, '$', separator)
                                endif
                            
                                appendbufline(g:copilot_chat_active_buffer, '$', split(message.content, "\n"))
                              endfor
                            
                              # Add final separator for new input
                              _buffer.AddInputSeparator()
                              echo 'Loaded chat history: ' .. name
                              normal G
                              return 1
                            enddef
                            
    1              0.000002000 export def Get(): list<string>
                              if !isdirectory(history_dir)
                                mkdir(history_dir, 'p')
                                return []
                              endif
                            
                              return map(glob(history_dir .. '/*.json', 0, 1), 'fnamemodify(v:val, ":t:r")')
                            enddef
                            
    1              0.000005000 export def Complete(arg_lead: string, cmd_line: any, cursor_pos: number): list<string>
                              return matchfuzzy(copilot_chat#history#get(), arg_lead)
                            enddef
                            
    1              0.000001000 export def List()
                              var histories = Get()
                            
                              if empty(histories)
                                echo 'No saved chat histories'
                                return
                              endif
                            
                              echo 'Available chat historie '
                              for history in histories
                                echo '- ' .. history
                              endfor
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/models.vim
Sourced 1 time
Total time:   1.143914000
 Self time:   1.143914000

count     total (s)      self (s)
    1              0.000013000 vim9script
    1              0.000007000 scriptencoding utf-8
                            
    1              0.000160000 import autoload 'copilot_chat/api.vim' as api
    1              0.000104000 import autoload 'copilot_chat/auth.vim' as auth
    1              0.000136000 import autoload 'copilot_chat/config.vim' as config
                            
    1              0.000015000 g:copilot_popup_selection = 0 # XXX: not sure why this doesnt work as a script var
    1              0.000009000 var model_key: string = 'model'
    1              0.000006000 var default_model: string = 'gpt-4o'
    1              1.143246000 var available_models: list<string> = api.FetchModels(auth.VerifySignin())
                            
    1              0.000025000 export def FilterModels(winid: number, key: string): number
                              if key ==? 'j' || key ==? "\<Down>"
                                g:copilot_popup_selection = (g:copilot_popup_selection + 1) % len(available_models)
                              elseif key ==? 'k' || key ==? "\<Up>"
                                g:copilot_popup_selection = (g:copilot_popup_selection - 1 + len(available_models)) % len(available_models)
                              elseif key ==? "\<CR>" || key ==? "\<Space>"
                                var selected_model: string = available_models[g:copilot_popup_selection]
                                config.SetValue(model_key, selected_model)
                                echo selected_model .. ' set as active model'
                                popup_close(winid)
                                return 1
                              elseif key ==? "\<Esc>" || key ==? 'q'
                                popup_close(winid)
                                return 1
                              endif
                            
                              var display_items: list<string> = copy(available_models)
                              var active_model_index = index(available_models, Current())
                              display_items[active_model_index] = '* ' .. display_items[active_model_index]
                              display_items[g:copilot_popup_selection] = '> ' .. display_items[g:copilot_popup_selection]
                            
                              popup_settext(winid, display_items)
                            
                              prop_add(g:copilot_popup_selection + 1, 1, {
                                'type': 'highlight',
                                'length': 60,
                                'bufnr': winbufnr(winid)
                              })
                              return 1
                            enddef
                            
    1              0.000004000 export def Select()
                              g:copilot_popup_selection = index(available_models, Current())
                              if g:copilot_popup_selection ==? -1
                                g:copilot_popup_selection = 0
                              endif
                            
                              var display_items = copy(available_models)
                              display_items[g:copilot_popup_selection] = '> ' .. display_items[g:copilot_popup_selection]
                            
                              execute 'syntax match SelectedText  /^ > .*/'
                              execute 'hi! SelectedText ctermfg = 46 guifg=#33FF33'
                              execute 'hi! GreenHighlight ctermfg = green ctermbg=NONE guifg=#33ff33 guibg=NONE'
                              execute 'hi! PopupNormal ctermfg = NONE ctermbg=NONE guifg=NONE guibg=NONE'
                            
                              var options = {
                                'border': [1, 1, 1, 1],
                                'borderchars': ['─', '│', '─', '│', '┌', '┐', '┘', '└'],
                                'borderhighlight': ['DiffAdd'],
                                'highlight': 'PopupNormal',
                                'padding': [1, 1, 1, 1],
                                'pos': 'center',
                                'minwidth': 50,
                                'filter': FilterModels,
                                'mapping': 0,
                                'title': 'Select Active Model'
                              }
                            
                              var popup_id = popup_create(display_items, options)
                            
                              var bufnr = winbufnr(popup_id)
                              prop_type_add('highlight', {'highlight': 'GreenHighlight', 'bufnr': bufnr})
                              prop_add(g:copilot_popup_selection + 1, 1, {
                                'type': 'highlight',
                                'length': 60,
                                'bufnr': bufnr
                              })
                            enddef
                            
    1              0.000003000 export def Current(): string
                              return config.GetValue(model_key, default_model)
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/vim-plan/plugin/plan.vim
Sourced 1 time
Total time:   0.000102000
 Self time:   0.000102000

count     total (s)      self (s)
                            " command definitions
    1              0.000001000 command! PlanMarkDone :call plan#MarkDone()
    1              0.000002000 command! PlanAll :call plan#ExtractTODOsFromRegistry()
    1              0.000001000 command! PlanOpen :call OpenFileFromLine()
    1              0.000001000 command! -nargs=1 PlanImportAsset :call plan#ImportAsset(<q-args>)
                            
                            " set up file navigation for notes
    1              0.000001000 set suffixesadd+=.plan
                            
    1              0.000000000 augroup PluginPlan
    1              0.000013000   autocmd!
                              " make sure idle notes are getting written to disk periodically
    1              0.000005000   execute 'autocmd CursorHold,CursorHoldI,BufLeave *.plan update'
    1              0.000002000   execute 'autocmd CursorHold,CursorHoldI,BufLeave *.plan update'
                            
    1              0.000013000   autocmd! BufRead,BufNewFile *.plan set filetype=plan
    1              0.000002000   autocmd! BufWritePost *.plan call AppendToPlanRegistry()
    1              0.000001000   autocmd! FileType plan noremap <S-Tab> :set foldlevel=0<CR>
    1              0.000013000   autocmd! FileType plan noremap <Leader>md :PlanMarkDone<CR>
    1              0.000012000   autocmd! FileType plan noremap <Leader>pa :PlanAll<CR>
    1              0.000012000   autocmd! FileType plan noremap <Leader>po :PlanOpen<CR>
                            
    1              0.000002000   autocmd! FileType globalplan noremap <buffer> <CR> :PlanOpen<CR>
    1              0.000000000 augroup END
                            
    1              0.000006000 let g:plan_registry_file = expand('~/.plan_registry')
                            
    1              0.000001000 function! AppendToPlanRegistry()
                                " Get the full path of the current file
                                let l:file_path = expand('%:p')
                            
                                " Check if the file is already in the registry
                                if filereadable(g:plan_registry_file) && !empty(filter(readfile(g:plan_registry_file), {_, val -> val == l:file_path}))
                                    return
                                endif
                            
                                " Append the file path to the registry
                                call writefile([l:file_path], g:plan_registry_file, 'a')
                            endfunction
                            
    1              0.000001000 function! OpenFileFromLine()
                                let l:line = getline('.')
                                let parts = split(l:line, ': ', 1)
                            
                                if len(parts) > 0
                                    let filepath = parts[0]
                                    execute 'edit' filepath
                                    call remove(parts, 0)
                                    let text = join(parts, ': ')
                                    let found = search(escape(text, '\.*$^~[]'))
                                else
                                    echo "Invalid input: No file path found"
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/scratch.vim/plugin/scratch.vim
Sourced 1 time
Total time:   0.000055000
 Self time:   0.000055000

count     total (s)      self (s)
                            " plugin/scratch.vim
                            
    1              0.000003000 if (exists('g:scratch_disable') && g:scratch_disable) || &compatible
                              finish
    1              0.000001000 endif
                            
    1              0.000001000 if !exists('g:scratch_autohide')
                              let g:scratch_autohide = &hidden
    1              0.000000000 endif
    1              0.000002000 if !exists('g:scratch_insert_autohide')
    1              0.000001000   let g:scratch_insert_autohide = 1
    1              0.000000000 endif
    1              0.000001000 if !exists('g:scratch_filetype')
    1              0.000001000   let g:scratch_filetype = 'scratch'
    1              0.000000000 endif
    1              0.000001000 if !exists('g:scratch_height')
    1              0.000001000   let g:scratch_height = 0.2
    1              0.000001000 endif
    1              0.000001000 if !exists('g:scratch_top')
    1              0.000000000   let g:scratch_top = 1
    1              0.000001000 endif
    1              0.000001000 if !exists('g:scratch_horizontal')
    1              0.000001000   let g:scratch_horizontal = 1
    1              0.000000000 endif
    1              0.000001000 if !exists('g:scratch_persistence_file')
    1              0.000001000   let g:scratch_persistence_file = ''
    1              0.000000000 endif
                            
    1              0.000001000 command! -bang -nargs=0 Scratch call scratch#open(<bang>0)
    1              0.000002000 command! -bang -nargs=0 ScratchInsert call scratch#insert(<bang>0)
    1              0.000002000 command! -bang -nargs=0 -range ScratchSelection call scratch#selection(<bang>0)
    1              0.000001000 command! -nargs=0 ScratchPreview call scratch#preview()
                            
    1              0.000004000 nnoremap <silent> <plug>(scratch-insert-reuse) :call scratch#insert(0)<cr>
    1              0.000003000 nnoremap <silent> <plug>(scratch-insert-clear) :call scratch#insert(1)<cr>
    1              0.000003000 xnoremap <silent> <plug>(scratch-selection-reuse) :<c-u>call scratch#selection(0)<cr>
    1              0.000003000 xnoremap <silent> <plug>(scratch-selection-clear) :<c-u>call scratch#selection(1)<cr>
                            
    1              0.000001000 if !exists('g:scratch_no_mappings')
    1              0.000003000   nmap gs <plug>(scratch-insert-reuse)
    1              0.000002000   nmap gS <plug>(scratch-insert-clear)
    1              0.000002000   xmap gs <plug>(scratch-selection-reuse)
    1              0.000002000   xmap gS <plug>(scratch-selection-clear)
    1              0.000002000   nnoremap gZzZz gs
    1              0.000001000 endif

SCRIPT  /Users/danbradbury/.vim/bundle/vim-poi/plugin/poi.vim
Sourced 1 time
Total time:   0.000106000
 Self time:   0.000106000

count     total (s)      self (s)
                            " Highlight points of interest
    1              0.000002000 au! ColorScheme * call <SID>ExecuteHighlight()
    1              0.000001000 au! BufEnter * call <SID>ExecuteHighlight()
    1              0.000001000 au! BufWinEnter * call <SID>ExecuteHighlight()
                            
                            " HIGHLIGHT COLOR INFORMATION
                            " for additional high contrasting colors refer to TABLE-1 in http://www.iscc.org/pdf/PC54_1724_001.pdf
                            " xterm 256 color chart: http://www.calmar.ws/vim/256-xterm-24bit-rgb-color-chart.html
                            " helpful contrast comparison tool: http://leaverou.github.io/contrast-ratio
                            " red / white
    1              0.000001000 let g:poi_color_count = 4
    1              0.000001000 let g:poi_bg1 = 88
    1              0.000001000 let g:poi_fg1 = 15
    1              0.000001000 let g:g_poi_bg1 = "#870000"
    1              0.000001000 let g:g_poi_fg1 = "#ffffff"
                            " yellow / purple
    1              0.000000000 let g:poi_bg2 = 226
    1              0.000001000 let g:poi_fg2 = 93
    1              0.000001000 let g:g_poi_bg2 = "#ffff00"
    1              0.000000000 let g:g_poi_fg2 = "#8700ff"
                            " orange / lightblue
    1              0.000000000 let g:poi_bg3 = 208
    1              0.000001000 let g:poi_fg3 = 17
    1              0.000001000 let g:g_poi_bg3 = "#ff8700"
    1              0.000000000 let g:g_poi_fg3 = "#00005f"
                            " blue / pink
    1              0.000000000 let g:poi_bg4 = 33
    1              0.000001000 let g:poi_fg4 = 200
    1              0.000000000 let g:g_poi_bg4 = "#0087ff"
    1              0.000000000 let g:g_poi_fg4 = "#ff00d7"
                            
                            " will be necessary when implementing the preview functionality (for now its not used)
    1              0.000000000 let g:pois = []
                            
    1              0.000012000 au! BufEnter * call <SID>MakeBuff()
                            
    1              0.000001000 function! s:ExecuteHighlight()
                              "Deperately looking for any way to DRY this up..(figured it would be just like MakeBuff)
                              execute 'highlight poi1 ctermbg='.g:poi_bg1.' ctermfg='.g:poi_fg1.' guibg='g:g_poi_bg1.' guifg='.g:g_poi_fg1
                              execute 'highlight poi2 ctermbg='.g:poi_bg2.' ctermfg='.g:poi_fg2.' guibg='g:g_poi_bg2.' guifg='.g:g_poi_fg2
                              execute 'highlight poi3 ctermbg='.g:poi_bg3.' ctermfg='.g:poi_fg3.' guibg='g:g_poi_bg3.' guifg='.g:g_poi_fg3
                              execute 'highlight poi4 ctermbg='.g:poi_bg4.' ctermfg='.g:poi_fg4.' guibg='g:g_poi_bg4.' guifg='.g:g_poi_fg4
                            endfunction
                            
    1              0.000001000 function! s:MakeBuff()
                              let start = 1
                              while start <= g:poi_color_count
                                if !exists('b:poi_lines'.start)
                                  let b:poi_lines{start} = []
                                endif
                                let start += 1
                              endwhile
                            endfunction
                            
                            " general helper methods
    1              0.000002000 function! s:AddToList(match_id, line_num, content, poi_group)
                              let dup_found = 0
                              let dup_index = -1
                              let c = 0
                              let match_removal = -1
                            
                              for i in b:poi_lines1
                                if i["line_num"] == a:line_num
                                  let dup_found = 1
                                  let dup_index = c
                                  let match_removal = i["match_id"]
                                endif
                                let c += 1
                              endfor
                            
                              if dup_found == 1
                                if dup_index != -1
                                  call remove(b:poi_lines1, dup_index)
                                  call matchdelete(match_removal)
                                  return -1
                                endif
                              else
                                call add(b:poi_lines1, {"line_num": a:line_num, "content": a:content, "match_id": a:match_id, "group": a:poi_group})
                                return 1
                              endif
                            endfunction
                            
                            " return the match_id to be used by matchdelete or -1000 if no dup is found
    1              0.000001000 function! s:CheckList(line_num, content)
                              let dup_found = 0
                              let match_id = 0
                            
                              for i in b:poi_lines1
                                if i["line_num"] == a:line_num
                                  let dup_found = 1
                                  let match_id = i["match_id"]
                                endif
                              endfor
                            
                              if dup_found == 1
                                return match_id
                              else
                                return -1000
                              endif
                            endfunction
                            
                            " Poi Line
    1              0.000000000 function! s:AddMatch(line, content, poi_group)
                              let value = eval(s:CheckList(a:line, a:content))
                              if value != -1000
                                call s:AddToList(value, a:line, a:content, a:poi_group)
                              else
                                let content = substitute(a:content, '\', '\\%d92', "g")
                                let content = substitute(content, '[', '\\%d91', "g")
                                let content = substitute(content, ']', '\\%d93', "g")
                                let content = substitute(content, '*', '\\%d42', "")
                                let content = substitute(content, ')', '\\%d41', "")
                                let temp = eval(matchadd("poi".a:poi_group, '\%'.a:line.'l'.content))
                                " ensure that the line is valid for a matchadd
                                if temp != -1
                                  call s:AddToList(temp, a:line, a:content, a:poi_group)
                                endif
                              endif
                            endfunction
                            
    1              0.000001000 function! s:AddSingleLine(num, poi_group)
                              call s:AddMatch(a:num, getline(a:num), a:poi_group)
                            endfunction
                            
                            " Poi Lines
    1              0.000001000 function! s:AddRange(start, end, poi_group)
                              let start = a:start
                              let end = a:end
                            
                              while start <= end
                                call s:AddSingleLine(eval(start), a:poi_group)
                                let start += 1
                              endwhile
                            endfunction
                            
                            " Poi Clear
    1              0.000000000 function! s:ClearPoi()
                              for i in b:poi_lines1
                                call matchdelete(i["match_id"])
                              endfor
                              let b:poi_lines1 = []
                            endfunction
                            
                            " PoiChange
    1              0.000001000 function! s:ChangeHighlightType(num)
                              let content = getline(a:num)
                              let add = 0
                              let c = 0
                            
                              for i in b:poi_lines1
                                if a:num == i["line_num"]
                                  call matchdelete(i["match_id"])
                                  "should be refactored into a cleanup method
                                  let content = substitute(i["content"], '\', '\\%d92', "g")
                                  let content = substitute(content, '[', '\\%d91', "g")
                                  let content = substitute(content, ']', '\\%d93', "g")
                                  let content = substitute(content, '*', '\\%d42', "")
                                  let content = substitute(content, ')', '\\%d41', "")
                            
                                  if i["group"] == g:poi_color_count
                                    let i["group"] = 1
                                  else
                                    let i["group"] += 1
                                  endif
                            
                                  let new_match_id = eval(matchadd("poi".i["group"], '\%'.a:num.'l'.content))
                                  let i["match_id"] = new_match_id
                                  let add = 1
                                endif
                                let c += 1
                              endfor
                            endfunction
                            
                            " PoiRangeChange
    1              0.000001000 function! s:ChangeRange(start, end)
                              let start = a:start
                              let end = a:end
                            
                              while start <= end
                                call s:ChangeHighlightType(eval(start))
                                let start += 1
                              endwhile
                            endfunction
                            
    1              0.000002000 com! -nargs=0 PoiLine :call <SID>AddSingleLine(line('.'),1)
    1              0.000002000 com! -nargs=0 PoiLine2 :call <SID>AddSingleLine(line('.'),2)
    1              0.000001000 com! -nargs=0 PoiLine3 :call <SID>AddSingleLine(line('.'),3)
    1              0.000001000 com! -nargs=0 PoiLine4 :call <SID>AddSingleLine(line('.'),4)
    1              0.000003000 com! -nargs=0 -range PoiLines :call <SID>AddRange(<line1>,<line2>,1)
    1              0.000002000 com! -nargs=0 -range PoiLines2 :call <SID>AddRange(<line1>,<line2>,2)
    1              0.000003000 com! -nargs=0 -range PoiLines3 :call <SID>AddRange(<line1>,<line2>,3)
    1              0.000002000 com! -nargs=0 -range PoiLines4 :call <SID>AddRange(<line1>,<line2>,4)
    1              0.000001000 com! -nargs=0 PoiClear :call <SID>ClearPoi()
    1              0.000002000 com! -nargs=0 PoiChange :call <SID>ChangeHighlightType(line('.'))
    1              0.000002000 com! -nargs=0 -range PoiRangeChange :call <SID>ChangeRange(<line1>,<line2>)
                            

SCRIPT  /Users/danbradbury/.vim/bundle/open-browser.vim/plugin/openbrowser.vim
Sourced 1 time
Total time:   0.000082000
 Self time:   0.000082000

count     total (s)      self (s)
                            " vim:foldmethod=marker:fen:
    1              0.000001000 scriptencoding utf-8
    1              0.000002000 let s:save_cpo = &cpo
    1              0.000002000 set cpo&vim
                            
    1              0.000001000 if exists('g:loaded_openbrowser') && g:loaded_openbrowser
                              finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_openbrowser = 1
                            
    1              0.000002000 if !(has('unix') || has('win32'))
                              echohl WarningMsg
                              echomsg 'Your platform is not supported!'
                              echohl None
                              finish
    1              0.000000000 endif
                            
                            
                            " For backward compatibility,
                            " - OpenBrowser()
                            " - OpenBrowserSearch()
                            
    1              0.000001000 function! OpenBrowser(...) abort
                              return call('openbrowser#open', a:000)
                            endfunction
                            
    1              0.000001000 function! OpenBrowserSearch(...) abort
                              return call('openbrowser#search', a:000)
                            endfunction
                            
                            
                            
                            " Ex command
    1              0.000002000 command!
                            \   -nargs=+
                            \   OpenBrowser
                            \   call openbrowser#_cmd_open(<q-args>)
    1              0.000002000 command!
                            \   -nargs=+ -complete=customlist,openbrowser#_cmd_search_complete
                            \   OpenBrowserSearch
                            \   call openbrowser#_cmd_search(<q-args>)
    1              0.000002000 command!
                            \   -nargs=+ -complete=customlist,openbrowser#_cmd_search_complete
                            \   OpenBrowserSmartSearch
                            \   call openbrowser#_cmd_smart_search(<q-args>)
                            
                            
                            
                            " Key-mapping
    1              0.000004000 nnoremap <silent> <Plug>(openbrowser-open) :<C-u>call openbrowser#_keymap_open('n')<CR>
    1              0.000003000 xnoremap <silent> <Plug>(openbrowser-open) :<C-u>call openbrowser#_keymap_open('v')<CR>
    1              0.000004000 nnoremap <silent> <Plug>(openbrowser-open-incognito) :<C-u>call openbrowser#_keymap_open('n', 0, ['--incognito'])<CR>
    1              0.000004000 xnoremap <silent> <Plug>(openbrowser-open-incognito) :<C-u>call openbrowser#_keymap_open('v', 0, ['--incognito'])<CR>
    1              0.000003000 nnoremap <silent> <Plug>(openbrowser-search) :<C-u>call openbrowser#_keymap_search('n')<CR>
    1              0.000003000 xnoremap <silent> <Plug>(openbrowser-search) :<C-u>call openbrowser#_keymap_search('v')<CR>
    1              0.000004000 nnoremap <silent> <Plug>(openbrowser-smart-search) :<C-u>call openbrowser#_keymap_smart_search('n')<CR>
    1              0.000003000 xnoremap <silent> <Plug>(openbrowser-smart-search) :<C-u>call openbrowser#_keymap_smart_search('v')<CR>
                            
                            
                            " Popup menus for Right-Click
    1              0.000002000 if !get(g:, 'openbrowser_no_default_menus', (&guioptions =~# 'M'))
    1              0.000001000   function! s:add_menu() abort
                                if get(g:, 'openbrowser_menu_lang',
                                \      &langmenu isnot# '' ? &langmenu : v:lang) =~# '^ja'
                                  runtime! lang/openbrowser_menu_ja.vim
                                endif
                            
                                nnoremenu PopUp.-OpenBrowserSep- <Nop>
                                xnoremenu PopUp.-OpenBrowserSep- <Nop>
                                nmenu <silent> PopUp.Open\ URL <Plug>(openbrowser-open)
                                xmenu <silent> PopUp.Open\ URL <Plug>(openbrowser-open)
                                nmenu <silent> PopUp.Open\ Word(s) <Plug>(openbrowser-search)
                                xmenu <silent> PopUp.Open\ Word(s) <Plug>(openbrowser-search)
                                nmenu <silent> PopUp.Open\ URL\ or\ Word(s) <Plug>(openbrowser-smart-search)
                                xmenu <silent> PopUp.Open\ URL\ or\ Word(s) <Plug>(openbrowser-smart-search)
                              endfunction
                            
    1              0.000001000   augroup openbrowser-menu
    1              0.000013000     autocmd!
    1              0.000001000     autocmd GUIEnter * call s:add_menu()
    1              0.000001000   augroup END
    1              0.000000000 endif
                            
                            
    1              0.000003000 let &cpo = s:save_cpo

SCRIPT  /Users/danbradbury/.vim/bundle/open-browser-github.vim/plugin/openbrowser/github.vim
Sourced 1 time
Total time:   0.000325000
 Self time:   0.000325000

count     total (s)      self (s)
                            " vim:foldmethod=marker:fen:
    1              0.000001000 scriptencoding utf-8
                            
                            " Load Once {{{
    1              0.000002000 if get(g:, 'loaded_openbrowser_github', 0) || &cp
                              finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_openbrowser_github = 1
                            " }}}
                            " Saving 'cpoptions' {{{
    1              0.000001000 let s:save_cpo = &cpo
    1              0.000001000 set cpo&vim
                            " }}}
                            
                            
    1              0.000001000 function! s:error(msg) abort
                              echohl ErrorMsg
                              echomsg a:msg
                              echohl None
                            endfunction
                            
    1              0.000051000 if !executable('git')
                              call s:error('Please install git in your PATH.')
                              finish
    1              0.000001000 endif
    1              0.000226000 if globpath(&rtp, 'plugin/openbrowser.vim') ==# ''
                              call s:error('open-browser-github.vim depends on open-browser.vim. Please install open-browser.vim')
                              finish
    1              0.000000000 endif
                            
    1              0.000002000 if !exists('g:openbrowser_github_always_used_branch')
    1              0.000001000   let g:openbrowser_github_always_used_branch = ''
    1              0.000000000 endif
    1              0.000002000 if !exists('g:openbrowser_github_always_use_commit_hash')
    1              0.000001000   let g:openbrowser_github_always_use_commit_hash = 1
    1              0.000000000 endif
    1              0.000002000 if !exists('g:openbrowser_github_url_exists_check')
    1              0.000001000   let g:openbrowser_github_url_exists_check = 'yes'
    1              0.000000000 endif
    1              0.000001000 if !exists('g:openbrowser_github_select_current_line')
    1              0.000001000   let g:openbrowser_github_select_current_line = 0
    1              0.000001000 endif
                            
                            
    1              0.000005000 command! -range=0 -bar -nargs=* -complete=file
                            \   OpenGithubFile
                            \   call openbrowser#github#file([<f-args>], <count>, <line1>, <line2>)
                            
    1              0.000002000 command! -bar -nargs=*
                            \   OpenGithubIssue
                            \   call openbrowser#github#issue([<f-args>])
                            
    1              0.000003000 command! -bar -nargs=*
                            \   OpenGithubPullReq
                            \   call openbrowser#github#pullreq([<f-args>])
                            
    1              0.000002000 command! -bar -nargs=*
                            \   OpenGithubProject
                            \   call openbrowser#github#project([<f-args>])
                            
    1              0.000002000 command! -bar -nargs=+
                            \   OpenGithubCommit
                            \   call openbrowser#github#commit([<f-args>])
                            
                            
                            " Restore 'cpoptions' {{{
    1              0.000002000 let &cpo = s:save_cpo
                            " }}}

SCRIPT  /Users/danbradbury/.vim/bundle/nerdcommenter/plugin/nerdcommenter.vim
Sourced 1 time
Total time:   0.001063000
 Self time:   0.000115000

count     total (s)      self (s)
    1              0.000002000 if exists('loaded_nerd_comments')
                                finish
    1              0.000000000 endif
    1              0.000001000 if v:version < 700
                                echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
                                finish
    1              0.000000000 endif
    1              0.000000000 let loaded_nerd_comments = 1
                            
                            " Function: s:InitVariable() function
                            " This function is used to initialise a given variable to a given value. The
                            " variable is only initialised if it does not exist prior
                            "
                            " Args:
                            "   -var: the name of the var to be initialised
                            "   -value: the value to initialise var to
                            "
                            " Returns:
                            "   0
    1              0.000001000 function s:InitVariable(var, value)
                                if !exists(a:var)
                                    execute 'let ' . a:var . ' = ' . string(a:value)
                                endif
                            endfunction
                            
                            " Section: variable initialization
    1   0.000011000   0.000003000 call s:InitVariable('g:NERDAllowAnyVisualDelims', 1)
    1   0.000006000   0.000002000 call s:InitVariable('g:NERDBlockComIgnoreEmpty', 0)
    1   0.000006000   0.000003000 call s:InitVariable('g:NERDCommentWholeLinesInVMode', 0)
    1   0.000005000   0.000002000 call s:InitVariable('g:NERDCommentEmptyLines', 0)
    1   0.000005000   0.000002000 call s:InitVariable('g:NERDCompactSexyComs', 0)
    1   0.000005000   0.000002000 call s:InitVariable('g:NERDCreateDefaultMappings', 1)
    1   0.000004000   0.000001000 call s:InitVariable('g:NERDDefaultNesting', 1)
    1   0.000005000   0.000001000 call s:InitVariable('g:NERDMenuMode', 3)
    1   0.000006000   0.000002000 call s:InitVariable('g:NERDLPlace', '[>')
    1   0.000004000   0.000001000 call s:InitVariable('g:NERDUsePlaceHolders', 1)
    1   0.000004000   0.000001000 call s:InitVariable('g:NERDRemoveAltComs', 1)
    1   0.000005000   0.000001000 call s:InitVariable('g:NERDRemoveExtraSpaces', 0)
    1   0.000005000   0.000001000 call s:InitVariable('g:NERDRPlace', '<]')
    1   0.000004000   0.000001000 call s:InitVariable('g:NERDSpaceDelims', 0)
    1   0.000005000   0.000002000 call s:InitVariable('g:NERDDefaultAlign', 'none')
    1   0.000005000   0.000002000 call s:InitVariable('g:NERDTrimTrailingWhitespace', 0)
    1   0.000005000   0.000001000 call s:InitVariable('g:NERDToggleCheckAllLines', 0)
    1   0.000005000   0.000001000 call s:InitVariable('g:NERDDisableTabsInBlockComm', 0)
    1   0.000005000   0.000001000 call s:InitVariable('g:NERDSuppressWarnings', 0)
                            
                            " Section: Comment mapping and menu item setup
                            " ===========================================================================
                            
                            " Create menu items for the specified modes.  If a:combo is not empty, then
                            " also define mappings and show a:combo in the menu items.
    1              0.000001000 function! s:CreateMaps(modes, target, desc, combo)
                                " Build up a map command like
                                " 'noremap <silent> <Plug>NERDCommenterComment :call nerdcommenter#Comment("n", "Comment")'
                                let plug = '<Plug>NERDCommenter' . a:target
                                let plug_start = 'noremap <silent> ' . plug . ' :call nerdcommenter#Comment("'
                                let plug_end = '", "' . a:target . '")<CR>'
                                " Build up a menu command like
                                " 'menu <silent> comment.Comment<Tab>\\cc <Plug>NERDCommenterComment'
                                let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment', '&Plugin.Nerd\ &Commenter'],
                                            \ g:NERDMenuMode, '')
                                let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
                                if strlen(a:combo)
                                    let leader = exists('g:mapleader') ? g:mapleader : '\'
                                    let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
                                endif
                                let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
                                " Execute the commands built above for each requested mode.
                                for mode in (a:modes ==# '') ? [''] : split(a:modes, '\zs')
                                    if strlen(a:combo)
                                        execute mode . plug_start . mode . plug_end
                                        if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
                                            execute mode . 'map <leader>' . a:combo . ' ' . plug
                                        endif
                                    endif
                                    " Check if the user wants the menu to be displayed.
                                    if g:NERDMenuMode !=# 0
                                        execute mode . menu_command
                                    endif
                                endfor
                            endfunction
                            
    1   0.000085000   0.000003000 call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')
    1   0.000067000   0.000003000 call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<Space>')
    1   0.000062000   0.000002000 call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')
    1   0.000061000   0.000003000 call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')
    1   0.000042000   0.000002000 call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')
    1   0.000063000   0.000002000 call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')
    1   0.000059000   0.000002000 call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')
    1   0.000060000   0.000001000 call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')
    1   0.000042000   0.000003000 call s:CreateMaps('n',  'Append',     'Append', 'cA')
    1   0.000029000   0.000001000 call s:CreateMaps('',   ':',          '-Sep-', '')
    1   0.000062000   0.000002000 call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')
    1   0.000063000   0.000003000 call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')
    1   0.000030000   0.000002000 call s:CreateMaps('',   ':',          '-Sep2-', '')
    1   0.000061000   0.000002000 call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')
    1   0.000043000   0.000003000 call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')
    1   0.000031000   0.000002000 call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')
    1   0.000028000   0.000001000 call s:CreateMaps('',   ':',          '-Sep3-', '')
    1   0.000030000   0.000003000 call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')
                            
                            " Shim functions so old code gets passed through to the autoload functions
    1              0.000000000 function! NERDComment(mode, type) range
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDComment() has been deprecated, please use nerdcommenter#Comment() instead'
                                endif
                            	if a:firstline != a:lastline
                            		echoerr "Sorry! We can't pass a range through this deprecation shim, please update your code."
                            		return v:false
                            	endif
                                return nerdcommenter#Comment(a:mode, a:type)
                            endfunction
                            
    1              0.000001000 function! NERDCommentIsLineCommented(lineNo)
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDCommentIsLineCommented() has been deprecated, please use nerdcommenter#IsLineCommented() instead'
                                endif
                                return nerdcommenter#IsLineCommented(a:lineNo)
                            endfunction
                            
    1              0.000001000 function! NERDCommentIsCharCommented(line, col)
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDCommentIsCharCommented() has been deprecated, please use nerdcommenter#IsCharCommented() instead'
                                endif
                                return nerdcommenter#IsCharCommented(a:line, a:col)
                            endfunction
                            
    1              0.000005000 inoremap <silent> <Plug>NERDCommenterInsert <C-\><C-O>:call nerdcommenter#Comment('i', "Insert")<CR>
                            
                            " switch to/from alternative delimiters (does not use wrapper function)
    1              0.000005000 nnoremap <Plug>NERDCommenterAltDelims :call nerdcommenter#SwitchToAlternativeDelimiters(1)<CR>

SCRIPT  /Users/danbradbury/.vim/bundle/vim-trailing-whitespace/plugin/trailing-whitespace.vim
Sourced 1 time
Total time:   0.000041000
 Self time:   0.000041000

count     total (s)      self (s)
    1              0.000003000 if exists('loaded_trailing_whitespace_plugin') | finish | endif
    1              0.000001000 let loaded_trailing_whitespace_plugin = 1
                            
    1              0.000002000 if !exists('g:extra_whitespace_ignored_filetypes')
    1              0.000001000     let g:extra_whitespace_ignored_filetypes = []
    1              0.000000000 endif
                            
    1              0.000001000 function! ShouldMatchWhitespace()
                                for ft in g:extra_whitespace_ignored_filetypes
                                    if ft ==# &filetype | return 0 | endif
                                endfor
                                if &buftype ==# 'terminal' | return 0 | endif
                                return 1
                            endfunction
                            
                            " Highlight EOL whitespace, http://vim.wikia.com/wiki/Highlight_unwanted_spaces
    1              0.000006000 highlight default ExtraWhitespace ctermbg=darkred guibg=darkred
    1              0.000001000 autocmd ColorScheme * highlight default ExtraWhitespace ctermbg=darkred guibg=darkred
    1              0.000003000 let term_open_event = (has('nvim') ? 'TermOpen' : 'TerminalOpen')
    1              0.000006000 exe 'autocmd BufRead,BufNew,FileType,' term_open_event '* if ShouldMatchWhitespace() | match ExtraWhitespace /\\\@<![\u3000[:space:]]\+$/ | else | match ExtraWhitespace /^^/ | endif'
                            
                            " The above flashes annoyingly while typing, be calmer in insert mode
    1              0.000001000 autocmd InsertLeave * if ShouldMatchWhitespace() | match ExtraWhitespace /\\\@<![\u3000[:space:]]\+$/ | endif
    1              0.000002000 autocmd InsertEnter * if ShouldMatchWhitespace() | match ExtraWhitespace /\\\@<![\u3000[:space:]]\+\%#\@<!$/ | endif
                            
    1              0.000001000 function! s:FixWhitespace(line1,line2)
                                silent! keepjumps execute ':' . a:line1 . ',' . a:line2 . 's/\\\@<!\s\+$//'
                            endfunction
                            
                            " Run :FixWhitespace to remove end of line white space
    1              0.000004000 command! -range=% FixWhitespace call <SID>FixWhitespace(<line1>,<line2>)

SCRIPT  /Users/danbradbury/.vim/bundle/csv.vim/plugin/csv.vim
Sourced 1 time
Total time:   0.000076000
 Self time:   0.000054000

count     total (s)      self (s)
                            " Plugin folklore START "{{{1
    1              0.000002000 if get(g:, 'loaded_csv', 0)
                                finish
    1              0.000001000 endif
    1              0.000000000 let g:loaded_csv = 1
    1              0.000002000 let s:cpo_save = &cpo
    1              0.000001000 set cpo&vim
                            
                            " CSV Plugin functions "{{{1
                            " CSVDoBufLoadAutocmd "{{{2
    1              0.000001000 fu! s:CSVDoBufLoadAutocmd()
                                " Visually arrange columns when opening a csv file
                                " do not check filetype here, it might be too late, rather use the
                                " filepattern from the ftdetect script
                                aug CSV_Edit
                                    au!
                                    au BufReadPost,BufWritePost *.csv,*.dat,*.tsv,*.tab call s:CSVArrange(1)
                                    au BufWritePre *.csv,*.dat,*.tsv,*.tab call s:CSVArrange(0)
                                aug end
                            endfu
                            " CSVArrange "{{{2
    1              0.000000000 fu! s:CSVArrange(arrange)
                                if !get(g:, 'csv_autocmd_arrange', 0)
                                    return
                                endif
                                if a:arrange
                                    call csv#CSVArrangeCol(1, line('$'), 0, get(g:, 'csv_autocmd_arrange_size', -1))
                                else
                                    call csv#PrepUnArrangeCol(1, line('$'))
                                endif
                            endfu
                            " Create Autocommand "{{{2
    1   0.000025000   0.000003000 call s:CSVDoBufLoadAutocmd()
                            
                            " CSV Table command and functions "{{{2
    1              0.000001000 if !get(g:, 'csv_disable_table_command', 0)
    1              0.000004000     com! -range -bang -nargs=? CSVTable call <sid>Table(<bang>0, <line1>, <line2>, <q-args>)
                            
    1              0.000001000     fu! <sid>Table(bang, line1, line2, delim)
                                    if match(split(&ft, '\.'), 'csv') > -1
                                        " Use CSVTabularize command
                                        echohl WarningMsg
                                        echomsg "For CSV files, use the :CSVTabularize command!"
                                        echohl None
                                        return
                                    endif
                                    " save and restore some options
                                    if has("conceal")
                                        let _a = [ &l:lz, &l:syntax, &l:ft, &l:sol, &l:tw, &l:wrap, &l:cole, &l:cocu, &l:fen, &l:fdm, &l:fdl, &l:fdc, &l:fml, &l:fdt, &l:ma, &l:ml]
                                    else
                                        let _a = [ &l:lz, &l:syntax, &l:ft, &l:sol, &l:tw, &l:wrap, &l:fen, &l:fdm, &l:fdl, &l:fdc, &l:fml, &l:fdt, &l:ma, &l:ml]
                                    endif
                                    let _b = winsaveview()
                                    let line1 = a:line1
                                    let line2 = a:line2
                            
                                    if line1 == line2
                                        " use the current paragraph
                                        let line1 = line("'{") + 1
                                        let line2 = line("'}") - 1
                                    endif
                            
                                    if !empty(a:delim)
                                        let g:csv_delim = (a:delim ==# '\t' ? "\t" : a:delim)
                                    endif
                                    " try to guess the delimiter from the specified region, therefore, we need
                                    " to initialize the plugin to inspect only those lines
                                    let [ b:csv_start, b:csv_end ] = [ line1, line2 ]
                                    " Reset b:did_ftplugin just to be sure
                                    unlet! b:did_ftplugin
                                    setl noml ft=csv lz ma
                                    " get indent
                                    let indent = matchstr(getline(a:line1), '^\s\+')
                                    exe printf(':sil %d,%ds/^\s\+//e', line1, line2)
                                    let last = line('$')
                                    try
                                        let b:csv_list=getline(line1, line2)
                                        call filter(b:csv_list, '!empty(v:val)')
                                        call map(b:csv_list, 'split(v:val, b:col.''\zs'')')
                                        if exists(":CSVTabularize")
                                            exe printf("%d,%dCSVTabularize%s", line1, line2, empty(a:bang) ? '' : '!')
                                        else
                                            echoerr "Not possible to call :CSVTabularize"
                                        endif
                                        unlet! b:col_width b:csv_list
                                    catch
                                    finally
                                        " move back to previous window
                                        noa wincmd p
                                        if !empty(indent)
                                            " undo removing the indent
                                            u
                                        endif
                                        if has("conceal")
                                            let [ &l:lz, &l:syntax, &l:ft, &l:sol, &l:tw, &l:wrap, &l:cole, &l:cocu, &l:fen, &l:fdm, &l:fdl, &l:fdc, &l:fml, &l:fdt, &l:ma, &l:ml] = _a
                                        else
                                            let [ &l:lz, &l:syntax, &l:ft, &l:sol, &l:tw, &l:wrap, &l:fen, &l:fdm, &l:fdl, &l:fdc, &l:fml, &l:fdt, &l:ma, &l:ml] = _a
                                        endif
                                        unlet! g:csv_delim
                                        call winrestview(_b)
                                    endtry
                                endfu
    1              0.000000000 endif
                            " Plugin folklore END {{{1
                            " Reset cpo setting "{{{2
    1              0.000001000 let &cpo = s:cpo_save
    1              0.000002000 unlet s:cpo_save
                            " Vim Modeline " {{{2
                            " vim: set foldmethod=marker et sw=0 sts=-1 ts=4:

SCRIPT  /Users/danbradbury/.vim/bundle/tabular/plugin/Tabular.vim
Sourced 1 time
Total time:   0.000116000
 Self time:   0.000116000

count     total (s)      self (s)
                            " Tabular:     Align columnar data using regex-designated column boundaries
                            " Maintainer:  Matthew Wozniski (godlygeek@gmail.com)
                            " Date:        Thu, 03 May 2012 20:49:32 -0400
                            " Version:     1.0
                            "
                            " Long Description:
                            " Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
                            " computer do this for you, since aligning things by hand quickly becomes
                            " unpleasant.  While there are other plugins for aligning text, the ones I've
                            " tried are either impossibly difficult to understand and use, or too simplistic
                            " to handle complicated tasks.  This plugin aims to make the easy things easy
                            " and the hard things possible, without providing an unnecessarily obtuse
                            " interface.  It's still a work in progress, and criticisms are welcome.
                            "
                            " License:
                            " Copyright (c) 2012, Matthew J. Wozniski
                            " All rights reserved.
                            "
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            "     * Redistributions of source code must retain the above copyright notice,
                            "       this list of conditions and the following disclaimer.
                            "     * Redistributions in binary form must reproduce the above copyright
                            "       notice, this list of conditions and the following disclaimer in the
                            "       documentation and/or other materials provided with the distribution.
                            "     * The names of the contributors may not be used to endorse or promote
                            "       products derived from this software without specific prior written
                            "       permission.
                            "
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
                            " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                            " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
                            " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
                            " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                            " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
                            " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
                            " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            
                            " Abort if running in vi-compatible mode or the user doesn't want us.
    1              0.000002000 if &cp || exists('g:tabular_loaded')
                              if &cp && &verbose
                                echo "Not loading Tabular in compatible mode."
                              endif
                              finish
    1              0.000001000 endif
                            
    1              0.000001000 let g:tabular_loaded = 1
                            
                            " Stupid vimscript crap                                                   {{{1
    1              0.000001000 let s:savecpo = &cpo
    1              0.000001000 set cpo&vim
                            
                            " Private Things                                                          {{{1
                            
                            " Dictionary of command name to command
    1              0.000002000 let s:TabularCommands = {}
                            
                            " Generate tab completion list for :Tabularize                            {{{2
                            " Return a list of commands that match the command line typed so far.
                            " NOTE: Tries to handle commands with spaces in the name, but Vim doesn't seem
                            "       to handle that terribly well... maybe I should give up on that.
    1              0.000001000 function! s:CompleteTabularizeCommand(argstart, cmdline, cursorpos)
                              let names = keys(s:TabularCommands)
                              if exists("b:TabularCommands")
                                let names += keys(b:TabularCommands)
                              endif
                            
                              let cmdstart = substitute(a:cmdline, '^\s*\S\+\s*', '', '')
                            
                              return filter(names, 'v:val =~# ''^\V'' . escape(cmdstart, ''\'')')
                            endfunction
                            
                            " Choose the proper command map from the given command line               {{{2
                            " Returns [ command map, command line with leading <buffer> removed ]
    1              0.000000000 function! s:ChooseCommandMap(commandline)
                              let map = s:TabularCommands
                              let cmd = a:commandline
                            
                              if cmd =~# '^<buffer>\s\+'
                                if !exists('b:TabularCommands')
                                  let b:TabularCommands = {}
                                endif
                                let map = b:TabularCommands
                                let cmd = substitute(cmd, '^<buffer>\s\+', '', '')
                              endif
                            
                              return [ map, cmd ]
                            endfunction
                            
                            " Parse '/pattern/format' into separate pattern and format parts.         {{{2
                            " If parsing fails, return [ '', '' ]
    1              0.000001000 function! s:ParsePattern(string)
                              if a:string[0] != '/'
                                return ['','']
                              endif
                            
                              let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'
                              let format = matchstr(a:string[1:-1], pat)
                              if !empty(format)
                                let format = format[1 : -1]
                                let pattern = a:string[1 : -len(format) - 2]
                              else
                                let pattern = a:string[1 : -1]
                              endif
                            
                              return [pattern, format]
                            endfunction
                            
                            " Split apart a list of | separated expressions.                          {{{2
    1              0.000001000 function! s:SplitCommands(string)
                              if a:string =~ '^\s*$'
                                return []
                              endif
                            
                              let end = match(a:string, "[\"'|]")
                            
                              " Loop until we find a delimiting | or end-of-string
                              while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')
                                if a:string[end] == "'"
                                  let end = match(a:string, "'", end+1) + 1
                                  if end == 0
                                    throw "No matching end single quote"
                                  endif
                                elseif a:string[end] == '"'
                                  " Find a " preceded by an even number of \ (or 0)
                                  let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'
                                  let end = matchend(a:string, pattern, end+1) + 1
                                  if end == 0
                                    throw "No matching end double quote"
                                  endif
                                else " Found ||
                                  let end += 2
                                endif
                            
                                let end = match(a:string, "[\"'|]", end)
                              endwhile
                            
                              if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'
                                throw "Empty element"
                              endif
                            
                              if end == -1
                                let rv = [ a:string ]
                              else
                                let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])
                              endif
                            
                              return rv
                            endfunction
                            
                            " Public Things                                                           {{{1
                            
                            " Command associating a command name with a simple pattern command        {{{2
                            " AddTabularPattern[!] [<buffer>] name /pattern[/format]
                            "
                            " If <buffer> is provided, the command will only be available in the current
                            " buffer, and will be used instead of any global command with the same name.
                            "
                            " If a command with the same name and scope already exists, it is an error,
                            " unless the ! is provided, in which case the existing command will be
                            " replaced.
                            "
                            " pattern is a regex describing the delimiter to be used.
                            "
                            " format describes the format pattern to be used.  The default will be used if
                            " none is provided.
    1              0.000002000 com! -nargs=+ -bang AddTabularPattern
                               \ call AddTabularPattern(<q-args>, <bang>0)
                            
    1              0.000000000 function! AddTabularPattern(command, force)
                              try
                                let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                            
                                let name = matchstr(rest, '.\{-}\ze\s*/')
                                let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                            
                                let [ pattern, format ] = s:ParsePattern(pattern)
                            
                                if empty(name) || empty(pattern)
                                  throw "Invalid arguments!"
                                endif
                            
                                if !a:force && has_key(commandmap, name)
                                  throw string(name) . " is already defined, use ! to overwrite."
                                endif
                            
                                let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)
                            
                                if !empty(format)
                                  let command .=  ", " . string(format)
                                endif
                            
                                let command .= ")"
                            
                                let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }
                              catch
                                echohl ErrorMsg
                                echomsg "AddTabularPattern: " . v:exception
                                echohl None
                              endtry
                            endfunction
                            
                            " Command associating a command name with a pipeline of functions         {{{2
                            " AddTabularPipeline[!] [<buffer>] name /pattern/ func [ | func2 [ | func3 ] ]
                            "
                            " If <buffer> is provided, the command will only be available in the current
                            " buffer, and will be used instead of any global command with the same name.
                            "
                            " If a command with the same name and scope already exists, it is an error,
                            " unless the ! is provided, in which case the existing command will be
                            " replaced.
                            "
                            " pattern is a regex that will be used to determine which lines will be
                            " filtered.  If the cursor line doesn't match the pattern, using the command
                            " will be a no-op, otherwise the cursor and all contiguous lines matching the
                            " pattern will be filtered.
                            "
                            " Each 'func' argument represents a function to be called.  This function
                            " will have access to a:lines, a List containing one String per line being
                            " filtered.
    1              0.000002000 com! -nargs=+ -bang AddTabularPipeline
                               \ call AddTabularPipeline(<q-args>, <bang>0)
                            
    1              0.000000000 function! AddTabularPipeline(command, force)
                              try
                                let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                            
                                let name = matchstr(rest, '.\{-}\ze\s*/')
                                let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                            
                                let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')
                                let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')
                            
                                if empty(name) || empty(pattern)
                                  throw "Invalid arguments!"
                                endif
                            
                                if !a:force && has_key(commandmap, name)
                                  throw string(name) . " is already defined, use ! to overwrite."
                                endif
                            
                                let commandlist = s:SplitCommands(commands)
                            
                                if empty(commandlist)
                                  throw "Must provide a list of functions!"
                                endif
                            
                                let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }
                              catch
                                echohl ErrorMsg
                                echomsg "AddTabularPipeline: " . v:exception
                                echohl None
                              endtry
                            endfunction
                            
                            " Tabularize /pattern[/format]                                            {{{2
                            " Tabularize name
                            "
                            " Align text, either using the given pattern, or the command associated with
                            " the given name.
    1              0.000003000 com! -nargs=* -range -complete=customlist,<SID>CompleteTabularizeCommand
                               \ Tabularize <line1>,<line2>call Tabularize(<q-args>)
                            
    1              0.000000000 function! Tabularize(command, ...) range
                              let piperange_opt = {}
                              if a:0
                                let piperange_opt = a:1
                              endif
                            
                              if empty(a:command)
                                if !exists("s:last_tabularize_command")
                                  echohl ErrorMsg
                                  echomsg "Tabularize hasn't been called yet; no pattern/command to reuse!"
                                  echohl None
                                  return
                                endif
                              else
                                let s:last_tabularize_command = a:command
                              endif
                            
                              let command = s:last_tabularize_command
                            
                              let range = a:firstline . ',' . a:lastline
                            
                              try
                                let [ pattern, format ] = s:ParsePattern(command)
                            
                                if !empty(pattern)
                                  let cmd  = "tabular#TabularizeStrings(a:lines, " . string(pattern)
                            
                                  if !empty(format)
                                    let cmd .= "," . string(format)
                                  endif
                            
                                  let cmd .= ")"
                            
                                  exe range . 'call tabular#PipeRangeWithOptions(pattern, [ cmd ], '
                                                  \ . 'piperange_opt)'
                                else
                                  if exists('b:TabularCommands') && has_key(b:TabularCommands, command)
                                    let usercmd = b:TabularCommands[command]
                                  elseif has_key(s:TabularCommands, command)
                                    let usercmd = s:TabularCommands[command]
                                  else
                                    throw "Unrecognized command " . string(command)
                                  endif
                            
                                  exe range . 'call tabular#PipeRangeWithOptions(usercmd["pattern"], '
                                                  \ . 'usercmd["commands"], piperange_opt)'
                                endif
                              catch
                                echohl ErrorMsg
                                echomsg "Tabularize: " . v:exception
                                echohl None
                                return
                              endtry
                            endfunction
                            
    1              0.000001000 function! TabularizeHasPattern()
                              return exists("s:last_tabularize_command")
                            endfunction
                            
                            " GTabularize /pattern[/format]                                           {{{2
                            " GTabularize name
                            "
                            " Align text on only matching lines, either using the given pattern, or the
                            " command associated with the given name.  Mnemonically, this is similar to
                            " the :global command, which takes some action on all rows matching a pattern
                            " in a range.  This command is different from normal :Tabularize in 3 ways:
                            "   1) If a line in the range does not match the pattern, it will be left
                            "      unchanged, and not in any way affect the outcome of other lines in the
                            "      range (at least, normally - but Pipelines can and will still look at
                            "      non-matching rows unless they are specifically written to be aware of
                            "      tabular#DoGTabularize() and handle it appropriately).
                            "   2) No automatic range determination - :Tabularize automatically expands
                            "      a single-line range (or a call with no range) to include all adjacent
                            "      matching lines.  That behavior does not make sense for this command.
                            "   3) If called without a range, it will act on all lines in the buffer (like
                            "      :global) rather than only a single line
    1              0.000004000 com! -nargs=* -range=% -complete=customlist,<SID>CompleteTabularizeCommand
                               \ GTabularize <line1>,<line2>
                               \ call Tabularize(<q-args>, { 'mode': 'GTabularize' } )
                            
                            " Stupid vimscript crap, part 2                                           {{{1
    1              0.000002000 let &cpo = s:savecpo
    1              0.000001000 unlet s:savecpo
                            
                            " vim:set sw=2 sts=2 fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
Sourced 1 time
Total time:   0.000336000
 Self time:   0.000336000

count     total (s)      self (s)
                            " =============================================================================
                            " File:          plugin/ctrlp.vim
                            " Description:   Fuzzy file, buffer, mru, tag, etc finder.
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            " GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
                            
    1              0.000003000 if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
                            	fini
    1              0.000000000 en
    1              0.000001000 let g:loaded_ctrlp = 1
                            
    1              0.000006000 let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs,
                            	\ g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins]
                            	\ = [[], [], [], [], {}, {}, [], 2]
                            
    1              0.000003000 if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
    1              0.000001000 if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en
                            
    1              0.000002000 com! -n=? -com=dir CtrlP         cal ctrlp#init(0, { 'dir': <q-args> })
    1              0.000002000 com! -n=? -com=dir CtrlPMRUFiles cal ctrlp#init(2, { 'dir': <q-args> })
                            
    1              0.000001000 com! -bar CtrlPBuffer   cal ctrlp#init(1)
    1              0.000002000 com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })
                            
    1              0.000001000 com! -bar CtrlPClearCache     cal ctrlp#clr()
    1              0.000001000 com! -bar CtrlPClearAllCaches cal ctrlp#clra()
                            
    1              0.000000000 com! -bar ClearCtrlPCache     cal ctrlp#clr()
    1              0.000000000 com! -bar ClearAllCtrlPCaches cal ctrlp#clra()
                            
    1              0.000001000 com! -bar CtrlPCurWD   cal ctrlp#init(0, { 'mode': '' })
    1              0.000002000 com! -bar CtrlPCurFile cal ctrlp#init(0, { 'mode': 'c' })
    1              0.000001000 com! -bar CtrlPRoot    cal ctrlp#init(0, { 'mode': 'r' })
                            
    1              0.000007000 if g:ctrlp_map != '' && !hasmapto(':<c-u>'.g:ctrlp_cmd.'<cr>', 'n')
    1              0.000006000 	exe 'nn <silent>' g:ctrlp_map ':<c-u>'.g:ctrlp_cmd.'<cr>'
    1              0.000000000 en
                            
    1              0.000263000 cal ctrlp#mrufiles#init()
                            
    1              0.000002000 com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
    1              0.000001000 com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())
                            
    1              0.000003000 com! -n=? -com=dir CtrlPDir
                            	\ cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })
                            
    1              0.000002000 com! -n=? -com=buffer CtrlPBufTag
                            	\ cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))
                            
    1              0.000002000 com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
    1              0.000001000 com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
    1              0.000002000 com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
                            
    1              0.000002000 com! -n=? -com=buffer CtrlPLine
                            	\ cal ctrlp#init(ctrlp#line#cmd(1, <q-args>))
                            
    1              0.000002000 com! -n=? -com=buffer CtrlPChange
                            	\ cal ctrlp#init(ctrlp#changes#cmd(0, <q-args>))
                            
    1              0.000001000 com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
    1              0.000001000 com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
    1              0.000002000 com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())
                            
    1              0.000002000 com! -n=? -com=dir CtrlPBookmarkDirAdd
                            	\ cal ctrlp#call('ctrlp#bookmarkdir#add', <q-args>)
                            
                            " vim:ts=2:sw=2:sts=2

SCRIPT  /Users/danbradbury/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim
Sourced 1 time
Total time:   0.000114000
 Self time:   0.000068000

count     total (s)      self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/mrufiles.vim
                            " Description:   Most Recently Used Files extension
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000002000 let [s:mrbs, s:mrufs] = [[], []]
                            
    1              0.000001000 fu! ctrlp#mrufiles#opts()
                            	let [pref, opts] = ['g:ctrlp_mruf_', {
                            		\ 'max': ['s:max', 250],
                            		\ 'include': ['s:in', ''],
                            		\ 'exclude': ['s:ex', ''],
                            		\ 'case_sensitive': ['s:cseno', 1],
                            		\ 'relative': ['s:re', 0],
                            		\ 'save_on_update': ['s:soup', 1],
                            		\ }]
                            	for [ke, va] in items(opts)
                            		let [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
                            	endfo
                            endf
    1   0.000050000   0.000004000 cal ctrlp#mrufiles#opts()
                            " Utilities {{{1
    1              0.000001000 fu! s:excl(fn)
                            	retu !empty({s:ex}) && a:fn =~# {s:ex}
                            endf
                            
    1              0.000001000 fu! s:mergelists()
                            	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
                            	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
                            	let mrufs = s:mrufs + diskmrufs
                            	retu s:chop(mrufs)
                            endf
                            
    1              0.000001000 fu! s:chop(mrufs)
                            	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
                            	retu a:mrufs
                            endf
                            
    1              0.000001000 fu! s:reformat(mrufs, ...)
                            	let cwd = getcwd()
                            	let cwd .= cwd !~ '[\/]$' ? ctrlp#utils#lash() : ''
                            	if {s:re}
                            		let cwd = exists('+ssl') ? tr(cwd, '/', '\') : cwd
                            		cal filter(a:mrufs, '!stridx(v:val, cwd)')
                            	en
                            	if a:0 && a:1 == 'raw' | retu a:mrufs | en
                            	let idx = strlen(cwd)
                            	if exists('+ssl') && &ssl
                            		let cwd = tr(cwd, '\', '/')
                            		cal map(a:mrufs, 'tr(v:val, "\\", "/")')
                            	en
                            	retu map(a:mrufs, '!stridx(v:val, cwd) ? strpart(v:val, idx) : v:val')
                            endf
                            
    1              0.000000000 fu! s:record(bufnr)
                            	if s:locked | retu | en
                            	let bufnr = a:bufnr + 0
                            	let bufname = bufname(bufnr)
                            	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
                            	en
                            endf
                            
    1              0.000001000 fu! s:addtomrufs(fname)
                            	let fn = fnamemodify(a:fname, ':p')
                            	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
                            	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} )
                            		\ || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
                            	let idx = index(s:mrufs, fn, 0, !{s:cseno})
                            	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en
                            endf
                            
    1              0.000001000 fu! s:savetofile(mrufs)
                            	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
                            endf
                            " Public {{{1
    1              0.000001000 fu! ctrlp#mrufiles#refresh(...)
                            	let mrufs = s:mergelists()
                            	cal filter(mrufs, '!empty(ctrlp#utils#glob(v:val, 1)) && !s:excl(v:val)')
                            	if exists('+ssl')
                            		cal map(mrufs, 'tr(v:val, "/", "\\")')
                            		cal map(s:mrufs, 'tr(v:val, "/", "\\")')
                            		let cond = 'count(mrufs, v:val, !{s:cseno}) == 1'
                            		cal filter(mrufs, cond)
                            		cal filter(s:mrufs, cond)
                            	en
                            	cal s:savetofile(mrufs)
                            	retu a:0 && a:1 == 'raw' ? [] : s:reformat(mrufs)
                            endf
                            
    1              0.000001000 fu! ctrlp#mrufiles#remove(files)
                            	let mrufs = []
                            	if a:files != []
                            		let mrufs = s:mergelists()
                            		let cond = 'index(a:files, v:val, 0, !{s:cseno}) < 0'
                            		cal filter(mrufs, cond)
                            		cal filter(s:mrufs, cond)
                            	en
                            	cal s:savetofile(mrufs)
                            	retu s:reformat(mrufs)
                            endf
                            
    1              0.000000000 fu! ctrlp#mrufiles#add(fn)
                            	if !empty(a:fn)
                            		cal s:addtomrufs(a:fn)
                            	en
                            endf
                            
    1              0.000001000 fu! ctrlp#mrufiles#list(...)
                            	retu a:0 ? a:1 == 'raw' ? s:reformat(s:mergelists(), a:1) : 0
                            		\ : s:reformat(s:mergelists())
                            endf
                            
    1              0.000001000 fu! ctrlp#mrufiles#bufs()
                            	retu s:mrbs
                            endf
                            
    1              0.000000000 fu! ctrlp#mrufiles#tgrel()
                            	let {s:re} = !{s:re}
                            endf
                            
    1              0.000000000 fu! ctrlp#mrufiles#cachefile()
                            	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
                            	retu s:cafile
                            endf
                            
    1              0.000001000 fu! ctrlp#mrufiles#init()
                            	if !has('autocmd') | retu | en
                            	let s:locked = 0
                            	aug CtrlPMRUF
                            		au!
                            		au BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
                            		au QuickFixCmdPre  *vimgrep* let s:locked = 1
                            		au QuickFixCmdPost *vimgrep* let s:locked = 0
                            		au VimLeavePre * cal s:savetofile(s:mergelists())
                            	aug END
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/danbradbury/.vim/bundle/tagbar/plugin/tagbar.vim
Sourced 1 time
Total time:   0.000583000
 Self time:   0.000123000

count     total (s)      self (s)
                            " ============================================================================
                            " File:        tagbar.vim
                            " Description: List the current file's tags in a sidebar, ordered by class etc
                            " Author:      Jan Larres <jan@majutsushi.net>
                            " Licence:     Vim licence
                            " Website:     https://preservim.github.io/tagbar
                            " Version:     3.1.1
                            " Note:        This plugin was heavily inspired by the 'Taglist' plugin by
                            "              Yegappan Lakshmanan and uses a small amount of code from it.
                            "
                            " Original taglist copyright notice:
                            "              Permission is hereby granted to use and distribute this code,
                            "              with or without modifications, provided that this copyright
                            "              notice is copied with it. Like anything else that's free,
                            "              taglist.vim is provided *as is* and comes with no warranty of
                            "              any kind, either expressed or implied. In no event will the
                            "              copyright holder be liable for any damamges resulting from the
                            "              use of this software.
                            " ============================================================================
                            
    1              0.000001000 scriptencoding utf-8
                            
    1              0.000002000 if &compatible || exists('g:loaded_tagbar')
                                finish
    1              0.000001000 endif
                            
                            " Basic init {{{1
                            
    1              0.000001000 if v:version < 700
                                echohl WarningMsg
                                echomsg 'Tagbar: Vim version is too old, Tagbar requires at least 7.0'
                                echohl None
                                finish
    1              0.000000000 endif
                            
    1              0.000001000 if v:version == 700 && !has('patch167')
                                echohl WarningMsg
                                echomsg 'Tagbar: Vim versions lower than 7.0.167 have a bug'
                                      \ 'that prevents this version of Tagbar from working.'
                                      \ 'Please use the alternate version posted on the website.'
                                echohl None
                                finish
    1              0.000001000 endif
                            
    1              0.000001000 function! s:init_var(var, value) abort
                                if !exists('g:tagbar_' . a:var)
                                    execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)
                                endif
                            endfunction
                            
    1              0.000000000 function! s:setup_options() abort
                                if exists('g:tagbar_position')
                                    " Map older deprecated values to correct values
                                    if g:tagbar_position ==# 'top'
                                        let g:tagbar_position = 'leftabove'
                                    elseif g:tagbar_position ==# 'bottom'
                                        let g:tagbar_position = 'rightbelow'
                                    elseif g:tagbar_position ==# 'left'
                                        let g:tagbar_position = 'topleft vertical'
                                    elseif g:tagbar_position ==# 'right'
                                        let g:tagbar_position = 'botright vertical'
                                    endif
                                    if g:tagbar_position !~# 'vertical'
                                        let previewwin_pos = 'rightbelow vertical'
                                    else
                                        let previewwin_pos = 'topleft'
                                    endif
                                    let default_pos = g:tagbar_position
                                else
                                    if exists('g:tagbar_vertical') && g:tagbar_vertical > 0
                                        let previewwin_pos = 'rightbelow vertical'
                                        if exists('g:tagbar_left') && g:tagbar_left
                                            let default_pos = 'leftabove'
                                        else
                                            let default_pos = 'rightbelow'
                                        endif
                                        let g:tagbar_height = g:tagbar_vertical
                                    elseif exists('g:tagbar_left') && g:tagbar_left
                                        let previewwin_pos = 'topleft'
                                        let default_pos = 'topleft vertical'
                                    else
                                        let previewwin_pos = 'topleft'
                                        let default_pos = 'botright vertical'
                                    endif
                                endif
                                let options = [
                                    \ ['autoclose', 0],
                                    \ ['autoclose_netrw', 0],
                                    \ ['autofocus', 0],
                                    \ ['autopreview', 0],
                                    \ ['autoshowtag', 0],
                                    \ ['case_insensitive', 0],
                                    \ ['compact', 0],
                                    \ ['expand', 0],
                                    \ ['file_size_limit', 0],
                                    \ ['foldlevel', 99],
                                    \ ['hide_nonpublic', 0],
                                    \ ['height', 10],
                                    \ ['indent', 2],
                                    \ ['jump_offset', 0],
                                    \ ['jump_lazy_scroll', 0],
                                    \ ['left', 0],
                                    \ ['help_visibility', 0],
                                    \ ['highlight_follow_insert', 0],
                                    \ ['highlight_method', 'nearest-stl'],
                                    \ ['ignore_anonymous', 0],
                                    \ ['no_autocmds', 0],
                                    \ ['position', default_pos],
                                    \ ['previewwin_pos', previewwin_pos],
                                    \ ['scopestrs', {}],
                                    \ ['scrolloff', 0],
                                    \ ['show_balloon', 1],
                                    \ ['show_data_type', 0],
                                    \ ['show_visibility', 1],
                                    \ ['show_linenumbers', 0],
                                    \ ['show_prefix', 1],
                                    \ ['show_suffix', 1],
                                    \ ['show_tag_count', 0],
                                    \ ['show_tag_linenumbers', 0],
                                    \ ['singleclick', 0],
                                    \ ['sort', 1],
                                    \ ['systemenc', &encoding],
                                    \ ['vertical', 0],
                                    \ ['width', 40],
                                    \ ['zoomwidth', 1],
                                    \ ['silent', 0],
                                    \ ['use_cache', 1],
                                    \ ['wrap', 0],
                                \ ]
                            
                                for [opt, val] in options
                                    call s:init_var(opt, val)
                                    unlet val
                                endfor
                            endfunction
    1   0.000306000   0.000007000 call s:setup_options()
                            
    1              0.000001000 if !exists('g:tagbar_iconchars')
    1              0.000014000     if has('multi_byte') && has('unix') && &encoding ==# 'utf-8' &&
                                 \ (!exists('+termencoding') || empty(&termencoding) || &termencoding ==# 'utf-8')
    1              0.000001000         let g:tagbar_iconchars = ['▸', '▾']
                                else
                                    let g:tagbar_iconchars = ['+', '-']
    1              0.000000000     endif
    1              0.000001000 endif
                            
    1              0.000001000 function! s:setup_keymaps() abort
                                let keymaps = [
                                    \ ['jump',          '<CR>'],
                                    \ ['preview',       'p'],
                                    \ ['previewwin',    'P'],
                                    \ ['nexttag',       '<C-N>'],
                                    \ ['prevtag',       '<C-P>'],
                                    \ ['showproto',     '<Space>'],
                                    \ ['hidenonpublic', 'v'],
                                    \
                                    \ ['openfold',      ['+', '<kPlus>', 'zo']],
                                    \ ['closefold',     ['-', '<kMinus>', 'zc']],
                                    \ ['togglefold',    ['o', 'za']],
                                    \ ['openallfolds',  ['*', '<kMultiply>', 'zR']],
                                    \ ['closeallfolds', ['=', 'zM']],
                                    \ ['incrementfolds',  ['zr']],
                                    \ ['decrementfolds',  ['zm']],
                                    \ ['nextfold',      'zj'],
                                    \ ['prevfold',      'zk'],
                                    \
                                    \ ['togglesort',            's'],
                                    \ ['togglecaseinsensitive', 'i'],
                                    \ ['toggleautoclose',       'c'],
                                    \ ['togglepause',           't'],
                                    \ ['zoomwin',               'x'],
                                    \ ['close',                 'q'],
                                    \ ['help',                  ['<F1>', '?']],
                                \ ]
                            
                                for [map, key] in keymaps
                                    call s:init_var('map_' . map, key)
                                    unlet key
                                endfor
                            endfunction
    1   0.000166000   0.000005000 call s:setup_keymaps()
                            
    1              0.000000000 augroup TagbarSession
    1              0.000013000     autocmd!
    1              0.000002000     autocmd SessionLoadPost * nested call tagbar#RestoreSession()
    1              0.000000000 augroup END
                            
                            " Commands {{{1
    1              0.000002000 command! -nargs=? Tagbar              call tagbar#ToggleWindow(<f-args>)
    1              0.000001000 command! -nargs=? TagbarToggle        call tagbar#ToggleWindow(<f-args>)
    1              0.000004000 command! -nargs=? TagbarOpen          call tagbar#OpenWindow(<f-args>)
    1              0.000002000 command! -nargs=0 TagbarOpenAutoClose call tagbar#OpenWindow('fcj')
    1              0.000001000 command! -nargs=0 TagbarClose         call tagbar#CloseWindow()
    1              0.000002000 command! -nargs=1 -bang TagbarSetFoldlevel  call tagbar#SetFoldLevel(<args>, <bang>0)
    1              0.000002000 command! -nargs=0 TagbarShowTag       call tagbar#highlighttag(1, 1)
    1              0.000002000 command! -nargs=* TagbarCurrentTag    echo tagbar#currenttag('%s', 'No current tag', <f-args>)
    1              0.000001000 command! -nargs=1 TagbarGetTypeConfig call tagbar#gettypeconfig(<f-args>)
    1              0.000002000 command! -nargs=? TagbarDebug         call tagbar#debug#start_debug(<f-args>)
    1              0.000001000 command! -nargs=0 TagbarDebugEnd      call tagbar#debug#stop_debug()
    1              0.000002000 command! -nargs=0 TagbarTogglePause   call tagbar#toggle_pause()
    1              0.000001000 command! -nargs=0 TagbarForceUpdate   call tagbar#ForceUpdate()
    1              0.000001000 command! -nargs=0 TagbarJump   call tagbar#jump()
    1              0.000001000 command! -nargs=0 TagbarJumpPrev      call tagbar#jumpToNearbyTag(-1)
    1              0.000002000 command! -nargs=0 TagbarJumpNext      call tagbar#jumpToNearbyTag(1)
                            
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  /Users/danbradbury/.vim/bundle/ack.vim/plugin/ack.vim
Sourced 1 time
Total time:   0.000081000
 Self time:   0.000081000

count     total (s)      self (s)
    1              0.000002000 if exists('g:loaded_ack') || &cp
                              finish
    1              0.000000000 endif
                            
    1              0.000001000 if !exists("g:ack_default_options")
    1              0.000002000   let g:ack_default_options = " -s -H --nopager --nocolor --nogroup --column"
    1              0.000000000 endif
                            
                            " Location of the ack utility
    1              0.000001000 if !exists("g:ackprg")
    1              0.000045000   if executable('ack-grep')
                                let g:ackprg = "ack-grep"
    1              0.000024000   elseif executable('ack')
                                let g:ackprg = "ack"
    1              0.000001000   else
    1              0.000000000     finish
                              endif
                              let g:ackprg .= g:ack_default_options
                            endif
                            
                            if !exists("g:ack_apply_qmappings")
                              let g:ack_apply_qmappings = !exists("g:ack_qhandler")
                            endif
                            
                            if !exists("g:ack_apply_lmappings")
                              let g:ack_apply_lmappings = !exists("g:ack_lhandler")
                            endif
                            
                            let s:ack_mappings = {
                                  \ "t": "<C-W><CR><C-W>T",
                                  \ "T": "<C-W><CR><C-W>TgT<C-W>j",
                                  \ "o": "<CR>",
                                  \ "O": "<CR><C-W>p<C-W>c",
                                  \ "go": "<CR><C-W>p",
                                  \ "h": "<C-W><CR><C-W>K",
                                  \ "H": "<C-W><CR><C-W>K<C-W>b",
                                  \ "v": "<C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t",
                                  \ "gv": "<C-W><CR><C-W>H<C-W>b<C-W>J" }
                            
                            if exists("g:ack_mappings")
                              let g:ack_mappings = extend(s:ack_mappings, g:ack_mappings)
                            else
                              let g:ack_mappings = s:ack_mappings
                            endif
                            
                            if !exists("g:ack_qhandler")
                              let g:ack_qhandler = "botright copen"
                            endif
                            
                            if !exists("g:ack_lhandler")
                              let g:ack_lhandler = "botright lopen"
                            endif
                            
                            if !exists("g:ackhighlight")
                              let g:ackhighlight = 0
                            endif
                            
                            if !exists("g:ack_autoclose")
                              let g:ack_autoclose = 0
                            endif
                            
                            if !exists("g:ack_autofold_results")
                              let g:ack_autofold_results = 0
                            endif
                            
                            if !exists("g:ack_use_cword_for_empty_search")
                              let g:ack_use_cword_for_empty_search = 1
                            endif
                            
                            command! -bang -nargs=* -complete=file Ack           call ack#Ack('grep<bang>', <q-args>)
                            command! -bang -nargs=* -complete=file AckAdd        call ack#Ack('grepadd<bang>', <q-args>)
                            command! -bang -nargs=* -complete=file AckFromSearch call ack#AckFromSearch('grep<bang>', <q-args>)
                            command! -bang -nargs=* -complete=file LAck          call ack#Ack('lgrep<bang>', <q-args>)
                            command! -bang -nargs=* -complete=file LAckAdd       call ack#Ack('lgrepadd<bang>', <q-args>)
                            command! -bang -nargs=* -complete=file AckFile       call ack#Ack('grep<bang> -g', <q-args>)
                            command! -bang -nargs=* -complete=help AckHelp       call ack#AckHelp('grep<bang>', <q-args>)
                            command! -bang -nargs=* -complete=help LAckHelp      call ack#AckHelp('lgrep<bang>', <q-args>)
                            command! -bang -nargs=*                AckWindow     call ack#AckWindow('grep<bang>', <q-args>)
                            command! -bang -nargs=*                LAckWindow    call ack#AckWindow('lgrep<bang>', <q-args>)
                            
                            let g:loaded_ack = 1
                            
                            " vim:set et sw=2 ts=2 tw=78 fdm=marker

SCRIPT  /Users/danbradbury/.vim/bundle/ag.vim/plugin/ag.vim
Sourced 1 time
Total time:   0.000024000
 Self time:   0.000024000

count     total (s)      self (s)
                            " NOTE: You must, of course, install ag / the_silver_searcher
    1              0.000002000 command! -bang -nargs=* -complete=file Ag call ag#Ag('grep<bang>',<q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=file AgBuffer call ag#AgBuffer('grep<bang>',<q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=file AgAdd call ag#Ag('grepadd<bang>', <q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=file AgFromSearch call ag#AgFromSearch('grep<bang>', <q-args>)
    1              0.000001000 command! -bang -nargs=* -complete=file LAg call ag#Ag('lgrep<bang>', <q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=file LAgBuffer call ag#AgBuffer('lgrep<bang>',<q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=file LAgAdd call ag#Ag('lgrepadd<bang>', <q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=file AgFile call ag#Ag('grep<bang> -g', <q-args>)
    1              0.000002000 command! -bang -nargs=* -complete=help AgHelp call ag#AgHelp('grep<bang>',<q-args>)
    1              0.000003000 command! -bang -nargs=* -complete=help LAgHelp call ag#AgHelp('lgrep<bang>',<q-args>)

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/plugin/NERD_tree.vim
Sourced 1 time
Total time:   0.006309000
 Self time:   0.006309000

count     total (s)      self (s)
                            " ============================================================================
                            " File:        NERD_tree.vim
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
                            "
                            " SECTION: Script init stuff {{{1
                            "============================================================
    1              0.000000000 scriptencoding utf-8
                            
    1              0.000001000 if exists('loaded_nerd_tree')
                                finish
    1              0.000001000 endif
    1              0.000001000 if v:version < 703
                                echoerr "NERDTree: this plugin requires vim >= 7.3. DOWNLOAD IT! You'll thank me later!"
                                finish
    1              0.000000000 endif
    1              0.000001000 let loaded_nerd_tree = 1
                            
                            "for line continuation - i.e dont want C in &cpoptions
    1              0.000001000 let s:old_cpo = &cpoptions
    1              0.000001000 set cpoptions&vim
                            
                            "SECTION: Initialize variable calls and other random constants {{{2
    1              0.000002000 let g:NERDTreeAutoCenter            = get(g:, 'NERDTreeAutoCenter',            1)
    1              0.000002000 let g:NERDTreeAutoCenterThreshold   = get(g:, 'NERDTreeAutoCenterThreshold',   3)
    1              0.000001000 let g:NERDTreeCaseSensitiveFS       = get(g:, 'NERDTreeCaseSensitiveFS',       2)
    1              0.000002000 let g:NERDTreeCaseSensitiveSort     = get(g:, 'NERDTreeCaseSensitiveSort',     0)
    1              0.000001000 let g:NERDTreeNaturalSort           = get(g:, 'NERDTreeNaturalSort',           0)
    1              0.000001000 let g:NERDTreeSortHiddenFirst       = get(g:, 'NERDTreeSortHiddenFirst',       1)
    1              0.000001000 let g:NERDTreeUseTCD                = get(g:, 'NERDTreeUseTCD',                0)
    1              0.000001000 let g:NERDTreeChDirMode             = get(g:, 'NERDTreeChDirMode',             0)
    1              0.000001000 let g:NERDTreeCreatePrefix          = get(g:, 'NERDTreeCreatePrefix',          'silent')
    1              0.000001000 let g:NERDTreeMinimalUI             = get(g:, 'NERDTreeMinimalUI',             0)
    1              0.000001000 let g:NERDTreeMinimalMenu           = get(g:, 'NERDTreeMinimalMenu',           0)
    1              0.000002000 let g:NERDTreeIgnore                = get(g:, 'NERDTreeIgnore',                ['\~$'])
    1              0.000008000 let g:NERDTreeBookmarksFile         = get(g:, 'NERDTreeBookmarksFile',         expand('$HOME') . '/.NERDTreeBookmarks')
    1              0.000001000 let g:NERDTreeBookmarksSort         = get(g:, 'NERDTreeBookmarksSort',         1)
    1              0.000001000 let g:NERDTreeHighlightCursorline   = get(g:, 'NERDTreeHighlightCursorline',   1)
    1              0.000001000 let g:NERDTreeHijackNetrw           = get(g:, 'NERDTreeHijackNetrw',           1)
    1              0.000002000 let g:NERDTreeMarkBookmarks         = get(g:, 'NERDTreeMarkBookmarks',         1)
    1              0.000001000 let g:NERDTreeMouseMode             = get(g:, 'NERDTreeMouseMode',             1)
    1              0.000001000 let g:NERDTreeNotificationThreshold = get(g:, 'NERDTreeNotificationThreshold', 100)
    1              0.000002000 let g:NERDTreeQuitOnOpen            = get(g:, 'NERDTreeQuitOnOpen',            0)
    1              0.000001000 let g:NERDTreeRespectWildIgnore     = get(g:, 'NERDTreeRespectWildIgnore',     0)
    1              0.000001000 let g:NERDTreeShowBookmarks         = get(g:, 'NERDTreeShowBookmarks',         0)
    1              0.000002000 let g:NERDTreeShowFiles             = get(g:, 'NERDTreeShowFiles',             1)
    1              0.000001000 let g:NERDTreeShowHidden            = get(g:, 'NERDTreeShowHidden',            0)
    1              0.000001000 let g:NERDTreeShowLineNumbers       = get(g:, 'NERDTreeShowLineNumbers',       0)
    1              0.000002000 let g:NERDTreeSortDirs              = get(g:, 'NERDTreeSortDirs',              1)
    1              0.000001000 let g:NERDTreeFileLines             = get(g:, 'NERDTreeFileLines',             0)
                            
                            
    1              0.000272000 if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
    1              0.000002000     let g:NERDTreeDirArrowExpandable  = get(g:, 'NERDTreeDirArrowExpandable',  '▸')
    1              0.000002000     let g:NERDTreeDirArrowCollapsible = get(g:, 'NERDTreeDirArrowCollapsible', '▾')
                            else
                                let g:NERDTreeDirArrowExpandable  = get(g:, 'NERDTreeDirArrowExpandable',  '+')
                                let g:NERDTreeDirArrowCollapsible = get(g:, 'NERDTreeDirArrowCollapsible', '~')
    1              0.000001000 endif
                            
    1              0.000002000 let g:NERDTreeCascadeOpenSingleChildDir = get(g:, 'NERDTreeCascadeOpenSingleChildDir', 1)
    1              0.000001000 let g:NERDTreeCascadeSingleChildDir     = get(g:, 'NERDTreeCascadeSingleChildDir',     1)
                            
    1              0.000004000 let g:NERDTreeSortOrder    = get(g:, 'NERDTreeSortOrder', ['\/$', '*', '\.swp$', '\.bak$', '\~$'])
    1              0.000000000 let g:NERDTreeOldSortOrder = []
                            
    1              0.000001000 let g:NERDTreeGlyphReadOnly = get(g:, 'NERDTreeGlyphReadOnly', 'RO')
                            
    1              0.000001000 if has('conceal')
    1              0.000002000     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\x07")
                            elseif (g:NERDTreeDirArrowExpandable ==# "\u00a0" || g:NERDTreeDirArrowCollapsible ==# "\u00a0")
                                let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\u00b7")
                            else
                                let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\u00a0")
    1              0.000000000 endif
                            
                            "the exists() crap here is a hack to stop vim spazzing out when
                            "loading a session that was created with an open nerd tree. It spazzes
                            "because it doesnt store b:NERDTree(its a b: var, and its a hash)
    1              0.000002000 let g:NERDTreeStatusline = get(g:, 'NERDTreeStatusline', "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}")
                            
    1              0.000001000 let g:NERDTreeWinPos  = get(g:, 'NERDTreeWinPos', 'left')
    1              0.000001000 let g:NERDTreeWinSize = get(g:, 'NERDTreeWinSize', 31)
                            
                            "init the shell commands that will be used to copy nodes, and remove dir trees
                            "Note: the space after the command is important
    1              0.000004000 if nerdtree#runningWindows()
                                let g:NERDTreeRemoveDirCmd = get(g:, 'NERDTreeRemoveDirCmd', 'rmdir /s /q ')
                                let g:NERDTreeCopyDirCmd   = get(g:, 'NERDTreeCopyDirCmd',   'xcopy /s /e /i /y /q ')
                                let g:NERDTreeCopyFileCmd  = get(g:, 'NERDTreeCopyFileCmd',  'copy /y ')
    1              0.000000000 else
    1              0.000002000     let g:NERDTreeRemoveDirCmd = get(g:, 'NERDTreeRemoveDirCmd', 'rm -rf ')
    1              0.000001000     let g:NERDTreeCopyCmd      = get(g:, 'NERDTreeCopyCmd',      'cp -r ')
    1              0.000000000 endif
                            
                            "SECTION: Init variable calls for key mappings {{{2
    1              0.000002000 let g:NERDTreeMapCustomOpen      = get(g:, 'NERDTreeMapCustomOpen',      '<CR>')
    1              0.000001000 let g:NERDTreeMapJumpBookmarks   = get(g:, 'NERDTreeMapJumpBookmarks',   'gb')
    1              0.000002000 let g:NERDTreeMapActivateNode    = get(g:, 'NERDTreeMapActivateNode',    'o')
    1              0.000001000 let g:NERDTreeMapChangeRoot      = get(g:, 'NERDTreeMapChangeRoot',      'C')
    1              0.000001000 let g:NERDTreeMapChdir           = get(g:, 'NERDTreeMapChdir',           'cd')
    1              0.000002000 let g:NERDTreeMapCloseChildren   = get(g:, 'NERDTreeMapCloseChildren',   'X')
    1              0.000001000 let g:NERDTreeMapCloseDir        = get(g:, 'NERDTreeMapCloseDir',        'x')
    1              0.000001000 let g:NERDTreeMapDeleteBookmark  = get(g:, 'NERDTreeMapDeleteBookmark',  'D')
    1              0.000002000 let g:NERDTreeMapMenu            = get(g:, 'NERDTreeMapMenu',            'm')
    1              0.000001000 let g:NERDTreeMapHelp            = get(g:, 'NERDTreeMapHelp',            '?')
    1              0.000001000 let g:NERDTreeMapJumpFirstChild  = get(g:, 'NERDTreeMapJumpFirstChild',  'K')
    1              0.000002000 let g:NERDTreeMapJumpLastChild   = get(g:, 'NERDTreeMapJumpLastChild',   'J')
    1              0.000001000 let g:NERDTreeMapJumpNextSibling = get(g:, 'NERDTreeMapJumpNextSibling', '<C-j>')
    1              0.000001000 let g:NERDTreeMapJumpParent      = get(g:, 'NERDTreeMapJumpParent',      'p')
    1              0.000002000 let g:NERDTreeMapJumpPrevSibling = get(g:, 'NERDTreeMapJumpPrevSibling', '<C-k>')
    1              0.000001000 let g:NERDTreeMapJumpRoot        = get(g:, 'NERDTreeMapJumpRoot',        'P')
    1              0.000001000 let g:NERDTreeMapOpenExpl        = get(g:, 'NERDTreeMapOpenExpl',        'e')
    1              0.000002000 let g:NERDTreeMapOpenInTab       = get(g:, 'NERDTreeMapOpenInTab',       't')
    1              0.000001000 let g:NERDTreeMapOpenInTabSilent = get(g:, 'NERDTreeMapOpenInTabSilent', 'T')
    1              0.000001000 let g:NERDTreeMapOpenRecursively = get(g:, 'NERDTreeMapOpenRecursively', 'O')
    1              0.000001000 let g:NERDTreeMapOpenSplit       = get(g:, 'NERDTreeMapOpenSplit',       'i')
    1              0.000002000 let g:NERDTreeMapOpenVSplit      = get(g:, 'NERDTreeMapOpenVSplit',      's')
    1              0.000002000 let g:NERDTreeMapPreview         = get(g:, 'NERDTreeMapPreview',         'g'.NERDTreeMapActivateNode)
    1              0.000001000 let g:NERDTreeMapPreviewSplit    = get(g:, 'NERDTreeMapPreviewSplit',    'g'.NERDTreeMapOpenSplit)
    1              0.000002000 let g:NERDTreeMapPreviewVSplit   = get(g:, 'NERDTreeMapPreviewVSplit',   'g'.NERDTreeMapOpenVSplit)
    1              0.000001000 let g:NERDTreeMapQuit            = get(g:, 'NERDTreeMapQuit',            'q')
    1              0.000002000 let g:NERDTreeMapRefresh         = get(g:, 'NERDTreeMapRefresh',         'r')
    1              0.000001000 let g:NERDTreeMapRefreshRoot     = get(g:, 'NERDTreeMapRefreshRoot',     'R')
    1              0.000002000 let g:NERDTreeMapToggleBookmarks = get(g:, 'NERDTreeMapToggleBookmarks', 'B')
    1              0.000001000 let g:NERDTreeMapToggleFiles     = get(g:, 'NERDTreeMapToggleFiles',     'F')
    1              0.000001000 let g:NERDTreeMapToggleFilters   = get(g:, 'NERDTreeMapToggleFilters',   'f')
    1              0.000002000 let g:NERDTreeMapToggleHidden    = get(g:, 'NERDTreeMapToggleHidden',    'I')
    1              0.000002000 let g:NERDTreeMapToggleFileLines = get(g:, 'NERDTreeMapToggleFileLines', 'FL')
    1              0.000001000 let g:NERDTreeMapToggleZoom      = get(g:, 'NERDTreeMapToggleZoom',      'A')
    1              0.000002000 let g:NERDTreeMapUpdir           = get(g:, 'NERDTreeMapUpdir',           'u')
    1              0.000001000 let g:NERDTreeMapUpdirKeepOpen   = get(g:, 'NERDTreeMapUpdirKeepOpen',   'U')
    1              0.000001000 let g:NERDTreeMapCWD             = get(g:, 'NERDTreeMapCWD',             'CD')
    1              0.000001000 let g:NERDTreeMenuDown           = get(g:, 'NERDTreeMenuDown',           'j')
    1              0.000001000 let g:NERDTreeMenuUp             = get(g:, 'NERDTreeMenuUp',             'k')
                            
                            "SECTION: Load class files{{{2
    1              0.003010000 call nerdtree#loadClassFiles()
                            
                            " SECTION: Commands {{{1
                            "============================================================
    1              0.000402000 call nerdtree#ui_glue#setupCommands()
                            
                            
                            " SECTION: Auto commands {{{1
                            "============================================================
    1              0.000000000 augroup NERDTree
                                "Save the cursor position whenever we close the nerd tree
    1              0.000007000     exec 'autocmd BufLeave,WinLeave '. g:NERDTreeCreator.BufNamePrefix() .'* call nerdtree#onBufLeave()'
                            
                                "disallow insert mode in the NERDTree
    1              0.000005000     exec 'autocmd BufEnter,WinEnter '. g:NERDTreeCreator.BufNamePrefix() .'* stopinsert'
    1              0.000001000 augroup END
                            
    1              0.000001000 if g:NERDTreeHijackNetrw
    1              0.000000000     augroup NERDTreeHijackNetrw
    1              0.000002000         autocmd VimEnter * silent! autocmd! FileExplorer
    1              0.000001000         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand('<amatch>'))
    1              0.000000000     augroup END
    1              0.000000000 endif
                            
    1              0.000001000 if g:NERDTreeChDirMode ==# 3
                                augroup NERDTreeChDirOnTabSwitch
                                    autocmd TabEnter * if g:NERDTree.ExistsForTab()|call g:NERDTree.ForCurrentTab().getRoot().path.changeToDir()|endif
                                augroup END
    1              0.000001000 endif
                            
                            " SECTION: Public API {{{1
                            "============================================================
    1              0.000001000 function! NERDTreeAddMenuItem(options)
                                call g:NERDTreeMenuItem.Create(a:options)
                            endfunction
                            
    1              0.000001000 function! NERDTreeAddMenuSeparator(...)
                                let opts = a:0 ? a:1 : {}
                                call g:NERDTreeMenuItem.CreateSeparator(opts)
                            endfunction
                            
    1              0.000001000 function! NERDTreeAddSubmenu(options)
                                return g:NERDTreeMenuItem.Create(a:options)
                            endfunction
                            
    1              0.000000000 function! NERDTreeAddKeyMap(options)
                                call g:NERDTreeKeyMap.Create(a:options)
                            endfunction
                            
    1              0.000001000 function! NERDTreeRender()
                                call nerdtree#renderView()
                            endfunction
                            
    1              0.000001000 function! NERDTreeFocus()
                                if g:NERDTree.IsOpen()
                                    call g:NERDTree.CursorToTreeWin(0)
                                else
                                    call g:NERDTreeCreator.ToggleTabTree('')
                                endif
                            endfunction
                            
    1              0.000000000 function! NERDTreeCWD()
                            
                                if empty(getcwd())
                                    call nerdtree#echoWarning('current directory does not exist')
                                    return
                                endif
                            
                                try
                                    let l:cwdPath = g:NERDTreePath.New(getcwd())
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('current directory does not exist')
                                    return
                                endtry
                            
                                call NERDTreeFocus()
                            
                                if b:NERDTree.root.path.equals(l:cwdPath)
                                    return
                                endif
                            
                                let l:newRoot = g:NERDTreeFileNode.New(l:cwdPath, b:NERDTree)
                                call b:NERDTree.changeRoot(l:newRoot)
                                normal! ^
                            endfunction
                            
    1              0.000001000 function! NERDTreeAddPathFilter(callback)
                                call g:NERDTree.AddPathFilter(a:callback)
                            endfunction
                            
                            " SECTION: Post Source Actions {{{1
    1              0.002416000 call nerdtree#postSourceActions()
                            
                            "reset &cpoptions back to users setting
    1              0.000003000 let &cpoptions = s:old_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/autoload/nerdtree.vim
Sourced 1 time
Total time:   0.000137000
 Self time:   0.000131000

count     total (s)      self (s)
    1              0.000002000 if exists('g:loaded_nerdtree_autoload')
                                finish
    1              0.000001000 endif
    1              0.000000000 let g:loaded_nerdtree_autoload = 1
                            
    1              0.000012000 let s:rootNERDTreePath = resolve(expand('<sfile>:p:h:h'))
                            
                            "FUNCTION: nerdtree#version(...) {{{1
                            "  If any value is given as an argument, the entire line of text from the
                            "  change log is shown for the current version; otherwise, only the version
                            "  number is shown.
    1              0.000001000 function! nerdtree#version(...) abort
                                let l:text = 'Unknown'
                                try
                                    let l:changelog = readfile(join([s:rootNERDTreePath, 'CHANGELOG.md'], nerdtree#slash()))
                                    let l:line = 0
                                    while l:line <= len(l:changelog)
                                        if l:changelog[l:line] =~# '\d\+\.\d\+'
                                            let l:text = substitute(l:changelog[l:line], '.*\(\d\+.\d\+\).*', '\1', '')
                                            let l:text .= substitute(l:changelog[l:line+1], '^.\{-}\(\.\d\+\).\{-}:\(.*\)', a:0>0 ? '\1:\2' : '\1', '')
                                            break
                                        endif
                                        let l:line += 1
                                    endwhile
                                catch
                                endtry
                                return l:text
                            endfunction
                            
                            " SECTION: General Functions {{{1
                            "============================================================
                            
                            " FUNCTION: nerdtree#closeTreeOnOpen() {{{2
    1              0.000000000 function! nerdtree#closeTreeOnOpen() abort
                                return g:NERDTreeQuitOnOpen == 1 || g:NERDTreeQuitOnOpen == 3
                            endfunction
                            
                            " FUNCTION: nerdtree#closeBookmarksOnOpen() {{{2
    1              0.000001000 function! nerdtree#closeBookmarksOnOpen() abort
                                return g:NERDTreeQuitOnOpen == 2 || g:NERDTreeQuitOnOpen == 3
                            endfunction
                            
                            " FUNCTION: nerdtree#slash() {{{2
                            " Return the path separator used by the underlying file system.  Special
                            " consideration is taken for the use of the 'shellslash' option on Windows
                            " systems.
    1              0.000000000 function! nerdtree#slash() abort
                                if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
                                return '/'
                            endfunction
                            
                            "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
                            "inits a window tree in the current buffer if appropriate
    1              0.000001000 function! nerdtree#checkForBrowse(dir) abort
                                if !isdirectory(a:dir)
                                    return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)
                            endfunction
                            
                            "FUNCTION: s:reuseWin(dir) {{{2
                            "finds a NERDTree buffer with root of dir, and opens it.
    1              0.000001000 function! s:reuseWin(dir) abort
                                let path = g:NERDTreePath.New(fnamemodify(a:dir, ':p'))
                            
                                for i in range(1, bufnr('$'))
                                    unlet! nt
                                    let nt = getbufvar(i, 'NERDTree')
                                    if empty(nt)
                                        continue
                                    endif
                            
                                    if nt.isWinTree() && nt.root.path.equals(path)
                                        call nt.setPreviousBuf(bufnr('#'))
                                        exec 'buffer ' . i
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
                            " completion function for the bookmark commands
    1              0.000001000 function! nerdtree#completeBookmarks(A,L,P) abort
                                return filter(g:NERDTreeBookmark.BookmarkNames(), 'v:val =~# "^' . a:A . '"')
                            endfunction
                            
                            "FUNCTION: nerdtree#compareNodes(n1, n2) {{{2
    1              0.000001000 function! nerdtree#compareNodes(n1, n2) abort
                                return nerdtree#compareNodePaths(a:n1.path, a:n2.path)
                            endfunction
                            
                            "FUNCTION: nerdtree#compareNodePaths(p1, p2) {{{2
    1              0.000001000 function! nerdtree#compareNodePaths(p1, p2) abort
                                let sortKey1 = a:p1.getSortKey()
                                let sortKey2 = a:p2.getSortKey()
                                let i = 0
                                while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
                                    if type(sortKey1[i]) == type(sortKey2[i])
                                        if sortKey1[i] <# sortKey2[i]
                                            return - 1
                                        elseif sortKey1[i] ># sortKey2[i]
                                            return 1
                                        endif
                                    elseif type(sortKey1[i]) == type(0)
                                        return -1
                                    elseif type(sortKey2[i]) == type(0)
                                        return 1
                                    endif
                                    let i += 1
                                endwhile
                            
                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
                            " Issue a deprecation warning for a:func. If a second arg is given, use this
                            " as the deprecation message
    1              0.000001000 function! nerdtree#deprecated(func, ...) abort
                                let msg = a:0 ? a:func . ' ' . a:1 : a:func . ' is deprecated'
                            
                                if !exists('s:deprecationWarnings')
                                    let s:deprecationWarnings = {}
                                endif
                                if !has_key(s:deprecationWarnings, a:func)
                                    let s:deprecationWarnings[a:func] = 1
                                    echomsg msg
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#exec(cmd, ignoreAll) {{{2
                            " Same as :exec cmd but, if ignoreAll is TRUE, set eventignore=all for the duration
    1              0.000000000 function! nerdtree#exec(cmd, ignoreAll) abort
                                let old_ei = &eventignore
                                if a:ignoreAll
                                    set eventignore=all
                                endif
                                try
                                    exec a:cmd
                                finally
                                    let &eventignore = old_ei
                                endtry
                            endfunction
                            
                            " FUNCTION: nerdtree#has_opt(options, name) {{{2
    1              0.000000000 function! nerdtree#has_opt(options, name) abort
                                return has_key(a:options, a:name) && a:options[a:name] ==# 1
                            endfunction
                            
                            " FUNCTION: nerdtree#loadClassFiles() {{{2
    1              0.000000000 function! nerdtree#loadClassFiles() abort
                                runtime lib/nerdtree/path.vim
                                runtime lib/nerdtree/menu_controller.vim
                                runtime lib/nerdtree/menu_item.vim
                                runtime lib/nerdtree/key_map.vim
                                runtime lib/nerdtree/bookmark.vim
                                runtime lib/nerdtree/tree_file_node.vim
                                runtime lib/nerdtree/tree_dir_node.vim
                                runtime lib/nerdtree/opener.vim
                                runtime lib/nerdtree/creator.vim
                                runtime lib/nerdtree/flag_set.vim
                                runtime lib/nerdtree/nerdtree.vim
                                runtime lib/nerdtree/ui.vim
                                runtime lib/nerdtree/event.vim
                                runtime lib/nerdtree/notifier.vim
                            endfunction
                            
                            " FUNCTION: nerdtree#postSourceActions() {{{2
    1              0.000001000 function! nerdtree#postSourceActions() abort
                                call g:NERDTreeBookmark.CacheBookmarks(1)
                                call nerdtree#ui_glue#createDefaultBindings()
                            
                                "load all nerdtree plugins
                                runtime! nerdtree_plugin/**/*.vim
                            endfunction
                            
                            "FUNCTION: nerdtree#runningWindows() {{{2
    1              0.000001000 function! nerdtree#runningWindows() abort
                                return has('win16') || has('win32') || has('win64')
                            endfunction
                            
                            "FUNCTION: nerdtree#runningCygwin() {{{2
    1              0.000000000 function! nerdtree#runningCygwin() abort
                                return has('win32unix')
                            endfunction
                            
                            "FUNCTION: nerdtree#runningMac() {{{2
    1              0.000001000 function! nerdtree#runningMac() abort
                                return has('gui_mac') || has('gui_macvim') || has('mac') || has('osx')
                            endfunction
                            
                            " FUNCTION: nerdtree#osDefaultCaseSensitiveFS() {{{2
    1              0.000000000 function! nerdtree#osDefaultCaseSensitiveFS() abort
                                return s:osDefaultCaseSensitiveFS
                            endfunction
                            
                            " FUNCTION: nerdtree#caseSensitiveFS() {{{2
    1              0.000000000 function! nerdtree#caseSensitiveFS() abort
                                return g:NERDTreeCaseSensitiveFS == 1 ||
                                            \((g:NERDTreeCaseSensitiveFS == 2 || g:NERDTreeCaseSensitiveFS == 3) &&
                                            \nerdtree#osDefaultCaseSensitiveFS())
                            endfunction
                            
                            "FUNCTION: nerdtree#pathEquals(lhs, rhs) {{{2
    1              0.000001000 function! nerdtree#pathEquals(lhs, rhs) abort
                                if nerdtree#caseSensitiveFS()
                                    return a:lhs ==# a:rhs
                                else
                                    return a:lhs ==? a:rhs
                                endif
                            endfunction
                            
                            "FUNCTION: nerdtree#onBufLeave() {{{2
                            " used for handling the nerdtree BufLeave/WinLeave events.
    1              0.000001000 function! nerdtree#onBufLeave() abort
                                " detect whether we are in the middle of sourcing a session.
                                " if it is a buffer from the sourced session we need to restore it.
                                if exists('g:SessionLoad') && !exists('b:NERDTree')
                                    let bname = bufname('%')
                                    " is the buffer for a tab tree?
                                    if bname =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'tab_\d\+$'
                                        " rename loaded buffer and mark it as trash to prevent this event
                                        " getting fired again
                                        exec 'file TRASH_' . bname
                                        " delete the trash buffer
                                        exec 'bwipeout!'
                                        " rescue the tab tree at the current working directory
                                        call g:NERDTreeCreator.CreateTabTree(getcwd())
                                    " is the buffer for a window tree?
                                    elseif bname =~# '^' . g:NERDTreeCreator.BufNamePrefix(). 'win_\d\+$'
                                        " rescue the window tree at the current working directory
                                        call g:NERDTreeCreator.CreateWindowTree(getcwd())
                                    else " unknown buffer type
                                        " rename buffer to mark it as broken.
                                        exec 'file BROKEN_' . bname
                                        call nerdtree#echoError('Failed to restore "' . bname . '" from session. Is this session created with an older version of NERDTree?')
                                    endif
                                else
                                    if g:NERDTree.IsOpen()
                                        call b:NERDTree.ui.saveScreenState()
                                    endif
                                endif
                            endfunction
                            
                            " SECTION: View Functions {{{1
                            "============================================================
                            
                            "FUNCTION: nerdtree#echo  {{{2
                            "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
                            "
                            "Args:
                            "msg: the message to echo
    1              0.000001000 function! nerdtree#echo(msg) abort
                                redraw
                                echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)
                            endfunction
                            
                            "FUNCTION: nerdtree#echoError {{{2
                            "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
                            "Args:
                            "msg: the message to echo
    1              0.000000000 function! nerdtree#echoError(msg) abort
                                echohl errormsg
                                call nerdtree#echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: nerdtree#echoWarning {{{2
                            "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
                            "Args:
                            "msg: the message to echo
    1              0.000001000 function! nerdtree#echoWarning(msg) abort
                                echohl warningmsg
                                call nerdtree#echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: nerdtree#renderView {{{2
    1              0.000000000 function! nerdtree#renderView() abort
                                call b:NERDTree.render()
                            endfunction
                            
    1   0.000007000   0.000003000 if nerdtree#runningWindows()
                                let s:osDefaultCaseSensitiveFS = 0
    1   0.000006000   0.000004000 elseif nerdtree#runningMac()
    1              0.000001000     let s:osDefaultCaseSensitiveFS = 0
                            else
                                let s:osDefaultCaseSensitiveFS = 1
    1              0.000000000 endif
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/path.vim
Sourced 1 time
Total time:   0.000261000
 Self time:   0.000261000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: Path
                            "
                            " The Path class provides an abstracted representation of a file system
                            " pathname.  Various operations on pathnames are provided and a number of
                            " representations of a given path name can be accessed here.
                            " ============================================================================
                            
                            
    1              0.000001000 let s:Path = {}
    1              0.000001000 let g:NERDTreePath = s:Path
                            
                            " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
    1              0.000001000 function! s:Path.AbsolutePathFor(pathStr)
                                let l:prependWorkingDir = 0
                            
                                if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
                                else
                                    let l:prependWorkingDir = a:pathStr !~# '^/'
                                endif
                            
                                let l:result = a:pathStr
                            
                                if l:prependWorkingDir
                                    let l:result = getcwd()
                            
                                    if l:result[-1:] == nerdtree#slash()
                                        let l:result = l:result . a:pathStr
                                    else
                                        let l:result = l:result . nerdtree#slash() . a:pathStr
                                    endif
                                endif
                            
                                return l:result
                            endfunction
                            
                            " FUNCTION: Path.bookmarkNames() {{{1
    1              0.000001000 function! s:Path.bookmarkNames()
                                if !exists('self._bookmarkNames')
                                    call self.cacheDisplayString()
                                endif
                                return self._bookmarkNames
                            endfunction
                            
                            " FUNCTION: Path.cacheDisplayString() {{{1
    1              0.000000000 function! s:Path.cacheDisplayString() abort
                                let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
                                if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
                                endif
                            
                                let self._bookmarkNames = []
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
                                if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
                                if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
                                endif
                            
                                if !self.isDirectory && b:NERDTree.ui.getShowFileLines() != 0
                                    let l:bufname = self.str({'format': 'Edit'})
                                    let l:lines = 0
                                    if executable('wc') 
                                        let l:lines = split(system('wc -l "'.l:bufname.'"'))[0]
                                    elseif nerdtree#runningWindows()
                                        let l:lines = substitute(system('type "'.l:bufname.'" | find /c /v ""'), '\n', '', 'g')
                                    else 
                                        let s:lines = readfile(l:bufname)
                                        let l:lines = 0
                                        for s:line in s:lines
                                            let l:lines += 1
                                            if l:lines >= 20000 
                                                break
                                            endif
                                        endfor
                                    endif
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ('.l:lines.')'
                                endif
                                if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif
                            endfunction
                            
                            " FUNCTION: Path.addDelimiter() {{{1
    1              0.000001000 function! s:Path.addDelimiter(line)
                                if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
                                    return a:line
                                else
                                    return a:line . g:NERDTreeNodeDelimiter
                                endif
                            endfunction
                            
                            " FUNCTION: Path.changeToDir() {{{1
    1              0.000001000 function! s:Path.changeToDir()
                                let dir = self.str({'format': 'Cd'})
                                if self.isDirectory ==# 0
                                    let dir = self.getParent().str({'format': 'Cd'})
                                endif
                            
                                try
                                    if g:NERDTreeUseTCD && exists(':tcd') ==# 2
                                        execute 'tcd ' . dir
                                        call nerdtree#echo("Tab's CWD is now: " . getcwd())
                                    else
                                        execute 'cd ' . dir
                                        call nerdtree#echo('CWD is now: ' . getcwd())
                                    endif
                                catch
                                    throw 'NERDTree.PathChangeError: cannot change CWD to ' . dir
                                endtry
                            endfunction
                            
                            " FUNCTION: Path.Create(fullpath) {{{1
                            "
                            " Factory method.
                            "
                            " Creates a path object with the given path. The path is also created on the
                            " filesystem. If the path already exists, a NERDTree.Path.Exists exception is
                            " thrown. If any other errors occur, a NERDTree.Path exception is thrown.
                            "
                            " Args:
                            " fullpath: the full filesystem path to the file/dir to create
    1              0.000001000 function! s:Path.Create(fullpath)
                                "bail if the a:fullpath already exists
                                if isdirectory(a:fullpath) || filereadable(a:fullpath)
                                    throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
                                endif
                            
                                try
                            
                                    "if it ends with a slash, assume its a dir create it
                                    if a:fullpath =~# '\(\\\|\/\)$'
                                        "whack the trailing slash off the end if it exists
                                        let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')
                            
                                        call mkdir(fullpath, 'p')
                            
                                    "assume its a file and create
                                    else
                                        call s:Path.createParentDirectories(a:fullpath)
                                        call writefile([], a:fullpath)
                                    endif
                                catch
                                    throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
                                endtry
                            
                                return s:Path.New(a:fullpath)
                            endfunction
                            
                            " FUNCTION: Path.copy(dest) {{{1
                            "
                            " Copies the file/dir represented by this Path to the given location
                            "
                            " Args:
                            " dest: the location to copy this dir/file to
    1              0.000001000 function! s:Path.copy(dest)
                                if !s:Path.CopyingSupported()
                                    throw 'NERDTree.CopyingNotSupportedError: Copying is not supported on this OS'
                                endif
                            
                                call s:Path.createParentDirectories(a:dest)
                            
                                if exists('g:NERDTreeCopyCmd')
                                    let cmd_prefix = g:NERDTreeCopyCmd
                                else
                                    let cmd_prefix = (self.isDirectory ? g:NERDTreeCopyDirCmd : g:NERDTreeCopyFileCmd)
                                endif
                            
                                let cmd = cmd_prefix . ' ' . shellescape(self.str()) . ' ' . shellescape(a:dest)
                                let success = system(cmd)
                                if v:shell_error !=# 0
                                    throw "NERDTree.CopyError: Could not copy '". self.str() ."' to: '" . a:dest . "'"
                                endif
                            endfunction
                            
                            " FUNCTION: Path.CopyingSupported() {{{1
                            "
                            " returns 1 if copying is supported for this OS
    1              0.000000000 function! s:Path.CopyingSupported()
                                return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
                            endfunction
                            
                            " FUNCTION: Path.copyingWillOverwrite(dest) {{{1
                            "
                            " returns 1 if copy this path to the given location will cause files to
                            " overwritten
                            "
                            " Args:
                            " dest: the location this path will be copied to
    1              0.000000000 function! s:Path.copyingWillOverwrite(dest)
                                if filereadable(a:dest)
                                    return 1
                                endif
                            
                                if isdirectory(a:dest)
                                    let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
                                    if filereadable(path)
                                        return 1
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Path.createParentDirectories(path) {{{1
                            "
                            " create parent directories for this path if needed
                            " without throwing any errors if those directories already exist
                            "
                            " Args:
                            " path: full path of the node whose parent directories may need to be created
    1              0.000001000 function! s:Path.createParentDirectories(path)
                                let dir_path = fnamemodify(a:path, ':h')
                                if !isdirectory(dir_path)
                                    call mkdir(dir_path, 'p')
                                endif
                            endfunction
                            
                            " FUNCTION: Path.delete() {{{1
                            "
                            " Deletes the file or directory represented by this path.
                            "
                            " Throws NERDTree.Path.Deletion exceptions
    1              0.000001000 function! s:Path.delete()
                                if self.isDirectory
                            
                                    let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
                                    let success = system(cmd)
                            
                                    if v:shell_error !=# 0
                                        throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
                                    endif
                                else
                                    if exists('g:NERDTreeRemoveFileCmd')
                                        let cmd = g:NERDTreeRemoveFileCmd . self.str({'escape': 1})
                                        let success = system(cmd)
                                    else
                                        let success = delete(self.str())
                                    endif
                            
                                    if success !=# 0
                                        throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
                                    endif
                                endif
                            
                                "delete all bookmarks for this path
                                for i in self.bookmarkNames()
                                    let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
                                    call bookmark.delete()
                                endfor
                            endfunction
                            
                            " FUNCTION: Path.displayString() {{{1
                            "
                            " Returns a string that specifies how the path should be represented as a
                            " string
    1              0.000001000 function! s:Path.displayString()
                                if self.cachedDisplayString ==# ''
                                    call self.cacheDisplayString()
                                endif
                            
                                return self.cachedDisplayString
                            endfunction
                            
                            " FUNCTION: Path.edit() {{{1
    1              0.000000000 function! s:Path.edit()
                                let l:bufname = self.str({'format': 'Edit'})
                                if bufname('%') !=# l:bufname
                                    exec 'edit ' . l:bufname
                                endif
                            endfunction
                            
                            " FUNCTION: Path.extractDriveLetter(fullpath) {{{1
                            "
                            " If running windows, cache the drive letter for this path
    1              0.000000000 function! s:Path.extractDriveLetter(fullpath)
                                if nerdtree#runningWindows()
                                    if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', 'g')
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
                                    let self.drive = ''
                                endif
                            
                            endfunction
                            
                            " FUNCTION: Path.exists() {{{1
                            " return 1 if this path points to a location that is readable or is a directory
    1              0.000000000 function! s:Path.exists()
                                let p = self.str()
                                return filereadable(p) || isdirectory(p)
                            endfunction
                            
                            " FUNCTION: Path._escChars() {{{1
    1              0.000000000 function! s:Path._escChars()
                                if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
                                endif
                            
                                return " \\`\|\"#%&,?()\*^<>[]{}$"
                            endfunction
                            
                            " FUNCTION: Path.getDir() {{{1
                            "
                            " Returns this path if it is a directory, else this paths parent.
                            "
                            " Return:
                            " a Path object
    1              0.000001000 function! s:Path.getDir()
                                if self.isDirectory
                                    return self
                                else
                                    return self.getParent()
                                endif
                            endfunction
                            
                            " FUNCTION: Path.getParent() {{{1
                            "
                            " Returns a new path object for this paths parent
                            "
                            " Return:
                            " a new Path object
    1              0.000000000 function! s:Path.getParent()
                                if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
                                else
                                    let path = '/'. join(self.pathSegments[0:-2], '/')
                                endif
                            
                                return s:Path.New(path)
                            endfunction
                            
                            " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
                            "
                            " Gets the last part of this path.
                            "
                            " Args:
                            " dirSlash: if 1 then a trailing slash will be added to the returned value for
                            " directory nodes.
    1              0.000001000 function! s:Path.getLastPathComponent(dirSlash)
                                if empty(self.pathSegments)
                                    return ''
                                endif
                                let toReturn = self.pathSegments[-1]
                                if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path.getSortOrderIndex() {{{1
                            " returns the index of the pattern in g:NERDTreeSortOrder that this path matches
    1              0.000000000 function! s:Path.getSortOrderIndex()
                                let i = 0
                                while i < len(g:NERDTreeSortOrder)
                                    if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' &&
                                    \ self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
                                        return i
                                    endif
                                    let i = i + 1
                                endwhile
                            
                                return index(g:NERDTreeSortOrder, '*')
                            endfunction
                            
                            " FUNCTION: Path._splitChunks(path) {{{1
                            " returns a list of path chunks
    1              0.000000000 function! s:Path._splitChunks(path)
                                let chunks = split(a:path, '\(\D\+\|\d\+\)\zs')
                                let i = 0
                                while i < len(chunks)
                                    "convert number literals to numbers
                                    if match(chunks[i], '^\d\+$') ==# 0
                                        let chunks[i] = str2nr(chunks[i])
                                    endif
                                    let i = i + 1
                                endwhile
                                return chunks
                            endfunction
                            
                            " FUNCTION: Path.getSortKey() {{{1
                            " returns a key used in compare function for sorting
    1              0.000001000 function! s:Path.getSortKey()
                                if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                    " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
                                    let metadata = []
                                    for tag in g:NERDTreeSortOrder
                                        if tag =~? '\[\[-\?timestamp\]\]'
                                            let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
                                        elseif tag =~? '\[\[-\?size\]\]'
                                            let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
                                        elseif tag =~? '\[\[extension\]\]'
                                            let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
                                            let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
                                        endif
                                    endfor
                            
                                    if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
                                        " Apply tags' sorting first if specified first.
                                        let self._sortKey = metadata + [self.getSortOrderIndex()]
                                    else
                                        " Otherwise, do regex grouping first.
                                        let self._sortKey = [self.getSortOrderIndex()] + metadata
                                    endif
                            
                                    let path = self.getLastPathComponent(0)
                                    if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
                                    if !g:NERDTreeCaseSensitiveSort
                                        let path = tolower(path)
                                    endif
                            
                                    call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
                                endif
                                return self._sortKey
                            endfunction
                            
                            " FUNCTION: Path.isHiddenUnder(path) {{{1
    1              0.000001000 function! s:Path.isHiddenUnder(path)
                            
                                if !self.isUnder(a:path)
                                    return 0
                                endif
                            
                                let l:startIndex = len(a:path.pathSegments)
                                let l:segments = self.pathSegments[l:startIndex : ]
                            
                                for l:segment in l:segments
                            
                                    if l:segment =~# '^\.'
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: Path.isUnixHiddenFile() {{{1
                            " check for unix hidden files
    1              0.000001000 function! s:Path.isUnixHiddenFile()
                                return self.getLastPathComponent(0) =~# '^\.'
                            endfunction
                            
                            " FUNCTION: Path.isUnixHiddenPath() {{{1
                            " check for unix path with hidden components
    1              0.000001000 function! s:Path.isUnixHiddenPath()
                                if self.getLastPathComponent(0) =~# '^\.'
                                    return 1
                                else
                                    for segment in self.pathSegments
                                        if segment =~# '^\.'
                                            return 1
                                        endif
                                    endfor
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: Path.ignore(nerdtree) {{{1
                            " returns true if this path should be ignored
    1              0.000000000 function! s:Path.ignore(nerdtree)
                                "filter out the user specified paths to ignore
                                if a:nerdtree.ui.isIgnoreFilterEnabled()
                                    for i in g:NERDTreeIgnore
                                        if self._ignorePatternMatches(i)
                                            return 1
                                        endif
                                    endfor
                            
                                    for l:Callback in g:NERDTree.PathFilters()
                                        let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                        if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                           return 1
                                        endif
                                    endfor
                                endif
                            
                                "dont show hidden files unless instructed to
                                if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
                                if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: Path._ignorePatternMatches(pattern) {{{1
                            " returns true if this path matches the given ignore pattern
    1              0.000000000 function! s:Path._ignorePatternMatches(pattern)
                                let pat = a:pattern
                                if strpart(pat,len(pat)-8) ==# '[[path]]'
                                    let pat = strpart(pat,0, len(pat)-8)
                                    return self.str() =~# pat
                                elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
                                return self.getLastPathComponent(0) =~# pat
                            endfunction
                            
                            " FUNCTION: Path.isAncestor(path) {{{1
                            " return 1 if this path is somewhere above the given path in the filesystem.
                            "
                            " a:path should be a dir
    1              0.000001000 function! s:Path.isAncestor(child)
                                return a:child.isUnder(self)
                            endfunction
                            
                            " FUNCTION: Path.isUnder(path) {{{1
                            " return 1 if this path is somewhere under the given path in the filesystem.
    1              0.000001000 function! s:Path.isUnder(parent)
                                if a:parent.isDirectory ==# 0
                                    return 0
                                endif
                                if nerdtree#runningWindows() && a:parent.drive !=# self.drive
                                    return 0
                                endif
                                let l:this_count = len(self.pathSegments)
                                if l:this_count ==# 0
                                    return 0
                                endif
                                let l:that_count = len(a:parent.pathSegments)
                                if l:that_count ==# 0
                                    return 1
                                endif
                                if l:that_count >= l:this_count
                                    return 0
                                endif
                                for i in range(0, l:that_count-1)
                                    if !nerdtree#pathEquals(self.pathSegments[i], a:parent.pathSegments[i])
                                        return 0
                                    endif
                                endfor
                                return 1
                            endfunction
                            
                            " FUNCTION: Path.JoinPathStrings(...) {{{1
    1              0.000001000 function! s:Path.JoinPathStrings(...)
                                let components = []
                                for i in a:000
                                    let components = extend(components, split(i, '/'))
                                endfor
                                return '/' . join(components, '/')
                            endfunction
                            
                            " FUNCTION: Path.equals() {{{1
                            "
                            " Determines whether 2 path objects are "equal".
                            " They are equal if the paths they represent are the same
                            "
                            " Args:
                            " path: the other path obj to compare this with
    1              0.000000000 function! s:Path.equals(path)
                                return nerdtree#pathEquals(self.str(), a:path.str())
                            endfunction
                            
                            " FUNCTION: Path.New(pathStr) {{{1
    1              0.000001000 function! s:Path.New(pathStr)
                                let l:newPath = copy(self)
                            
                                call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
                                let l:newPath.cachedDisplayString = ''
                                let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
                                return l:newPath
                            endfunction
                            
                            " FUNCTION: Path.Resolve() {{{1
                            " Invoke the vim resolve() function and return the result
                            " This is necessary because in some versions of vim resolve() removes trailing
                            " slashes while in other versions it doesn't.  This always removes the trailing
                            " slash
    1              0.000000000 function! s:Path.Resolve(path)
                                let tmp = resolve(a:path)
                                return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
                            endfunction
                            
                            " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
                            "
                            "
                            " Throws NERDTree.Path.InvalidArguments exception.
    1              0.000001000 function! s:Path.readInfoFromDisk(fullpath)
                                call self.extractDriveLetter(a:fullpath)
                            
                                let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
                                if getftype(fullpath) ==# 'fifo'
                                    throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
                                endif
                            
                                let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
                                let self.isReadOnly = 0
                                if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
                                    let self.isDirectory = 0
                                    let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
                                endif
                            
                                let self.isExecutable = 0
                                if !self.isDirectory
                                    let self.isExecutable = getfperm(a:fullpath) =~# 'x'
                                endif
                            
                                "grab the last part of the path (minus the trailing slash)
                                let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
                                let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
                                let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
                                if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Path.refresh(nerdtree) {{{1
    1              0.000001000 function! s:Path.refresh(nerdtree)
                                call self.readInfoFromDisk(self.str())
                                call g:NERDTreePathNotifier.NotifyListeners('refresh', self, a:nerdtree, {})
                                call self.cacheDisplayString()
                            endfunction
                            
                            " FUNCTION: Path.refreshFlags(nerdtree) {{{1
    1              0.000000000 function! s:Path.refreshFlags(nerdtree)
                                call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
                                call self.cacheDisplayString()
                            endfunction
                            
                            " FUNCTION: Path.rename() {{{1
                            "
                            " Renames this node on the filesystem
    1              0.000000000 function! s:Path.rename(newPath)
                                if a:newPath ==# ''
                                    throw 'NERDTree.InvalidArgumentsError: Invalid newPath for renaming = '. a:newPath
                                endif
                            
                                call s:Path.createParentDirectories(a:newPath)
                            
                                let success =  rename(self.str(), a:newPath)
                                if success !=# 0
                                    throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
                                endif
                                call self.readInfoFromDisk(a:newPath)
                            
                                for i in self.bookmarkNames()
                                    let b = g:NERDTreeBookmark.BookmarkFor(i)
                                    call b.setPath(copy(self))
                                endfor
                                call g:NERDTreeBookmark.Write()
                            endfunction
                            
                            " FUNCTION: Path.str() {{{1
                            " Return a string representation of this Path object.
                            "
                            " Args:
                            " This function takes a single dictionary (optional) with keys and values that
                            " specify how the returned pathname should be formatted.
                            "
                            " The dictionary may have the following keys:
                            "  'format'
                            "  'escape'
                            "  'truncateTo'
                            "
                            " The 'format' key may have a value of:
                            "  'Cd' - a string to be used with ":cd" and similar commands
                            "  'Edit' - a string to be used with ":edit" and similar commands
                            "  'UI' - a string to be displayed in the NERDTree user interface
                            "
                            " The 'escape' key, if specified, will cause the output to be escaped with
                            " Vim's internal "shellescape()" function.
                            "
                            " The 'truncateTo' key shortens the length of the path to that given by the
                            " value associated with 'truncateTo'. A '<' is prepended.
    1              0.000001000 function! s:Path.str(...)
                                let options = a:0 ? a:1 : {}
                                let toReturn = ''
                            
                                if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
                                else
                                    let toReturn = self._str()
                                endif
                            
                                if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
                                if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path._strForUI() {{{1
    1              0.000000000 function! s:Path._strForUI()
                                let toReturn = '/' . join(self.pathSegments, '/')
                                if self.isDirectory && toReturn !=# '/'
                                    let toReturn  = toReturn . '/'
                                endif
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path._strForCd() {{{1
                            " Return a string representation of this Path that is suitable for use as an
                            " argument to Vim's internal ":cd" command.
    1              0.000000000 function! s:Path._strForCd()
                                return fnameescape(self.str())
                            endfunction
                            
                            " FUNCTION: Path._strForEdit() {{{1
                            " Return a string representation of this Path that is suitable for use as an
                            " argument to Vim's internal ":edit" command.
    1              0.000000000 function! s:Path._strForEdit()
                            
                                " Make the path relative to the current working directory, if possible.
                                let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
                                if nerdtree#runningWindows() && l:result[0] == nerdtree#slash()
                                    let l:result = self.drive . l:result
                                endif
                            
                                let l:result = fnameescape(l:result)
                            
                                if empty(l:result)
                                    let l:result = '.'
                                endif
                            
                                return l:result
                            endfunction
                            
                            " FUNCTION: Path._strForGlob() {{{1
    1              0.000001000 function! s:Path._strForGlob()
                                let lead = nerdtree#slash()
                            
                                "if we are running windows then slap a drive letter on the front
                                if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
                                let toReturn = lead . join(self.pathSegments, nerdtree#slash())
                            
                                if !nerdtree#runningWindows()
                                    let toReturn = escape(toReturn, self._escChars())
                                endif
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path._str() {{{1
                            " Return the absolute pathname associated with this Path object.  The pathname
                            " returned is appropriate for the underlying file system.
    1              0.000000000 function! s:Path._str()
                                let l:separator = nerdtree#slash()
                                let l:leader = l:separator
                            
                                if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
                                return l:leader . join(self.pathSegments, l:separator)
                            endfunction
                            
                            " FUNCTION: Path.strTrunk() {{{1
                            " Gets the path without the last segment on the end.
    1              0.000001000 function! s:Path.strTrunk()
                                return self.drive . '/' . join(self.pathSegments[0:-2], '/')
                            endfunction
                            
                            " FUNCTION: Path.tabnr() {{{1
                            " return the number of the first tab that is displaying this file
                            "
                            " return 0 if no tab was found
    1              0.000001000 function! s:Path.tabnr()
                                let str = self.str()
                                for t in range(tabpagenr('$'))
                                    for b in tabpagebuflist(t+1)
                                        if str ==# expand('#' . b . ':p')
                                            return t+1
                                        endif
                                    endfor
                                endfor
                                return 0
                            endfunction
                            
                            " FUNCTION: Path.WinToUnixPath(pathstr){{{1
                            " Takes in a windows path and returns the unix equiv
                            "
                            " A class level method
                            "
                            " Args:
                            " pathstr: the windows path to convert
    1              0.000001000 function! s:Path.WinToUnixPath(pathstr)
                                if !nerdtree#runningWindows()
                                    return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', 'g')
                            
                                return toReturn
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim
Sourced 1 time
Total time:   0.000064000
 Self time:   0.000064000

count     total (s)      self (s)
                            "CLASS: MenuController
                            "============================================================
    1              0.000001000 let s:MenuController = {}
    1              0.000001000 let g:NERDTreeMenuController = s:MenuController
                            
                            "FUNCTION: MenuController.New(menuItems) {{{1
                            "create a new menu controller that operates on the given menu items
    1              0.000001000 function! s:MenuController.New(menuItems)
                                let newMenuController =  copy(self)
                                if a:menuItems[0].isSeparator()
                                    let newMenuController.menuItems = a:menuItems[1:-1]
                                else
                                    let newMenuController.menuItems = a:menuItems
                                endif
                                return newMenuController
                            endfunction
                            
                            " FUNCTION: s:MenuController.isMinimal() {{{1
    1              0.000001000 function! s:MenuController.isMinimal()
                                return g:NERDTreeMinimalMenu
                            endfunction
                            
                            " FUNCTION: MenuController.showMenu() {{{1
                            " Enter the main loop of the NERDTree menu, prompting the user to select
                            " a menu item.
    1              0.000001000 function! s:MenuController.showMenu()
                                call self._saveOptions()
                            
                                try
                                    let self.selection = 0
                                    let l:done = 0
                            
                                    while !l:done
                                        if has('nvim')
                                            mode
                                        else
                                            redraw!
                                        endif
                                        call self._echoPrompt()
                            
                                        let l:key = nr2char(getchar())
                                        let l:done = self._handleKeypress(l:key)
                                    endwhile
                                finally
                                    call self._restoreOptions()
                            
                                    " Redraw when Ctrl-C or Esc is received.
                                    if !l:done || self.selection ==# -1
                                        redraw!
                                    endif
                                endtry
                            
                                if self.selection !=# -1
                                    let l:m = self._current()
                                    call l:m.execute()
                                endif
                            endfunction
                            
                            "FUNCTION: MenuController._echoPrompt() {{{1
    1              0.000001000 function! s:MenuController._echoPrompt()
                                let navHelp = 'Use ' . g:NERDTreeMenuDown . '/' . g:NERDTreeMenuUp . '/enter'
                            
                                if self.isMinimal()
                                    let selection = self.menuItems[self.selection].text
                                    let keyword = matchstr(selection, '[^ ]*([^ ]*')
                            
                                    let shortcuts = map(copy(self.menuItems), "v:val['shortcut']")
                                    let shortcuts[self.selection] = ' ' . keyword . ' '
                            
                                    echo 'Menu: [' . join(shortcuts, ',') . '] (' . navHelp . ' or shortcut): '
                                else
                                    echo 'NERDTree Menu. ' . navHelp . ', or the shortcuts indicated'
                                    echo '========================================================='
                            
                                    for i in range(0, len(self.menuItems)-1)
                                        if self.selection ==# i
                                            echo '> ' . self.menuItems[i].text
                                        else
                                            echo '  ' . self.menuItems[i].text
                                        endif
                                    endfor
                                endif
                            endfunction
                            
                            "FUNCTION: MenuController._current(key) {{{1
                            "get the MenuItem that is currently selected
    1              0.000001000 function! s:MenuController._current()
                                return self.menuItems[self.selection]
                            endfunction
                            
                            "FUNCTION: MenuController._handleKeypress(key) {{{1
                            "change the selection (if appropriate) and return 1 if the user has made
                            "their choice, 0 otherwise
    1              0.000000000 function! s:MenuController._handleKeypress(key)
                                if a:key ==# g:NERDTreeMenuDown
                                    call self._cursorDown()
                                elseif a:key ==# g:NERDTreeMenuUp
                                    call self._cursorUp()
                                elseif a:key ==# nr2char(27) "escape
                                    let self.selection = -1
                                    return 1
                                elseif a:key ==# "\r" || a:key ==# "\n" "enter and ctrl-j
                                    return 1
                                else
                                    let index = self._nextIndexFor(a:key)
                                    if index !=# -1
                                        let self.selection = index
                                        if len(self._allIndexesFor(a:key)) ==# 1
                                            return 1
                                        endif
                                    endif
                                endif
                            
                                return 0
                            endfunction
                            
                            "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
                            "get indexes to all menu items with the given shortcut
    1              0.000001000 function! s:MenuController._allIndexesFor(shortcut)
                                let toReturn = []
                            
                                for i in range(0, len(self.menuItems)-1)
                                    if self.menuItems[i].shortcut ==# a:shortcut
                                        call add(toReturn, i)
                                    endif
                                endfor
                            
                                return toReturn
                            endfunction
                            
                            "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
                            "get the index to the next menu item with the given shortcut, starts from the
                            "current cursor location and wraps around to the top again if need be
    1              0.000001000 function! s:MenuController._nextIndexFor(shortcut)
                                for i in range(self.selection+1, len(self.menuItems)-1)
                                    if self.menuItems[i].shortcut ==# a:shortcut
                                        return i
                                    endif
                                endfor
                            
                                for i in range(0, self.selection)
                                    if self.menuItems[i].shortcut ==# a:shortcut
                                        return i
                                    endif
                                endfor
                            
                                return -1
                            endfunction
                            
                            "FUNCTION: MenuController._setCmdheight() {{{1
                            "sets &cmdheight to whatever is needed to display the menu
    1              0.000000000 function! s:MenuController._setCmdheight()
                                if self.isMinimal()
                                    let &cmdheight = 1
                                else
                                    let &cmdheight = len(self.menuItems) + 3
                                endif
                            endfunction
                            
                            "FUNCTION: MenuController._saveOptions() {{{1
                            "set any vim options that are required to make the menu work (saving their old
                            "values)
    1              0.000000000 function! s:MenuController._saveOptions()
                                let self._oldLazyredraw = &lazyredraw
                                let self._oldCmdheight = &cmdheight
                                set nolazyredraw
                                call self._setCmdheight()
                            endfunction
                            
                            "FUNCTION: MenuController._restoreOptions() {{{1
                            "restore the options we saved in _saveOptions()
    1              0.000001000 function! s:MenuController._restoreOptions()
                                let &cmdheight = self._oldCmdheight
                                let &lazyredraw = self._oldLazyredraw
                            endfunction
                            
                            "FUNCTION: MenuController._cursorDown() {{{1
                            "move the cursor to the next menu item, skipping separators
    1              0.000000000 function! s:MenuController._cursorDown()
                                let done = 0
                                while !done
                                    if self.selection < len(self.menuItems)-1
                                        let self.selection += 1
                                    else
                                        let self.selection = 0
                                    endif
                            
                                    if !self._current().isSeparator()
                                        let done = 1
                                    endif
                                endwhile
                            endfunction
                            
                            "FUNCTION: MenuController._cursorUp() {{{1
                            "move the cursor to the previous menu item, skipping separators
    1              0.000001000 function! s:MenuController._cursorUp()
                                let done = 0
                                while !done
                                    if self.selection > 0
                                        let self.selection -= 1
                                    else
                                        let self.selection = len(self.menuItems)-1
                                    endif
                            
                                    if !self._current().isSeparator()
                                        let done = 1
                                    endif
                                endwhile
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim
Sourced 1 time
Total time:   0.000042000
 Self time:   0.000042000

count     total (s)      self (s)
                            "CLASS: MenuItem
                            "============================================================
    1              0.000002000 let s:MenuItem = {}
    1              0.000001000 let g:NERDTreeMenuItem = s:MenuItem
                            
                            "FUNCTION: MenuItem.All() {{{1
                            "get all top level menu items
    1              0.000001000 function! s:MenuItem.All()
                                if !exists('s:menuItems')
                                    let s:menuItems = []
                                endif
                                return s:menuItems
                            endfunction
                            
                            "FUNCTION: MenuItem.AllEnabled() {{{1
                            "get all top level menu items that are currently enabled
    1              0.000001000 function! s:MenuItem.AllEnabled()
                                let toReturn = []
                                for i in s:MenuItem.All()
                                    if i.enabled()
                                        call add(toReturn, i)
                                    endif
                                endfor
                                return toReturn
                            endfunction
                            
                            "FUNCTION: MenuItem.Create(options) {{{1
                            "make a new menu item and add it to the global list
    1              0.000001000 function! s:MenuItem.Create(options)
                                let newMenuItem = copy(self)
                            
                                let newMenuItem.text = a:options['text']
                                let newMenuItem.shortcut = a:options['shortcut']
                                let newMenuItem.children = []
                            
                                let newMenuItem.isActiveCallback = -1
                                if has_key(a:options, 'isActiveCallback')
                                    let newMenuItem.isActiveCallback = a:options['isActiveCallback']
                                endif
                            
                                let newMenuItem.callback = -1
                                if has_key(a:options, 'callback')
                                    let newMenuItem.callback = a:options['callback']
                                endif
                            
                                if has_key(a:options, 'parent')
                                    call add(a:options['parent'].children, newMenuItem)
                                else
                                    call add(s:MenuItem.All(), newMenuItem)
                                endif
                            
                                return newMenuItem
                            endfunction
                            
                            "FUNCTION: MenuItem.CreateSeparator(options) {{{1
                            "make a new separator menu item and add it to the global list
    1              0.000000000 function! s:MenuItem.CreateSeparator(options)
                                let standard_options = { 'text': '--------------------',
                                            \ 'shortcut': -1,
                                            \ 'callback': -1 }
                                let options = extend(a:options, standard_options, 'force')
                            
                                return s:MenuItem.Create(options)
                            endfunction
                            
                            "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
                            "make a new submenu and add it to global list
    1              0.000001000 function! s:MenuItem.CreateSubmenu(options)
                                let standard_options = { 'callback': -1 }
                                let options = extend(a:options, standard_options, 'force')
                            
                                return s:MenuItem.Create(options)
                            endfunction
                            
                            "FUNCTION: MenuItem.enabled() {{{1
                            "return 1 if this menu item should be displayed
                            "
                            "delegates off to the isActiveCallback, and defaults to 1 if no callback was
                            "specified
    1              0.000001000 function! s:MenuItem.enabled()
                                if self.isActiveCallback != -1
                                    return type(self.isActiveCallback) == type(function('tr')) ? self.isActiveCallback() : {self.isActiveCallback}()
                                endif
                                return 1
                            endfunction
                            
                            "FUNCTION: MenuItem.execute() {{{1
                            "perform the action behind this menu item, if this menuitem has children then
                            "display a new menu for them, otherwise deletegate off to the menuitem's
                            "callback
    1              0.000001000 function! s:MenuItem.execute()
                                if len(self.children)
                                    let mc = g:NERDTreeMenuController.New(self.children)
                                    call mc.showMenu()
                                else
                                    if self.callback != -1
                                        if type(self.callback) == type(function('tr'))
                                            call self.callback()
                                        else
                                            call {self.callback}()
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: MenuItem.isSeparator() {{{1
                            "return 1 if this menuitem is a separator
    1              0.000001000 function! s:MenuItem.isSeparator()
                                return self.callback == -1 && self.children == []
                            endfunction
                            
                            "FUNCTION: MenuItem.isSubmenu() {{{1
                            "return 1 if this menuitem is a submenu
    1              0.000001000 function! s:MenuItem.isSubmenu()
                                return self.callback == -1 && !empty(self.children)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim
Sourced 1 time
Total time:   0.000050000
 Self time:   0.000050000

count     total (s)      self (s)
                            "CLASS: KeyMap
                            "============================================================
    1              0.000002000 let s:KeyMap = {}
    1              0.000001000 let g:NERDTreeKeyMap = s:KeyMap
    1              0.000000000 let s:keyMaps = {}
                            
                            "FUNCTION: KeyMap.All() {{{1
    1              0.000000000 function! s:KeyMap.All()
                                let sortedKeyMaps = values(s:keyMaps)
                                call sort(sortedKeyMaps, s:KeyMap.Compare, s:KeyMap)
                            
                                return sortedKeyMaps
                            endfunction
                            
                            "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
    1              0.000000000 function! s:KeyMap.Compare(keyMap1, keyMap2)
                            
                                if a:keyMap1.key >? a:keyMap2.key
                                    return 1
                                endif
                            
                                if a:keyMap1.key <? a:keyMap2.key
                                    return -1
                                endif
                            
                                return 0
                            endfunction
                            
                            "FUNCTION: KeyMap.FindFor(key, scope) {{{1
    1              0.000001000 function! s:KeyMap.FindFor(key, scope)
                                return get(s:keyMaps, a:key . a:scope, {})
                            endfunction
                            
                            "FUNCTION: KeyMap.BindAll() {{{1
    1              0.000000000 function! s:KeyMap.BindAll()
                                for i in values(s:keyMaps)
                                    call i.bind()
                                endfor
                            endfunction
                            
                            "FUNCTION: KeyMap.bind() {{{1
    1              0.000000000 function! s:KeyMap.bind()
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
                                let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
                                if self.key =~# specialNotationRegex
                                    let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
                                else
                                    let keymapInvokeString = self.key
                                endif
                                let keymapInvokeString = escape(keymapInvokeString, '\"')
                            
                                let premap = self.key ==# '<LeftRelease>' ? ' <LeftRelease>' : ' '
                            
                                exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
                            endfunction
                            
                            "FUNCTION: KeyMap.Remove(key, scope) {{{1
    1              0.000001000 function! s:KeyMap.Remove(key, scope)
                                return remove(s:keyMaps, a:key . a:scope)
                            endfunction
                            
                            "FUNCTION: KeyMap.invoke() {{{1
                            "Call the KeyMaps callback function
    1              0.000001000 function! s:KeyMap.invoke(...)
                                let l:Callback = type(self.callback) ==# type(function('tr')) ? self.callback : function(self.callback)
                                if a:0
                                    call l:Callback(a:1)
                                else
                                    call l:Callback()
                                endif
                            endfunction
                            
                            "FUNCTION: KeyMap.Invoke() {{{1
                            "Find a keymapping for a:key and the current scope invoke it.
                            "
                            "Scope is determined as follows:
                            "   * if the cursor is on a dir node then DirNode
                            "   * if the cursor is on a file node then FileNode
                            "   * if the cursor is on a bookmark then Bookmark
                            "
                            "If a keymap has the scope of 'all' then it will be called if no other keymap
                            "is found for a:key and the scope.
    1              0.000001000 function! s:KeyMap.Invoke(key)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
                                if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
                                let node = g:NERDTreeFileNode.GetSelected()
                                if !empty(node)
                            
                                    "try file node
                                    if !node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, 'FileNode')
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, 'DirNode')
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, 'Node')
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, 'Bookmark')
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, 'all')
                                if !empty(km)
                                    return km.invoke()
                                endif
                            endfunction
                            
                            "FUNCTION: KeyMap.Create(options) {{{1
    1              0.000001000 function! s:KeyMap.Create(options)
                                let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
                            
                                "dont override other mappings unless the 'override' option is given
                                if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
                                    return
                                end
                            
                                let newKeyMap = copy(self)
                                let newKeyMap.key = opts['key']
                                let newKeyMap.quickhelpText = opts['quickhelpText']
                                let newKeyMap.callback = opts['callback']
                                let newKeyMap.scope = opts['scope']
                            
                                call s:KeyMap.Add(newKeyMap)
                            endfunction
                            
                            "FUNCTION: KeyMap.Add(keymap) {{{1
    1              0.000001000 function! s:KeyMap.Add(keymap)
                                let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim
Sourced 1 time
Total time:   0.000115000
 Self time:   0.000115000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: Bookmark
                            "
                            " The Bookmark class serves two purposes:
                            "   (1) It is the top-level prototype for new, concrete Bookmark objects.
                            "   (2) It provides an interface for client code to query and manipulate the
                            "       global list of Bookmark objects within the current Vim session.
                            " ============================================================================
                            
                            
    1              0.000001000 let s:Bookmark = {}
    1              0.000001000 let g:NERDTreeBookmark = s:Bookmark
                            
                            " FUNCTION: Bookmark.activate(nerdtree) {{{1
    1              0.000000000 function! s:Bookmark.activate(nerdtree, ...)
                                call self.open(a:nerdtree, a:0 ? a:1 : {})
                            endfunction
                            
                            " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
                            " Class method to add a new bookmark to the list, if a previous bookmark exists
                            " with the same name, just update the path for that bookmark
    1              0.000001000 function! s:Bookmark.AddBookmark(name, path)
                                for i in s:Bookmark.Bookmarks()
                                    if i.name ==# a:name
                                        let i.path = a:path
                                        return
                                    endif
                                endfor
                                call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
                            endfunction
                            
                            " FUNCTION: Bookmark.Bookmarks() {{{1
                            " Class method to get all bookmarks. Lazily initializes the bookmarks global
                            " variable
    1              0.000000000 function! s:Bookmark.Bookmarks()
                                if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
                                endif
                                return g:NERDTreeBookmarks
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
                            " class method that returns 1 if a bookmark with the given name is found, 0
                            " otherwise
    1              0.000001000 function! s:Bookmark.BookmarkExistsFor(name)
                                try
                                    call s:Bookmark.BookmarkFor(a:name)
                                    return 1
                                catch /^NERDTree.BookmarkNotFoundError/
                                    return 0
                                endtry
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkFor(name) {{{1
                            " Class method that returns the Bookmark object having the specified name.
                            " Throws NERDTree.BookmarkNotFoundError if no Bookmark is found.
    1              0.000001000 function! s:Bookmark.BookmarkFor(name)
                                let l:result = {}
                                for l:bookmark in s:Bookmark.Bookmarks()
                                    if l:bookmark.name ==# a:name
                                        let l:result = l:bookmark
                                        break
                                    endif
                                endfor
                                if empty(l:result)
                                    throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                endif
                                return l:result
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkNames() {{{1
                            " Class method to return an array of all bookmark names
    1              0.000001000 function! s:Bookmark.BookmarkNames()
                                let names = []
                                for i in s:Bookmark.Bookmarks()
                                    call add(names, i.name)
                                endfor
                                return names
                            endfunction
                            
                            " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
                            " Class method to read all bookmarks from the bookmarks file initialize
                            " bookmark objects for each one.
                            "
                            " Args:
                            " silent - dont echo an error msg if invalid bookmarks are found
    1              0.000000000 function! s:Bookmark.CacheBookmarks(silent)
                                if filereadable(g:NERDTreeBookmarksFile)
                                    let g:NERDTreeBookmarks = []
                                    let g:NERDTreeInvalidBookmarks = []
                                    let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
                                    let invalidBookmarksFound = 0
                                    for i in bookmarkStrings
                            
                                        "ignore blank lines
                                        if i !=# ''
                            
                                            let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                                            let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
                                            let path = fnamemodify(path, ':p')
                            
                                            try
                                                let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                                                call add(g:NERDTreeBookmarks, bookmark)
                                            catch /^NERDTree.InvalidArgumentsError/
                                                call add(g:NERDTreeInvalidBookmarks, i)
                                                let invalidBookmarksFound += 1
                                            endtry
                                        endif
                                    endfor
                                    if invalidBookmarksFound
                                        call s:Bookmark.Write()
                                        if !a:silent
                                            call nerdtree#echo(invalidBookmarksFound . ' invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.')
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
                            " Class method that indicates the relative position of two bookmarks when
                            " placed in alphabetical order by name. Case-sensitivity is determined by an
                            " option. Supports the s:Bookmark.SortBookmarksList() method.
    1              0.000001000 function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
                                let l:result = 0
                                if g:NERDTreeBookmarksSort ==# 1
                                    if a:firstBookmark.name <? a:secondBookmark.name
                                        let l:result = -1
                                    elseif a:firstBookmark.name >? a:secondBookmark.name
                                        let l:result = 1
                                    endif
                                elseif g:NERDTreeBookmarksSort ==# 2
                                    if a:firstBookmark.name <# a:secondBookmark.name
                                        let l:result = -1
                                    elseif a:firstBookmark.name ># a:secondBookmark.name
                                        let l:result = 1
                                    endif
                                endif
                                return l:result
                            endfunction
                            
                            " FUNCTION: Bookmark.ClearAll() {{{1
                            " Class method to delete all bookmarks.
    1              0.000001000 function! s:Bookmark.ClearAll()
                                for i in s:Bookmark.Bookmarks()
                                    call i.delete()
                                endfor
                                call s:Bookmark.Write()
                            endfunction
                            
                            " FUNCTION: Bookmark.delete() {{{1
                            " Delete this bookmark. If the node for this bookmark is under the current
                            " root, then recache bookmarks for its Path object
    1              0.000000000 function! s:Bookmark.delete()
                                call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
                                call s:Bookmark.Write()
                            endfunction
                            
                            " FUNCTION: s:Edit() {{{1
                            " opens the NERDTreeBookmarks file for manual editing
    1              0.000000000 function! s:Bookmark.Edit()
                                call nerdtree#exec('wincmd w', 1)
                                call nerdtree#exec('edit '.g:NERDTreeBookmarksFile, 1)
                            endfunction
                            
                            " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
                            " Returns the tree node object associated with this Bookmark.
                            " Throws NERDTree.BookmarkedNodeNotFoundError if the node is not found.
                            "
                            " Args:
                            " searchFromAbsoluteRoot: boolean flag, search from the highest cached node
                            "   if true and from the current tree root if false
    1              0.000001000 function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
                                if a:searchFromAbsoluteRoot
                                    let l:searchRoot = a:nerdtree.root.AbsoluteTreeRoot()
                                else
                                    let l:searchRoot = a:nerdtree.root
                                endif
                                let l:targetNode = l:searchRoot.findNode(self.path)
                                if empty(l:targetNode)
                                    throw 'NERDTree.BookmarkedNodeNotFoundError: node for bookmark "' . self.name . '" not found'
                                endif
                                return l:targetNode
                            endfunction
                            
                            " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
                            " Class method that returns the tree node object for the Bookmark with the
                            " given name. Throws NERDTree.BookmarkNotFoundError if a Bookmark with the
                            " name does not exist. Throws NERDTree.BookmarkedNodeNotFoundError if a
                            " tree node for the named Bookmark could not be found.
    1              0.000001000 function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
                                let l:bookmark = s:Bookmark.BookmarkFor(a:name)
                                return l:bookmark.getNode(a:nerdtree, a:searchFromAbsoluteRoot)
                            endfunction
                            
                            " FUNCTION: Bookmark.GetSelected() {{{1
                            " returns the Bookmark the cursor is over, or {}
    1              0.000000000 function! s:Bookmark.GetSelected()
                                let line = getline('.')
                                let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
                                if name !=# line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: Bookmark.InvalidBookmarks() {{{1
                            " Class method to get all invalid bookmark strings read from the bookmarks
                            " file
    1              0.000000000 function! s:Bookmark.InvalidBookmarks()
                                if !exists('g:NERDTreeInvalidBookmarks')
                                    let g:NERDTreeInvalidBookmarks = []
                                endif
                                return g:NERDTreeInvalidBookmarks
                            endfunction
                            
                            " FUNCTION: Bookmark.mustExist() {{{1
    1              0.000001000 function! s:Bookmark.mustExist()
                                if !self.path.exists()
                                    call s:Bookmark.CacheBookmarks(1)
                                    throw 'NERDTree.BookmarkPointsToInvalidLocationError: the bookmark "'.
                                        \ self.name .'" points to a non existing location: "'. self.path.str()
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.New(name, path) {{{1
                            " Create a new bookmark object with the given name and path object
    1              0.000001000 function! s:Bookmark.New(name, path)
                                if a:name =~# ' '
                                    throw 'NERDTree.IllegalBookmarkNameError: illegal name:' . a:name
                                endif
                            
                                let newBookmark = copy(self)
                                let newBookmark.name = a:name
                                let newBookmark.path = a:path
                                return newBookmark
                            endfunction
                            
                            " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
                            "Args:
                            "
                            "nerdtree: the tree to load open the bookmark in
                            "
                            "A dictionary containing the following keys (all optional):
                            "  'where': Specifies whether the node should be opened in new split/tab or in
                            "           the previous window. Can be either 'v' (vertical split), 'h'
                            "           (horizontal split), 't' (new tab) or 'p' (previous window).
                            "  'reuse': if a window is displaying the file then jump the cursor there
                            "  'keepopen': dont close the tree window
                            "  'stay': open the file, but keep the cursor in the tree win
                            "
    1              0.000001000 function! s:Bookmark.open(nerdtree, ...)
                                let opts = a:0 ? a:1 : {}
                            
                                if nerdtree#closeBookmarksOnOpen()
                                    call a:nerdtree.ui.toggleShowBookmarks()
                                endif
                            
                                if self.path.isDirectory && !has_key(opts, 'where')
                                    call self.toRoot(a:nerdtree)
                                else
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.openInNewTab(options) {{{1
                            " Create a new bookmark object with the given name and path object
    1              0.000000000 function! s:Bookmark.openInNewTab(options)
                                call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
                                call self.open(a:options)
                            endfunction
                            
                            " FUNCTION: Bookmark.setPath(path) {{{1
                            " makes this bookmark point to the given path
    1              0.000000000 function! s:Bookmark.setPath(path)
                                let self.path = a:path
                            endfunction
                            
                            " FUNCTION: Bookmark.SortBookmarksList() {{{1
                            " Class method that sorts the global list of bookmarks alphabetically by name.
                            " Note that case-sensitivity is determined by a user option.
    1              0.000001000 function! s:Bookmark.SortBookmarksList()
                                call sort(s:Bookmark.Bookmarks(), s:Bookmark.CompareBookmarksByName, s:Bookmark)
                            endfunction
                            
                            " FUNCTION: Bookmark.str() {{{1
                            " Get the string that should be rendered in the view for this bookmark
    1              0.000001000 function! s:Bookmark.str()
                                let pathStrMaxLen = winwidth(g:NERDTree.GetWinNum()) - 4 - strdisplaywidth(self.name)
                                if &number
                                    let pathStrMaxLen = pathStrMaxLen - &numberwidth
                                endif
                            
                                let pathStr = self.path.str({'format': 'UI'})
                                if strdisplaywidth(pathStr) > pathStrMaxLen
                                    while strdisplaywidth(pathStr) > pathStrMaxLen && strchars(pathStr) > 0
                                        let pathStr = substitute(pathStr, '^.', '', '')
                                    endwhile
                                    let pathStr = '<' . pathStr
                                endif
                                return '>' . self.name . ' ' . pathStr
                            endfunction
                            
                            " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
                            " Set the root of the given NERDTree to the node for this Bookmark. If a node
                            " for this Bookmark does not exist, a new one is initialized.
    1              0.000001000 function! s:Bookmark.toRoot(nerdtree)
                                if self.validate()
                                    try
                                        let l:targetNode = self.getNode(a:nerdtree, 1)
                                        call l:targetNode.closeChildren()
                                    catch /^NERDTree.BookmarkedNodeNotFoundError/
                                        let l:targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path, a:nerdtree)
                                    endtry
                                    call a:nerdtree.changeRoot(l:targetNode)
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
                            " Class method that makes the Bookmark with the given name the root of
                            " specified NERDTree.
    1              0.000001000 function! s:Bookmark.ToRoot(name, nerdtree)
                                let l:bookmark = s:Bookmark.BookmarkFor(a:name)
                                call l:bookmark.toRoot(a:nerdtree)
                            endfunction
                            
                            " FUNCTION: Bookmark.validate() {{{1
    1              0.000001000 function! s:Bookmark.validate()
                                if self.path.exists()
                                    return 1
                                else
                                    call s:Bookmark.CacheBookmarks(1)
                                    call nerdtree#echo(self.name . 'now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.')
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.Write() {{{1
                            " Class method to write all bookmarks to the bookmarks file
    1              0.000001000 function! s:Bookmark.Write()
                                let bookmarkStrings = []
                                for i in s:Bookmark.Bookmarks()
                                    call add(bookmarkStrings, i.name . ' ' . fnamemodify(i.path.str(), ':~'))
                                endfor
                            
                                "add a blank line before the invalid ones
                                call add(bookmarkStrings, '')
                            
                                for j in s:Bookmark.InvalidBookmarks()
                                    call add(bookmarkStrings, j)
                                endfor
                            
                                try
                                    call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
                                catch
                                    call nerdtree#echoError('Failed to write bookmarks file. Make sure g:NERDTreeBookmarksFile points to a valid location.')
                                endtry
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim
Sourced 1 time
Total time:   0.000107000
 Self time:   0.000107000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: TreeFileNode
                            "
                            " This class is the parent of the TreeDirNode class and is the 'Component'
                            " part of the composite design pattern between the NERDTree node classes.
                            " ============================================================================
                            
                            
    1              0.000001000 let s:TreeFileNode = {}
    1              0.000001000 let g:NERDTreeFileNode = s:TreeFileNode
                            
                            " FUNCTION: TreeFileNode.activate(...) {{{1
    1              0.000000000 function! s:TreeFileNode.activate(...)
                                call self.open(a:0 ? a:1 : {})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.bookmark(name) {{{1
                            " bookmark this node with a:name
    1              0.000001000 function! s:TreeFileNode.bookmark(name)
                            
                                " if a bookmark exists with the same name and the node is cached then save
                                " it so we can update its display string
                                let oldMarkedNode = {}
                                try
                                    let oldMarkedNode = g:NERDTreeBookmark.GetNodeForName(a:name, 1, self.getNerdtree())
                                catch /^NERDTree.BookmarkNotFoundError/
                                catch /^NERDTree.BookmarkedNodeNotFoundError/
                                endtry
                            
                                call g:NERDTreeBookmark.AddBookmark(a:name, self.path)
                                call self.path.cacheDisplayString()
                                call g:NERDTreeBookmark.Write()
                            
                                if !empty(oldMarkedNode)
                                    call oldMarkedNode.path.cacheDisplayString()
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.cacheParent() {{{1
                            " initializes self.parent if it isnt already
    1              0.000001000 function! s:TreeFileNode.cacheParent()
                                if empty(self.parent)
                                    let parentPath = self.path.getParent()
                                    if parentPath.equals(self.path)
                                        throw 'NERDTree.CannotCacheParentError: already at root'
                                    endif
                                    let self.parent = s:TreeFileNode.New(parentPath, self.getNerdtree())
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.clearBookmarks() {{{1
    1              0.000001000 function! s:TreeFileNode.clearBookmarks()
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        call i.delete()
                                    end
                                endfor
                                call self.path.cacheDisplayString()
                            endfunction
                            
                            " FUNCTION: TreeFileNode.copy(dest) {{{1
    1              0.000001000 function! s:TreeFileNode.copy(dest)
                                call self.path.copy(a:dest)
                                let newPath = g:NERDTreePath.New(a:dest)
                                let parent = self.getNerdtree().root.findNode(newPath.getParent())
                                if !empty(parent)
                                    call parent.refresh()
                                    return parent.findNode(newPath)
                                else
                                    return {}
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.delete {{{1
                            " Removes this node from the tree and calls the Delete method for its path obj
    1              0.000001000 function! s:TreeFileNode.delete()
                                call self.path.delete()
                                call self.parent.removeChild(self)
                            endfunction
                            
                            " FUNCTION: TreeFileNode.displayString() {{{1
                            "
                            " Returns a string that specifies how the node should be represented as a
                            " string
                            "
                            " Return:
                            " a string that can be used in the view to represent this node
    1              0.000001000 function! s:TreeFileNode.displayString()
                                return self.path.flagSet.renderToString() . self.path.displayString()
                            endfunction
                            
                            " FUNCTION: TreeFileNode.equals(treenode) {{{1
                            "
                            " Compares this treenode to the input treenode and returns 1 if they are the
                            " same node.
                            "
                            " Use this method instead of ==  because sometimes when the treenodes contain
                            " many children, vim seg faults when doing ==
                            "
                            " Args:
                            " treenode: the other treenode to compare to
    1              0.000001000 function! s:TreeFileNode.equals(treenode)
                                return self.path.str() ==# a:treenode.path.str()
                            endfunction
                            
                            " FUNCTION: TreeFileNode.findNode(path) {{{1
                            " Returns self if this node.path.Equals the given path.
                            " Returns {} if not equal.
                            "
                            " Args:
                            " path: the path object to compare against
    1              0.000000000 function! s:TreeFileNode.findNode(path)
                                if a:path.equals(self.path)
                                    return self
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.findSibling(direction) {{{1
                            " Find the next or previous sibling of this node.
                            "
                            " Args:
                            " direction: 0 for previous, 1 for next
                            "
                            " Return:
                            " The next/previous TreeFileNode object or an empty dictionary if not found.
    1              0.000001000 function! s:TreeFileNode.findSibling(direction)
                            
                                " There can be no siblings if there is no parent.
                                if empty(self.parent)
                                    return {}
                                endif
                            
                                let l:nodeIndex = self.parent.getChildIndex(self.path)
                            
                                if l:nodeIndex == -1
                                    return {}
                                endif
                            
                                " Get the next index to begin the search.
                                let l:nodeIndex += a:direction ? 1 : -1
                            
                                while 0 <= l:nodeIndex && l:nodeIndex < self.parent.getChildCount()
                            
                                    " Return the next node if it is not ignored.
                                    if !self.parent.children[l:nodeIndex].path.ignore(self.getNerdtree())
                                        return self.parent.children[l:nodeIndex]
                                    endif
                            
                                    let l:nodeIndex += a:direction ? 1 : -1
                                endwhile
                            
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.getNerdtree(){{{1
    1              0.000001000 function! s:TreeFileNode.getNerdtree()
                                return self._nerdtree
                            endfunction
                            
                            " FUNCTION: TreeFileNode.GetRootForTab(){{{1
                            " get the root node for this tab
    1              0.000000000 function! s:TreeFileNode.GetRootForTab()
                                if g:NERDTree.ExistsForTab()
                                    return getbufvar(t:NERDTreeBufName, 'NERDTree').root
                                end
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.GetSelected() {{{1
                            " If the cursor is currently positioned on a tree node, return the node.
                            " Otherwise, return the empty dictionary.
    1              0.000000000 function! s:TreeFileNode.GetSelected()
                            
                                try
                                    let l:path = b:NERDTree.ui.getPath(line('.'))
                            
                                    if empty(l:path)
                                        return {}
                                    endif
                            
                                    return b:NERDTree.root.findNode(l:path)
                                catch
                                    return {}
                                endtry
                            endfunction
                            
                            " FUNCTION: TreeFileNode.isVisible() {{{1
                            " returns 1 if this node should be visible according to the tree filters and
                            " hidden file filters (and their on/off status)
    1              0.000001000 function! s:TreeFileNode.isVisible()
                                return !self.path.ignore(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeFileNode.isRoot() {{{1
    1              0.000000000 function! s:TreeFileNode.isRoot()
                                if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
                                endif
                            
                                return self.equals(self.getNerdtree().root)
                            endfunction
                            
                            " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
                            " Returns a new TreeNode object with the given path and parent
                            "
                            " Args:
                            " path: file/dir that the node represents
                            " nerdtree: the tree the node belongs to
    1              0.000000000 function! s:TreeFileNode.New(path, nerdtree)
                                if a:path.isDirectory
                                    return g:NERDTreeDirNode.New(a:path, a:nerdtree)
                                else
                                    let newTreeNode = copy(self)
                                    let newTreeNode.path = a:path
                                    let newTreeNode.parent = {}
                                    let newTreeNode._nerdtree = a:nerdtree
                                    return newTreeNode
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.open() {{{1
    1              0.000000000 function! s:TreeFileNode.open(...)
                                let opts = a:0 ? a:1 : {}
                                let opener = g:NERDTreeOpener.New(self.path, opts)
                                call opener.open(self)
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openSplit() {{{1
                            " Open this node in a new window
    1              0.000001000 function! s:TreeFileNode.openSplit()
                                call nerdtree#deprecated('TreeFileNode.openSplit', 'is deprecated, use .open() instead.')
                                call self.open({'where': 'h'})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openVSplit() {{{1
                            " Open this node in a new vertical window
    1              0.000001000 function! s:TreeFileNode.openVSplit()
                                call nerdtree#deprecated('TreeFileNode.openVSplit', 'is deprecated, use .open() instead.')
                                call self.open({'where': 'v'})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openInNewTab(options) {{{1
    1              0.000001000 function! s:TreeFileNode.openInNewTab(options)
                                call nerdtree#deprecated('TreeFileNode.openinNewTab', 'is deprecated, use .open() instead.')
                                call self.open(extend({'where': 't'}, a:options))
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openExplorer()
    1              0.000001000 function! s:TreeFileNode.openExplorer()
                                execute 'wincmd p'
                                execute 'edit '.self.path.getParent().str({'format':'Edit'})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
                            " Places the cursor on the line number this node is rendered on
                            "
                            " Args:
                            " isJump: 1 if this cursor movement should be counted as a jump by vim
                            " recurseUpward: try to put the cursor on the parent if the this node isnt
                            " visible
    1              0.000001000 function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
                                let ln = self.getNerdtree().ui.getLineNum(self)
                                if ln != -1
                                    if a:isJump
                                        mark '
                                    endif
                                    call cursor(ln, col('.'))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.refresh() {{{1
    1              0.000001000 function! s:TreeFileNode.refresh()
                                call self.path.refresh(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeFileNode.refreshFlags() {{{1
    1              0.000001000 function! s:TreeFileNode.refreshFlags()
                                call self.path.refreshFlags(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeFileNode.rename() {{{1
                            " Calls the rename method for this nodes path obj
    1              0.000001000 function! s:TreeFileNode.rename(newName)
                                let newName = substitute(a:newName, '\(\\\|\/\)$', '', '')
                                call self.path.rename(newName)
                                call self.parent.removeChild(self)
                            
                                let parentPath = self.path.getParent()
                                let newParent = self.getNerdtree().root.findNode(parentPath)
                            
                                if newParent != {}
                                    call newParent.createChild(self.path, 1)
                                    call newParent.refresh()
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.renderToString {{{1
                            " returns a string representation for this tree to be rendered in the view
    1              0.000001000 function! s:TreeFileNode.renderToString()
                                return self._renderToString(0, 0)
                            endfunction
                            
                            " Args:
                            " depth: the current depth in the tree for this call
                            " drawText: 1 if we should actually draw the line for this node (if 0 then the
                            " child nodes are rendered only)
                            " for each depth in the tree
    1              0.000001000 function! s:TreeFileNode._renderToString(depth, drawText)
                                let output = ''
                                if a:drawText ==# 1
                            
                                    let treeParts = repeat('  ', a:depth - 1)
                                    let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
                                    let line = treeParts . self.displayString()
                                    let output = output . line . "\n"
                                endif
                            
                                " if the node is an open dir, draw its children
                                if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
                                    let childNodesToDraw = self.getVisibleChildren()
                            
                                    if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
                                        for i in childNodesToDraw
                                            let output = output . i._renderToString(a:depth + 1, 1)
                                        endfor
                                    endif
                                endif
                            
                                return output
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
Sourced 1 time
Total time:   0.000214000
 Self time:   0.000214000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: TreeDirNode
                            "
                            " A subclass of NERDTreeFileNode.
                            "
                            " The 'composite' part of the file/dir composite.
                            " ============================================================================
                            
                            
    1              0.000005000 let s:TreeDirNode = copy(g:NERDTreeFileNode)
    1              0.000001000 let g:NERDTreeDirNode = s:TreeDirNode
                            
                            " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
                            " Class method that returns the highest cached ancestor of the current root.
    1              0.000000000 function! s:TreeDirNode.AbsoluteTreeRoot()
                                let currentNode = b:NERDTree.root
                                while currentNode.parent !=# {}
                                    let currentNode = currentNode.parent
                                endwhile
                                return currentNode
                            endfunction
                            
                            " FUNCTION: TreeDirNode.activate([options]) {{{1
    1              0.000000000 function! s:TreeDirNode.activate(...)
                                let l:options = (a:0 > 0) ? a:1 : {}
                            
                                call self.toggleOpen(l:options)
                            
                                " Note that we only re-render the NERDTree for this node if we did NOT
                                " create a new node and render it in a new window or tab.  In the latter
                                " case, rendering the NERDTree for this node could overwrite the text of
                                " the new NERDTree!
                                if !has_key(l:options, 'where') || empty(l:options['where'])
                                    call self.getNerdtree().render()
                                    call self.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
                            " Adds the given treenode to the list of children for this node
                            "
                            " Args:
                            " -treenode: the node to add
                            " -inOrder: 1 if the new node should be inserted in sorted order
    1              0.000001000 function! s:TreeDirNode.addChild(treenode, inOrder)
                                call add(self.children, a:treenode)
                                let a:treenode.parent = self
                            
                                if a:inOrder
                                    call self.sortChildren()
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.close() {{{1
                            " Mark this TreeDirNode as closed.
    1              0.000001000 function! s:TreeDirNode.close()
                            
                                " Close all directories in this directory node's cascade. This is
                                " necessary to ensure consistency when cascades are rendered.
                                for l:dirNode in self.getCascade()
                                    let l:dirNode.isOpen = 0
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.closeChildren() {{{1
                            " Recursively close any directory nodes that are descendants of this node.
    1              0.000001000 function! s:TreeDirNode.closeChildren()
                                for l:child in self.children
                                    if l:child.path.isDirectory
                                        call l:child.close()
                                        call l:child.closeChildren()
                                    endif
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
                            " Instantiates a new child node for this node with the given path. The new
                            " nodes parent is set to this node.
                            "
                            " Args:
                            " path: a Path object that this node will represent/contain
                            " inOrder: 1 if the new node should be inserted in sorted order
                            "
                            " Returns:
                            " the newly created node
    1              0.000001000 function! s:TreeDirNode.createChild(path, inOrder)
                                let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
                                call self.addChild(newTreeNode, a:inOrder)
                                return newTreeNode
                            endfunction
                            
                            " FUNCTION: TreeDirNode.displayString() {{{1
                            " Assemble and return a string that can represent this TreeDirNode object in
                            " the NERDTree window.
    1              0.000000000 function! s:TreeDirNode.displayString()
                                let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
                                let l:label = ''
                                let l:cascade = self.getCascade()
                                for l:dirNode in l:cascade
                                    let l:next = l:dirNode.path.displayString()
                                    let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
                                endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
                                let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
                                let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
                                let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
                                return l:symbol . l:flags . l:label
                            endfunction
                            
                            " FUNCTION: TreeDirNode.findNode(path) {{{1
                            " Will find one of the children (recursively) that has the given path
                            "
                            " Args:
                            " path: a path object
    1              0.000000000 unlet s:TreeDirNode.findNode
    1              0.000000000 function! s:TreeDirNode.findNode(path)
                                if a:path.equals(self.path)
                                    return self
                                endif
                                if nerdtree#caseSensitiveFS()
                                    if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                        return {}
                                    endif
                                else
                                    if stridx(tolower(a:path.str()), tolower(self.path.str()), 0) ==# -1
                                        return {}
                                    endif
                                endif
                            
                                if self.path.isDirectory
                                    for i in self.children
                                        let retVal = i.findNode(a:path)
                                        if retVal !=# {}
                                            return retVal
                                        endif
                                    endfor
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getCascade() {{{1
                            " Return an array of dir nodes (starting from self) that can be cascade opened.
    1              0.000001000 function! s:TreeDirNode.getCascade()
                                if !self.isCascadable()
                                    return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getCascadeRoot() {{{1
                            " Return the first directory node in the cascade in which this directory node
                            " is rendered.
    1              0.000001000 function! s:TreeDirNode.getCascadeRoot()
                            
                                " Don't search above the current NERDTree root node.
                                if self.isRoot()
                                    return self
                                endif
                            
                                let l:cascadeRoot = self
                                let l:parent = self.parent
                            
                                while !empty(l:parent) && !l:parent.isRoot()
                            
                                    if index(l:parent.getCascade(), self) ==# -1
                                        break
                                    endif
                            
                                    let l:cascadeRoot = l:parent
                                    let l:parent = l:parent.parent
                                endwhile
                            
                                return l:cascadeRoot
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChildCount() {{{1
                            " Returns the number of children this node has
    1              0.000001000 function! s:TreeDirNode.getChildCount()
                                return len(self.children)
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChild(path) {{{1
                            " Returns child node of this node that has the given path or {} if no such node
                            " exists.
                            "
                            " This function doesnt not recurse into child dir nodes
                            "
                            " Args:
                            " path: a path object
    1              0.000001000 function! s:TreeDirNode.getChild(path)
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
                                endif
                            
                                let index = self.getChildIndex(a:path)
                                if index ==# -1
                                    return {}
                                else
                                    return self.children[index]
                                endif
                            
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
                            " returns the child at the given index
                            "
                            " Args:
                            " indx: the index to get the child from
                            " visible: 1 if only the visible children array should be used, 0 if all the
                            " children should be searched.
    1              0.000000000 function! s:TreeDirNode.getChildByIndex(indx, visible)
                                let array_to_search = a:visible? self.getVisibleChildren() : self.children
                                if a:indx > len(array_to_search)
                                    throw 'NERDTree.InvalidArgumentsError: Index is out of bounds.'
                                endif
                                return array_to_search[a:indx]
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChildIndex(path) {{{1
                            " Returns the index of the child node of this node that has the given path or
                            " -1 if no such node exists.
                            "
                            " This function doesnt not recurse into child dir nodes
                            "
                            " Args:
                            " path: a path object
    1              0.000001000 function! s:TreeDirNode.getChildIndex(path)
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return -1
                                endif
                            
                                "do a binary search for the child
                                let a = 0
                                let z = self.getChildCount()
                                while a < z
                                    let mid = (a+z)/2
                                    let diff = nerdtree#compareNodePaths(a:path, self.children[mid].path)
                            
                                    if diff ==# -1
                                        let z = mid
                                    elseif diff ==# 1
                                        let a = mid+1
                                    else
                                        return mid
                                    endif
                                endwhile
                                return -1
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getDirChildren() {{{1
                            " Return a list of all child nodes from 'self.children' that are of type
                            " TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.
    1              0.000000000 function! s:TreeDirNode.getDirChildren()
                                return filter(copy(self.children), 'v:val.path.isDirectory ==# 1')
                            endfunction
                            
                            " FUNCTION: TreeDirNode._glob(pattern, all) {{{1
                            " Return a list of strings naming the descendants of the directory in this
                            " TreeDirNode object that match the specified glob pattern.
                            "
                            " Args:
                            " pattern: (string) the glob pattern to apply
                            " all: (0 or 1) if 1, include '.' and '..' if they match 'pattern'; if 0,
                            "      always exclude them
                            "
                            " Note: If the pathnames in the result list are below the working directory,
                            " they are returned as pathnames relative to that directory. This is because
                            " this function, internally, attempts to obey 'wildignore' rules that use
                            " relative paths.
    1              0.000000000 function! s:TreeDirNode._glob(pattern, all)
                            
                                " Construct a path specification such that globpath() will return
                                " relative pathnames, if possible.
                                if self.path.str() ==# getcwd()
                                    let l:pathSpec = ','
                                else
                                    let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                            
                                    if nerdtree#runningWindows()
                                        let l:pathSpec = substitute(l:pathSpec, "\\[\\(.*\\]\\)", "[[]\\1", "g")
                                    endif
                            
                                    " On Windows, the drive letter may be removed by "fnamemodify()".
                                    if nerdtree#runningWindows() && l:pathSpec[0] == nerdtree#slash()
                                        let l:pathSpec = self.path.drive . l:pathSpec
                                    endif
                                endif
                            
                                let l:globList = []
                            
                                " See ':h version7.txt' and ':h version8.txt' for details on the
                                " development of the glob() and globpath() functions.
                                if v:version > 704 || (v:version ==# 704 && has('patch654'))
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                elseif v:version ==# 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
                                endif
                            
                                " If a:all is false, filter '.' and '..' from the output.
                                if !a:all
                                    let l:toRemove = []
                            
                                    for l:file in l:globList
                                        let l:tail = fnamemodify(l:file, ':t')
                            
                                        " If l:file has a trailing slash, then its :tail will be ''. Use
                                        " :h to drop the slash and the empty string after it; then use :t
                                        " to get the directory name.
                                        if l:tail ==# ''
                                            let l:tail = fnamemodify(l:file, ':h:t')
                                        endif
                            
                                        if l:tail ==# '.' || l:tail ==# '..'
                                            call add(l:toRemove, l:file)
                                            if len(l:toRemove) ==# 2
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    for l:file in l:toRemove
                                        call remove(l:globList, index(l:globList, l:file))
                                    endfor
                                endif
                            
                                return l:globList
                            endfunction
                            
                            " FUNCTION: TreeDirNode.GetSelected() {{{1
                            " Returns the current node if it is a dir node, or else returns the current
                            " nodes parent
    1              0.000001000 unlet s:TreeDirNode.GetSelected
    1              0.000001000 function! s:TreeDirNode.GetSelected()
                                let currentDir = g:NERDTreeFileNode.GetSelected()
                                if currentDir !=# {} && !currentDir.isRoot()
                                    if currentDir.path.isDirectory ==# 0
                                        let currentDir = currentDir.parent
                                    endif
                                endif
                                return currentDir
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
                            " Returns the number of visible children this node has
    1              0.000000000 function! s:TreeDirNode.getVisibleChildCount()
                                return len(self.getVisibleChildren())
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getVisibleChildren() {{{1
                            " Returns a list of children to display for this node, in the correct order
                            "
                            " Return:
                            " an array of treenodes
    1              0.000001000 function! s:TreeDirNode.getVisibleChildren()
                                let toReturn = []
                                for i in self.children
                                    if i.path.ignore(self.getNerdtree()) ==# 0
                                        call add(toReturn, i)
                                    endif
                                endfor
                                return toReturn
                            endfunction
                            
                            " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
                            " returns 1 if this node has any childre, 0 otherwise..
    1              0.000000000 function! s:TreeDirNode.hasVisibleChildren()
                                return self.getVisibleChildCount() !=# 0
                            endfunction
                            
                            " FUNCTION: TreeDirNode.isCascadable() {{{1
                            " true if this dir has only one visible child that is also a dir
                            " false if this dir is bookmarked or symlinked. Why? Two reasons:
                            "  1. If cascaded, we don't know which dir is bookmarked or is a symlink.
                            "  2. If the parent is a symlink or is bookmarked, you end up with unparsable
                            "     text, and NERDTree cannot get the path of any child node.
                            " Also, return false if this directory is the tree root, which should never be
                            " part of a cascade.
    1              0.000000000 function! s:TreeDirNode.isCascadable()
                                if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
                                endif
                            
                                if self.isRoot()
                                    return 0
                                endif
                            
                                if self.path.isSymLink
                                    return 0
                                endif
                            
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
                                endfor
                            
                                let c = self.getVisibleChildren()
                                return len(c) ==# 1 && c[0].path.isDirectory
                            endfunction
                            
                            " FUNCTION: TreeDirNode._initChildren() {{{1
                            " Removes all childen from this node and re-reads them
                            "
                            " Args:
                            " silent: 1 if the function should not echo any 'please wait' messages for
                            " large directories
                            "
                            " Return: the number of child nodes read
    1              0.000000000 function! s:TreeDirNode._initChildren(silent)
                                "remove all the current child nodes
                                let self.children = []
                            
                                let files = self._glob('*', 1) + self._glob('.*', 0)
                            
                                if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo('Please wait, caching a large dir ...')
                                endif
                            
                                let invalidFilesFound = 0
                                let invalidFiles = []
                                for i in files
                                    try
                                        let path = g:NERDTreePath.New(i)
                                        call self.createChild(path, 0)
                                        call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                    catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
                                        let invalidFiles += [i]
                                    endtry
                                endfor
                            
                                let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
                                call self.sortChildren()
                            
                                call nerdtree#echo('')
                            
                                if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . ' Invalid file(s): ' . join(invalidFiles, ', '))
                                endif
                                return self.getChildCount()
                            endfunction
                            
                            " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
                            " Return a new TreeDirNode object with the given path and parent.
                            "
                            " Args:
                            " path: dir that the node represents
                            " nerdtree: the tree the node belongs to
    1              0.000000000 function! s:TreeDirNode.New(path, nerdtree)
                                if a:path.isDirectory !=# 1
                                    throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
                                endif
                            
                                let newTreeNode = copy(self)
                                let newTreeNode.path = a:path
                            
                                let newTreeNode.isOpen = 0
                                let newTreeNode.children = []
                            
                                let newTreeNode.parent = {}
                                let newTreeNode._nerdtree = a:nerdtree
                            
                                return newTreeNode
                            endfunction
                            
                            " FUNCTION: TreeDirNode.open([options]) {{{1
                            " Open this directory node in the current tree or elsewhere if special options
                            " are provided. Return 0 if options were processed. Otherwise, return the
                            " number of new cached nodes.
    1              0.000001000 function! s:TreeDirNode.open(...)
                                let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
                                if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
                                endif
                            
                                " Open any ancestors of this node that render within the same cascade.
                                let l:parent = self.parent
                                while !empty(l:parent) && !l:parent.isRoot()
                                    if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
                                        break
                                    endif
                                endwhile
                            
                                let self.isOpen = 1
                            
                                let l:numChildrenCached = 0
                                if empty(self.children)
                                    let l:numChildrenCached = self._initChildren(0)
                                endif
                            
                                return l:numChildrenCached
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openAlong([opts]) {{{1
                            " recursive open the dir if it has only one directory child.
                            "
                            " return the level of opened directories.
    1              0.000001000 function! s:TreeDirNode.openAlong(...)
                                let opts = a:0 ? a:1 : {}
                                let level = 0
                            
                                let node = self
                                while node.path.isDirectory
                                    call node.open(opts)
                                    let level += 1
                                    if node.getVisibleChildCount() ==# 1
                                        let node = node.getChildByIndex(0, 1)
                                    else
                                        break
                                    endif
                                endwhile
                                return level
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openExplorer() {{{1
                            " Open an explorer window for this node in the previous window. The explorer
                            " can be a NERDTree window or a netrw window.
    1              0.000001000 function! s:TreeDirNode.openExplorer()
                                execute 'wincmd p'
                                execute 'edit '.self.path.str({'format':'Edit'})
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openInNewTab(options) {{{1
    1              0.000001000 unlet s:TreeDirNode.openInNewTab
    1              0.000001000 function! s:TreeDirNode.openInNewTab(options)
                                call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
                                call self.open({'where': 't'})
                            endfunction
                            
                            " FUNCTION: TreeDirNode._openInNewTab() {{{1
    1              0.000001000 function! s:TreeDirNode._openInNewTab()
                                tabnew
                                call g:NERDTreeCreator.CreateTabTree(self.path.str())
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openRecursively() {{{1
                            " Open this directory node and any descendant directory nodes whose pathnames
                            " are not ignored.
    1              0.000001000 function! s:TreeDirNode.openRecursively()
                                silent call self.open()
                            
                                for l:child in self.children
                                    if l:child.path.isDirectory && !l:child.path.ignore(l:child.getNerdtree())
                                        call l:child.openRecursively()
                                    endif
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.refresh() {{{1
    1              0.000001000 function! s:TreeDirNode.refresh()
                                call self.path.refresh(self.getNerdtree())
                            
                                "if this node was ever opened, refresh its children
                                if self.isOpen || !empty(self.children)
                                    let files = self._glob('*', 1) + self._glob('.*', 0)
                                    let newChildNodes = []
                                    let invalidFilesFound = 0
                                    let invalidFiles = []
                                    for i in files
                                        try
                                            "create a new path and see if it exists in this nodes children
                                            let path = g:NERDTreePath.New(i)
                                            let newNode = self.getChild(path)
                                            if newNode !=# {} && path.str() ==# newNode.path.str()
                                                call newNode.refresh()
                                                call add(newChildNodes, newNode)
                            
                                            "the node doesnt exist so create it
                                            else
                                                let newNode = g:NERDTreeFileNode.New(path, self.getNerdtree())
                                                let newNode.parent = self
                                                call add(newChildNodes, newNode)
                                            endif
                                        catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound += 1
                                            let invalidFiles += [i]
                                        endtry
                                    endfor
                            
                                    "swap this nodes children out for the children we just read/refreshed
                                    let self.children = newChildNodes
                                    call self.sortChildren()
                            
                                    if invalidFilesFound
                                        call nerdtree#echoWarning(invalidFilesFound . ' Invalid file(s): ' . join(invalidFiles, ', '))
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.refreshFlags() {{{1
    1              0.000000000 unlet s:TreeDirNode.refreshFlags
    1              0.000001000 function! s:TreeDirNode.refreshFlags()
                                call self.path.refreshFlags(self.getNerdtree())
                                for i in self.children
                                    call i.refreshFlags()
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.refreshDirFlags() {{{1
    1              0.000000000 function! s:TreeDirNode.refreshDirFlags()
                                call self.path.refreshFlags(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeDirNode.reveal(path) {{{1
                            " reveal the given path, i.e. cache and open all treenodes needed to display it
                            " in the UI
                            " Returns the revealed node
    1              0.000001000 function! s:TreeDirNode.reveal(path, ...)
                                let opts = a:0 ? a:1 : {}
                            
                                if !a:path.isUnder(self.path)
                                    throw 'NERDTree.InvalidArgumentsError: ' . a:path.str() . ' should be under ' . self.path.str()
                                endif
                            
                                call self.open()
                            
                                if self.path.equals(a:path.getParent())
                                    let n = self.findNode(a:path)
                                    " We may be looking for a newly-saved file that isn't in the tree yet.
                                    if n ==# {}
                                        call self.refresh()
                                        let n = self.findNode(a:path)
                                    endif
                                    if has_key(opts, 'open')
                                        call n.open()
                                    endif
                                    return n
                                endif
                            
                                let p = a:path
                                while !p.getParent().equals(self.path)
                                    let p = p.getParent()
                                endwhile
                            
                                let n = self.findNode(p)
                                return n.reveal(a:path, opts)
                            endfunction
                            
                            " FUNCTION: TreeDirNode.removeChild(treenode) {{{1
                            " Remove the given treenode from self.children.
                            " Throws NERDTree.ChildNotFoundError if the node is not found.
                            "
                            " Args:
                            " treenode: the node object to remove
    1              0.000000000 function! s:TreeDirNode.removeChild(treenode)
                                for i in range(0, self.getChildCount()-1)
                                    if self.children[i].equals(a:treenode)
                                        call remove(self.children, i)
                                        return
                                    endif
                                endfor
                            
                                throw 'NERDTree.ChildNotFoundError: child node was not found'
                            endfunction
                            
                            " FUNCTION: TreeDirNode.sortChildren() {{{1
                            " Sort self.children by alphabetical order and directory priority.
    1              0.000001000 function! s:TreeDirNode.sortChildren()
                                if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
                                endif
                                let CompareFunc = function('nerdtree#compareNodes')
                                call sort(self.children, CompareFunc)
                                let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
                            endfunction
                            
                            " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
                            " Opens this directory if it is closed and vice versa
    1              0.000001000 function! s:TreeDirNode.toggleOpen(...)
                                let opts = a:0 ? a:1 : {}
                                if self.isOpen ==# 1
                                    call self.close()
                                else
                                    if g:NERDTreeCascadeOpenSingleChildDir ==# 0
                                        call self.open(opts)
                                    else
                                        call self.openAlong(opts)
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
                            " Replaces the child of this with the given node (where the child node's full
                            " path matches a:newNode's fullpath). The search for the matching node is
                            " non-recursive
                            "
                            " Arg:
                            " newNode: the node to graft into the tree
    1              0.000001000 function! s:TreeDirNode.transplantChild(newNode)
                                for i in range(0, self.getChildCount()-1)
                                    if self.children[i].equals(a:newNode)
                                        let self.children[i] = a:newNode
                                        let a:newNode.parent = self
                                        break
                                    endif
                                endfor
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/opener.vim
Sourced 1 time
Total time:   0.000094000
 Self time:   0.000094000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: Opener
                            "
                            " The Opener class defines an API for 'opening' operations.
                            " ============================================================================
                            
                            
    1              0.000001000 let s:Opener = {}
    1              0.000001000 let g:NERDTreeOpener = s:Opener
                            
                            " FUNCTION: s:Opener._bufInWindows(bnum) {{{1
                            " [[STOLEN FROM VTREEEXPLORER.VIM]]
                            " Determine the number of windows open to this buffer number.
                            " Care of Yegappan Lakshman.  Thanks!
                            "
                            " Args:
                            " bnum: the subject buffers buffer number
    1              0.000001000 function! s:Opener._bufInWindows(bnum)
                                let cnt = 0
                                let winnum = 1
                                while 1
                                    let bufnum = winbufnr(winnum)
                                    if bufnum < 0
                                        break
                                    endif
                                    if bufnum ==# a:bnum
                                        let cnt = cnt + 1
                                    endif
                                    let winnum = winnum + 1
                                endwhile
                            
                                return cnt
                            endfunction
                            
                            " FUNCTION: Opener._checkToCloseTree(newtab) {{{1
                            " Check the class options to see if the tree should be closed now.
                            "
                            " Args:
                            " a:newtab - boolean. If set, only close the tree now if we are opening the
                            " target in a new tab. This is needed because we have to close tree before we
                            " leave the tab
    1              0.000000000 function! s:Opener._checkToCloseTree(newtab)
                                if self._keepopen
                                    return
                                endif
                            
                                if (a:newtab && self._where ==# 't') || !a:newtab
                                    call g:NERDTree.Close()
                                endif
                            endfunction
                            
                            " FUNCTION: s:Opener._firstUsableWindow() {{{1
                            " find the window number of the first normal window
    1              0.000001000 function! s:Opener._firstUsableWindow()
                                let i = 1
                                while i <= winnr('$')
                                    let bnum = winbufnr(i)
                                    if bnum !=# -1 && getbufvar(bnum, '&buftype') ==# ''
                                                \ && !getwinvar(i, '&previewwindow')
                                                \ && (!getbufvar(bnum, '&modified') || &hidden)
                                        return i
                                    endif
                            
                                    let i += 1
                                endwhile
                                return -1
                            endfunction
                            
                            " FUNCTION: Opener._gotoTargetWin() {{{1
    1              0.000001000 function! s:Opener._gotoTargetWin()
                                if b:NERDTree.isWinTree()
                                    if self._where ==# 'v'
                                        call self._newVSplit()
                                    elseif self._where ==# 'h'
                                        call self._newSplit()
                                    elseif self._where ==# 't'
                                        tabnew
                                    endif
                                else
                                    call self._checkToCloseTree(1)
                            
                                    if self._where ==# 'v'
                                        call self._newVSplit()
                                    elseif self._where ==# 'h'
                                        call self._newSplit()
                                    elseif self._where ==# 't'
                                        tabnew
                                    elseif self._where ==# 'p'
                                        call self._previousWindow()
                                    endif
                            
                                    call self._checkToCloseTree(0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
                            " Returns 0 if opening a file from the tree in the given window requires it to
                            " be split, 1 otherwise
                            "
                            " Args:
                            " winnumber: the number of the window in question
    1              0.000001000 function! s:Opener._isWindowUsable(winnumber)
                                "gotta split if theres only one window (i.e. the NERD tree)
                                if winnr('$') ==# 1
                                    return 0
                                endif
                            
                                let oldwinnr = winnr()
                                call nerdtree#exec(a:winnumber . 'wincmd p', 1)
                                let specialWindow = getbufvar('%', '&buftype') !=# '' || getwinvar('%', '&previewwindow')
                                let modified = &modified
                                call nerdtree#exec(oldwinnr . 'wincmd p', 1)
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
                                if specialWindow
                                    return 0
                                endif
                            
                                if &hidden
                                    return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2
                            endfunction
                            
                            " FUNCTION: Opener.New(path, opts) {{{1
                            " Instantiate a new NERDTreeOpener object.
                            " Args:
                            " a:path: the path object that is to be opened
                            " a:opts: a dictionary containing the following optional keys...
                            "   'where': specifies whether the node should be opened in new split, in
                            "            a new tab or, in the last window; takes values 'v', 'h', or 't'
                            "   'reuse': if file is already shown in a window, jump there; takes values
                            "            'all', 'currenttab', or empty
                            "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
                            "   'stay': boolean (0 or 1); if true, remain in tree window after opening
    1              0.000000000 function! s:Opener.New(path, opts)
                                let l:newOpener = copy(self)
                            
                                let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
                                let l:newOpener._nerdtree = b:NERDTree
                                let l:newOpener._path = a:path
                                let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
                                let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
                                let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
                                call l:newOpener._saveCursorPos()
                            
                                return l:newOpener
                            endfunction
                            
                            " FUNCTION: Opener._newSplit() {{{1
    1              0.000000000 function! s:Opener._newSplit()
                                let onlyOneWin = (winnr('$') ==# 1)
                                let savesplitright = &splitright
                                if onlyOneWin
                                    let &splitright = (g:NERDTreeWinPos ==# 'left')
                                endif
                                " If only one window (ie. NERDTree), split vertically instead.
                                let splitMode = onlyOneWin ? 'vertical' : ''
                            
                                " Open the new window
                                try
                                    call nerdtree#exec('wincmd p', 1)
                                    call nerdtree#exec(splitMode . ' split',1)
                                catch /^Vim\%((\a\+)\)\=:E37/
                                    call g:NERDTree.CursorToTreeWin()
                                    throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
                                catch /^Vim\%((\a\+)\)\=:/
                                    "do nothing
                                endtry
                            
                                "resize the tree window if no other window was open before
                                if onlyOneWin
                                    call nerdtree#exec('wincmd p', 1)
                                    call nerdtree#exec('silent '. splitMode .' resize '. g:NERDTreeWinSize, 1)
                                    call nerdtree#exec('wincmd p', 0)
                                endif
                            
                                let &splitright=savesplitright
                            endfunction
                            
                            " FUNCTION: Opener._newVSplit() {{{1
    1              0.000000000 function! s:Opener._newVSplit()
                                let l:winwidth = winwidth('.')
                            
                                let onlyOneWin = (winnr('$') ==# 1)
                                let savesplitright = &splitright
                                if onlyOneWin
                                    let &splitright = (g:NERDTreeWinPos ==# 'left')
                                    let l:winwidth = g:NERDTreeWinSize
                                endif
                            
                                call nerdtree#exec('wincmd p', 1)
                                call nerdtree#exec('vsplit', 1)
                            
                                let l:currentWindowNumber = winnr()
                            
                                " Restore the NERDTree to its original width.
                                call g:NERDTree.CursorToTreeWin()
                                execute 'silent vertical resize ' . l:winwidth
                            
                                call nerdtree#exec(l:currentWindowNumber . 'wincmd w', 0)
                                let &splitright=savesplitright
                            endfunction
                            
                            " FUNCTION: Opener.open(target) {{{1
    1              0.000001000 function! s:Opener.open(target)
                                if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
                                endif
                            
                                call self._openFile()
                            endfunction
                            
                            " FUNCTION: Opener._openFile() {{{1
    1              0.000000000 function! s:Opener._openFile()
                                if !self._stay && self._keepopen && get(b:, 'NERDTreeZoomed', 0)
                                    call b:NERDTree.ui.toggleZoom()
                                endif
                            
                                if self._reuseWindow()
                                    return
                                endif
                            
                                call self._gotoTargetWin()
                            
                                if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
                                endif
                            
                                call self._path.edit()
                            endfunction
                            
                            " FUNCTION: Opener._openDirectory(node) {{{1
    1              0.000001000 function! s:Opener._openDirectory(node)
                                call self._gotoTargetWin()
                            
                                if self._nerdtree.isWinTree()
                                    call g:NERDTreeCreator.CreateWindowTree(a:node.path.str())
                                else
                                    if empty(self._where)
                                        call b:NERDTree.changeRoot(a:node)
                                    elseif self._where ==# 't'
                                        call g:NERDTreeCreator.CreateTabTree(a:node.path.str())
                                    else
                                        call g:NERDTreeCreator.CreateWindowTree(a:node.path.str())
                                    endif
                                endif
                            
                                if self._stay
                                    call self._restoreCursorPos()
                                endif
                            endfunction
                            
                            " FUNCTION: Opener._previousWindow() {{{1
    1              0.000001000 function! s:Opener._previousWindow()
                                if !self._isWindowUsable(winnr('#')) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
                                    try
                                        if !self._isWindowUsable(winnr('#'))
                                            call nerdtree#exec(self._firstUsableWindow() . 'wincmd w', 1)
                                        else
                                            call nerdtree#exec('wincmd p', 1)
                                        endif
                                    catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
                                endif
                            endfunction
                            
                            " FUNCTION: Opener._restoreCursorPos() {{{1
    1              0.000001000 function! s:Opener._restoreCursorPos()
                                call nerdtree#exec(self._tabnr . 'tabnext', 1)
                                call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w', 1)
                            endfunction
                            
                            " FUNCTION: Opener._reuseWindow() {{{1
                            " put the cursor in the first window we find for this file
                            "
                            " return 1 if we were successful
    1              0.000000000 function! s:Opener._reuseWindow()
                                if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
                                let winnr = bufwinnr('^' . self._path.str() . '$')
                                if winnr !=# -1
                                    call nerdtree#exec(winnr . 'wincmd w', 0)
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
                                if self._reuse ==# 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
                                let tabnr = self._path.tabnr()
                                if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec(tabnr . 'tabnext', 1)
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . 'wincmd w', 0)
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: Opener._saveCursorPos() {{{1
    1              0.000000000 function! s:Opener._saveCursorPos()
                                let self._bufnr = bufnr('')
                                let self._tabnr = tabpagenr()
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/creator.vim
Sourced 1 time
Total time:   0.000127000
 Self time:   0.000127000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: Creator
                            "
                            " This class is responsible for creating NERDTree instances.  The new NERDTree
                            " may be a tab tree, a window tree, or a mirrored tree.  In the process of
                            " creating a NERDTree, it sets up all of the window and buffer options and key
                            " mappings etc.
                            " ============================================================================
                            
                            
    1              0.000002000 let s:Creator = {}
    1              0.000001000 let g:NERDTreeCreator = s:Creator
                            
                            " FUNCTION: s:Creator._bindMappings() {{{1
    1              0.000001000 function! s:Creator._bindMappings()
                                call g:NERDTreeKeyMap.BindAll()
                            
                                command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
                                command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
                                command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
                                command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
                                command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()
                            endfunction
                            
                            " FUNCTION: s:Creator._broadcastInitEvent() {{{1
    1              0.000000000 function! s:Creator._broadcastInitEvent()
                                if exists('#User#NERDTreeInit')
                                    doautocmd User NERDTreeInit
                                endif
                            endfunction
                            
                            " FUNCTION: s:Creator.BufNamePrefix() {{{1
    1              0.000001000 function! s:Creator.BufNamePrefix()
                                return 'NERD_tree_'
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateExploreTree(dir) {{{1
    1              0.000000000 function! s:Creator.CreateExploreTree(dir)
                                try
                                    let path = g:NERDTreePath.New(a:dir)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo('Invalid directory name:' . a:dir)
                                    return
                                endtry
                            
                                let creator = s:Creator.New()
                                if getbufinfo('%')[0].changed && !&hidden && !&autowriteall
                                    let l:splitLocation = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'top' ? 'topleft ' : 'botright '
                                    let l:splitDirection = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'right' ? 'vertical' : ''
                                    silent! execute l:splitLocation . l:splitDirection . ' new'
                                else
                                    silent! execute 'enew'
                                endif
                            
                                call creator.createWindowTree(a:dir)
                                "we want windowTree buffer to disappear after moving to any other buffer
                                setlocal bufhidden=wipe
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
    1              0.000001000 function! s:Creator.CreateTabTree(name)
                                let creator = s:Creator.New()
                                call creator.createTabTree(a:name)
                            endfunction
                            
                            " FUNCTION: s:Creator.createTabTree(a:name) {{{1
                            " name: the name of a bookmark or a directory
    1              0.000001000 function! s:Creator.createTabTree(name)
                                let l:path = self._pathForString(a:name)
                            
                                " Abort if an exception was thrown (i.e., if the bookmark or directory
                                " does not exist).
                                if empty(l:path)
                                    return
                                endif
                            
                                " Obey the user's preferences for changing the working directory.
                                if g:NERDTreeChDirMode != 0
                                    call l:path.changeToDir()
                                endif
                            
                                if g:NERDTree.ExistsForTab()
                                    call g:NERDTree.Close()
                                    call self._removeTreeBufForTab()
                                endif
                            
                                call self._createTreeWin()
                                call self._createNERDTree(l:path, 'tab')
                                call b:NERDTree.render()
                                call b:NERDTree.root.putCursorHere(0, 0)
                            
                                call self._broadcastInitEvent()
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
    1              0.000001000 function! s:Creator.CreateWindowTree(dir)
                                let creator = s:Creator.New()
                                call creator.createWindowTree(a:dir)
                            endfunction
                            
                            " FUNCTION: s:Creator.createWindowTree(dir) {{{1
    1              0.000000000 function! s:Creator.createWindowTree(dir)
                                try
                                    let path = g:NERDTreePath.New(a:dir)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo('Invalid directory name:' . a:dir)
                                    return
                                endtry
                            
                                "we want the directory buffer to disappear when we do the :edit below
                                setlocal bufhidden=wipe
                            
                                let previousBuf = expand('#')
                            
                                "we need a unique name for each window tree buffer to ensure they are
                                "all independent
                                exec g:NERDTreeCreatePrefix . ' edit ' . self._nextBufferName('win')
                            
                                call self._createNERDTree(path, 'window')
                                let b:NERDTree._previousBuf = bufnr(previousBuf)
                                call self._setCommonBufOptions()
                            
                                call b:NERDTree.render()
                            
                                call self._broadcastInitEvent()
                            endfunction
                            
                            " FUNCTION: s:Creator._createNERDTree(path) {{{1
    1              0.000001000 function! s:Creator._createNERDTree(path, type)
                                let b:NERDTree = g:NERDTree.New(a:path, a:type)
                            
                                " TODO: This assignment is kept for compatibility reasons.  Many other
                                " plugins use b:NERDTreeRoot instead of b:NERDTree.root.  Remove this
                                " assignment in the future.
                                let b:NERDTreeRoot = b:NERDTree.root
                            
                                call b:NERDTree.root.open()
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateMirror() {{{1
    1              0.000001000 function! s:Creator.CreateMirror()
                                let creator = s:Creator.New()
                                call creator.createMirror()
                            endfunction
                            
                            " FUNCTION: s:Creator.createMirror() {{{1
    1              0.000001000 function! s:Creator.createMirror()
                                "get the names off all the nerd tree buffers
                                let treeBufNames = []
                                for i in range(1, tabpagenr('$'))
                                    let nextName = self._tabpagevar(i, 'NERDTreeBufName')
                                    if nextName != -1 && (!exists('t:NERDTreeBufName') || nextName != t:NERDTreeBufName)
                                        call add(treeBufNames, nextName)
                                    endif
                                endfor
                                let treeBufNames = self._uniq(treeBufNames)
                            
                                "map the option names (that the user will be prompted with) to the nerd
                                "tree buffer names
                                let options = {}
                                let i = 0
                                while i < len(treeBufNames)
                                    let bufName = treeBufNames[i]
                                    let treeRoot = getbufvar(bufName, 'NERDTree').root
                                    let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
                                    let i = i + 1
                                endwhile
                            
                                "work out which tree to mirror, if there is more than 1 then ask the user
                                let bufferName = ''
                                if len(keys(options)) > 1
                                    let choices = ['Choose a tree to mirror']
                                    let choices = extend(choices, sort(keys(options)))
                                    let choice = inputlist(choices)
                                    if choice < 1 || choice > len(options) || choice ==# ''
                                        return
                                    endif
                            
                                    let bufferName = options[sort(keys(options))[choice-1]]
                                elseif len(keys(options)) ==# 1
                                    let bufferName = values(options)[0]
                                else
                                    call nerdtree#echo('No trees to mirror')
                                    return
                                endif
                            
                                if g:NERDTree.ExistsForTab() && g:NERDTree.IsOpen()
                                    call g:NERDTree.Close()
                                endif
                            
                                let t:NERDTreeBufName = bufferName
                                call self._createTreeWin()
                                exec 'buffer ' .  bufferName
                                call b:NERDTree.ui.restoreScreenState()
                                if !&hidden
                                    call b:NERDTree.render()
                                endif
                            endfunction
                            
                            " FUNCTION: s:Creator._createTreeWin() {{{1
                            " Initialize the NERDTree window.  Open the window, size it properly, set all
                            " local options, etc.
    1              0.000000000 function! s:Creator._createTreeWin()
                                let l:splitLocation = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'top' ? 'topleft ' : 'botright '
                                let l:splitDirection = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'right' ? 'vertical' : ''
                                let l:splitSize = g:NERDTreeWinSize
                            
                                if !g:NERDTree.ExistsForTab()
                                    let t:NERDTreeBufName = self._nextBufferName('tab')
                                    silent! execute l:splitLocation . l:splitDirection . ' ' . l:splitSize . ' new'
                                    silent! execute 'edit ' . t:NERDTreeBufName
                                    silent! execute l:splitDirection . ' resize '. l:splitSize
                                else
                                    silent! execute l:splitLocation . l:splitDirection . ' ' . l:splitSize . ' split'
                                    silent! execute 'buffer ' . t:NERDTreeBufName
                                endif
                            
                                setlocal winfixwidth
                            
                                call self._setCommonBufOptions()
                            
                                if has('patch-7.4.1925')
                                    clearjumps
                                endif
                            
                            endfunction
                            
                            " FUNCTION: s:Creator._isBufHidden(nr) {{{1
    1              0.000000000 function! s:Creator._isBufHidden(nr)
                                redir => bufs
                                silent ls!
                                redir END
                            
                                return bufs =~ a:nr . '..h'
                            endfunction
                            
                            " FUNCTION: s:Creator.New() {{{1
    1              0.000000000 function! s:Creator.New()
                                let newCreator = copy(self)
                                return newCreator
                            endfunction
                            
                            " FUNCTION: s:Creator._nextBufferName(type='') {{{1
                            " gets an optional buffer type of either 'tab' or 'win'.
                            " returns the buffer name for the next nerd tree of such type.
    1              0.000001000 function! s:Creator._nextBufferName(...)
                                if a:0 > 0
                                    let type = a:1
                                else
                                    let type = ''
                                end
                                let name = s:Creator.BufNamePrefix()
                                if type ==# 'tab'
                                    let name = name . 'tab_'
                                elseif type ==# 'win'
                                    let name = name . 'win_'
                                endif
                                let name = name . self._nextBufferNumber()
                                return name
                            endfunction
                            
                            " FUNCTION: s:Creator._nextBufferNumber() {{{1
                            " the number to add to the nerd tree buffer name to make the buf name unique
    1              0.000000000 function! s:Creator._nextBufferNumber()
                                if !exists('s:Creator._NextBufNum')
                                    let s:Creator._NextBufNum = 1
                                else
                                    let s:Creator._NextBufNum += 1
                                endif
                            
                                return s:Creator._NextBufNum
                            endfunction
                            
                            " FUNCTION: s:Creator._pathForString(str) {{{1
                            " find a bookmark or adirectory for the given string
    1              0.000001000 function! s:Creator._pathForString(str)
                                let path = {}
                                if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
                                else
                                    let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
                                    if dir =~# '^\.'
                                        let dir = getcwd() . nerdtree#slash() . dir
                                    endif
                            
                                    "hack to prevent removing slash if dir is the root of the file system.
                                    if dir !=# '/'
                                        let dir = g:NERDTreePath.Resolve(dir)
                                    endif
                            
                                    try
                                        let path = g:NERDTreePath.New(dir)
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('No bookmark or directory found for: ' . a:str)
                                        return {}
                                    endtry
                                endif
                                if !path.isDirectory
                                    let path = path.getParent()
                                endif
                            
                                return path
                            endfunction
                            
                            " Function: s:Creator._removeTreeBufForTab()   {{{1
    1              0.000001000 function! s:Creator._removeTreeBufForTab()
                                let buf = bufnr(t:NERDTreeBufName)
                            
                                "if &hidden is not set then it will already be gone
                                if buf != -1
                            
                                    "nerdtree buf may be mirrored/displayed elsewhere
                                    if self._isBufHidden(buf)
                                        exec 'bwipeout ' . buf
                                    endif
                            
                                endif
                            
                                unlet t:NERDTreeBufName
                            endfunction
                            
                            " FUNCTION: s:Creator._setCommonBufOptions() {{{1
    1              0.000000000 function! s:Creator._setCommonBufOptions()
                            
                                " Options for a non-file/control buffer.
                                setlocal bufhidden=hide
                                setlocal buftype=nofile
                                setlocal noswapfile
                            
                                " Options for controlling buffer/window appearance.
                                setlocal foldcolumn=0
                                setlocal foldmethod=manual
                                setlocal nobuflisted
                                setlocal nofoldenable
                                setlocal nolist
                                setlocal nospell
                                setlocal nowrap
                            
                                if g:NERDTreeShowLineNumbers
                                    setlocal number
                                else
                                    setlocal nonumber
                                    if v:version >= 703
                                        setlocal norelativenumber
                                    endif
                                endif
                            
                                iabc <buffer>
                            
                                if g:NERDTreeHighlightCursorline
                                    setlocal cursorline
                                endif
                            
                                call self._setupStatusline()
                                call self._bindMappings()
                            
                                setlocal filetype=nerdtree
                            endfunction
                            
                            " FUNCTION: s:Creator._setupStatusline() {{{1
    1              0.000000000 function! s:Creator._setupStatusline()
                                if g:NERDTreeStatusline != -1
                                    let &l:statusline = g:NERDTreeStatusline
                                endif
                            endfunction
                            
                            " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
    1              0.000000000 function! s:Creator._tabpagevar(tabnr, var)
                                let currentTab = tabpagenr()
                                let old_ei = &eventignore
                                set eventignore=all
                            
                                try
                                    exec 'tabnext ' . a:tabnr
                                    let v = -1
                                    if exists('t:' . a:var)
                                        exec 'let v = t:' . a:var
                                    endif
                                    exec 'tabnext ' . currentTab
                            
                                finally
                                    let &eventignore = old_ei
                                endtry
                            
                                return v
                            endfunction
                            
                            " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
    1              0.000001000 function! s:Creator.ToggleTabTree(dir)
                                let creator = s:Creator.New()
                                call creator.toggleTabTree(a:dir)
                            endfunction
                            
                            " FUNCTION: s:Creator.toggleTabTree(dir) {{{1
                            " Toggles the NERD tree. I.e if the NERD tree is open, it is closed. If it is
                            " closed, it is restored or initialized. If dir is not empty, it will be set
                            " as the new root.
                            "
                            " Args:
                            " dir: the full path for the root node (is used if the NERD tree is being
                            " initialized, or to change the root to a new dir.)
    1              0.000000000 function! s:Creator.toggleTabTree(dir)
                                if g:NERDTree.ExistsForTab()
                                    if !g:NERDTree.IsOpen()
                                        call self._createTreeWin()
                                        if !empty(a:dir) && a:dir !=# b:NERDTree.root.path.str()
                                            call self.createTabTree(a:dir)
                                        elseif !&hidden
                                            call b:NERDTree.render()
                                        endif
                                        call b:NERDTree.ui.restoreScreenState()
                                    else
                                        call g:NERDTree.Close()
                                    endif
                                else
                                    call self.createTabTree(a:dir)
                                endif
                            endfunction
                            
                            " Function: s:Creator._uniq(list)   {{{1
                            " returns a:list without duplicates
    1              0.000000000 function! s:Creator._uniq(list)
                              let uniqlist = []
                              for elem in a:list
                                if index(uniqlist, elem) ==# -1
                                  let uniqlist += [elem]
                                endif
                              endfor
                              return uniqlist
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim
Sourced 1 time
Total time:   0.000026000
 Self time:   0.000026000

count     total (s)      self (s)
                            "CLASS: FlagSet
                            "============================================================
    1              0.000001000 let s:FlagSet = {}
    1              0.000001000 let g:NERDTreeFlagSet = s:FlagSet
                            
                            "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
    1              0.000000000 function! s:FlagSet.addFlag(scope, flag)
                                let flags = self._flagsForScope(a:scope)
                                if index(flags, a:flag) == -1
                                    call add(flags, a:flag)
                                end
                            endfunction
                            
                            "FUNCTION: FlagSet.clearFlags(scope) {{{1
    1              0.000001000 function! s:FlagSet.clearFlags(scope)
                                let self._flags[a:scope] = []
                            endfunction
                            
                            "FUNCTION: FlagSet._flagsForScope(scope) {{{1
    1              0.000001000 function! s:FlagSet._flagsForScope(scope)
                                if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
                                return self._flags[a:scope]
                            endfunction
                            
                            "FUNCTION: FlagSet.New() {{{1
    1              0.000000000 function! s:FlagSet.New()
                                let newObj = copy(self)
                                let newObj._flags = {}
                                return newObj
                            endfunction
                            
                            "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
    1              0.000000000 function! s:FlagSet.removeFlag(scope, flag)
                                let flags = self._flagsForScope(a:scope)
                            
                                let i = index(flags, a:flag)
                                if i >= 0
                                    call remove(flags, i)
                                endif
                            endfunction
                            
                            "FUNCTION: FlagSet.renderToString() {{{1
    1              0.000001000 function! s:FlagSet.renderToString()
                                let flagstring = ''
                                for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
                                if len(flagstring) == 0
                                    return ''
                                endif
                            
                                return '[' . flagstring . ']'
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim
Sourced 1 time
Total time:   0.000066000
 Self time:   0.000066000

count     total (s)      self (s)
                            "CLASS: NERDTree
                            "============================================================
    1              0.000002000 let s:NERDTree = {}
    1              0.000001000 let g:NERDTree = s:NERDTree
                            
                            "FUNCTION: s:NERDTree.AddPathFilter() {{{1
    1              0.000001000 function! s:NERDTree.AddPathFilter(callback)
                                call add(s:NERDTree.PathFilters(), a:callback)
                            endfunction
                            
                            "FUNCTION: s:NERDTree.changeRoot(node) {{{1
    1              0.000001000 function! s:NERDTree.changeRoot(node)
                                if a:node.path.isDirectory
                                    let self.root = a:node
                                else
                                    call a:node.cacheParent()
                                    let self.root = a:node.parent
                                endif
                            
                                call self.root.open()
                            
                                "change dir to the dir of the new root if instructed to
                                if g:NERDTreeChDirMode >= 2
                                    call self.root.path.changeToDir()
                                endif
                            
                                call self.render()
                                call self.root.putCursorHere(0, 0)
                            
                                if exists('#User#NERDTreeNewRoot')
                                    doautocmd User NERDTreeNewRoot
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.Close() {{{1
                            "Closes the tab tree window for this tab
    1              0.000001000 function! s:NERDTree.Close()
                                if !s:NERDTree.IsOpen()
                                    return
                                endif
                            
                                if winnr('$') !=# 1
                                    " Use the window ID to identify the currently active window or fall
                                    " back on the buffer ID if win_getid/win_gotoid are not available, in
                                    " which case we'll focus an arbitrary window showing the buffer.
                                    let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
                            
                                    if winnr() ==# s:NERDTree.GetWinNum()
                                        call nerdtree#exec('wincmd p', 1)
                                        let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
                                        call nerdtree#exec('wincmd p', 1)
                                    else
                                        let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
                                    endif
                            
                                    call nerdtree#exec(s:NERDTree.GetWinNum() . ' wincmd w', 1)
                                    call nerdtree#exec('close', 0)
                                    if l:useWinId
                                        call nerdtree#exec('call win_gotoid(' . l:activeBufOrWin . ')', 0)
                                    else
                                        call nerdtree#exec(bufwinnr(l:activeBufOrWin) . ' wincmd w', 0)
                                    endif
                                else
                                    close
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
                            "Places the cursor at the top of the bookmarks table
    1              0.000000000 function! s:NERDTree.CursorToBookmarkTable()
                                if !b:NERDTree.ui.getShowBookmarks()
                                    throw 'NERDTree.IllegalOperationError: cant find bookmark table, bookmarks arent active'
                                endif
                            
                                if g:NERDTreeMinimalUI
                                    return cursor(1, 2)
                                endif
                            
                                let rootNodeLine = b:NERDTree.ui.getRootLineNum()
                            
                                let line = 1
                                while getline(line) !~# '^>-\+Bookmarks-\+$'
                                    let line = line + 1
                                    if line >= rootNodeLine
                                        throw 'NERDTree.BookmarkTableNotFoundError: didnt find the bookmarks table'
                                    endif
                                endwhile
                                call cursor(line, 2)
                            endfunction
                            
                            "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
                            "Places the cursor in the nerd tree window
    1              0.000000000 function! s:NERDTree.CursorToTreeWin(...)
                                call g:NERDTree.MustBeOpen()
                                call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)
                            endfunction
                            
                            " Function: s:NERDTree.ExistsForBuffer()   {{{1
                            " Returns 1 if a nerd tree root exists in the current buffer
    1              0.000000000 function! s:NERDTree.ExistsForBuf()
                                return exists('b:NERDTree')
                            endfunction
                            
                            " Function: s:NERDTree.ExistsForTab()   {{{1
                            " Returns 1 if a nerd tree root exists in the current tab
    1              0.000000000 function! s:NERDTree.ExistsForTab()
                                if !exists('t:NERDTreeBufName')
                                    return
                                end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
                                return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))
                            endfunction
                            
    1              0.000001000 function! s:NERDTree.ForCurrentBuf()
                                if s:NERDTree.ExistsForBuf()
                                    return b:NERDTree
                                else
                                    return {}
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
    1              0.000000000 function! s:NERDTree.ForCurrentTab()
                                if !s:NERDTree.ExistsForTab()
                                    return
                                endif
                            
                                let bufnr = bufnr(t:NERDTreeBufName)
                                return getbufvar(bufnr, 'NERDTree')
                            endfunction
                            
                            "FUNCTION: s:NERDTree.getRoot() {{{1
    1              0.000000000 function! s:NERDTree.getRoot()
                                return self.root
                            endfunction
                            
                            "FUNCTION: s:NERDTree.GetWinNum() {{{1
                            "gets the nerd tree window number for this tab
    1              0.000002000 function! s:NERDTree.GetWinNum()
                                if exists('t:NERDTreeBufName')
                                    return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'win_\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1
                            endfunction
                            
                            "FUNCTION: s:NERDTree.IsOpen() {{{1
    1              0.000001000 function! s:NERDTree.IsOpen()
                                return s:NERDTree.GetWinNum() !=# -1
                            endfunction
                            
                            "FUNCTION: s:NERDTree.isTabTree() {{{1
    1              0.000000000 function! s:NERDTree.isTabTree()
                                return self._type ==# 'tab'
                            endfunction
                            
                            "FUNCTION: s:NERDTree.isWinTree() {{{1
    1              0.000001000 function! s:NERDTree.isWinTree()
                                return self._type ==# 'window'
                            endfunction
                            
                            "FUNCTION: s:NERDTree.MustBeOpen() {{{1
    1              0.000000000 function! s:NERDTree.MustBeOpen()
                                if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.New() {{{1
    1              0.000001000 function! s:NERDTree.New(path, type)
                                let newObj = copy(self)
                                let newObj.ui = g:NERDTreeUI.New(newObj)
                                let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
                                let newObj._type = a:type
                                return newObj
                            endfunction
                            
                            "FUNCTION: s:NERDTree.PathFilters() {{{1
    1              0.000000000 function! s:NERDTree.PathFilters()
                                if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
                                return s:NERDTree._PathFilters
                            endfunction
                            
                            "FUNCTION: s:NERDTree.previousBuf() {{{1
    1              0.000001000 function! s:NERDTree.previousBuf()
                                return self._previousBuf
                            endfunction
                            
    1              0.000000000 function! s:NERDTree.setPreviousBuf(bnum)
                                let self._previousBuf = a:bnum
                            endfunction
                            
                            "FUNCTION: s:NERDTree.render() {{{1
                            "A convenience function - since this is called often
    1              0.000000000 function! s:NERDTree.render()
                                call self.ui.render()
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/ui.vim
Sourced 1 time
Total time:   0.000165000
 Self time:   0.000165000

count     total (s)      self (s)
                            " ============================================================================
                            " CLASS: UI
                            " ============================================================================
                            
                            
    1              0.000001000 let s:UI = {}
    1              0.000001000 let g:NERDTreeUI = s:UI
                            
                            " FUNCTION: s:UI.centerView() {{{1
                            " centers the nerd tree window around the cursor (provided the nerd tree
                            " options permit)
    1              0.000000000 function! s:UI.centerView()
                                if g:NERDTreeAutoCenter
                                    let current_line = winline()
                                    let lines_to_top = current_line
                                    let lines_to_bottom = winheight(g:NERDTree.GetWinNum()) - current_line
                                    if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
                                        normal! zz
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:UI._dumpHelp  {{{1
                            " prints out the quick help
    1              0.000000000 function! s:UI._dumpHelp()
                                if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapJumpBookmarks .": jump to bookmark table\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFileLines .': files lines (' . (self.getShowFileLines() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
                                    let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
                                endif
                            endfunction
                            
                            
                            " FUNCTION: s:UI.new(nerdtree) {{{1
    1              0.000001000 function! s:UI.New(nerdtree)
                                let newObj = copy(self)
                                let newObj.nerdtree = a:nerdtree
                                let newObj._showHelp = 0
                                let newObj._ignoreEnabled = 1
                                let newObj._showFiles = g:NERDTreeShowFiles
                                let newObj._showHidden = g:NERDTreeShowHidden
                                let newObj._showBookmarks = g:NERDTreeShowBookmarks
                                let newObj._showFileLines = g:NERDTreeFileLines
                            
                                return newObj
                            endfunction
                            
                            " FUNCTION: s:UI.getPath(ln) {{{1
                            " Return the Path object for the node that is rendered on the given line
                            " number.  If the 'up a dir' line is selected, return the Path object for
                            " the parent of the root.  Return the empty dictionary if the given line
                            " does not reference a tree node.
    1              0.000001000 function! s:UI.getPath(ln)
                                let line = getline(a:ln)
                            
                                let rootLine = self.getRootLineNum()
                            
                                if a:ln ==# rootLine
                                    return self.nerdtree.root.path
                                endif
                            
                                if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
                                if a:ln < rootLine
                                    return {}
                                endif
                            
                                let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
                                let curFile = self._stripMarkup(line)
                            
                                let dir = ''
                                let lnum = a:ln
                                while lnum > 0
                                    let lnum = lnum - 1
                                    let curLine = getline(lnum)
                                    let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
                                    if lnum ==# rootLine
                                        let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
                                        break
                                    endif
                                    if curLineStripped =~# '/$'
                                        let lpindent = self._indentLevelFor(curLine)
                                        if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', '', '') . dir
                                            continue
                                        endif
                                    endif
                                endwhile
                                let curFile = self.nerdtree.root.path.drive . dir . curFile
                                let toReturn = g:NERDTreePath.New(curFile)
                                return toReturn
                            endfunction
                            
                            " FUNCTION: s:UI.getLineNum(node) {{{1
                            " Return the line number where the given node is rendered.  Return -1 if the
                            " given node is not visible.
    1              0.000001000 function! s:UI.getLineNum(node)
                            
                                if a:node.isRoot()
                                    return self.getRootLineNum()
                                endif
                            
                                let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
                                let l:currentPathComponent = 1
                            
                                let l:fullPath = a:node.path.str({'format': 'UI'})
                            
                                for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
                                    let l:currentLine = getline(l:lineNumber)
                                    let l:indentLevel = self._indentLevelFor(l:currentLine)
                            
                                    if l:indentLevel !=# l:currentPathComponent
                                        continue
                                    endif
                            
                                    let l:currentLine = self._stripMarkup(l:currentLine)
                                    let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                            
                                    " Directories: If the current path 'starts with' the full path, then
                                    " either the paths are equal or the line is a cascade containing the
                                    " full path.
                                    if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
                                        return l:lineNumber
                                    endif
                            
                                    " Files: The paths must exactly match.
                                    if l:fullPath ==# l:currentPath
                                        return l:lineNumber
                                    endif
                            
                                    " Otherwise: If the full path starts with the current path and the
                                    " current path is a directory, we add a new path component.
                                    if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
                                        let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
                                        call add(l:pathComponents, l:currentLine)
                                        let l:currentPathComponent += 1
                                    endif
                                endfor
                            
                                return -1
                            endfunction
                            
                            " FUNCTION: s:UI.getRootLineNum(){{{1
                            " gets the line number of the root node
    1              0.000001000 function! s:UI.getRootLineNum()
                                let rootLine = 1
                                while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
                                endwhile
                                return rootLine
                            endfunction
                            
                            " FUNCTION: s:UI.getShowBookmarks() {{{1
    1              0.000001000 function! s:UI.getShowBookmarks()
                                return self._showBookmarks
                            endfunction
                            
                            " FUNCTION: s:UI.getShowFiles() {{{1
    1              0.000000000 function! s:UI.getShowFiles()
                                return self._showFiles
                            endfunction
                            
                            " FUNCTION: s:UI.getShowHelp() {{{1
    1              0.000001000 function! s:UI.getShowHelp()
                                return self._showHelp
                            endfunction
                            
                            " FUNCTION: s:UI.getShowHidden() {{{1
    1              0.000000000 function! s:UI.getShowHidden()
                                return self._showHidden
                            endfunction
                            
                            " FUNCTION: s:UI.getShowFileLines() {{{1
    1              0.000001000 function! s:UI.getShowFileLines()
                                return self._showFileLines
                            endfunction
                            
                            " FUNCTION: s:UI._indentLevelFor(line) {{{1
    1              0.000001000 function! s:UI._indentLevelFor(line)
                                " Replace multi-character DirArrows with a single space so the
                                " indentation calculation doesn't get messed up.
                                if g:NERDTreeDirArrowExpandable ==# ''
                                    let l:line = '  '.a:line
                                else
                                    let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
                                endif
                                let leadChars = match(l:line, '\M\[^ ]')
                                return leadChars / s:UI.IndentWid()
                            endfunction
                            
                            " FUNCTION: s:UI.IndentWid() {{{1
    1              0.000000000 function! s:UI.IndentWid()
                                return 2
                            endfunction
                            
                            " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
    1              0.000001000 function! s:UI.isIgnoreFilterEnabled()
                                return self._ignoreEnabled ==# 1
                            endfunction
                            
                            " FUNCTION: s:UI.isMinimal() {{{1
    1              0.000000000 function! s:UI.isMinimal()
                                return g:NERDTreeMinimalUI
                            endfunction
                            
                            " FUNCTION: s:UI.MarkupReg() {{{1
    1              0.000000000 function! s:UI.MarkupReg()
                                return '^ *['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']\? '
                            endfunction
                            
                            " FUNCTION: s:UI._renderBookmarks {{{1
    1              0.000001000 function! s:UI._renderBookmarks()
                            
                                if !self.isMinimal()
                                    call setline(line('.')+1, '>----------Bookmarks----------')
                                    call cursor(line('.')+1, col('.'))
                                endif
                            
                                if g:NERDTreeBookmarksSort ==# 1 || g:NERDTreeBookmarksSort ==# 2
                                    call g:NERDTreeBookmark.SortBookmarksList()
                                endif
                            
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    call setline(line('.')+1, i.str())
                                    call cursor(line('.')+1, col('.'))
                                endfor
                            
                                call setline(line('.')+1, '')
                                call cursor(line('.')+1, col('.'))
                            endfunction
                            
                            " FUNCTION: s:UI.restoreScreenState() {{{1
                            "
                            " Sets the screen state back to what it was when nerdtree#saveScreenState was last
                            " called.
                            "
                            " Assumes the cursor is in the NERDTree window
    1              0.000000000 function! s:UI.restoreScreenState()
                                if !has_key(self, '_screenState')
                                    return
                                endif
                                call nerdtree#exec('silent vertical resize ' . self._screenState['oldWindowSize'], 1)
                            
                                let old_scrolloff=&scrolloff
                                let &scrolloff=0
                                call cursor(self._screenState['oldTopLine'], 0)
                                normal! zt
                                call setpos('.', self._screenState['oldPos'])
                                let &scrolloff=old_scrolloff
                            endfunction
                            
                            " FUNCTION: s:UI.saveScreenState() {{{1
                            " Saves the current cursor position in the current buffer and the window
                            " scroll position
    1              0.000001000 function! s:UI.saveScreenState()
                                let win = winnr()
                                let self._screenState = {}
                                try
                                    call g:NERDTree.CursorToTreeWin()
                                    let self._screenState['oldPos'] = getpos('.')
                                    let self._screenState['oldTopLine'] = line('w0')
                                    let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
                                    call nerdtree#exec(win . 'wincmd w', 1)
                                catch
                                endtry
                            endfunction
                            
                            " FUNCTION: s:UI.setShowHidden(val) {{{1
    1              0.000001000 function! s:UI.setShowHidden(val)
                                let self._showHidden = a:val
                            endfunction
                            
                            " FUNCTION: s:UI._stripMarkup(line){{{1
                            " find the filename in the given line, and return it.
                            "
                            " Args:
                            " line: the subject line
    1              0.000000000 function! s:UI._stripMarkup(line)
                                let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
                                return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')
                            endfunction
                            
                            " FUNCTION: s:UI.render() {{{1
    1              0.000000000 function! s:UI.render()
                                setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
                                let curLine = line('.')
                                let curCol = col('.')
                                let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
                                silent 1,$delete _
                            
                                call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
                                if !self.isMinimal()
                                    call setline(line('.')+1, '')
                                    call cursor(line('.')+1, col('.'))
                                endif
                            
                                if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                " add the 'up a dir' line
                                if !self.isMinimal()
                                    call setline(line('.')+1, s:UI.UpDirLine())
                                    call cursor(line('.')+1, col('.'))
                                endif
                            
                                " draw the header line
                                let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
                                call setline(line('.')+1, header)
                                call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
                                silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
                                silent 1,1delete _
                            
                                " restore the view
                                let old_scrolloff=&scrolloff
                                let &scrolloff=0
                                call cursor(topLine, 1)
                                normal! zt
                                call cursor(curLine, curCol)
                                let &scrolloff = old_scrolloff
                            
                                setlocal readonly nomodifiable
                            endfunction
                            
                            
                            " FUNCTION: UI.renderViewSavingPosition {{{1
                            " Renders the tree and ensures the cursor stays on the current node or the
                            " current nodes parent if it is no longer available upon re-rendering
    1              0.000001000 function! s:UI.renderViewSavingPosition()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                            
                                " go up the tree till we find a node that will be visible or till we run
                                " out of nodes
                                while currentNode !=# {} && !currentNode.isVisible() && !currentNode.isRoot()
                                    let currentNode = currentNode.parent
                                endwhile
                            
                                call self.render()
                            
                                if currentNode !=# {}
                                    call currentNode.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:UI.toggleHelp() {{{1
    1              0.000000000 function! s:UI.toggleHelp()
                                let self._showHelp = !self._showHelp
                            endfunction
                            
                            " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
                            " toggles the use of the NERDTreeIgnore option
    1              0.000000000 function! s:UI.toggleIgnoreFilter()
                                let self._ignoreEnabled = !self._ignoreEnabled
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.setShowBookmarks() {{{1
                            " Sets the visibility of the Bookmark table.
    1              0.000001000 function! s:UI.setShowBookmarks(value)
                                let self._showBookmarks = a:value
                            
                                if self.getShowBookmarks()
                                    call self.nerdtree.render()
                                    call g:NERDTree.CursorToBookmarkTable()
                                else
                            
                                    if empty(g:NERDTreeFileNode.GetSelected())
                                        call b:NERDTree.root.putCursorHere(0, 0)
                                        normal! 0
                                    endif
                            
                                    call self.renderViewSavingPosition()
                                endif
                            
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowBookmarks() {{{1
                            " Toggle the visibility of the Bookmark table.
    1              0.000000000 function! s:UI.toggleShowBookmarks()
                                call self.setShowBookmarks(!self._showBookmarks)
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowFiles() {{{1
                            " toggles the display of hidden files
    1              0.000001000 function! s:UI.toggleShowFiles()
                                let self._showFiles = !self._showFiles
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowHidden() {{{1
                            " toggles the display of hidden files
    1              0.000000000 function! s:UI.toggleShowHidden()
                                let self._showHidden = !self._showHidden
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowFileLines() {{{1
                            " toggles the display of file lines
    1              0.000001000 function! s:UI.toggleShowFileLines()
                                let self._showFileLines = !self._showFileLines
                                call self.nerdtree.root.refresh()
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleZoom() {{{1
                            " zoom (maximize/minimize) the NERDTree window
    1              0.000000000 function! s:UI.toggleZoom()
                                if exists('b:NERDTreeZoomed') && b:NERDTreeZoomed
                                    setlocal nowinfixwidth
                                    wincmd =
                                    setlocal winfixwidth
                                    call nerdtree#exec('silent vertical resize '. g:NERDTreeWinSize, 1)
                                    let b:NERDTreeZoomed = 0
                                else
                                    call nerdtree#exec('vertical resize '. get(g:, 'NERDTreeWinSizeMax', ''), 1)
                                    let b:NERDTreeZoomed = 1
                                endif
                            endfunction
                            
                            " FUNCTION: s:UI.UpDirLine() {{{1
    1              0.000001000 function! s:UI.UpDirLine()
                                return '.. (up a dir)'
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/event.vim
Sourced 1 time
Total time:   0.000009000
 Self time:   0.000009000

count     total (s)      self (s)
                            "CLASS: Event
                            "============================================================
    1              0.000002000 let s:Event = {}
    1              0.000001000 let g:NERDTreeEvent = s:Event
                            
    1              0.000001000 function! s:Event.New(nerdtree, subject, action, params) abort
                                let newObj = copy(self)
                                let newObj.nerdtree = a:nerdtree
                                let newObj.subject = a:subject
                                let newObj.action = a:action
                                let newObj.params = a:params
                                return newObj
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim
Sourced 1 time
Total time:   0.000018000
 Self time:   0.000018000

count     total (s)      self (s)
                            "CLASS: Notifier
                            "============================================================
    1              0.000001000 let s:Notifier = {}
                            
    1              0.000001000 function! s:Notifier.AddListener(event, funcname)
                                let listeners = s:Notifier.GetListenersForEvent(a:event)
                                if listeners == []
                                    let listenersMap = s:Notifier.GetListenersMap()
                                    let listenersMap[a:event] = listeners
                                endif
                                call add(listeners, a:funcname)
                            endfunction
                            
    1              0.000001000 function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
                                let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
                                for Listener in s:Notifier.GetListenersForEvent(a:event)
                                    let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
                                    call l:Callback(event)
                                endfor
                            endfunction
                            
    1              0.000001000 function! s:Notifier.GetListenersMap()
                                if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
                                endif
                                return s:refreshListenersMap
                            endfunction
                            
    1              0.000001000 function! s:Notifier.GetListenersForEvent(name)
                                let listenersMap = s:Notifier.GetListenersMap()
                                return get(listenersMap, a:name, [])
                            endfunction
                            
    1              0.000003000 let g:NERDTreePathNotifier = deepcopy(s:Notifier)

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim
Sourced 1 time
Total time:   0.000249000
 Self time:   0.000249000

count     total (s)      self (s)
    1              0.000002000 if exists('g:loaded_nerdtree_ui_glue_autoload')
                                finish
    1              0.000000000 endif
    1              0.000002000 let g:loaded_nerdtree_ui_glue_autoload = 1
                            
                            " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
    1              0.000001000 function! nerdtree#ui_glue#createDefaultBindings() abort
                                let s = '<SNR>' . s:SID() . '_'
                            
                                call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
                                call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': 'all', 'callback': s.'handleLeftClick' })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'DirNode', 'callback': s.'activateDirNode' })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'FileNode', 'callback': s.'activateFileNode' })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'all', 'callback': s.'activateAll' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'FileNode', 'callback': s.'customOpenFile'})
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'DirNode', 'callback': s.'customOpenDir'})
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'Bookmark', 'callback': s.'customOpenBookmark'})
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'all', 'callback': s.'activateAll' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'DirNode', 'callback': s.'activateDirNode' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'FileNode', 'callback': s.'activateFileNode' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'Bookmark', 'callback': s.'previewBookmark' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'all', 'callback': s.'activateAll' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'FileNode', 'callback': s.'openHSplit' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'Bookmark', 'callback': s.'openHSplitBookmark' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'FileNode', 'callback': s.'openVSplit' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'Bookmark', 'callback': s.'openVSplitBookmark' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'FileNode', 'callback': s.'previewNodeCurrent' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'FileNode', 'callback': s.'previewNodeHSplit' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeHSplitBookmark' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'FileNode', 'callback': s.'previewNodeVSplit' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeVSplitBookmark' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': 'DirNode', 'callback': s.'openNodeRecursively' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': 'Node', 'callback': s.'chCwd' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': 'all', 'callback': s.'closeTreeWindow' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': 'all', 'callback': s.'refreshRoot' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': 'Node', 'callback': s.'refreshCurrent' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': 'all', 'callback': s.'displayHelp' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': 'all', 'callback': s.'toggleZoom' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': 'all', 'callback': s.'toggleShowHidden' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': 'all', 'callback': s.'toggleIgnoreFilter' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': 'all', 'callback': s.'toggleShowFiles' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': 'all', 'callback': s.'toggleShowBookmarks' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFileLines, 'scope': 'all', 'callback': s.'toggleShowFileLines' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': 'Node', 'callback': s.'closeCurrentDir' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': 'DirNode', 'callback': s.'closeChildren' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': 'Node', 'callback': s.'showMenu' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': 'Node', 'callback': s.'jumpToParent' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': 'Node', 'callback': s.'jumpToFirstChild' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': 'Node', 'callback': s.'jumpToLastChild' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': 'all', 'callback': s.'jumpToRoot' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': 'Node', 'callback': s.'jumpToNextSibling' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': 'Node', 'callback': s.'jumpToPrevSibling' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpBookmarks, 'scope': 'all', 'callback': s.'jumpToBookmarks' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'DirNode', 'callback': s.'openExplorer' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'FileNode', 'callback': s.'openExplorer' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': 'Bookmark', 'callback': s.'deleteBookmark' })
                            endfunction
                            
                            
                            "SECTION: Interface bindings {{{1
                            "============================================================
                            
                            "FUNCTION: s:customOpenFile() {{{1
                            " Open file node with the 'custom' key, initially <CR>.
    1              0.000001000 function! s:customOpenFile(node) abort
                                call a:node.activate(s:initCustomOpenArgs().file)
                            endfunction
                            
                            "FUNCTION: s:customOpenDir() {{{1
                            " Open directory node with the 'custom' key, initially <CR>.
    1              0.000000000 function! s:customOpenDir(node) abort
                                call s:activateDirNode(a:node, s:initCustomOpenArgs().dir)
                            endfunction
                            
                            "FUNCTION: s:customOpenBookmark() {{{1
                            " Open bookmark node with the 'custom' key, initially <CR>.
    1              0.000001000 function! s:customOpenBookmark(node) abort
                                if a:node.path.isDirectory
                                    call a:node.activate(b:NERDTree, s:initCustomOpenArgs().dir)
                                else
                                    call a:node.activate(b:NERDTree, s:initCustomOpenArgs().file)
                                endif
                            endfunction
                            
                            "FUNCTION: s:initCustomOpenArgs() {{{1
    1              0.000001000 function! s:initCustomOpenArgs() abort
                                let l:defaultOpenArgs = {'file': {'reuse': 'all', 'where': 'p', 'keepopen':!nerdtree#closeTreeOnOpen()}, 'dir': {}}
                                try
                                    let g:NERDTreeCustomOpenArgs = get(g:, 'NERDTreeCustomOpenArgs', {})
                                    call  extend(g:NERDTreeCustomOpenArgs, l:defaultOpenArgs, 'keep')
                                catch /^Vim(\a\+):E712:/
                                    call nerdtree#echoWarning('g:NERDTreeCustomOpenArgs is not set properly. Using default value.')
                                    let g:NERDTreeCustomOpenArgs = l:defaultOpenArgs
                                finally
                                    return g:NERDTreeCustomOpenArgs
                                endtry
                            endfunction
                            
                            "FUNCTION: s:activateAll() {{{1
                            "handle the user activating the updir line
    1              0.000000000 function! s:activateAll() abort
                                if getline('.') ==# g:NERDTreeUI.UpDirLine()
                                    return nerdtree#ui_glue#upDir(0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:activateDirNode(directoryNode, options) {{{1
                            " Open a directory with optional options
    1              0.000001000 function! s:activateDirNode(directoryNode, ...) abort
                            
                                if a:directoryNode.isRoot() && a:directoryNode.isOpen
                                    call nerdtree#echo('cannot close tree root')
                                    return
                                endif
                            
                                call a:directoryNode.activate((a:0 > 0) ? a:1 : {})
                            endfunction
                            
                            "FUNCTION: s:activateFileNode() {{{1
                            "handle the user activating a tree node
    1              0.000001000 function! s:activateFileNode(node) abort
                                call a:node.activate({'reuse': 'all', 'where': 'p', 'keepopen': !nerdtree#closeTreeOnOpen()})
                            endfunction
                            
                            "FUNCTION: s:activateBookmark(bookmark) {{{1
                            "handle the user activating a bookmark
    1              0.000001000 function! s:activateBookmark(bm) abort
                                call a:bm.activate(b:NERDTree, !a:bm.path.isDirectory ? {'where': 'p', 'keepopen': !nerdtree#closeTreeOnOpen()} : {})
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
                            " Associate the current node with the given name
    1              0.000001000 function! nerdtree#ui_glue#bookmarkNode(...) abort
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                if currentNode !=# {}
                                    let name = a:1
                                    if empty(name)
                                        let name = currentNode.path.getLastPathComponent(0)
                                    endif
                                    try
                                        call currentNode.bookmark(name)
                                        call b:NERDTree.render()
                                    catch /^NERDTree.IllegalBookmarkNameError/
                                        call nerdtree#echo('bookmark names must not contain spaces')
                                    endtry
                                else
                                    call nerdtree#echo('select a node first')
                                endif
                            endfunction
                            
                            " FUNCTION: s:chCwd(node) {{{1
    1              0.000001000 function! s:chCwd(node) abort
                                try
                                    call a:node.path.changeToDir()
                                catch /^NERDTree.PathChangeError/
                                    call nerdtree#echoWarning('could not change cwd')
                                endtry
                            endfunction
                            
                            " FUNCTION: s:chRoot(node) {{{1
                            " changes the current root to the selected one
    1              0.000001000 function! s:chRoot(node) abort
                                call b:NERDTree.changeRoot(a:node)
                            endfunction
                            
                            " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
                            " Change the NERDTree root to match the current working directory.
    1              0.000001000 function! nerdtree#ui_glue#chRootCwd() abort
                                NERDTreeCWD
                            endfunction
                            
                            " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
    1              0.000001000 function! nerdtree#ui_glue#clearBookmarks(bookmarks) abort
                                if a:bookmarks ==# ''
                                    let currentNode = g:NERDTreeFileNode.GetSelected()
                                    if currentNode !=# {}
                                        call currentNode.clearBookmarks()
                                    endif
                                else
                                    for name in split(a:bookmarks, ' ')
                                        let bookmark = g:NERDTreeBookmark.BookmarkFor(name)
                                        call bookmark.delete()
                                    endfor
                                endif
                                call b:NERDTree.root.refresh()
                                call b:NERDTree.render()
                            endfunction
                            
                            " FUNCTION: s:closeChildren(node) {{{1
                            " closes all childnodes of the current node
    1              0.000001000 function! s:closeChildren(node) abort
                                call a:node.closeChildren()
                                call b:NERDTree.render()
                                call a:node.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:closeCurrentDir(node) {{{1
                            " Close the parent directory of the current node.
    1              0.000000000 function! s:closeCurrentDir(node) abort
                            
                                if a:node.isRoot()
                                    call nerdtree#echo('cannot close parent of tree root')
                                    return
                                endif
                            
                                let l:parent = a:node.parent
                            
                                while l:parent.isCascadable()
                                    let l:parent = l:parent.parent
                                endwhile
                            
                                if l:parent.isRoot()
                                    call nerdtree#echo('cannot close tree root')
                                    return
                                endif
                            
                                call l:parent.close()
                                call b:NERDTree.render()
                                call l:parent.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:closeTreeWindow() {{{1
                            " close the tree window
    1              0.000001000 function! s:closeTreeWindow() abort
                                if b:NERDTree.isWinTree() && b:NERDTree.previousBuf() !=# -1
                                    exec 'buffer ' . b:NERDTree.previousBuf()
                                else
                                    if winnr('$') > 1
                                        call g:NERDTree.Close()
                                    else
                                        call nerdtree#echo('Cannot close last window')
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:deleteBookmark(bookmark) {{{1
                            " Prompt the user to confirm the deletion of the selected bookmark.
    1              0.000001000 function! s:deleteBookmark(bookmark) abort
                                let l:message = 'Delete the bookmark "' . a:bookmark.name
                                            \ . '" from the bookmark list?'
                            
                                let l:choices = "&Yes\n&No"
                            
                                echo | redraw
                                let l:selection = confirm(l:message, l:choices, 1, 'Warning')
                            
                                if l:selection !=# 1
                                    call nerdtree#echo('bookmark not deleted')
                                    return
                                endif
                            
                                try
                                    call a:bookmark.delete()
                                    silent call b:NERDTree.root.refresh()
                                    call b:NERDTree.render()
                                    echo | redraw
                                catch /^NERDTree/
                                    call nerdtree#echoWarning('could not remove bookmark')
                                endtry
                            endfunction
                            
                            " FUNCTION: s:displayHelp() {{{1
                            " toggles the help display
    1              0.000001000 function! s:displayHelp() abort
                                call b:NERDTree.ui.toggleHelp()
                                call b:NERDTree.render()
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:findAndRevealPath(pathStr) {{{1
    1              0.000000000 function! s:findAndRevealPath(pathStr) abort
                                let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
                                let l:revealOpts = {}
                            
                                if empty(l:pathStr)
                                    call nerdtree#echoWarning('no file for the current buffer')
                                    return
                                endif
                            
                                if !filereadable(l:pathStr)
                                    let l:pathStr = fnamemodify(l:pathStr, ':h')
                                    let l:revealOpts['open'] = 1
                                endif
                            
                                try
                                    let l:pathStr = g:NERDTreePath.Resolve(l:pathStr)
                                    let l:pathObj = g:NERDTreePath.New(l:pathStr)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('invalid path')
                                    return
                                endtry
                            
                                if !g:NERDTree.ExistsForTab()
                                    try
                                        let l:cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('current directory does not exist.')
                                        let l:cwd = l:pathObj.getParent()
                                    endtry
                            
                                    if l:pathObj.isUnder(l:cwd)
                                        call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
                                    endif
                                else
                                    NERDTreeFocus
                            
                                    if !l:pathObj.isUnder(b:NERDTree.root.path)
                                        call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
                                    endif
                                endif
                            
                                if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
                                    call b:NERDTree.ui.setShowHidden(1)
                                endif
                            
                                let l:node = b:NERDTree.root.reveal(l:pathObj, l:revealOpts)
                                call b:NERDTree.render()
                                call l:node.putCursorHere(1, 0)
                            endfunction
                            
                            "FUNCTION: s:handleLeftClick() {{{1
                            "Checks if the click should open the current node
    1              0.000000000 function! s:handleLeftClick() abort
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                if currentNode !=# {}
                            
                                    "the dir arrows are multibyte chars, and vim's string functions only
                                    "deal with single bytes - so split the line up with the hack below and
                                    "take the line substring manually
                                    let line = split(getline(line('.')), '\zs')
                                    let startToCur = ''
                                    for i in range(0,len(line)-1)
                                        let startToCur .= line[i]
                                    endfor
                            
                                    if currentNode.path.isDirectory
                                        if startToCur =~# g:NERDTreeUI.MarkupReg() && startToCur =~# '[+~'.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \?$'
                                            call currentNode.activate()
                                            return
                                        endif
                                    endif
                            
                                    if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
                                        let char = strpart(startToCur, strlen(startToCur)-1, 1)
                                        if char !~# g:NERDTreeUI.MarkupReg()
                                            if currentNode.path.isDirectory
                                                call currentNode.activate()
                                            else
                                                call currentNode.activate({'reuse': 'all', 'where': 'p', 'keepopen':!nerdtree#closeTreeOnOpen()})
                                            endif
                                            return
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:handleMiddleMouse() {{{1
    1              0.000001000 function! s:handleMiddleMouse() abort
                            
                                " A middle mouse click does not automatically position the cursor as one
                                " would expect. Forcing the execution of a regular left mouse click here
                                " fixes this problem.
                                execute "normal! \<LeftMouse>"
                            
                                let l:currentNode = g:NERDTreeFileNode.GetSelected()
                                if empty(l:currentNode)
                                    call nerdtree#echoError('use the pointer to select a node')
                                    return
                                endif
                            
                                if l:currentNode.path.isDirectory
                                    call l:currentNode.openExplorer()
                                else
                                    call l:currentNode.open({'where': 'h'})
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
                            "this is needed since I cant figure out how to invoke dict functions from a
                            "key map
    1              0.000001000 function! nerdtree#ui_glue#invokeKeyMap(key) abort
                                call g:NERDTreeKeyMap.Invoke(a:key)
                            endfunction
                            
                            " FUNCTION: s:jumpToFirstChild(node) {{{1
    1              0.000001000 function! s:jumpToFirstChild(node) abort
                                call s:jumpToChild(a:node, 0)
                            endfunction
                            
                            " FUNCTION: s:jumpToLastChild(node) {{{1
    1              0.000001000 function! s:jumpToLastChild(node) abort
                                call s:jumpToChild(a:node, 1)
                            endfunction
                            
                            " FUNCTION: s:jumpToChild(node, last) {{{1
                            " Jump to the first or last child node at the same file system level.
                            "
                            " Args:
                            " node: the node on which the cursor currently sits
                            " last: 1 (true) if jumping to last child, 0 (false) if jumping to first
    1              0.000001000 function! s:jumpToChild(node, last) abort
                                let l:node = a:node.path.isDirectory ? a:node.getCascadeRoot() : a:node
                            
                                if l:node.isRoot()
                                    return
                                endif
                            
                                let l:parent = l:node.parent
                                let l:children = l:parent.getVisibleChildren()
                            
                                let l:target = a:last ? l:children[len(l:children) - 1] : l:children[0]
                            
                                call l:target.putCursorHere(1, 0)
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:jumpToParent(node) {{{1
                            " Move the cursor to the parent of the specified node.  For a cascade, move to
                            " the parent of the cascade's first node.  At the root node, do nothing.
    1              0.000001000 function! s:jumpToParent(node) abort
                                let l:node = a:node.path.isDirectory ? a:node.getCascadeRoot() : a:node
                            
                                if l:node.isRoot()
                                    return
                                endif
                            
                                if empty(l:node.parent)
                                    call nerdtree#echo('could not jump to parent node')
                                    return
                                endif
                            
                                call l:node.parent.putCursorHere(1, 0)
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:jumpToRoot() {{{1
                            " moves the cursor to the root node
    1              0.000001000 function! s:jumpToRoot() abort
                                call b:NERDTree.root.putCursorHere(1, 0)
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:jumpToNextSibling(node) {{{1
    1              0.000001000 function! s:jumpToNextSibling(node) abort
                                call s:jumpToSibling(a:node, 1)
                            endfunction
                            
                            " FUNCTION: s:jumpToPrevSibling(node) {{{1
    1              0.000001000 function! s:jumpToPrevSibling(node) abort
                                call s:jumpToSibling(a:node, 0)
                            endfunction
                            
                            " FUNCTION: s:jumpToSibling(node, forward) {{{1
                            " Move the cursor to the next or previous node at the same file system level.
                            "
                            " Args:
                            " node: the node on which the cursor currently sits
                            " forward: 0 to jump to previous sibling, 1 to jump to next sibling
    1              0.000001000 function! s:jumpToSibling(node, forward) abort
                                let l:node = a:node.path.isDirectory ? a:node.getCascadeRoot() : a:node
                                let l:sibling = l:node.findSibling(a:forward)
                            
                                if empty(l:sibling)
                                    return
                                endif
                            
                                call l:sibling.putCursorHere(1, 0)
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:jumpToBookmarks() {{{1
                            " moves the cursor to the bookmark table
    1              0.000000000 function! s:jumpToBookmarks() abort
                                try
                                    if b:NERDTree.ui.getShowBookmarks()
                                        call g:NERDTree.CursorToBookmarkTable()
                                    else
                                        call b:NERDTree.ui.setShowBookmarks(1)
                                    endif
                                catch /^NERDTree/
                                    call nerdtree#echoError('Failed to jump to the bookmark table')
                                    return
                                endtry
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
                            " Open the Bookmark that has the specified name. This function provides the
                            " implementation for the :OpenBookmark command.
    1              0.000001000 function! nerdtree#ui_glue#openBookmark(name) abort
                                try
                                    let l:bookmark = g:NERDTreeBookmark.BookmarkFor(a:name)
                                catch /^NERDTree.BookmarkNotFoundError/
                                    call nerdtree#echoError('bookmark "' . a:name . '" not found')
                                    return
                                endtry
                                if l:bookmark.path.isDirectory
                                    call l:bookmark.open(b:NERDTree)
                                    return
                                endif
                            
                                call l:bookmark.open(b:NERDTree, s:initCustomOpenArgs().file)
                            endfunction
                            
                            " FUNCTION: s:openHSplit(target) {{{1
    1              0.000000000 function! s:openHSplit(target) abort
                                call a:target.activate({'where': 'h', 'keepopen': !nerdtree#closeTreeOnOpen()})
                            endfunction
                            
                            " FUNCTION: s:openVSplit(target) {{{1
    1              0.000001000 function! s:openVSplit(target) abort
                                call a:target.activate({'where': 'v', 'keepopen': !nerdtree#closeTreeOnOpen()})
                            endfunction
                            
                            "FUNCTION: s:openHSplitBookmark(bookmark) {{{1
                            "handle the user activating a bookmark
    1              0.000000000 function! s:openHSplitBookmark(bm) abort
                                call a:bm.activate(b:NERDTree, !a:bm.path.isDirectory ? {'where': 'h', 'keepopen': !nerdtree#closeTreeOnOpen()} : {})
                            endfunction
                            
                            "FUNCTION: s:openVSplitBookmark(bookmark) {{{1
                            "handle the user activating a bookmark
    1              0.000001000 function! s:openVSplitBookmark(bm) abort
                                call a:bm.activate(b:NERDTree, !a:bm.path.isDirectory ? {'where': 'v', 'keepopen': !nerdtree#closeTreeOnOpen()} : {})
                            endfunction
                            
                            " FUNCTION: s:previewHSplitBookmark(bookmark) {{{1
    1              0.000001000 function! s:previewNodeHSplitBookmark(bookmark) abort
                                call a:bookmark.activate(b:NERDTree, !a:bookmark.path.isDirectory ? {'stay': 1, 'where': 'h', 'keepopen': 1} : {})
                            endfunction
                            
                            " FUNCTION: s:previewVSplitBookmark(bookmark) {{{1
    1              0.000001000 function! s:previewNodeVSplitBookmark(bookmark) abort
                                call a:bookmark.activate(b:NERDTree, !a:bookmark.path.isDirectory ? {'stay': 1, 'where': 'v', 'keepopen': 1} : {})
                            endfunction
                            
                            " FUNCTION: s:openExplorer(node) {{{1
    1              0.000001000 function! s:openExplorer(node) abort
                                call a:node.openExplorer()
                            endfunction
                            
                            " FUNCTION: s:openInNewTab(target) {{{1
    1              0.000000000 function! s:openInNewTab(target) abort
                                let l:opener = g:NERDTreeOpener.New(a:target.path, {'where': 't', 'keepopen': !nerdtree#closeTreeOnOpen()})
                                call l:opener.open(a:target)
                            endfunction
                            
                            " FUNCTION: s:openInNewTabSilent(target) {{{1
    1              0.000001000 function! s:openInNewTabSilent(target) abort
                                let l:opener = g:NERDTreeOpener.New(a:target.path, {'where': 't', 'keepopen': !nerdtree#closeTreeOnOpen(), 'stay': 1})
                                call l:opener.open(a:target)
                            endfunction
                            
                            " FUNCTION: s:openNodeRecursively(node) {{{1
    1              0.000001000 function! s:openNodeRecursively(node) abort
                                call nerdtree#echo('Recursively opening node. Please wait...')
                                call a:node.openRecursively()
                                call b:NERDTree.render()
                                call nerdtree#echo('')
                            endfunction
                            
                            " FUNCTION: s:previewBookmark(bookmark) {{{1
    1              0.000000000 function! s:previewBookmark(bookmark) abort
                                if a:bookmark.path.isDirectory
                                    execute 'NERDTreeFind '.a:bookmark.path.str()
                                else
                                    call a:bookmark.activate(b:NERDTree, {'stay': 1, 'where': 'p', 'keepopen': 1})
                                endif
                            endfunction
                            
                            "FUNCTION: s:previewNodeCurrent(node) {{{1
    1              0.000000000 function! s:previewNodeCurrent(node) abort
                                call a:node.open({'stay': 1, 'where': 'p', 'keepopen': 1})
                            endfunction
                            
                            "FUNCTION: s:previewNodeHSplit(node) {{{1
    1              0.000000000 function! s:previewNodeHSplit(node) abort
                                call a:node.open({'stay': 1, 'where': 'h', 'keepopen': 1})
                            endfunction
                            
                            "FUNCTION: s:previewNodeVSplit(node) {{{1
    1              0.000001000 function! s:previewNodeVSplit(node) abort
                                call a:node.open({'stay': 1, 'where': 'v', 'keepopen': 1})
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
                            " put the cursor on the node associate with the given name
    1              0.000000000 function! nerdtree#ui_glue#revealBookmark(name) abort
                                try
                                    let targetNode = g:NERDTreeBookmark.GetNodeForName(a:name, 0, b:NERDTree)
                                    call targetNode.putCursorHere(0, 1)
                                catch /^NERDTree.BookmarkNotFoundError/
                                    call nerdtree#echo('Bookmark isn''t cached under the current root')
                                endtry
                            endfunction
                            
                            " FUNCTION: s:refreshRoot() {{{1
                            " Reloads the current root. All nodes below this will be lost and the root dir
                            " will be reloaded.
    1              0.000001000 function! s:refreshRoot() abort
                                if !g:NERDTree.IsOpen()
                                    return
                                endif
                                call nerdtree#echo('Refreshing the root node. This could take a while...')
                            
                                let l:curWin = winnr()
                                call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', 1)
                                call b:NERDTree.root.refresh()
                                call b:NERDTree.render()
                                redraw
                                call nerdtree#exec(l:curWin . 'wincmd w', 1)
                                call nerdtree#echo('')
                            endfunction
                            
                            " FUNCTION: s:refreshCurrent(node) {{{1
                            " refreshes the root for the current node
    1              0.000001000 function! s:refreshCurrent(node) abort
                                let node = a:node
                                if !node.path.isDirectory
                                    let node = node.parent
                                endif
                            
                                call nerdtree#echo('Refreshing node. This could take a while...')
                                call node.refresh()
                                call b:NERDTree.render()
                                call nerdtree#echo('')
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
    1              0.000001000 function! nerdtree#ui_glue#setupCommands() abort
                                command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
                                command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
                                command! -n=? -complete=dir -bar NERDTreeExplore :call g:NERDTreeCreator.CreateExploreTree('<args>')
                                command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
                                command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
                                command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
                                command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
                                command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
                                command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
                                command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
                            endfunction
                            
                            " Function: s:SID()   {{{1
    1              0.000000000 function! s:SID() abort
                                if !exists('s:sid')
                                    let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
                                endif
                                return s:sid
                            endfun
                            
                            " FUNCTION: s:showMenu(node) {{{1
    1              0.000001000 function! s:showMenu(node) abort
                                let mc = g:NERDTreeMenuController.New(g:NERDTreeMenuItem.AllEnabled())
                                call mc.showMenu()
                            endfunction
                            
                            " FUNCTION: s:toggleIgnoreFilter() {{{1
    1              0.000001000 function! s:toggleIgnoreFilter() abort
                                call b:NERDTree.ui.toggleIgnoreFilter()
                            endfunction
                            
                            " FUNCTION: s:toggleShowBookmarks() {{{1
    1              0.000001000 function! s:toggleShowBookmarks() abort
                                call b:NERDTree.ui.toggleShowBookmarks()
                            endfunction
                            
                            " FUNCTION: s:toggleShowFiles() {{{1
    1              0.000001000 function! s:toggleShowFiles() abort
                                call b:NERDTree.ui.toggleShowFiles()
                            endfunction
                            
                            " FUNCTION: s:toggleShowHidden() {{{1
                            " toggles the display of hidden files
    1              0.000001000 function! s:toggleShowHidden() abort
                                call b:NERDTree.ui.toggleShowHidden()
                            endfunction
                            
                            " FUNCTION: s:toggleShowFileLines() {{{1
                            " toggles the display of hidden files
    1              0.000001000 function! s:toggleShowFileLines() abort
                                call b:NERDTree.ui.toggleShowFileLines()
                            endfunction
                            
                            " FUNCTION: s:toggleZoom() {{{1
    1              0.000001000 function! s:toggleZoom() abort
                                call b:NERDTree.ui.toggleZoom()
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
                            " Move the NERDTree up one level.
                            "
                            " Args:
                            " preserveState: if 1, the current root is left open when the new tree is
                            " rendered; if 0, the current root node is closed
    1              0.000001000 function! nerdtree#ui_glue#upDir(preserveState) abort
                            
                                try
                                    call b:NERDTree.root.cacheParent()
                                catch /^NERDTree.CannotCacheParentError/
                                    call nerdtree#echo('already at root directory')
                                    return
                                endtry
                            
                                let l:oldRoot = b:NERDTree.root
                                let l:newRoot = b:NERDTree.root.parent
                            
                                call l:newRoot.open()
                                call l:newRoot.transplantChild(l:oldRoot)
                            
                                if !a:preserveState
                                    call l:oldRoot.close()
                                endif
                            
                                call b:NERDTree.changeRoot(l:newRoot)
                                call l:oldRoot.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:upDirCurrentRootOpen() {{{1
    1              0.000001000 function! s:upDirCurrentRootOpen() abort
                                call nerdtree#ui_glue#upDir(1)
                            endfunction
                            
                            " FUNCTION: s:upDirCurrentRootClosed() {{{1
    1              0.000001000 function! s:upDirCurrentRootClosed() abort
                                call nerdtree#ui_glue#upDir(0)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
Sourced 1 time
Total time:   0.000053000
 Self time:   0.000023000

count     total (s)      self (s)
                            " ============================================================================
                            " File:        exec_menuitem.vim
                            " Description: plugin for NERD Tree that provides an execute file menu item
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000002000 if exists('g:loaded_nerdtree_exec_menuitem')
                                finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_nerdtree_exec_menuitem = 1
                            
    1   0.000036000   0.000006000 call NERDTreeAddMenuItem({
                                        \ 'text': '(!)Execute file',
                                        \ 'shortcut': '!',
                                        \ 'callback': 'NERDTreeExecFile',
                                        \ 'isActiveCallback': 'NERDTreeExecFileActive' })
                            
    1              0.000001000 function! NERDTreeExecFileActive()
                                let node = g:NERDTreeFileNode.GetSelected()
                                return !node.path.isDirectory && node.path.isExecutable
                            endfunction
                            
    1              0.000000000 function! NERDTreeExecFile()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                echo "==========================================================\n"
                                echo "Complete the command to execute (add arguments etc):\n"
                                let cmd = treenode.path.str({'escape': 1})
                                let cmd = input(':!', cmd . ' ')
                            
                                if cmd !=# ''
                                    exec ':!' . cmd
                                else
                                    echo 'Aborted'
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
Sourced 1 time
Total time:   0.000475000
 Self time:   0.000250000

count     total (s)      self (s)
                            " ============================================================================
                            " File:        fs_menu.vim
                            " Description: plugin for the NERD Tree that provides a file system menu
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000002000 if exists('g:loaded_nerdtree_fs_menu')
                                finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_nerdtree_fs_menu = 1
                            
                            "Automatically delete the buffer after deleting or renaming a file
    1              0.000001000 if !exists('g:NERDTreeAutoDeleteBuffer')
    1              0.000001000     let g:NERDTreeAutoDeleteBuffer = 0
    1              0.000001000 endif
                            
    1   0.000025000   0.000004000 call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
    1   0.000022000   0.000003000 call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
    1   0.000021000   0.000003000 call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
                            
    1   0.000005000   0.000002000 if nerdtree#runningMac()
    1   0.000026000   0.000003000     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in the Finder', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
    1   0.000022000   0.000003000     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
    1   0.000022000   0.000003000     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
    1              0.000000000 endif
                            
    1              0.000030000 if executable('xdg-open')
                                call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
                                call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
    1              0.000000000 endif
                            
    1   0.000005000   0.000002000 if nerdtree#runningWindows()
                                call NERDTreeAddMenuItem({'text': '(r)eveal the current node in the Explorer', 'shortcut': 'r', 'callback': 'NERDTreeRevealInExplorer'})
                                call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileWindows'})
    1              0.000001000 endif
                            
    1   0.000005000   0.000003000 if g:NERDTreePath.CopyingSupported()
    1   0.000022000   0.000002000     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
    1              0.000001000 endif
    1   0.000023000   0.000003000 call NERDTreeAddMenuItem({'text': (has('clipboard')?'copy (p)ath to clipboard':'print (p)ath to screen'), 'shortcut': 'p', 'callback': 'NERDTreeCopyPath'})
                            
    1              0.000002000 if has('unix') || has('osx')
    1   0.000021000   0.000002000     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
    1   0.000022000   0.000002000     call NERDTreeAddMenuItem({'text': '(C)hange node permissions', 'shortcut':'C', 'callback': 'NERDTreeChangePermissions'})
                            else
                                call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
    1              0.000000000 endif
                            
    1              0.000001000 if exists('*system')
    1   0.000022000   0.000003000     call NERDTreeAddMenuItem({'text': 'Run (s)ystem command in this directory', 'shortcut':'s', 'callback': 'NERDTreeSystemCommand'})
    1              0.000000000 endif
                            
                            "FUNCTION: s:inputPrompt(action){{{1
                            "returns the string that should be prompted to the user for the given action
                            "
                            "Args:
                            "action: the action that is being performed, e.g. 'delete'
    1              0.000001000 function! s:inputPrompt(action)
                                if a:action ==# 'add'
                                    let title = 'Add a childnode'
                                    let info = "Enter the dir/file name to be created. Dirs end with a '/'"
                                    let minimal = 'Add node:'
                            
                                elseif a:action ==# 'copy'
                                    let title = 'Copy the current node'
                                    let info = 'Enter the new path to copy the node to:'
                                    let minimal = 'Copy to:'
                            
                                elseif a:action ==# 'delete'
                                    let title = 'Delete the current node'
                                    let info = 'Are you sure you wish to delete the node:'
                                    let minimal = 'Delete?'
                            
                                elseif a:action ==# 'deleteNonEmpty'
                                    let title = 'Delete the current node'
                                    let info =  "STOP! Directory is not empty! To delete, type 'yes'"
                                    let minimal = 'Delete directory?'
                            
                                elseif a:action ==# 'move'
                                    let title = 'Rename the current node'
                                    let info = 'Enter the new path for the node:'
                                    let minimal = 'Move to:'
                                endif
                            
                                if g:NERDTreeMenuController.isMinimal()
                                    redraw! " Clear the menu
                                    return minimal . ' '
                                else
                                    let divider = '=========================================================='
                                    return title . "\n" . divider . "\n" . info . "\n"
                                end
                            endfunction
                            
                            "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
                            "prints out the given msg and, if the user responds by pushing 'y' then the
                            "buffer with the given bufnum is deleted
                            "
                            "Args:
                            "bufnum: the buffer that may be deleted
                            "msg: a message that will be echoed to the user asking them if they wish to
                            "     del the buffer
    1              0.000001000 function! s:promptToDelBuffer(bufnum, msg)
                                echo a:msg
                                if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
                                    " 1. ensure that all windows which display the just deleted filename
                                    " now display an empty buffer (so a layout is preserved).
                                    " Is not it better to close single tabs with this file only ?
                                    let s:originalTabNumber = tabpagenr()
                                    let s:originalWindowNumber = winnr()
                                    " Go to the next buffer in buffer list if at least one extra buffer is listed
                                    " Otherwise open a new empty buffer
                                    if v:version >= 800
                                        let l:listedBufferCount = len(getbufinfo({'buflisted':1}))
                                    elseif v:version >= 702
                                        let l:listedBufferCount = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))
                                    else
                                        " Ignore buffer count in this case to make sure we keep the old
                                        " behavior
                                        let l:listedBufferCount = 0
                                    endif
                                    if l:listedBufferCount > 1
                                        call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . a:bufnum . " | exec ':bnext! ' | endif", 1)
                                    else
                                        call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . a:bufnum . " | exec ':enew! ' | endif", 1)
                                    endif
                                    call nerdtree#exec('tabnext ' . s:originalTabNumber, 1)
                                    call nerdtree#exec(s:originalWindowNumber . 'wincmd w', 1)
                                    " 3. We don't need a previous buffer anymore
                                    call nerdtree#exec('bwipeout! ' . a:bufnum, 0)
                                endif
                            endfunction
                            
                            "FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1
                            "The buffer with the given bufNum is replaced with a new one
                            "
                            "Args:
                            "bufNum: the buffer that may be deleted
                            "newNodeName: the name given to the renamed node
                            "isDirectory: determines how to do the create the new filenames
    1              0.000001000 function! s:renameBuffer(bufNum, newNodeName, isDirectory)
                                if a:isDirectory
                                    let quotedFileName = fnameescape(a:newNodeName . '/' . fnamemodify(bufname(a:bufNum),':t'))
                                    let editStr = g:NERDTreePath.New(a:newNodeName . '/' . fnamemodify(bufname(a:bufNum),':t')).str({'format': 'Edit'})
                                else
                                    let quotedFileName = fnameescape(a:newNodeName)
                                    let editStr = g:NERDTreePath.New(a:newNodeName).str({'format': 'Edit'})
                                endif
                                let s:originalTabNumber = tabpagenr()
                                let s:originalWindowNumber = winnr()
                                let l:tempBufferName = 'NERDTreeRenameTempBuffer'
                            
                                " 1. swap deleted file buffer with a temporary one
                                " this step is needed to compensate for case insensitive filesystems
                            
                                " 1.1. create an intermediate(temporary) buffer
                                call nerdtree#exec('badd ' . l:tempBufferName, 0)
                                let l:tempBufNum = bufnr(l:tempBufferName)
                                " 1.2. ensure that all windows which display the just deleted filename
                                " display the new temp buffer.
                                call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . a:bufNum . " | exec ':e! " . l:tempBufferName . "' | endif", 0)
                                " 1.3. We don't need the deleted file buffer anymore
                                try
                                    call nerdtree#exec('confirm bwipeout ' . a:bufNum, 0)
                                catch
                                    " This happens when answering Cancel if confirmation is needed. Do nothing.
                                endtry
                            
                                " 2. swap temporary buffer with the new filename buffer
                                " 2.1. create the actual new file buffer
                                call nerdtree#exec('badd ' . quotedFileName, 0)
                            
                                " 2.2. ensure that all windows which display the temporary buffer
                                " display a buffer for the new filename.
                                call nerdtree#exec('tabdo windo if winbufnr(0) ==# ' . l:tempBufNum . " | exec ':e! " . editStr . "' | endif", 0)
                                call nerdtree#exec('tabnext ' . s:originalTabNumber, 1)
                                call nerdtree#exec(s:originalWindowNumber . 'wincmd w', 1)
                                " 2.3. We don't need the temporary buffer anymore
                                try
                                    call nerdtree#exec('confirm bwipeout ' . l:tempBufNum, 0)
                                catch
                                    " This happens when answering Cancel if confirmation is needed. Do nothing.
                                endtry
                            endfunction
                            
                            "FUNCTION: NERDTreeAddNode(){{{1
    1              0.000001000 function! NERDTreeAddNode()
                                let curDirNode = g:NERDTreeDirNode.GetSelected()
                                let prompt = s:inputPrompt('add')
                                let newNodeName = substitute(input(prompt, curDirNode.path.str() . nerdtree#slash(), 'file'), '\(^\s*\|\s*$\)', '', 'g')
                            
                                if newNodeName ==# ''
                                    call nerdtree#echo('Node Creation Aborted.')
                                    return
                                endif
                            
                                try
                                    let newPath = g:NERDTreePath.Create(newNodeName)
                                    let parentNode = b:NERDTree.root.findNode(newPath.getParent())
                            
                                    let newTreeNode = g:NERDTreeFileNode.New(newPath, b:NERDTree)
                                    " Emptying g:NERDTreeOldSortOrder forces the sort to
                                    " recalculate the cached sortKey so nodes sort correctly.
                                    let g:NERDTreeOldSortOrder = []
                                    if empty(parentNode)
                                        call b:NERDTree.root.refresh()
                                        call b:NERDTree.render()
                                    elseif parentNode.isOpen || !empty(parentNode.children)
                                        call parentNode.addChild(newTreeNode, 1)
                                        call NERDTreeRender()
                                        call newTreeNode.putCursorHere(1, 0)
                                    endif
                            
                                    redraw!
                                catch /^NERDTree/
                                    call nerdtree#echoWarning('Node Not Created.')
                                endtry
                            endfunction
                            
                            "FUNCTION: NERDTreeMoveNode(){{{1
    1              0.000000000 function! NERDTreeMoveNode()
                                let curNode = g:NERDTreeFileNode.GetSelected()
                                let prompt = s:inputPrompt('move')
                                let newNodePath = input(prompt, curNode.path.str(), 'file')
                                while filereadable(newNodePath)
                                    " allow renames with different casing when g:NERDTreeCaseSensitiveFS
                                    " is set to either 0 or 3 and the 2 paths are equal
                                    if (g:NERDTreeCaseSensitiveFS == 0 || g:NERDTreeCaseSensitiveFS == 3) &&
                                                \nerdtree#pathEquals(curNode.path.str(), newNodePath)
                                        break
                                    endif
                            
                                    call nerdtree#echoWarning('This destination already exists, Try again.')
                            
                                    " inform the user about the flag if we think it is a false positive
                                    " when g:NERDTreeCaseSensitiveFS is set to 2
                                    if g:NERDTreeCaseSensitiveFS == 2 &&
                                                \!nerdtree#osDefaultCaseSensitiveFS() &&
                                                \nerdtree#pathEquals(curNode.path.str(), newNodePath)
                                        echon "\n(If it is a false positive please consider assigning NERDTreeCaseSensitiveFS's value)"
                                    endif
                            
                                    " prompt the user again
                                    let newNodePath = substitute(input(prompt, curNode.path.str(), 'file'), '\(^\s*\|\s*$\)', '', 'g')
                                endwhile
                            
                            
                                if newNodePath ==# ''
                                    call nerdtree#echo('Node Renaming Aborted.')
                                    return
                                endif
                            
                                try
                                    if curNode.path.isDirectory
                                        let l:curPath = escape(curNode.path.str(),'\') . (nerdtree#runningWindows()?'\\':'/') . '.*'
                                        let l:openBuffers = filter(range(1,bufnr('$')),'bufexists(v:val) && fnamemodify(bufname(v:val),":p") =~# "'.escape(l:curPath,'\').'"')
                                    else
                                        let l:openBuffers = filter(range(1,bufnr('$')),'bufexists(v:val) && fnamemodify(bufname(v:val),":p") ==# curNode.path.str()')
                                    endif
                            
                                    call curNode.rename(newNodePath)
                                    " Emptying g:NERDTreeOldSortOrder forces the sort to
                                    " recalculate the cached sortKey so nodes sort correctly.
                                    let g:NERDTreeOldSortOrder = []
                                    call b:NERDTree.root.refresh()
                                    call NERDTreeRender()
                            
                                    " If the file node is open, or files under the directory node are
                                    " open, ask the user if they want to replace the file(s) with the
                                    " renamed files.
                                    if !empty(l:openBuffers)
                                        if curNode.path.isDirectory
                                            echo "\nDirectory renamed.\n\nFiles with the old directory name are open in buffers " . join(l:openBuffers, ', ') . '. Replace these buffers with the new files? (yN)'
                                        else
                                            echo "\nFile renamed.\n\nThe old file is open in buffer " . l:openBuffers[0] . '. Replace this buffer with the new file? (yN)'
                                        endif
                                        if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
                                            for bufNum in l:openBuffers
                                                call s:renameBuffer(bufNum, newNodePath, curNode.path.isDirectory)
                                            endfor
                                        endif
                                    endif
                            
                                    call curNode.putCursorHere(1, 0)
                            
                                    redraw!
                                catch /^NERDTree/
                                    call nerdtree#echoWarning('Node Not Renamed.')
                                endtry
                            endfunction
                            
                            " FUNCTION: NERDTreeDeleteNode() {{{1
    1              0.000001000 function! NERDTreeDeleteNode()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                let confirmed = 0
                            
                                if currentNode.path.isDirectory && ((currentNode.isOpen && currentNode.getChildCount() > 0) ||
                                                                  \ (len(currentNode._glob('*', 1)) > 0))
                                    let prompt = s:inputPrompt('deleteNonEmpty') . currentNode.path.str() . ': '
                                    let choice = input(prompt)
                                    let confirmed = choice ==# 'yes'
                                else
                                    let prompt = s:inputPrompt('delete') . currentNode.path.str() . ' (yN): '
                                    echo prompt
                                    let choice = nr2char(getchar())
                                    let confirmed = choice ==# 'y'
                                endif
                            
                                if confirmed
                                    try
                                        call currentNode.delete()
                                        call NERDTreeRender()
                            
                                        "if the node is open in a buffer, ask the user if they want to
                                        "close that buffer
                                        let bufnum = bufnr('^'.currentNode.path.str().'$')
                                        if buflisted(bufnum)
                                            let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? ' (hidden)' : '') .'. Delete this buffer? (yN)'
                                            call s:promptToDelBuffer(bufnum, prompt)
                                        endif
                            
                                        redraw!
                                    catch /^NERDTree/
                                        call nerdtree#echoWarning('Could not remove node')
                                    endtry
                                else
                                    call nerdtree#echo('delete aborted')
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeListNode() {{{1
    1              0.000000000 function! NERDTreeListNode()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if !empty(treenode)
                                    let s:uname = system('uname')
                                    let stat_cmd = 'stat -c "%s" '
                            
                                    if s:uname =~? 'Darwin'
                                        let stat_cmd = 'stat -f "%z" '
                                    endif
                            
                                    let cmd = 'size=$(' . stat_cmd . shellescape(treenode.path.str()) . ') && ' .
                                    \         'size_with_commas=$(echo $size | sed -e :a -e "s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta") && ' .
                                    \         'ls -ld ' . shellescape(treenode.path.str()) . ' | sed -e "s/ $size / $size_with_commas /"'
                            
                                    let metadata = split(system(cmd),'\n')
                                    call nerdtree#echo(metadata[0])
                                else
                                    call nerdtree#echo('No information available')
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeListNodeWin32() {{{1
    1              0.000001000 function! NERDTreeListNodeWin32()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if !empty(l:node)
                                    let l:path = l:node.path.str()
                                    call nerdtree#echo(printf('%s:%s  MOD:%s  BYTES:%d  PERMISSIONS:%s',
                                                \ toupper(getftype(l:path)),
                                                \ fnamemodify(l:path, ':t'),
                                                \ strftime('%c', getftime(l:path)),
                                                \ getfsize(l:path),
                                                \ getfperm(l:path)))
                                    return
                                endif
                            
                                call nerdtree#echo('node not recognized')
                            endfunction
                            
                            " FUNCTION: NERDTreeChangePermissions() {{{1
    1              0.000001000 function! NERDTreeChangePermissions()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                                let l:prompt = "change node permissions (chmod args): "
                                let l:newNodePerm = input(l:prompt)
                            
                                if !empty(l:node)
                                    let l:path = l:node.path.str()
                                    let l:cmd = 'chmod ' .. newNodePerm .. ' ' .. path
                                    let l:error = split(system(l:cmd), '\n')
                            
                                    if !empty(l:error)
                                        call nerdtree#echo(l:error[0])
                                    endif
                            
                                    call b:NERDTree.root.refresh()
                                    call b:NERDTree.render()
                                    return
                                endif
                            
                                call nerdtree#echo('node not recognized')
                            endfunction
                            
                            " FUNCTION: NERDTreeCopyNode() {{{1
    1              0.000000000 function! NERDTreeCopyNode()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                let prompt = s:inputPrompt('copy')
                                let newNodePath = substitute(input(prompt, currentNode.path.str(), 'file'), '\(^\s*\|\s*$\)', '', 'g')
                            
                                if newNodePath !=# ''
                                    "strip trailing slash
                                    let newNodePath = substitute(newNodePath, '\/$', '', '')
                            
                                    let confirmed = 1
                                    if currentNode.path.copyingWillOverwrite(newNodePath)
                                        call nerdtree#echo('Warning: copying may overwrite files! Continue? (yN)')
                                        let choice = nr2char(getchar())
                                        let confirmed = choice ==# 'y'
                                    endif
                            
                                    if confirmed
                                        try
                                            let newNode = currentNode.copy(newNodePath)
                                            " Emptying g:NERDTreeOldSortOrder forces the sort to
                                            " recalculate the cached sortKey so nodes sort correctly.
                                            let g:NERDTreeOldSortOrder = []
                                            if empty(newNode)
                                                call b:NERDTree.root.refresh()
                                                call b:NERDTree.render()
                                            else
                                                call NERDTreeRender()
                                                call newNode.putCursorHere(0, 0)
                                            endif
                                        catch /^NERDTree/
                                            call nerdtree#echoWarning('Could not copy node')
                                        endtry
                                    endif
                                else
                                    call nerdtree#echo('Copy aborted.')
                                endif
                                redraw!
                            endfunction
                            
                            " FUNCTION: NERDTreeCopyPath() {{{1
    1              0.000001000 function! NERDTreeCopyPath()
                                let l:nodePath = g:NERDTreeFileNode.GetSelected().path.str()
                                if has('clipboard')
                                    if &clipboard ==# 'unnamedplus'
                                        let @+ = l:nodePath
                                    else
                                        let @* = l:nodePath
                                    endif
                                    call nerdtree#echo('The path [' . l:nodePath . '] was copied to your clipboard.')
                                else
                                    call nerdtree#echo('The full path is: ' . l:nodePath)
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeQuickLook() {{{1
    1              0.000001000 function! NERDTreeQuickLook()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                call system('qlmanage -p 2>/dev/null ' . shellescape(l:node.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeRevealInFinder() {{{1
    1              0.000001000 function! NERDTreeRevealInFinder()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                call system('open -R ' . shellescape(l:node.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeExecuteFile() {{{1
    1              0.000000000 function! NERDTreeExecuteFile()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                call system('open ' . shellescape(l:node.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeRevealFileLinux() {{{1
    1              0.000000000 function! NERDTreeRevealFileLinux()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                " Handle the edge case of "/", which has no parent.
                                if l:node.path.str() ==# '/'
                                    call system('xdg-open /')
                                    return
                                endif
                            
                                if empty(l:node.parent)
                                    return
                                endif
                            
                                call system('xdg-open ' . shellescape(l:node.parent.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeExecuteFileLinux() {{{1
    1              0.000001000 function! NERDTreeExecuteFileLinux()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                call system('xdg-open ' . shellescape(l:node.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeRevealInExplorer() {{{1
    1              0.000000000 function! NERDTreeRevealInExplorer()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                call system('cmd.exe /c explorer /select, ' . shellescape(l:node.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeExecuteFileWindows() {{{1
    1              0.000001000 function! NERDTreeExecuteFileWindows()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                call system('cmd.exe /c start "" ' . shellescape(l:node.path.str()))
                            endfunction
                            
                            " FUNCTION: NERDTreeSystemCommand() {{{1
    1              0.000000000 function! NERDTreeSystemCommand()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if empty(l:node)
                                    return
                                endif
                            
                                let l:cwd = getcwd()
                                let l:directory = l:node.path.isDirectory ? l:node.path.str() : l:node.parent.path.str()
                                execute 'cd '.l:directory
                            
                                let l:nl = nr2char(10)
                                echo l:nl . system(input(l:directory . (nerdtree#runningWindows() ? '> ' : ' $ ')))
                                execute 'cd '.l:cwd
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim
Sourced 1 time
Total time:   0.000024000
 Self time:   0.000024000

count     total (s)      self (s)
                            " ============================================================================
                            " File:        vcs.vim
                            " Description: NERDTree plugin that provides a command to open on the root of
                            "              a version control system repository.
                            " Maintainer:  Phil Runninger
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000003000 command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')
    1              0.000003000 command! -n=? -complete=dir -bar NERDTreeToggleVCS :call <SID>ToggleTabTreeVCS('<args>')
                            
                            " FUNCTION: s:CreateTabTreeVCS(a:name) {{{1
    1              0.000001000 function! s:CreateTabTreeVCS(name)
                                let l:path = g:NERDTreeCreator._pathForString(a:name)
                                let l:path = s:FindParentVCSRoot(l:path)
                                call g:NERDTreeCreator.createTabTree(empty(l:path) ? '' : l:path._str())
                            endfunction
                            
                            " FUNCTION: s:ToggleTabTreeVCS(a:name) {{{1
                            " Behaves the same as ToggleTabTree except roots directory at VCS root
    1              0.000001000 function! s:ToggleTabTreeVCS(name)
                                let l:path = g:NERDTreeCreator._pathForString(a:name)
                                let l:path = s:FindParentVCSRoot(l:path)
                                call g:NERDTreeCreator.toggleTabTree(empty(l:path) ? '' : l:path._str())
                            endfunction
                            
                            " FUNCTION: s:FindParentVCSRoot(a:path) {{{1
                            " Finds the root version control system folder of the given path. If a:path is
                            " not part of a repository, return the original path.
    1              0.000000000 function! s:FindParentVCSRoot(path)
                                let l:path = a:path
                                while !empty(l:path) &&
                                    \ l:path._str() !~# '^\(\a:[\\\/]\|\/\)$' &&
                                    \ !isdirectory(l:path._str() . '/.git') &&
                                    \ !isdirectory(l:path._str() . '/.svn') &&
                                    \ !isdirectory(l:path._str() . '/.hg') &&
                                    \ !isdirectory(l:path._str() . '/.bzr') &&
                                    \ !isdirectory(l:path._str() . '/_darcs')
                                    let l:path = l:path.getParent()
                                endwhile
                                return (empty(l:path) || l:path._str() =~# '^\(\a:[\\\/]\|\/\)$') ? a:path : l:path
                            endfunction
                            

SCRIPT  /Users/danbradbury/.vim/bundle/semantic-highlight.vim/plugin/semhl.vim
Sourced 1 time
Total time:   0.000617000
 Self time:   0.000617000

count     total (s)      self (s)
                            " A special thanks goes out to John Leimon <jleimon@gmail.com>
                            " for his more complete C/C++ version,
                            " which served as a great basis for understanding
                            " regex matching in Vim
                            
                            " Allow users to configure the plugin to auto start for certain filetypes
    1              0.000003000 if (exists('g:semanticEnableFileTypes'))
                            	if type(g:semanticEnableFileTypes) == type([])
                            		execute 'autocmd FileType ' . join(g:semanticEnableFileTypes, ',') . ' call s:enableHighlight()'
                            	elseif type(g:semanticEnableFileTypes) == type({})
                            		execute 'autocmd FileType ' . join(keys(g:semanticEnableFileTypes), ',') . ' call s:enableHighlight()'
                            		execute 'autocmd CursorHold ' . join(map(values(g:semanticEnableFileTypes), '"*." . v:val'), ',') . ' call s:semHighlight()'
                            	endif
    1              0.000000000 endif
                            
                            " Set defaults for colors
    1              0.000016000 let s:semanticGUIColors = ["#9CD8F7", "#F5FA1D", "#F97C65", "#35D27F", "#EB75D6", "#E5D180", "#8997F5", "#D49DA5", "#7FEC35", "#F6B223", "#B4F1C3", "#99B730", "#F67C1B", "#3AC6BE", "#EAAFF1", "#DE9A4E", "#BBEA87", "#EEF06D", "#8FB272", "#EAA481", "#F58AAE", "#80B09B", "#5DE866", "#B5A5C5", "#88ADE6", "#4DAABD", "#EDD528", "#FA6BB2", "#47F2D4", "#F47F86", "#2ED8FF", "#B8E01C", "#C5A127", "#74BB46", "#D386F1", "#97DFD6", "#B1A96F", "#66BB75", "#97AA49", "#EF874A", "#48EDF0", "#C0AE50", "#89AAB6", "#D7D1EB", "#5EB894", "#57F0AC", "#B5AF1B", "#B7A5F0", "#8BE289", "#D38AC6", "#C8EE63", "#ED9C36", "#85BA5F", "#9DEA74", "#85C52D", "#40B7E5", "#EEA3C2", "#7CE9B6", "#8CEC58", "#D8A66C", "#51C03B", "#C4CE64", "#45E648", "#4DC15E", "#63A5F3", "#EA8C66", "#D2D43E", "#E5BCE8", "#E4B7CB", "#B092F4", "#44C58C", "#D1E998", "#76E4F2", "#E19392", "#A8E5A4", "#BF9FD6", "#E8C25B", "#58F596", "#6BAEAC", "#94C291", "#7EF1DB", "#E8D65C", "#A7EA38", "#D38AE0", "#ECF453", "#5CD8B8", "#B6BF6B", "#BEE1F1", "#B1D43E", "#EBE77B", "#84A5
    1              0.000002000 let s:semanticTermColors = range(20)
                            
                            " The user can change the GUI/Term colors, but cannot directly access the list of colors we use
                            " If the user overrode the default in their vimrc, use that
    1              0.000003000 let g:semanticGUIColors = exists('g:semanticGUIColors') ? g:semanticGUIColors : s:semanticGUIColors
    1              0.000002000 let g:semanticTermColors = exists('g:semanticTermColors') ? g:semanticTermColors : s:semanticTermColors
                            
                            " Allow the user to turn cache off
    1              0.000002000 let g:semanticUseCache = exists('g:semanticUseCache') ? g:semanticUseCache : 1
    1              0.000001000 let g:semanticPersistCache = exists('g:semanticPersistCache') ? g:semanticPersistCache : 1
    1              0.000003000 let g:semanticPersistCacheLocation = exists('g:semanticPersistCacheLocation') ? g:semanticPersistCacheLocation : $HOME . '/.semantic-highlight-cache'
                            
                            " Allow the user to override blacklists
    1              0.000001000 let g:semanticEnableBlacklist = exists('g:semanticEnableBlacklist') ? g:semanticEnableBlacklist : 1
                            
    1              0.000001000 let s:blacklist = {}
    1              0.000000000 if g:semanticEnableBlacklist
    1              0.000286000 	let s:blacklist = blacklist#GetBlacklist()
    1              0.000000000 endif
                            
    1              0.000172000 let s:containedinlist = containedinlist#GetContainedinlist()
                            
    1              0.000001000 let g:semanticUseBackground = 0
    1              0.000001000 let s:hasBuiltColors = 0
                            
    1              0.000002000 command! SemanticHighlight call s:semHighlight()
    1              0.000002000 command! SemanticHighlightRevert call s:disableHighlight()
    1              0.000001000 command! SemanticHighlightToggle call s:toggleHighlight()
    1              0.000001000 command! RebuildSemanticColors call s:buildColors()
                            
    1              0.000001000 function! s:readCache() abort
                            	if !filereadable(g:semanticPersistCacheLocation)
                            		return []
                            	endif
                            
                            	let l:localCache = {}
                            	let s:cacheList = readfile(g:semanticPersistCacheLocation)
                            	for s:cacheListItem in s:cacheList
                            		let s:cacheListItemList = eval(s:cacheListItem)
                            		let l:localCache[s:cacheListItemList[0]] = s:cacheListItemList[1]
                            	endfor
                            
                            	if exists("s:cacheListItem")
                            		unlet s:cacheListItem s:cacheList
                            	endif
                            
                            	return l:localCache
                            endfunction
                            
    1              0.000001000 let s:cache = {}
    1              0.000002000 let b:cache_defined = {}
    1              0.000019000 if g:semanticPersistCache && filereadable(g:semanticPersistCacheLocation)
    1              0.000030000 	let s:cache = s:readCache()
    1              0.000001000 endif
                            
    1              0.000003000 autocmd VimLeave * call s:persistCache()
                            
    1              0.000001000 function! s:persistCache()
                            	let l:cacheList = []
                            	let l:mergedCache = extend(s:readCache(), s:cache)
                            	for [match,color] in items(l:mergedCache)
                            		call add(l:cacheList, string([match, color]))
                            		unlet match color
                            	endfor
                            	call writefile(l:cacheList, g:semanticPersistCacheLocation)
                            endfunction
                            
    1              0.000001000 function! s:getCachedColor(current_color, match)
                            	if !g:semanticUseCache
                            		return a:current_color
                            	endif
                            
                            	if (has_key(s:cache, a:match))
                            		return s:cache[a:match]
                            	endif
                            
                            	let s:cache[a:match] = a:current_color
                            	return a:current_color
                            endfunction
                            
    1              0.000001000 function! s:semHighlight()
                            	if s:hasBuiltColors == 0
                            		call s:buildColors()
                            	endif
                            
                            	let b:cache_defined = {}
                            
                            	let buflen = line('$')
                            	let pattern = '\<[\$@]*[a-zA-Z\_][a-zA-Z0-9\_]*\>'
                            	let colorLen = len(s:semanticColors)
                            	let cur_color = str2nr(matchstr(reltimestr(reltime()), '\v\.@<=\d+')[1:]) % colorLen    " found on https://stackoverflow.com/questions/12737977/native-vim-random-number-script
                            
                            	while buflen
                            		let curline = getline(buflen)
                            		let index = 0
                            		while 1
                            			let match = matchstr(curline, pattern, index)
                            
                            			if (empty(match))
                            				break
                            			endif
                            
                            			let l:no_blacklist_exists_for_filetype = empty(s:blacklist) || !has_key(s:blacklist, &filetype)
                            			if ((l:no_blacklist_exists_for_filetype || index(s:blacklist[&filetype], match) == -1) && !has_key(b:cache_defined, match))
                            				let b:cache_defined[match] = 1
                            				let l:containedin = ''
                            				if (!empty(s:containedinlist) && has_key(s:containedinlist, &filetype))
                            					let l:containedin = ' containedin=' . s:containedinlist[&filetype]
                            				endif
                            
                            				execute 'syn keyword _semantic' . s:getCachedColor(cur_color, match) . l:containedin . ' ' . match
                            				let cur_color = (cur_color + 1) % colorLen
                            			endif
                            
                            			let index += len(match) + 1
                            		endwhile
                            		let buflen -= 1
                            	endwhile
                            endfunction
                            
    1              0.000001000 function! s:buildColors()
                            	if (g:semanticUseBackground)
                            		let type = 'bg'
                            	else
                            		let type = 'fg'
                            	endif
                            	if $NVIM_TUI_ENABLE_TRUE_COLOR || has('gui_running') || (exists('&guicolors') && &guicolors) || (exists('&termguicolors') && &termguicolors)
                            		let colorType = 'gui'
                            		" Update color list in case the user made any changes
                            		let s:semanticColors = g:semanticGUIColors
                            	else
                            		let colorType = 'cterm'
                            		" Update color list in case the user made any changes
                            		let s:semanticColors = g:semanticTermColors
                            	endif
                            
                            	let semIndex = 0
                            	for semCol in s:semanticColors
                            		execute 'hi! def _semantic'.semIndex.' ' . colorType . type . '='.semCol
                            		let semIndex += 1
                            	endfor
                            	let s:hasBuiltColors = 1
                            endfunction
                            
    1              0.000001000 function! s:disableHighlight()
                            	let b:semanticOn = 0
                            	for key in range(len(s:semanticColors))
                            		execute 'syn clear _semantic'.key
                            	endfor
                            
                            	let b:cache_defined = {}
                            endfunction
                            
    1              0.000001000 function! s:enableHighlight()
                            	let b:cache_defined = {}
                            	call s:semHighlight()
                            	let b:semanticOn = 1
                            endfunction
                            
    1              0.000000000 function! s:toggleHighlight()
                            	if (exists('b:semanticOn') && b:semanticOn == 1)
                            		call s:disableHighlight()
                            	else
                            		call s:semHighlight()
                            		let b:semanticOn = 1
                            	endif
                            endfunction
                            

SCRIPT  /Users/danbradbury/.vim/bundle/semantic-highlight.vim/autoload/blacklist.vim
Sourced 1 time
Total time:   0.000136000
 Self time:   0.000136000

count     total (s)      self (s)
    1              0.000121000 let s:blacklist = {
                            	\ 'javascript': [
                            	\	'render',
                            	\	'constructor',
                            	\	'console',
                            	\	'log',
                            	\	'await',
                            	\	'window',
                            	\	'break',
                            	\	'case',
                            	\	'catch',
                            	\	'class',
                            	\	'const',
                            	\	'continue',
                            	\	'debugger',
                            	\	'default',
                            	\	'delete',
                            	\	'do',
                            	\	'else',
                            	\	'enum',
                            	\	'export',
                            	\	'extends',
                            	\	'false',
                            	\	'finally',
                            	\	'for',
                            	\	'function',
                            	\	'if',
                            	\	'implements',
                            	\	'import',
                            	\	'in',
                            	\	'instanceof',
                            	\	'interface',
                            	\	'let',
                            	\	'new',
                            	\	'null',
                            	\	'package',
                            	\	'private',
                            	\	'protected',
                            	\	'public',
                            	\	'return',
                            	\	'static',
                            	\	'super',
                            	\	'switch',
                            	\	'this',
                            	\	'throw',
                            	\	'true',
                            	\	'try',
                            	\	'typeof',
                            	\	'require',
                            	\	'from',
                            	\	'props',
                            	\	'state',
                            	\	'bind',
                            	\	'var',
                            	\	'void',
                            	\	'while',
                            	\	'with',
                            	\ ],
                            	\ 'typescript': [
                            	\	'await',
                            	\	'break',
                            	\	'case',
                            	\	'catch',
                            	\	'class',
                            	\	'const',
                            	\	'continue',
                            	\	'debugger',
                            	\	'default',
                            	\	'delete',
                            	\	'do',
                            	\	'else',
                            	\	'enum',
                            	\	'export',
                            	\	'extends',
                            	\	'false',
                            	\	'finally',
                            	\	'for',
                            	\	'function',
                            	\	'if',
                            	\	'implements',
                            	\	'import',
                            	\	'in',
                            	\	'instanceof',
                            	\	'interface',
                            	\	'let',
                            	\	'new',
                            	\	'null',
                            	\	'package',
                            	\	'private',
                            	\	'protected',
                            	\	'public',
                            	\	'return',
                            	\	'static',
                            	\	'super',
                            	\	'switch',
                            	\	'this',
                            	\	'throw',
                            	\	'true',
                            	\	'try',
                            	\	'typeof',
                            	\	'var',
                            	\	'void',
                            	\	'while',
                            	\	'with',
                            	\	'boolean',
                            	\	'number',
                            	\	'string',
                            	\	'Array',
                            	\	'Object',
                            	\	'any',
                            	\	'module',
                            	\ ],
                            	\ 'ruby': [
                            	\	'BEGIN',
                            	\	'do',
                            	\	'?',
                            	\	'END',
                            	\	'__FILE__',
                            	\	'__LINE__',
                            	\	'alias',
                            	\	'and',
                            	\	'begin',
                            	\	'break',
                            	\	'case',
                            	\	'class',
                            	\	'def',
                            	\	'defined',
                            	\	'else',
                            	\	'elsif',
                            	\	'end',
                            	\	'ensure',
                            	\	'false',
                            	\	'for',
                            	\	'if',
                            	\	'in',
                            	\	'module',
                            	\	'next',
                            	\	'nil',
                            	\	'not',
                            	\	'or',
                            	\	'redo',
                            	\	'rescue',
                            	\	'retry',
                            	\	'return',
                            	\	'self',
                            	\	'super',
                            	\	'then',
                            	\	'true',
                            	\	'undef',
                            	\	'unless',
                            	\	'until',
                            	\	'when',
                            	\	'while',
                            	\	'while',
                            	\ ],
                            	\ 'php': [
                            	\	'__CLASS__',
                            	\	'__DIR__',
                            	\	'__FILE__',
                            	\	'__FUNCTION__',
                            	\	'__LINE__',
                            	\	'__METHOD__',
                            	\	'__NAMESPACE__',
                            	\	'__TRAIT__',
                            	\	'__halt_compiler',
                            	\	'abstract',
                            	\	'and',
                            	\	'array',
                            	\	'as',
                            	\	'break',
                            	\	'callable',
                            	\	'case',
                            	\	'catch',
                            	\	'class',
                            	\	'clone',
                            	\	'const',
                            	\	'continue',
                            	\	'declare',
                            	\	'default',
                            	\	'die',
                            	\	'do',
                            	\	'echo',
                            	\	'else',
                            	\	'elseif',
                            	\	'empty',
                            	\	'enddeclare',
                            	\	'endfor',
                            	\	'endforeach',
                            	\	'endif',
                            	\	'endswitch',
                            	\	'endwhile',
                            	\	'eval',
                            	\	'exit',
                            	\	'extends',
                            	\	'final',
                            	\	'for',
                            	\	'foreach',
                            	\	'function',
                            	\	'global',
                            	\	'goto',
                            	\	'if',
                            	\	'implements',
                            	\	'include',
                            	\	'include_once',
                            	\	'instanceof',
                            	\	'insteadof',
                            	\	'interface',
                            	\	'isset',
                            	\	'list',
                            	\	'namespace',
                            	\	'new',
                            	\	'or',
                            	\	'print',
                            	\	'private',
                            	\	'protected',
                            	\	'public',
                            	\	'require',
                            	\	'require_once',
                            	\	'return',
                            	\	'static',
                            	\	'switch',
                            	\	'throw',
                            	\	'trait',
                            	\	'try',
                            	\	'unset',
                            	\	'use',
                            	\	'var',
                            	\	'while',
                            	\	'xor',
                            	\ ],
                            	\ 'python': [
                            	\	'True',
                            	\	'False',
                            	\	'None',
                            	\	'and',
                            	\	'as',
                            	\	'assert',
                            	\	'break',
                            	\	'class',
                            	\	'continue',
                            	\	'def',
                            	\	'del',
                            	\	'elif',
                            	\	'else',
                            	\	'except',
                            	\	'exec',
                            	\	'finally',
                            	\	'for',
                            	\	'from',
                            	\	'global',
                            	\	'if',
                            	\	'import',
                            	\	'in',
                            	\	'is',
                            	\	'lambda',
                            	\	'not',
                            	\	'or',
                            	\	'pass',
                            	\	'print',
                            	\	'raise',
                            	\	'return',
                            	\	'try',
                            	\	'while',
                            	\	'with',
                            	\	'yield',
                            	\ ],
                            	\ 'coffee': [
                            	\	'true',
                            	\	'false',
                            	\	'null',
                            	\	'this',
                            	\	'new',
                            	\	'delete',
                            	\	'typeof',
                            	\	'in',
                            	\	'instanceof',
                            	\	'return',
                            	\	'throw',
                            	\	'break',
                            	\	'continue',
                            	\	'debugger',
                            	\	'if',
                            	\	'else',
                            	\	'switch',
                            	\	'for',
                            	\	'while',
                            	\	'do',
                            	\	'try',
                            	\	'catch',
                            	\	'finally',
                            	\	'class',
                            	\	'extends',
                            	\	'super',
                            	\	'undefined',
                            	\	'then',
                            	\	'unless',
                            	\	'until',
                            	\	'loop',
                            	\	'of',
                            	\	'by',
                            	\	'when',
                            	\ ],
                            	\ 'c': [
                            	\	'auto',
                            	\	'break',
                            	\	'bool',
                            	\	'case',
                            	\	'char',
                            	\	'const',
                            	\	'continue',
                            	\	'default',
                            	\	'define',
                            	\	'defined',
                            	\	'do',
                            	\	'double',
                            	\	'elif',
                            	\	'else',
                            	\	'endif',
                            	\	'enum',
                            	\	'extern',
                            	\	'float',
                            	\	'for',
                            	\	'goto',
                            	\	'if',
                            	\	'ifdef',
                            	\	'int',
                            	\	'int8_t',
                            	\	'int16_t',
                            	\	'int32_t',
                            	\	'long',
                            	\	'register',
                            	\	'return',
                            	\	'short',
                            	\	'signed',
                            	\	'sizeof',
                            	\	'static',
                            	\	'struct',
                            	\	'switch',
                            	\	'typedef',
                            	\	'uint8_t',
                            	\	'uint16_t',
                            	\	'uint32_t',
                            	\	'union',
                            	\	'unsigned',
                            	\	'void',
                            	\	'volatile',
                            	\	'while',
                            	\ ],
                            	\ 'cpp': [
                            	\	'auto',
                            	\	'alignas',
                            	\	'alignof',
                            	\	'break',
                            	\	'bool',
                            	\	'case',
                            	\	'char',
                            	\	'char16_t',
                            	\	'char32_t',
                            	\	'const',
                            	\	'constexpr',
                            	\	'const_cast',
                            	\	'continue',
                            	\	'class',
                            	\	'default',
                            	\	'define',
                            	\	'decltype',
                            	\	'delete',
                            	\	'do',
                            	\	'double',
                            	\	'dynamic_cast',
                            	\	'else',
                            	\	'enum',
                            	\	'error',
                            	\	'extern',
                            	\	'explicit',
                            	\	'float',
                            	\	'false',
                            	\	'friend',
                            	\	'final',
                            	\	'for',
                            	\	'goto',
                            	\	'if',
                            	\	'inline',
                            	\	'int',
                            	\	'int8_t',
                            	\	'int16_t',
                            	\	'int32_t',
                            	\	'long',
                            	\	'line',
                            	\	'mutable',
                            	\	'namespace',
                            	\	'new',
                            	\	'noexcept',
                            	\	'nullptr',
                            	\	'operator',
                            	\	'override',
                            	\	'private',
                            	\	'pragma',
                            	\	'protected',
                            	\	'public',
                            	\	'register',
                            	\	'reinterpret_cast',
                            	\	'return',
                            	\	'short',
                            	\	'signed',
                            	\	'sizeof',
                            	\	'static',
                            	\	'static_assert',
                            	\	'static_cast',
                            	\	'struct',
                            	\	'switch',
                            	\	'template',
                            	\	'this',
                            	\	'thread_local',
                            	\	'throw',
                            	\	'true',
                            	\	'try',
                            	\	'typedef',
                            	\	'typeid',
                            	\	'typename',
                            	\	'uint8_t',
                            	\	'uint16_t',
                            	\	'uint32_t',
                            	\	'union',
                            	\	'unsigned',
                            	\	'undef',
                            	\	'using',
                            	\	'virtual',
                            	\	'void',
                            	\	'volatile',
                            	\	'wchar_t',
                            	\	'while',
                            	\ ],
                            	\ 'java': [
                            	\   'abstract',
                            	\   'continue',
                            	\   'for',
                            	\   'new',
                            	\   'switch',
                            	\   'assert',
                            	\   'default',
                            	\   'goto',
                            	\   'package',
                            	\   'synchronized',
                            	\   'boolean',
                            	\   'do',
                            	\   'if',
                            	\   'private',
                            	\   'this',
                            	\   'break',
                            	\   'double',
                            	\   'implements',
                            	\   'protected',
                            	\   'throw',
                            	\   'byte',
                            	\   'else',
                            	\   'import',
                            	\   'public',
                            	\   'throws',
                            	\   'case',
                            	\   'enum',
                            	\   'instanceof',
                            	\   'return',
                            	\   'transient',
                            	\   'catch',
                            	\   'extends',
                            	\   'int',
                            	\   'short',
                            	\   'try',
                            	\   'char',
                            	\   'final',
                            	\   'interface',
                            	\   'static',
                            	\   'void',
                            	\   'class',
                            	\   'finally',
                            	\   'long',
                            	\   'strictfp',
                            	\   'volatile',
                            	\   'const',
                            	\   'float',
                            	\   'native',
                            	\   'super',
                            	\   'while'
                            	\ ],
                            	\ 'rust': [
                            	\	'Self',
                            	\	'as',
                            	\	'bool',
                            	\	'box',
                            	\	'break',
                            	\	'char',
                            	\	'const',
                            	\	'continue',
                            	\	'crate',
                            	\	'else',
                            	\	'enum',
                            	\	'extern',
                            	\	'f32',
                            	\	'f64',
                            	\	'fn',
                            	\	'for',
                            	\	'i16',
                            	\	'i32',
                            	\	'i64',
                            	\	'i8',
                            	\	'if',
                            	\	'impl',
                            	\	'isize',
                            	\	'let',
                            	\	'loop',
                            	\	'match',
                            	\	'mod',
                            	\	'move',
                            	\	'mut',
                            	\	'pub',
                            	\	'return',
                            	\	'ref',
                            	\	'self',
                            	\	'static',
                            	\	'str',
                            	\	'struct',
                            	\	'super',
                            	\	'trait',
                            	\	'type',
                            	\	'u16',
                            	\	'u32',
                            	\	'u64',
                            	\	'u8',
                            	\	'unsafe',
                            	\	'use',
                            	\	'usize',
                            	\	'where',
                            	\	'while',
                            	\ ],
                            	\ 'go': [
                            	\	'break',
                            	\	'case',
                            	\	'chan',
                            	\	'const',
                            	\	'continue',
                            	\	'default',
                            	\	'defer',
                            	\	'else',
                            	\	'fallthrough',
                            	\	'for',
                            	\	'func',
                            	\	'go',
                            	\	'goto',
                            	\	'if',
                            	\	'import',
                            	\	'interface',
                            	\	'map',
                            	\	'package',
                            	\	'range',
                            	\	'return',
                            	\	'select',
                            	\	'struct',
                            	\	'switch',
                            	\	'type',
                            	\	'var',
                            	\	'string',
                            	\	'bool',
                            	\	'error',
                            	\	'true',
                            	\	'false',
                            	\	'int8',
                            	\	'int16',
                            	\	'int32',
                            	\	'int64',
                            	\	'uint8',
                            	\	'uint16',
                            	\	'uint32',
                            	\	'uint64',
                            	\	'float32',
                            	\	'float64',
                            	\	'complex64',
                            	\	'complex128',
                            	\	'byte',
                            	\ ],
                            	\ 'scala': [
                            	\ 'abstract',
                            	\ 'case',
                            	\ 'catch',
                            	\ 'class',
                            	\ 'def',
                            	\ 'do',
                            	\ 'else',
                            	\ 'extends',
                            	\ 'false',
                            	\ 'final',
                            	\ 'finally',
                            	\ 'for',
                            	\ 'forSome',
                            	\ 'if',
                            	\ 'implicit',
                            	\ 'import',
                            	\ 'lazy',
                            	\ 'macro',
                            	\ 'match',
                            	\ 'new',
                            	\ 'null',
                            	\ 'object',
                            	\ 'override',
                            	\ 'package',
                            	\ 'private',
                            	\ 'protected',
                            	\ 'return',
                            	\ 'sealed',
                            	\ 'super',
                            	\ 'this',
                            	\ 'throw',
                            	\ 'trait',
                            	\ 'try',
                            	\ 'true',
                            	\ 'type',
                            	\ 'val',
                            	\ 'var',
                            	\ 'while',
                            	\ 'with',
                            	\ 'yield',
                            	\ '_',
                            	\ ':',
                            	\ '=',
                            	\ '=>',
                            	\ '<-',
                            	\ '<:',
                            	\ '<%',
                            	\ '>:',
                            	\ '#',
                            	\ '@',
                            	\ ],
                            	\ }
                            
    1              0.000002000 if (exists('g:semanticBlacklistOverride'))
                            	let s:blacklist = extend(s:blacklist, g:semanticBlacklistOverride)
    1              0.000000000 endif
                            
    1              0.000001000 function! blacklist#GetBlacklist()
                            	return s:blacklist
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/semantic-highlight.vim/autoload/containedinlist.vim
Sourced 1 time
Total time:   0.000012000
 Self time:   0.000012000

count     total (s)      self (s)
    1              0.000003000 let s:containedinlist = {
                            	\ 'php': 'phpBracketInString,phpVarSelector,phpClExpressions,phpIdentifier',
                            	\ }
                            
    1              0.000002000 if (exists('g:semanticContainedlistOverride'))
                            	let s:containedinlist = extend(s:containedinlist, g:semanticContainedlistOverride)
    1              0.000001000 endif
                            
    1              0.000001000 function! containedinlist#GetContainedinlist()
                            	return s:containedinlist
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim
Sourced 1 time
Total time:   0.001447000
 Self time:   0.001447000

count     total (s)      self (s)
    1              0.000002000 scriptencoding utf-8
                            
    1              0.000003000 if exists('g:loaded_gitgutter') || !has('signs') || &cp
                              finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_gitgutter = 1
                            
                            " Initialisation {{{
                            
    1              0.000002000 if v:version < 703 || (v:version == 703 && !has("patch105"))
                              call gitgutter#utility#warn('Requires Vim 7.3.105')
                              finish
    1              0.000000000 endif
                            
    1              0.000003000 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000001000 function! s:obsolete(var)
                              if exists(a:var)
                                call gitgutter#utility#warn(a:var.' is obsolete and has no effect.')
                              endif
                            endfunction
                            
                            
    1              0.000002000 let g:gitgutter_preview_win_location = get(g:, 'gitgutter_preview_win_location', 'bo')
    1              0.000002000 if exists('*nvim_open_win')
                              let g:gitgutter_preview_win_floating = get(g:, 'gitgutter_preview_win_floating', 1)
                              let g:gitgutter_floating_window_options = get(g:, 'gitgutter_floating_window_options', {
                                    \ 'relative': 'cursor',
                                    \ 'row': 1,
                                    \ 'col': 0,
                                    \ 'width': 42,
                                    \ 'height': &previewheight,
                                    \ 'style': 'minimal'
                                    \ })
    1              0.000001000 else
    1              0.000002000   let default = exists('&previewpopup') ? !empty(&previewpopup) : 0
    1              0.000002000   let g:gitgutter_preview_win_floating = get(g:, 'gitgutter_preview_win_floating', default)
    1              0.000003000   let g:gitgutter_floating_window_options = get(g:, 'gitgutter_floating_window_options', {
                                    \ 'line': 'cursor+1',
                                    \ 'col': 'cursor',
                                    \ 'moved': 'any'
                                    \ })
    1              0.000001000 endif
    1              0.000001000 let g:gitgutter_enabled = get(g:, 'gitgutter_enabled', 1)
    1              0.000001000 if exists('*sign_unplace')
    1              0.000002000   let g:gitgutter_max_signs = get(g:, 'gitgutter_max_signs', -1)
                            else
                              let g:gitgutter_max_signs = get(g:, 'gitgutter_max_signs', 500)
    1              0.000000000 endif
    1              0.000001000 let g:gitgutter_signs             = get(g:, 'gitgutter_signs', 1)
    1              0.000001000 let g:gitgutter_highlight_lines   = get(g:, 'gitgutter_highlight_lines', 0)
    1              0.000009000 let g:gitgutter_highlight_linenrs = get(g:, 'gitgutter_highlight_linenrs', 0)
    1              0.000002000 let g:gitgutter_sign_priority     = get(g:, 'gitgutter_sign_priority', 10)
                            " Nvim 0.4.0 has an expanding sign column
                            " The sign_place() function supports sign priority.
    1              0.000004000 if (has('nvim-0.4.0') || exists('*sign_place')) && !exists('g:gitgutter_sign_allow_clobber')
    1              0.000001000   let g:gitgutter_sign_allow_clobber = 1
    1              0.000000000 endif
    1              0.000002000 let g:gitgutter_sign_allow_clobber   = get(g:, 'gitgutter_sign_allow_clobber', 0)
    1              0.000001000 let g:gitgutter_set_sign_backgrounds = get(g:, 'gitgutter_set_sign_backgrounds', 0)
    1              0.000001000 let g:gitgutter_sign_added           = get(g:, 'gitgutter_sign_added', '+')
    1              0.000002000 let g:gitgutter_sign_modified        = get(g:, 'gitgutter_sign_modified', '~')
    1              0.000001000 let g:gitgutter_sign_removed         = get(g:, 'gitgutter_sign_removed', '_')
                            
    1              0.000283000 if gitgutter#utility#supports_overscore_sign()
    1              0.000002000   let g:gitgutter_sign_removed_first_line = get(g:, 'gitgutter_sign_removed_first_line', '‾')
                            else
                              let g:gitgutter_sign_removed_first_line = get(g:, 'gitgutter_sign_removed_first_line', '_^')
    1              0.000000000 endif
                            
    1              0.000002000 let g:gitgutter_sign_removed_above_and_below = get(g:, 'gitgutter_sign_removed_above_and_below', '_¯')
    1              0.000002000 let g:gitgutter_sign_modified_removed        = get(g:, 'gitgutter_sign_modified_removed', '~_')
    1              0.000001000 let g:gitgutter_git_args                     = get(g:, 'gitgutter_git_args', '')
    1              0.000002000 let g:gitgutter_diff_relative_to             = get(g:, 'gitgutter_diff_relative_to', 'index')
    1              0.000002000 let g:gitgutter_diff_args                    = get(g:, 'gitgutter_diff_args', '')
    1              0.000001000 let g:gitgutter_diff_base                    = get(g:, 'gitgutter_diff_base', '')
    1              0.000002000 let g:gitgutter_map_keys                     = get(g:, 'gitgutter_map_keys', 1)
    1              0.000001000 let g:gitgutter_terminal_reports_focus       = get(g:, 'gitgutter_terminal_reports_focus', 1)
    1              0.000002000 let g:gitgutter_async                        = get(g:, 'gitgutter_async', 1)
    1              0.000001000 let g:gitgutter_log                          = get(g:, 'gitgutter_log', 0)
    1              0.000002000 let g:gitgutter_use_location_list            = get(g:, 'gitgutter_use_location_list', 0)
    1              0.000001000 let g:gitgutter_close_preview_on_escape      = get(g:, 'gitgutter_close_preview_on_escape', 0)
    1              0.000002000 let g:gitgutter_show_msg_on_hunk_jumping     = get(g:, 'gitgutter_show_msg_on_hunk_jumping', 1)
                            
    1              0.000002000 let g:gitgutter_git_executable = get(g:, 'gitgutter_git_executable', 'git')
    1              0.000027000 if !executable(g:gitgutter_git_executable)
                              if g:gitgutter_enabled
                                call gitgutter#utility#warn('Cannot find git. Please set g:gitgutter_git_executable.')
                              endif
                              finish
    1              0.000000000 endif
                            
    1              0.000001000 let default_grep = 'grep'
    1              0.000002000 let g:gitgutter_grep = get(g:, 'gitgutter_grep', default_grep)
    1              0.000001000 if !empty(g:gitgutter_grep)
    1              0.000043000   if executable(split(g:gitgutter_grep)[0])
    1              0.000003000     if $GREP_OPTIONS =~# '--color=always'
                                  let g:gitgutter_grep .= ' --color=never'
    1              0.000000000     endif
                              else
                                if g:gitgutter_grep !=# default_grep
                                  call gitgutter#utility#warn('Cannot find '.g:gitgutter_grep.'. Please check g:gitgutter_grep.')
                                endif
                                let g:gitgutter_grep = ''
    1              0.000001000   endif
    1              0.000000000 endif
                            
    1              0.000689000 call gitgutter#highlight#define_highlights()
    1              0.000063000 call gitgutter#highlight#define_signs()
                            
                            " Prevent infinite loop where:
                            " - executing a job in the foreground launches a new window which takes the focus;
                            " - when the job finishes, focus returns to gvim;
                            " - the FocusGained event triggers a new job (see below).
    1              0.000006000 if gitgutter#utility#windows() && !(g:gitgutter_async && gitgutter#async#available())
                              set noshelltemp
    1              0.000000000 endif
                            
                            " }}}
                            
                            " Primary functions {{{
                            
    1              0.000002000 command! -bar GitGutterAll call gitgutter#all(1)
    1              0.000002000 command! -bar GitGutter    call gitgutter#process_buffer(bufnr(''), 1)
                            
    1              0.000001000 command! -bar GitGutterDisable call gitgutter#disable()
    1              0.000002000 command! -bar GitGutterEnable  call gitgutter#enable()
    1              0.000001000 command! -bar GitGutterToggle  call gitgutter#toggle()
                            
    1              0.000002000 command! -bar GitGutterBufferDisable call gitgutter#buffer_disable()
    1              0.000001000 command! -bar GitGutterBufferEnable  call gitgutter#buffer_enable()
    1              0.000001000 command! -bar GitGutterBufferToggle  call gitgutter#buffer_toggle()
                            
    1              0.000001000 command! -bar GitGutterQuickFix call gitgutter#quickfix(0)
    1              0.000001000 command! -bar GitGutterQuickFixCurrentFile call gitgutter#quickfix(1)
                            
    1              0.000001000 command! -bar GitGutterDiffOrig call gitgutter#difforig()
                            
                            " }}}
                            
                            " Line highlights {{{
                            
    1              0.000002000 command! -bar GitGutterLineHighlightsDisable call gitgutter#highlight#line_disable()
    1              0.000001000 command! -bar GitGutterLineHighlightsEnable  call gitgutter#highlight#line_enable()
    1              0.000002000 command! -bar GitGutterLineHighlightsToggle  call gitgutter#highlight#line_toggle()
                            
                            " }}}
                            
                            " 'number' column highlights {{{
    1              0.000002000 command! -bar GitGutterLineNrHighlightsDisable call gitgutter#highlight#linenr_disable()
    1              0.000001000 command! -bar GitGutterLineNrHighlightsEnable  call gitgutter#highlight#linenr_enable()
    1              0.000002000 command! -bar GitGutterLineNrHighlightsToggle  call gitgutter#highlight#linenr_toggle()
                            " }}}
                            
                            " Signs {{{
                            
    1              0.000001000 command! -bar GitGutterSignsEnable  call gitgutter#sign#enable()
    1              0.000002000 command! -bar GitGutterSignsDisable call gitgutter#sign#disable()
    1              0.000001000 command! -bar GitGutterSignsToggle  call gitgutter#sign#toggle()
                            
                            " }}}
                            
                            " Hunks {{{
                            
    1              0.000003000 command! -bar -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
    1              0.000002000 command! -bar -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
                            
    1              0.000003000 command! -bar -range=% GitGutterStageHunk call gitgutter#hunk#stage(<line1>,<line2>)
    1              0.000002000 command! -bar GitGutterUndoHunk    call gitgutter#hunk#undo()
    1              0.000001000 command! -bar GitGutterPreviewHunk call gitgutter#hunk#preview()
                            
                            " Hunk text object
    1              0.000008000 onoremap <silent> <Plug>(GitGutterTextObjectInnerPending) :<C-U>call gitgutter#hunk#text_object(1)<CR>
    1              0.000004000 onoremap <silent> <Plug>(GitGutterTextObjectOuterPending) :<C-U>call gitgutter#hunk#text_object(0)<CR>
    1              0.000004000 xnoremap <silent> <Plug>(GitGutterTextObjectInnerVisual)  :<C-U>call gitgutter#hunk#text_object(1)<CR>
    1              0.000004000 xnoremap <silent> <Plug>(GitGutterTextObjectOuterVisual)  :<C-U>call gitgutter#hunk#text_object(0)<CR>
                            
                            
                            " Returns the git-diff hunks for the file or an empty list if there
                            " aren't any hunks.
                            "
                            " The return value is a list of lists.  There is one inner list per hunk.
                            "
                            "   [
                            "     [from_line, from_count, to_line, to_count],
                            "     [from_line, from_count, to_line, to_count],
                            "     ...
                            "   ]
                            "
                            " where:
                            "
                            " `from`  - refers to the staged file
                            " `to`    - refers to the working tree's file
                            " `line`  - refers to the line number where the change starts
                            " `count` - refers to the number of lines the change covers
    1              0.000001000 function! GitGutterGetHunks()
                              let bufnr = bufnr('')
                              return gitgutter#utility#is_active(bufnr) ? gitgutter#hunk#hunks(bufnr) : []
                            endfunction
                            
                            " Returns an array that contains a summary of the hunk status for the current
                            " window.  The format is [ added, modified, removed ], where each value
                            " represents the number of lines added/modified/removed respectively.
    1              0.000001000 function! GitGutterGetHunkSummary()
                              return gitgutter#hunk#summary(winbufnr(0))
                            endfunction
                            
                            " }}}
                            
                            " Folds {{{
                            
    1              0.000001000 command! -bar GitGutterFold call gitgutter#fold#toggle()
                            
                            " }}}
                            
    1              0.000001000 command! -bar GitGutterDebug call gitgutter#debug#debug()
                            
                            " Maps {{{
                            
    1              0.000005000 nnoremap <silent> <expr> <Plug>(GitGutterNextHunk) &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
    1              0.000007000 nnoremap <silent> <expr> <Plug>GitGutterNextHunk   &diff ? ']c' : ":\<C-U>call gitgutter#utility#warn('Please change your map \<lt>Plug>GitGutterNextHunk to \<lt>Plug>(GitGutterNextHunk)')\<CR>"
    1              0.000004000 nnoremap <silent> <expr> <Plug>(GitGutterPrevHunk) &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
    1              0.000007000 nnoremap <silent> <expr> <Plug>GitGutterPrevHunk   &diff ? '[c' : ":\<C-U>call gitgutter#utility#warn('Please change your map \<lt>Plug>GitGutterPrevHunk to \<lt>Plug>(GitGutterPrevHunk)')\<CR>"
                            
    1              0.000003000 xnoremap <silent> <Plug>(GitGutterStageHunk)   :GitGutterStageHunk<CR>
    1              0.000006000 xnoremap <silent> <Plug>GitGutterStageHunk     :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterStageHunk to <lt>Plug>(GitGutterStageHunk)')<CR>
    1              0.000003000 nnoremap <silent> <Plug>(GitGutterStageHunk)   :GitGutterStageHunk<CR>
    1              0.000006000 nnoremap <silent> <Plug>GitGutterStageHunk     :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterStageHunk to <lt>Plug>(GitGutterStageHunk)')<CR>
    1              0.000003000 nnoremap <silent> <Plug>(GitGutterUndoHunk)    :GitGutterUndoHunk<CR>
    1              0.000006000 nnoremap <silent> <Plug>GitGutterUndoHunk      :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterUndoHunk to <lt>Plug>(GitGutterUndoHunk)')<CR>
    1              0.000003000 nnoremap <silent> <Plug>(GitGutterPreviewHunk) :GitGutterPreviewHunk<CR>
    1              0.000006000 nnoremap <silent> <Plug>GitGutterPreviewHunk   :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterPreviewHunk to <lt>Plug>(GitGutterPreviewHunk)')<CR>
                            
                            " }}}
                            
    1              0.000001000 function! s:on_bufenter()
                              call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
                              if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start') && has('lambda')
                                  call s:next_tick("call gitgutter#process_buffer(+".bufnr('').", 0)")
                                else
                                  call gitgutter#process_buffer(bufnr(''), 0)
                                endif
                                return
                              endif
                            
                              if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
                                call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
                              endif
                            endfunction
                            
    1              0.000001000 function! s:next_tick(cmd)
                              call timer_start(1, {-> execute(a:cmd)})
                            endfunction
                            
                            " Autocommands {{{
                            
    1              0.000001000 augroup gitgutter
    1              0.000020000   autocmd!
                            
    1              0.000002000   autocmd TabEnter * let t:gitgutter_didtabenter = 1
                            
    1              0.000002000   autocmd BufEnter * call s:on_bufenter()
                            
                              " Ensure Vim is always checking for CursorMoved to avoid CursorMoved
                              " being fired at the wrong time in floating preview window on Neovim.
                              " See vim/vim#2053.
    1              0.000001000   autocmd CursorMoved * execute ''
                            
    1              0.000002000   autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(bufnr(''), 0)
    1              0.000003000   if exists('*timer_start') && has('lambda')
    1              0.000002000     autocmd FileChangedShellPost * call s:next_tick("call gitgutter#process_buffer(+".expand('<abuf>').", 1)")
                              else
                                autocmd FileChangedShellPost * call gitgutter#process_buffer(+expand('<abuf>'), 1)
    1              0.000000000   endif
                            
                              " Ensure that all buffers are processed when opening vim with multiple files, e.g.:
                              "
                              "   vim -o file1 file2
    1              0.000002000   autocmd VimEnter * if winnr() != winnr('$') | call gitgutter#all(0) | endif
                            
    1              0.000002000   autocmd ShellCmdPost * call gitgutter#all(1)
    1              0.000002000   autocmd BufLeave term://* call gitgutter#all(1)
                            
    1              0.000002000   autocmd User FugitiveChanged call gitgutter#all(1)
                            
    1              0.000002000   autocmd BufFilePre  * GitGutterBufferDisable
    1              0.000001000   autocmd BufFilePost * GitGutterBufferEnable
                            
                              " Handle all buffers when focus is gained, but only after it was lost.
                              " FocusGained gets triggered on startup with Neovim at least already.
                              " Therefore this tracks also if it was lost before.
    1              0.000002000   let s:focus_was_lost = 0
    1              0.000001000   autocmd FocusGained * if s:focus_was_lost | let s:focus_was_lost = 0 | call gitgutter#all(1) | endif
    1              0.000001000   autocmd FocusLost * let s:focus_was_lost = 1
                            
    1              0.000001000   if exists('##VimResume')
    1              0.000001000     autocmd VimResume * call gitgutter#all(1)
    1              0.000000000   endif
                            
    1              0.000001000   autocmd ColorScheme * call gitgutter#highlight#define_highlights()
                            
                              " Disable during :vimgrep
    1              0.000002000   autocmd QuickFixCmdPre  *vimgrep* let [g:gitgutter_was_enabled, g:gitgutter_enabled] = [g:gitgutter_enabled, 0]
    1              0.000002000   autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = g:gitgutter_was_enabled | unlet g:gitgutter_was_enabled
    1              0.000001000 augroup END
                            
                            " }}}
                            
                            " vim:set et sw=2 fdm=marker:

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim
Sourced 1 time
Total time:   0.000104000
 Self time:   0.000104000

count     total (s)      self (s)
    1              0.000001000 function! gitgutter#utility#supports_overscore_sign()
                              if gitgutter#utility#windows()
                                return &encoding ==? 'utf-8'
                              else
                                return &termencoding ==? &encoding || &termencoding == ''
                              endif
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#setbufvar(buffer, varname, val)
                              let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
                              let ggvars = getbufvar(buffer, 'gitgutter')
                              if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
                              endif
                              let ggvars[a:varname] = a:val
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#getbufvar(buffer, varname, ...)
                              let ggvars = getbufvar(a:buffer, 'gitgutter')
                              if type(ggvars) == type({}) && has_key(ggvars, a:varname)
                                return ggvars[a:varname]
                              endif
                              if a:0
                                return a:1
                              endif
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#warn(message) abort
                              echohl WarningMsg
                              echo a:message
                              echohl None
                              let v:warningmsg = a:message
                            endfunction
                            
    1              0.000000000 function! gitgutter#utility#warn_once(bufnr, message, key) abort
                              if empty(gitgutter#utility#getbufvar(a:bufnr, a:key))
                                call gitgutter#utility#setbufvar(a:bufnr, a:key, '1')
                                echohl WarningMsg
                                redraw | echom a:message
                                echohl None
                                let v:warningmsg = a:message
                              endif
                            endfunction
                            
                            " Returns truthy when the buffer's file should be processed; and falsey when it shouldn't.
                            " This function does not and should not make any system calls.
    1              0.000001000 function! gitgutter#utility#is_active(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'enabled') &&
                                    \ !pumvisible() &&
                                    \ s:is_file_buffer(a:bufnr) &&
                                    \ s:exists_file(a:bufnr) &&
                                    \ s:not_git_dir(a:bufnr)
                            endfunction
                            
    1              0.000001000 function! s:not_git_dir(bufnr) abort
                              return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'
                            endfunction
                            
    1              0.000001000 function! s:is_file_buffer(bufnr) abort
                              return empty(getbufvar(a:bufnr, '&buftype'))
                            endfunction
                            
                            " From tpope/vim-fugitive
    1              0.000001000 function! s:winshell()
                              return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
                            endfunction
                            
                            " From tpope/vim-fugitive
    1              0.000001000 function! gitgutter#utility#shellescape(arg) abort
                              if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#file(bufnr)
                              return s:abs_path(a:bufnr, 1)
                            endfunction
                            
                            " Not shellescaped
    1              0.000001000 function! gitgutter#utility#extension(bufnr) abort
                              return fnamemodify(s:abs_path(a:bufnr, 0), ':e')
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#system(cmd, ...) abort
                              call gitgutter#debug#log(a:cmd, a:000)
                            
                              call s:use_known_shell()
                              silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
                              call s:restore_shell()
                            
                              return output
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#has_repo_path(bufnr)
                              return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1
                            endfunction
                            
                            " Path of file relative to repo root.
                            "
                            " *     empty string - not set
                            " * non-empty string - path
                            " *               -1 - pending
                            " *               -2 - not tracked by git
                            " *               -3 - assume unchanged
    1              0.000001000 function! gitgutter#utility#repo_path(bufnr, shellesc) abort
                              let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
                              return a:shellesc ? gitgutter#utility#shellescape(p) : p
                            endfunction
                            
                            
    1              0.000002000 let s:set_path_handler = {}
                            
    1              0.000001000 function! s:set_path_handler.out(buffer, listing) abort
                              let listing = s:strip_trailing_new_line(a:listing)
                              let [status, path] = [listing[0], listing[2:]]
                              if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:buffer, 'path', -3)
                              else
                                call gitgutter#utility#setbufvar(a:buffer, 'path', path)
                              endif
                            
                              if type(self.continuation) == type(function('tr'))
                                call self.continuation()
                              else
                                call call(self.continuation.function, self.continuation.arguments)
                              endif
                            endfunction
                            
    1              0.000001000 function! s:set_path_handler.err(buffer) abort
                              call gitgutter#utility#setbufvar(a:buffer, 'path', -2)
                            endfunction
                            
                            
                            " continuation - a funcref or hash to call after setting the repo path asynchronously.
                            "
                            " Returns 'async' if the the path is set asynchronously, 0 otherwise.
    1              0.000001000 function! gitgutter#utility#set_repo_path(bufnr, continuation) abort
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                              " *               -3 - assume unchanged
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr,
                                    \ g:gitgutter_git_executable.' '.g:gitgutter_git_args.
                                    \ ' ls-files -v --error-unmatch --full-name -z -- '.
                                    \ gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
                              if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
                                let handler = copy(s:set_path_handler)
                                let handler.continuation = a:continuation
                                call gitgutter#async#execute(cmd, a:bufnr, handler)
                                return 'async'
                              endif
                            
                              let listing = gitgutter#utility#system(cmd)
                            
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                return
                              endif
                            
                              let listing = s:strip_trailing_new_line(listing)
                              let [status, path] = [listing[0], listing[2:]]
                              if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#utility#cd_cmd(bufnr, cmd) abort
                              let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
                              return cd.' '.s:dir(a:bufnr).' && '.a:cmd
                            endfunction
                            
    1              0.000001000 function! s:unc_path(bufnr)
                              return s:abs_path(a:bufnr, 0) =~ '^\\\\'
                            endfunction
                            
    1              0.000000000 function! s:dos_shell()
                              return &shell == 'cmd.exe' || &shell == 'command.com'
                            endfunction
                            
    1              0.000001000 function! s:use_known_shell() abort
                              if has('unix') && &shell !=# 'sh'
                                let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
                                let &shell = 'sh'
                                set shellcmdflag=-c shellredir=>%s\ 2>&1
                              endif
                              if has('win32') && (&shell =~# 'pwsh' || &shell =~# 'powershell')
                                let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
                                let &shell = 'cmd.exe'
                                set shellcmdflag=/s\ /c shellredir=>%s\ 2>&1 shellpipe=>%s\ 2>&1 shellquote= shellxquote="
                              endif
                            endfunction
                            
    1              0.000001000 function! s:restore_shell() abort
                              if (has('unix') || has('win32')) && exists('s:shell')
                                let [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote] = [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote]
                              endif
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#get_diff_base(bufnr)
                              let p = resolve(expand('#'.a:bufnr.':p'))
                              let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
                              if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
                              endif
                              return g:gitgutter_diff_base
                            endfunction
                            
    1              0.000001000 function! s:abs_path(bufnr, shellesc)
                              let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
                              let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
                              return a:shellesc ? gitgutter#utility#shellescape(p) : p
                            endfunction
                            
    1              0.000001000 function! s:dir(bufnr) abort
                              return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))
                            endfunction
                            
                            " Not shellescaped.
    1              0.000001000 function! s:filename(bufnr) abort
                              return fnamemodify(s:abs_path(a:bufnr, 0), ':t')
                            endfunction
                            
    1              0.000001000 function! s:exists_file(bufnr) abort
                              return filereadable(s:abs_path(a:bufnr, 0))
                            endfunction
                            
                            " Get rid of any trailing new line or SOH character.
                            "
                            " git ls-files -z produces output with null line termination.
                            " Vim's system() replaces any null characters in the output
                            " with SOH (start of header), i.e. ^A.
    1              0.000001000 function! s:strip_trailing_new_line(line) abort
                              return substitute(a:line, '[[:cntrl:]]$', '', '')
                            endfunction
                            
    1              0.000001000 function! gitgutter#utility#windows()
                              return has('win64') || has('win32') || has('win16')
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim
Sourced 1 time
Total time:   0.000087000
 Self time:   0.000087000

count     total (s)      self (s)
    1              0.000001000 function! gitgutter#highlight#line_disable() abort
                              let g:gitgutter_highlight_lines = 0
                              call s:define_sign_line_highlights()
                            
                              if !g:gitgutter_signs
                                call gitgutter#sign#clear_signs(bufnr(''))
                              endif
                            
                              redraw!
                            endfunction
                            
    1              0.000001000 function! gitgutter#highlight#line_enable() abort
                              let old_highlight_lines = g:gitgutter_highlight_lines
                            
                              let g:gitgutter_highlight_lines = 1
                              call s:define_sign_line_highlights()
                            
                              if !old_highlight_lines && !g:gitgutter_signs
                                call gitgutter#all(1)
                              endif
                            
                              redraw!
                            endfunction
                            
    1              0.000001000 function! gitgutter#highlight#line_toggle() abort
                              if g:gitgutter_highlight_lines
                                call gitgutter#highlight#line_disable()
                              else
                                call gitgutter#highlight#line_enable()
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#highlight#linenr_disable() abort
                              let g:gitgutter_highlight_linenrs = 0
                              call s:define_sign_linenr_highlights()
                            
                              if !g:gitgutter_signs
                                call gitgutter#sign#clear_signs(bufnr(''))
                              endif
                            
                              redraw!
                            endfunction
                            
    1              0.000001000 function! gitgutter#highlight#linenr_enable() abort
                              let old_highlight_linenrs = g:gitgutter_highlight_linenrs
                            
                              let g:gitgutter_highlight_linenrs = 1
                              call s:define_sign_linenr_highlights()
                            
                              if !old_highlight_linenrs && !g:gitgutter_signs
                                call gitgutter#all(1)
                              endif
                            
                              redraw!
                            endfunction
                            
    1              0.000001000 function! gitgutter#highlight#linenr_toggle() abort
                              if g:gitgutter_highlight_linenrs
                                call gitgutter#highlight#linenr_disable()
                              else
                                call gitgutter#highlight#linenr_enable()
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#highlight#define_highlights() abort
                              let [guibg, ctermbg] = s:get_background_colors('SignColumn')
                            
                              " Highlights used by the signs.
                            
                              " When they are invisible.
                              execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
                              execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
                              execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
                              highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
                            
                              " When they are visible.
                              for type in ["Add", "Change", "Delete"]
                                if hlexists("GitGutter".type) && s:get_foreground_colors("GitGutter".type) != ['NONE', 'NONE']
                                  if g:gitgutter_set_sign_backgrounds
                                    execute "highlight GitGutter".type." guibg=".guibg." ctermbg=".ctermbg
                                  endif
                                  continue
                                elseif s:useful_diff_colours()
                                  let [guifg, ctermfg] = s:get_foreground_colors('Diff'.type)
                                else
                                  let [guifg, ctermfg] = s:get_foreground_fallback_colors(type)
                                endif
                                execute "highlight GitGutter".type." guifg=".guifg." guibg=".guibg." ctermfg=".ctermfg." ctermbg=".ctermbg
                              endfor
                            
                              if hlexists("GitGutterChangeDelete") && g:gitgutter_set_sign_backgrounds
                                execute "highlight GitGutterChangeDelete guibg=".guibg." ctermbg=".ctermbg
                              endif
                            
                              highlight default link GitGutterChangeDelete GitGutterChange
                            
                              " Highlights used for the whole line.
                            
                              highlight default link GitGutterAddLine          DiffAdd
                              highlight default link GitGutterChangeLine       DiffChange
                              highlight default link GitGutterDeleteLine       DiffDelete
                              highlight default link GitGutterChangeDeleteLine GitGutterChangeLine
                            
                              highlight default link GitGutterAddLineNr          CursorLineNr
                              highlight default link GitGutterChangeLineNr       CursorLineNr
                              highlight default link GitGutterDeleteLineNr       CursorLineNr
                              highlight default link GitGutterChangeDeleteLineNr CursorLineNr
                            
                              " Highlights used intra line.
                              highlight default GitGutterAddIntraLine    gui=reverse cterm=reverse
                              highlight default GitGutterDeleteIntraLine gui=reverse cterm=reverse
                              " Set diff syntax colours (used in the preview window) - diffAdded,diffChanged,diffRemoved -
                              " to match the signs, if not set aleady.
                              for [dtype,type] in [['Added','Add'], ['Changed','Change'], ['Removed','Delete']]
                                if !hlexists('diff'.dtype)
                                  let [guifg, ctermfg] = s:get_foreground_colors('GitGutter'.type)
                                  execute "highlight diff".dtype." guifg=".guifg." ctermfg=".ctermfg." guibg=NONE ctermbg=NONE"
                                endif
                              endfor
                            endfunction
                            
    1              0.000001000 function! gitgutter#highlight#define_signs() abort
                              sign define GitGutterLineAdded
                              sign define GitGutterLineModified
                              sign define GitGutterLineRemoved
                              sign define GitGutterLineRemovedFirstLine
                              sign define GitGutterLineRemovedAboveAndBelow
                              sign define GitGutterLineModifiedRemoved
                            
                              call s:define_sign_text()
                              call gitgutter#highlight#define_sign_text_highlights()
                              call s:define_sign_line_highlights()
                              call s:define_sign_linenr_highlights()
                            endfunction
                            
    1              0.000001000 function! s:define_sign_text() abort
                              execute "sign define GitGutterLineAdded                 text=" . g:gitgutter_sign_added
                              execute "sign define GitGutterLineModified              text=" . g:gitgutter_sign_modified
                              execute "sign define GitGutterLineRemoved               text=" . g:gitgutter_sign_removed
                              execute "sign define GitGutterLineRemovedFirstLine      text=" . g:gitgutter_sign_removed_first_line
                              execute "sign define GitGutterLineRemovedAboveAndBelow  text=" . g:gitgutter_sign_removed_above_and_below
                              execute "sign define GitGutterLineModifiedRemoved       text=" . g:gitgutter_sign_modified_removed
                            endfunction
                            
    1              0.000001000 function! gitgutter#highlight#define_sign_text_highlights() abort
                              " Once a sign's text attribute has been defined, it cannot be undefined or
                              " set to an empty value.  So to make signs' text disappear (when toggling
                              " off or disabling) we make them invisible by setting their foreground colours
                              " to the background's.
                              if g:gitgutter_signs
                                sign define GitGutterLineAdded                 texthl=GitGutterAdd
                                sign define GitGutterLineModified              texthl=GitGutterChange
                                sign define GitGutterLineRemoved               texthl=GitGutterDelete
                                sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
                                sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
                                sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
                              else
                                sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
                                sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
                                sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
                              endif
                            endfunction
                            
    1              0.000001000 function! s:define_sign_line_highlights() abort
                              if g:gitgutter_highlight_lines
                                sign define GitGutterLineAdded                 linehl=GitGutterAddLine
                                sign define GitGutterLineModified              linehl=GitGutterChangeLine
                                sign define GitGutterLineRemoved               linehl=GitGutterDeleteLine
                                sign define GitGutterLineRemovedFirstLine      linehl=GitGutterDeleteLine
                                sign define GitGutterLineRemovedAboveAndBelow  linehl=GitGutterDeleteLine
                                sign define GitGutterLineModifiedRemoved       linehl=GitGutterChangeDeleteLine
                              else
                                sign define GitGutterLineAdded                 linehl=NONE
                                sign define GitGutterLineModified              linehl=NONE
                                sign define GitGutterLineRemoved               linehl=NONE
                                sign define GitGutterLineRemovedFirstLine      linehl=NONE
                                sign define GitGutterLineRemovedAboveAndBelow  linehl=NONE
                                sign define GitGutterLineModifiedRemoved       linehl=NONE
                              endif
                            endfunction
                            
    1              0.000001000 function! s:define_sign_linenr_highlights() abort
                              if has('nvim-0.3.2')
                                try
                                  if g:gitgutter_highlight_linenrs
                                    sign define GitGutterLineAdded                 numhl=GitGutterAddLineNr
                                    sign define GitGutterLineModified              numhl=GitGutterChangeLineNr
                                    sign define GitGutterLineRemoved               numhl=GitGutterDeleteLineNr
                                    sign define GitGutterLineRemovedFirstLine      numhl=GitGutterDeleteLineNr
                                    sign define GitGutterLineRemovedAboveAndBelow  numhl=GitGutterDeleteLineNr
                                    sign define GitGutterLineModifiedRemoved       numhl=GitGutterChangeDeleteLineNr
                                  else
                                    sign define GitGutterLineAdded                 numhl=NONE
                                    sign define GitGutterLineModified              numhl=NONE
                                    sign define GitGutterLineRemoved               numhl=NONE
                                    sign define GitGutterLineRemovedFirstLine      numhl=NONE
                                    sign define GitGutterLineRemovedAboveAndBelow  numhl=NONE
                                    sign define GitGutterLineModifiedRemoved       numhl=NONE
                                  endif
                                catch /E475/
                                endtry
                              endif
                            endfunction
                            
    1              0.000001000 function! s:get_hl(group, what, mode) abort
                              let r = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
                              if empty(r) || r == -1
                                return 'NONE'
                              endif
                              return r
                            endfunction
                            
    1              0.000001000 function! s:get_foreground_colors(group) abort
                              let ctermfg = s:get_hl(a:group, 'fg', 'cterm')
                              let guifg = s:get_hl(a:group, 'fg', 'gui')
                              return [guifg, ctermfg]
                            endfunction
                            
    1              0.000001000 function! s:get_background_colors(group) abort
                              let ctermbg = s:get_hl(a:group, 'bg', 'cterm')
                              let guibg = s:get_hl(a:group, 'bg', 'gui')
                              return [guibg, ctermbg]
                            endfunction
                            
    1              0.000001000 function! s:useful_diff_colours()
                              let [guifg_add, ctermfg_add] = s:get_foreground_colors('DiffAdd')
                              let [guifg_del, ctermfg_del] = s:get_foreground_colors('DiffDelete')
                            
                              return guifg_add != guifg_del && ctermfg_add != ctermfg_del
                            endfunction
                            
    1              0.000001000 function! s:get_foreground_fallback_colors(type)
                              if a:type == 'Add'
                                return ['#009900', '2']
                              elseif a:type == 'Change'
                                return ['#bbbb00', '3']
                              elseif a:type == 'Delete'
                                return ['#ff2222', '1']
                              endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-test/plugin/test.vim
Sourced 1 time
Total time:   0.001202000
 Self time:   0.001202000

count     total (s)      self (s)
    1              0.000002000 if exists('g:loaded_test')
                              finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_test = 1
                            
    1              0.000004000 let g:test#plugin_path = expand('<sfile>:p:h:h')
                            
    1              0.000028000 let g:test#default_runners = {
                              \ 'CSharp':     ['Xunit', 'DotnetTest'],
                              \ 'Clojure':    ['FireplaceTest', 'LeinTest'],
                              \ 'Crystal':    ['CrystalSpec'],
                              \ 'Cpp':        ['Catch2'],
                              \ 'Dart':       ['DartTest', 'FlutterTest'],
                              \ 'Elixir':     ['ExUnit', 'ESpec'],
                              \ 'Elm':        ['ElmTest'],
                              \ 'Erlang':     ['CommonTest', 'EUnit', 'PropEr'],
                              \ 'Go':         ['GoTest', 'Ginkgo', 'RichGo', 'Delve'],
                              \ 'Groovy':     ['MavenTest', 'GradleTest'],
                              \ 'Haskell':    ['StackTest', 'CabalTest'],
                              \ 'Java':       ['MavenTest', 'GradleTest'],
                              \ 'JavaScript': ['Ava', 'CucumberJS', 'DenoTest', 'Intern', 'TAP', 'Teenytest', 'Karma', 'Lab', 'Mocha',  'NgTest', 'Nx', 'Jasmine', 'Jest', 'ReactScripts', 'WebdriverIO', 'Cypress', 'VueTestUtils', 'Playwright', 'Vitest', 'Ember'],
                              \ 'Kotlin':     ['GradleTest'],
                              \ 'Lua':        ['Busted'],
                              \ 'Mint':       ['MintTest'],
                              \ 'Nim':        ['UnitTest'],
                              \ 'PHP':        ['Codeception', 'Dusk', 'Pest', 'PHPUnit', 'Behat', 'PHPSpec', 'Kahlan', 'Peridot'],
                              \ 'Perl':       ['Prove'],
                              \ 'Python':     ['Behave', 'DjangoTest', 'PyTest', 'PyUnit', 'Nose', 'Nose2', 'Mamba'],
                              \ 'Racket':     ['RackUnit'],
                              \ 'Ruby':       ['Rails', 'M', 'Minitest', 'RSpec', 'Cucumber', 'TestBench'],
                              \ 'Rust':       ['CargoNextest', 'CargoTest'],
                              \ 'Scala':      ['SbtTest', 'BloopTest'],
                              \ 'Shell':      ['Bats', 'ShellSpec'],
                              \ 'Swift':      ['SwiftPM'],
                              \ 'VimL':       ['Themis', 'VSpec', 'Vader', 'Testify', 'Vroom'],
                              \ 'Zig':        ['ZigTest'],
                              \ 'Gleam':      ['GleamTest'],
                            \}
                            
    1              0.000002000 let g:test#custom_strategies = get(g:, 'test#custom_strategies', {})
    1              0.000001000 let g:test#custom_transformations = get(g:, 'test#custom_transformations', {})
    1              0.000002000 let g:test#runner_commands = get(g:, 'test#runner_commands', [])
                            
    1              0.000006000 command! -nargs=* -bar TestNearest call test#run('nearest', split(<q-args>))
    1              0.000003000 command! -nargs=* -bar -complete=file
                                  \                TestFile    call test#run('file', split(<q-args>))
    1              0.000002000 command! -nargs=* -bar TestClass   call test#run('class', split(<q-args>))
    1              0.000002000 command! -nargs=* -bar TestSuite   call test#run('suite', split(<q-args>))
    1              0.000056000 command! -nargs=* -bar TestLast    call test#run_last(split(<q-args>))
    1              0.000003000 command!          -bar TestVisit   call test#visit()
                            
   30              0.000467000 for [s:language, s:runners] in items(test#get_runners())
  114              0.000044000   for s:runner in s:runners
   85              0.000088000     if index(g:test#runner_commands, s:runner) != -1
                                  if exists(':'.s:runner) | continue | endif
                                  let s:runner_id = tolower(s:language).'#'.tolower(s:runner)
                                  execute 'command! -bar -nargs=* -complete=file'
                                        \ s:runner
                                        \ 'call test#execute("'.s:runner_id.'", split(<q-args>))'
   85              0.000023000     endif
  114              0.000038000   endfor
   30              0.000011000 endfor
                            
    1              0.000001000 if &autochdir
                              let g:test#project_root = getcwd()
    1              0.000001000 endif

SCRIPT  /Users/danbradbury/.vim/bundle/vim-test/autoload/test.vim
Sourced 1 time
Total time:   0.000113000
 Self time:   0.000113000

count     total (s)      self (s)
    1              0.000003000 function! test#run(type, arguments) abort
                              call s:before_run()
                            
                              let alternate_file = s:alternate_file()
                            
                              if test#test_file(expand('%'))
                                let position = s:get_position(expand('%'))
                                let g:test#last_position = position
                              elseif !empty(alternate_file) && test#test_file(alternate_file) && (!exists('g:test#last_position') || alternate_file !=# g:test#last_position['file'])
                                let position = s:get_position(alternate_file)
                              elseif exists('g:test#last_position')
                                let position = g:test#last_position
                              else
                                call s:after_run()
                                call s:echo_failure('Not a test file') | return
                              endif
                            
                              let runner = test#determine_runner(position['file'])
                            
                              let args = test#base#build_position(runner, a:type, position)
                              let args = a:arguments + args
                              let args = test#base#options(runner, args, a:type)
                            
                              if type(get(g:, 'test#strategy')) == type({})
                                let strategy = get(g:test#strategy, a:type)
                                call test#execute(runner, args, strategy)
                              else
                                call test#execute(runner, args)
                              endif
                            
                              call s:after_run()
                            endfunction
                            
    1              0.000001000 function! test#run_last(arguments) abort
                              if exists('g:test#last_command')
                                call s:before_run()
                            
                                let env = s:extract_env_from_command(a:arguments)
                                let strategy = s:extract_strategy_from_command(a:arguments)
                            
                                if empty(strategy)
                                  let strategy = g:test#last_strategy
                                endif
                            
                                let cmd = [env, g:test#last_command] + a:arguments
                                call filter(cmd, '!empty(v:val)')
                            
                                call test#shell(join(cmd), strategy)
                            
                                call s:after_run()
                              else
                                call s:echo_failure('No tests were run so far')
                              endif
                            endfunction
                            
    1              0.000001000 function! test#exists() abort
                              return test#test_file(expand('%')) || test#test_file(s:alternate_file())
                            endfunction
                            
    1              0.000001000 function! test#visit() abort
                              if exists('g:test#last_position')
                                execute 'edit' '+'.g:test#last_position['line'] g:test#last_position['file']
                              else
                                call s:echo_failure('No tests were run so far')
                              endif
                            endfunction
                            
    1              0.000002000 function! test#execute(runner, args, ...) abort
                              let env = s:extract_env_from_command(a:args)
                              let strategy = s:extract_strategy_from_command(a:args)
                              if empty(strategy)
                                if !empty(a:000)
                                  let strategy = a:1
                                else
                                  let strategy = get(g:, 'test#strategy')
                                endif
                              endif
                              if empty(strategy)
                                let strategy = 'basic'
                              endif
                            
                              let args = a:args
                              let args = test#base#options(a:runner, args)
                              call filter(args, '!empty(v:val)')
                            
                              let executable = test#base#executable(a:runner)
                              let args = test#base#build_args(a:runner, args, strategy)
                              let cmd = [env, executable] + args
                              call filter(cmd, '!empty(v:val)')
                            
                              call test#shell(join(cmd), strategy)
                            endfunction
                            
    1              0.000002000 function! test#shell(cmd, strategy) abort
                              let g:test#last_command = a:cmd
                              let g:test#last_strategy = a:strategy
                            
                              let cmd = a:cmd
                            
                              if has_key(g:, 'test#transformation')
                                let cmd = g:test#custom_transformations[g:test#transformation](cmd)
                              endif
                            
                              if cmd =~# '^:'
                                let strategy = 'vimscript'
                              else
                                let strategy = a:strategy
                              endif
                            
                              if has_key(g:test#custom_strategies, strategy)
                                call g:test#custom_strategies[strategy](cmd)
                              else
                                call test#strategy#{strategy}(cmd)
                              endif
                            endfunction
                            
    1              0.000001000 function! test#determine_runner(file) abort
                              for [language, runners] in items(test#get_runners())
                                for runner in runners
                                  let runner = tolower(language).'#'.tolower(runner)
                                  if exists("g:test#enabled_runners")
                                    if index(g:test#enabled_runners, runner) < 0
                                      continue
                                    endif
                                  endif
                                  if test#base#test_file(runner, fnamemodify(a:file, ':.'))
                                    return runner
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000001000 function! test#get_runners() abort
                              if exists('g:test#runners')
                                let custom_runners = g:test#runners
                              elseif exists('g:test#custom_runners')
                                let custom_runners = g:test#custom_runners
                              else
                                let custom_runners = {}
                              endif
                            
                              return s:extend(custom_runners, g:test#default_runners)
                            endfunction
                            
    1              0.000001000 function! test#test_file(file) abort
                              return !empty(test#determine_runner(a:file))
                            endfunction
                            
    1              0.000002000 function! s:alternate_file() abort
                              if get(g:, 'test#no_alternate') | return '' | endif
                              let alternate_file = ''
                            
                              if empty(alternate_file) && exists('g:loaded_projectionist')
                                let alternate_file = get(filter(projectionist#query_file('alternate'), 'filereadable(v:val)'), 0, '')
                              endif
                            
                              if empty(alternate_file) && has_key(g:, 'test#custom_alternate_file')
                                let alternate_file = g:test#custom_alternate_file()
                              endif
                            
                              if empty(alternate_file) && exists('g:loaded_rails') && !empty(rails#app())
                                let alternate_file = rails#buffer().alternate()
                              endif
                            
                              return alternate_file
                            endfunction
                            
    1              0.000001000 function! s:before_run() abort
                              let modified_buffers = len(getbufinfo({'bufmodified': 1}))
                              if &autowrite || &autowriteall
                                silent! wall
                            
                              elseif exists('g:test#prompt_for_unsaved_changes') && l:modified_buffers
                                let answer = confirm(
                                    \ "Warning: you have unsaved changes",
                                    \ "&write\nwrite &all\n&continue", 3)
                            
                                if l:answer == 1
                                  write
                                elseif l:answer == 2
                                  wall
                                endif
                              endif
                            
                              if exists('g:test#project_root')
                                if type(g:test#project_root) == v:t_func
                                  execute 'cd' g:test#project_root()
                                else
                                  execute 'cd' g:test#project_root
                                endif
                              endif
                            endfunction
                            
    1              0.000001000 function! s:after_run() abort
                              if exists('g:test#project_root')
                                execute 'cd -'
                              endif
                            endfunction
                            
    1              0.000001000 function! s:get_position(path) abort
                              let filename_modifier = get(g:, 'test#filename_modifier', ':.')
                            
                              let position = {}
                              let position['file'] = fnamemodify(a:path, filename_modifier)
                              let position['line'] = a:path == expand('%') ? line('.') : 1
                              let position['col']  = a:path == expand('%') ? col('.') : 1
                            
                              return position
                            endfunction
                            
    1              0.000001000 function! s:extract_strategy_from_command(arguments) abort
                              for idx in range(0, len(a:arguments) - 1)
                                if a:arguments[idx] =~# '^-strategy='
                                  return substitute(remove(a:arguments, idx), '-strategy=', '', '')
                                endif
                              endfor
                            endfunction
                            
    1              0.000001000 function! s:extract_env_from_command(arguments) abort
                              let env = filter(copy(a:arguments), 'v:val =~# ''^[A-Z_]\+=.\+''')
                              call filter(a:arguments, 'v:val !~# ''^[A-Z_]\+=.\+''')
                              return join(env)
                            endfunction
                            
    1              0.000001000 function! s:echo_failure(message) abort
                              echohl WarningMsg
                              echo a:message
                              echohl None
                            endfunction
                            
    1              0.000000000 function! s:extend(source, dict) abort
                              let result = {}
                              for [key, value] in items(a:source)
                                let result[key] = value
                              endfor
                              for [key, value] in items(a:dict)
                                let result[key] = get(result, key, []) + value
                              endfor
                              return result
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-dispatch/plugin/dispatch.vim
Sourced 1 time
Total time:   0.000928000
 Self time:   0.000150000

count     total (s)      self (s)
                            " Location:     plugin/dispatch.vim
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.8
                            " GetLatestVimScripts: 4504 1 :AutoInstall: dispatch.vim
                            
    1              0.000003000 if exists("g:loaded_dispatch") || v:version < 700 || &compatible
                              finish
    1              0.000000000 endif
    1              0.000002000 let g:loaded_dispatch = 1
                            
    1              0.000009000 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete Dispatch
                                  \ execute dispatch#compile_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000007000 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete FocusDispatch
                                  \ execute dispatch#focus_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000007000 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#make_complete Make
                                  \ execute dispatch#compile_command(<bang>0, '-- ' . <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000006000 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete Spawn
                                  \ execute dispatch#spawn_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000007000 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete Start
                                  \ execute dispatch#start_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000002000 command! -bang -bar Copen call dispatch#copen(<bang>0, '<mods>')
                            
    1              0.000002000 command! -bang -bar -nargs=* AbortDispatch
                                  \ execute dispatch#abort_command(<bang>0, <q-args>)
                            
    1              0.000002000 function! s:map(mode, lhs, rhs, ...) abort
                              let flags = (a:0 ? a:1 : '') . (a:rhs =~# '^<Plug>' ? '' : '<script>')
                              let head = a:lhs
                              let tail = ''
                              let keys = get(g:, a:mode.'remap', {})
                              if type(keys) == type([])
                                return
                              endif
                              while !empty(head)
                                if has_key(keys, head)
                                  let head = keys[head]
                                  if empty(head)
                                    return
                                  endif
                                  break
                                endif
                                let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                              endwhile
                              exe a:mode.'map' flags head.tail a:rhs
                            endfunction
                            
    1              0.000007000 nmap <script> <SID>:.    :<C-R>=getcmdline() =~ ',' ? "\0250" : ""<CR>
                            
    1              0.000002000 if !get(g:, 'dispatch_no_maps')
    1   0.000059000   0.000005000   call s:map('n', 'm<CR>',      '<SID>:.Make<CR>')
    1   0.000040000   0.000002000   call s:map('n', 'm<Space>',   '<SID>:.Make<Space>')
    1   0.000044000   0.000002000   call s:map('n', 'm!',         '<SID>:.Make!')
    1   0.000041000   0.000003000   call s:map('n', 'm?',         ':<C-U>echo ":Dispatch" dispatch#make_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1   0.000036000   0.000001000   call s:map('n', '`<CR>',      '<SID>:.Dispatch<CR>')
    1   0.000036000   0.000001000   call s:map('n', '`<Space>',   '<SID>:.Dispatch<Space>')
    1   0.000035000   0.000003000   call s:map('n', '`!',         '<SID>:.Dispatch!')
    1   0.000035000   0.000002000   call s:map('n', '`?',         '<SID>:.FocusDispatch<CR>')
    1   0.000035000   0.000001000   call s:map('n', '''<CR>',     '<SID>:.Start<CR>')
    1   0.000036000   0.000002000   call s:map('n', '''<Space>',  '<SID>:.Start<Space>')
    1   0.000035000   0.000003000   call s:map('n', '''!',        '<SID>:.Start!')
    1   0.000037000   0.000002000   call s:map('n', '''?',        ':<C-U>echo ":Start" dispatch#start_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1   0.000044000   0.000002000   call s:map('n', 'g''<CR>',    '<SID>:.Spawn<CR>')
    1   0.000044000   0.000001000   call s:map('n', 'g''<Space>', '<SID>:.Spawn<Space>')
    1   0.000043000   0.000002000   call s:map('n', 'g''!',       '<SID>:.Spawn!')
    1   0.000045000   0.000002000   call s:map('n', 'g''?',       ':<C-U>echo ":Spawn" dispatch#spawn_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1   0.000044000   0.000003000   call s:map('n', 'g`<CR>',     '<SID>:.Spawn<CR>')
    1   0.000044000   0.000002000   call s:map('n', 'g`<Space>',  '<SID>:.Spawn<Space>')
    1   0.000042000   0.000001000   call s:map('n', 'g`!',        '<SID>:.Spawn!')
    1   0.000045000   0.000002000   call s:map('n', 'g`?',        ':<C-U>echo ":Spawn" dispatch#spawn_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1              0.000001000 endif
                            
    1              0.000001000 function! DispatchComplete(id) abort
                              return dispatch#complete(a:id)
                            endfunction
                            
    1              0.000002000 if !exists('g:dispatch_handlers')
    1              0.000003000   let g:dispatch_handlers = [
                                    \ 'tmux',
                                    \ 'job',
                                    \ 'screen',
                                    \ 'terminal',
                                    \ 'windows',
                                    \ 'iterm',
                                    \ 'x11',
                                    \ 'headless',
                                    \ ]
    1              0.000001000 endif
                            
    1              0.000001000 augroup dispatch
    1              0.000018000   autocmd!
    1              0.000003000   autocmd QuickfixCmdPre,QuickfixCmdPost * "
    1              0.000004000   autocmd FileType qf
                                    \ if &buftype ==# 'quickfix' && empty(getloclist(winnr())) && get(w:, 'quickfix_title') =~# '^:noautocmd cgetfile\>\|^:\d*Dispatch\>' |
                                    \   call dispatch#quickfix_init() |
                                    \ endif
    1              0.000001000 augroup END

SCRIPT  /Users/danbradbury/.vim/bundle/markdown-preview.nvim/plugin/mkdp.vim
Sourced 1 time
Total time:   0.000114000
 Self time:   0.000089000

count     total (s)      self (s)
                            " set to 1, the vim will open the preview window once enter the markdown
                            " buffer
    1              0.000002000 if !exists('g:mkdp_auto_start')
    1              0.000001000   let g:mkdp_auto_start = 0
    1              0.000001000 endif
                            
                            " let g:mkdp_auto_open = 0
                            " set to 1, the vim will auto open preview window when you edit the
                            " markdown file
                            
                            " set to 1, the vim will auto close current preview window when change
                            " from markdown buffer to another buffer
    1              0.000001000 if !exists('g:mkdp_auto_close')
    1              0.000001000   let g:mkdp_auto_close = 1
    1              0.000000000 endif
                            
                            " set to 1, the vim will just refresh markdown when save the buffer or
                            " leave from insert mode, default 0 is auto refresh markdown as you edit or
                            " move the cursor
    1              0.000001000 if !exists('g:mkdp_refresh_slow')
    1              0.000001000   let g:mkdp_refresh_slow = 0
    1              0.000000000 endif
                            
                            " set to 1, the MarkdownPreview command can be use for all files,
                            " by default it just can be use in markdown file
    1              0.000001000 if !exists('g:mkdp_command_for_global')
    1              0.000001000   let g:mkdp_command_for_global = 0
    1              0.000001000 endif
                            
                            " set to 1, preview server available to others in your network
                            " by default, the server only listens on localhost (127.0.0.1)
    1              0.000001000 if !exists('g:mkdp_open_to_the_world')
    1              0.000001000   let g:mkdp_open_to_the_world = 0
    1              0.000000000 endif
                            
                            " use custom ip to open preview page
                            " default empty
    1              0.000001000 if !exists('g:mkdp_open_ip')
    1              0.000000000   let g:mkdp_open_ip = ''
    1              0.000000000 endif
                            
                            " set to 1, echo preview page url in command line when open preview page
                            " default is 0
    1              0.000001000 if !exists('g:mkdp_echo_preview_url')
    1              0.000000000   let g:mkdp_echo_preview_url = 0
    1              0.000000000 endif
                            
                            " use custom vim function to open preview page
                            " this function will receive url as param
    1              0.000001000 if !exists('g:mkdp_browserfunc')
    1              0.000001000   let g:mkdp_browserfunc = ''
    1              0.000000000 endif
                            
                            " specify browser to open preview page
    1              0.000001000 if !exists('g:mkdp_browser')
    1              0.000001000   let g:mkdp_browser = ''
    1              0.000000000 endif
                            
    1              0.000001000 if !exists('g:mkdp_preview_options')
    1              0.000012000   let g:mkdp_preview_options = {
                                  \ 'mkit': {},
                                  \ 'katex': {},
                                  \ 'uml': {},
                                  \ 'maid': {},
                                  \ 'disable_sync_scroll': 0,
                                  \ 'sync_scroll_type': 'middle',
                                  \ 'hide_yaml_meta': 1,
                                  \ 'sequence_diagrams': {},
                                  \ 'flowchart_diagrams': {},
                                  \ 'content_editable': v:false,
                                  \ 'disable_filename': 0,
                                  \ 'toc': {}
                                  \ }
                            elseif !has_key(g:mkdp_preview_options, 'disable_filename')
                              let g:mkdp_preview_options['disable_filename'] = 0
    1              0.000000000 endif
                            
                            " markdown css file absolute path
    1              0.000002000 if !exists('g:mkdp_markdown_css')
    1              0.000000000   let g:mkdp_markdown_css = ''
    1              0.000001000 endif
                            
                            " highlight css file absolute path
    1              0.000001000 if !exists('g:mkdp_highlight_css')
    1              0.000001000   let g:mkdp_highlight_css = ''
    1              0.000000000 endif
                            
    1              0.000001000 if !exists('g:mkdp_port')
    1              0.000000000   let g:mkdp_port = ''
    1              0.000001000 endif
                            
                            " preview page title
                            " ${name} will be replace with the file name
    1              0.000001000 if !exists('g:mkdp_page_title')
    1              0.000002000   let g:mkdp_page_title = '「${name}」'
    1              0.000000000 endif
                            
                            " recognized filetypes
    1              0.000001000 if !exists('g:mkdp_filetypes')
    1              0.000001000   let g:mkdp_filetypes = ['markdown']
    1              0.000001000 endif
                            
                            " markdown images custom path
    1              0.000001000 if !exists('g:mkdp_images_path')
    1              0.000001000   let g:mkdp_images_path = ''
    1              0.000000000 endif
                            
                            " combine preview window
    1              0.000001000 if !exists('g:mkdp_combine_preview')
    1              0.000001000   let g:mkdp_combine_preview = 0
    1              0.000000000 endif
                            
                            " auto refetch combine preview contents when change markdown buffer
                            " only when g:mkdp_combine_preview is 1
    1              0.000001000 if !exists('g:mkdp_combine_preview_auto_refresh')
    1              0.000001000   let g:mkdp_combine_preview_auto_refresh = 1
    1              0.000000000 endif
                            
                            " if there are any active preview client
    1              0.000001000 let g:mkdp_clients_active = 0
                            
    1              0.000001000 function! s:init_command() abort
                              command! -buffer MarkdownPreview call mkdp#util#open_preview_page()
                              command! -buffer MarkdownPreviewStop call mkdp#util#stop_preview()
                              command! -buffer MarkdownPreviewToggle call mkdp#util#toggle_preview()
                              " mapping for user
                              noremap <buffer> <silent> <Plug>MarkdownPreview :MarkdownPreview<CR>
                              inoremap <buffer> <silent> <Plug>MarkdownPreview <Esc>:MarkdownPreview<CR>a
                              noremap <buffer> <silent> <Plug>MarkdownPreviewStop :MarkdownPreviewStop<CR>
                              inoremap <buffer> <silent> <Plug>MarkdownPreviewStop <Esc>:MarkdownPreviewStop<CR>a
                              nnoremap <buffer> <silent> <Plug>MarkdownPreviewToggle :MarkdownPreviewToggle<CR>
                              inoremap <buffer> <silent> <Plug>MarkdownPreviewToggle <Esc>:MarkdownPreviewToggle<CR>
                            endfunction
                            
    1              0.000001000 function! s:init() abort
                              augroup mkdp_init
                                autocmd!
                                if g:mkdp_command_for_global
                                  autocmd BufEnter * :call s:init_command()
                                else
                                  autocmd BufEnter,FileType * if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
                                endif
                                if g:mkdp_auto_start
                                  execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#open_preview_page()'
                                endif
                                if g:mkdp_combine_preview && g:mkdp_combine_preview_auto_refresh
                                  execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#combine_preview_refresh()'
                                endif
                              augroup END
                            endfunction
                            
    1   0.000028000   0.000003000 call s:init()

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim
Sourced 1 time
Total time:   0.000030000
 Self time:   0.000030000

count     total (s)      self (s)
                            " ---------------------------------------------------------------------
                            " getscriptPlugin.vim
                            "  Maintainer:	This runtime file is looking for a new maintainer.
                            "  Original Author:	Charles E. Campbell
                            "  Date:	Nov 29, 2013
                            "  Installing:	:help glvs-install
                            "  Usage:	:help glvs
                            "
                            " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
                            "
                            " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
                            " all the peoples praise Him."
                            " ---------------------------------------------------------------------
                            " Initialization:	{{{1
                            " if you're sourcing this file, surely you can't be
                            " expecting vim to be in its vi-compatible mode
    1              0.000002000 if exists("g:loaded_getscriptPlugin")
                             finish
    1              0.000001000 endif
    1              0.000001000 if &cp
                             if &verbose
                              echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
                             endif
                             finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_getscriptPlugin = "v36"
    1              0.000002000 let s:keepcpo                = &cpo
    1              0.000003000 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000002000 com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
    1              0.000001000 com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
    1              0.000002000 sil! com    -nargs=0 GLVS                call getscript#GetLatestVimScripts()
                            
                            " ---------------------------------------------------------------------
                            " Restore Options: {{{1
    1              0.000002000 let &cpo= s:keepcpo
    1              0.000001000 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            " vim: ts=8 sts=2 fdm=marker nowrap

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000098000
 Self time:   0.000098000

count     total (s)      self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000003000 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000001000 endif
    1              0.000001000 let loaded_gzip = 1
                            
    1              0.000001000 augroup gzip
                              " Remove all gzip autocommands
    1              0.000013000   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000010000   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000003000   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
    1              0.000002000   autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
    1              0.000002000   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000003000   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000002000   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000003000   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000001000   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000002000   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000002000   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000002000   autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
    1              0.000002000   autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
    1              0.000002000   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000001000   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000001000   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000002000   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000001000   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000001000   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000001000   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000002000   autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
    1              0.000001000   autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
    1              0.000001000   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000002000   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000001000   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000001000   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000001000   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000001000   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000001000   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000002000   autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
    1              0.000001000   autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
    1              0.000001000 augroup END

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/logiPat.vim
Sourced 1 time
Total time:   0.000133000
 Self time:   0.000133000

count     total (s)      self (s)
                            " LogiPat: Boolean logical pattern matcher
                            "   Maintainer:	This runtime file is looking for a new maintainer.
                            "   Original Author:  Charles E. Campbell
                            "   Date:    Apr 04, 2016
                            "   Version: 4
                            "   Purpose: to do Boolean-logic based regular expression pattern matching
                            " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like most anything else that's free,
                            "               LogiPat.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            "   Usage: {{{1
                            "       :LogiPat ...
                            "
                            "         Boolean logic supported:
                            "            () grouping operators
                            "            !  not the following pattern
                            "            |  logical or
                            "            &  logical and
                            "            "..pattern.."
                            "	Example: {{{1
                            "		:LogiPat !("january"|"february")
                            "		  would match all strings not containing the strings january
                            "		  or february
                            "	GetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
                            "
                            "  Behold, you will conceive in your womb, and bring forth a son, {{{1
                            "  and will call his name Jesus. He will be great, and will be
                            "  called the Son of the Most High. The Lord God will give him the
                            "  throne of his father, David, and he will reign over the house of
                            "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
                            
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000002000 if &cp || exists("loaded_logiPat")
                             finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_logiPat = "v4"
    1              0.000001000 let s:keepcpo        = &cpo
    1              0.000001000 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000002000 com!     -nargs=* LogiPat		call   LogiPat(<q-args>,1)
    1              0.000002000 sil! com -nargs=* LP			call   LogiPat(<q-args>,1)
    1              0.000002000 sil! com -nargs=* LPR			call   LogiPat(<q-args>,1,"r")
    1              0.000002000 com!     -nargs=+ LPE			echomsg LogiPat(<q-args>)
    1              0.000002000 com!     -nargs=+ LogiPatFlags	let  s:LogiPatFlags="<args>"
    1              0.000003000 sil! com -nargs=+ LPF			let  s:LogiPatFlags="<args>"
                            
                            " =====================================================================
                            " Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " LogiPat: this function interprets the boolean-logic pattern {{{2
    1              0.000001000 fun! LogiPat(pat,...)
                            "  call Dfunc("LogiPat(pat<".a:pat.">)")
                            
                              " LogiPat(pat,dosearch)
                              if a:0 > 0
                               let dosearch= a:1
                              else
                               let dosearch= 0
                              endif
                              if a:0 >= 3
                               let s:LogiPatFlags= a:3
                              endif
                            
                              let s:npatstack = 0
                              let s:nopstack  = 0
                              let s:preclvl   = 0
                              let expr        = a:pat
                            
                              " Lexer/Parser
                              while expr != ""
                            "   call Decho("expr<".expr.">")
                            
                               if expr =~ '^"'
                            	" push a Pattern; accept "" as a single " in the pattern
                                let expr = substitute(expr,'^\s*"','','')
                                let pat  = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\1','')
                            	let pat  = substitute(pat,'""','"','g')
                                let expr = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\2','')
                                let expr = substitute(expr,'^\s*','','')
                            "    call Decho("pat<".pat."> expr<".expr.">")
                            
                                call s:LP_PatPush('.*'.pat.'.*')
                            
                               elseif expr =~ '^[!()|&]'
                                " push an operator
                                let op   = strpart(expr,0,1)
                                let expr = strpart(expr,strlen(op))
                            	" allow for those who can't resist doubling their and/or operators
                            	if op =~ '[|&]' && expr[0] == op
                                 let expr = strpart(expr,strlen(op))
                            	endif
                                call s:LP_OpPush(op)
                            
                               elseif expr =~ '^\s'
                                " skip whitespace
                                let expr= strpart(expr,1)
                            
                               else
                                echoerr "operator<".strpart(expr,0,1)."> not supported (yet)"
                                let expr= strpart(expr,1)
                               endif
                            
                              endwhile
                            
                              " Final Execution
                              call s:LP_OpPush('Z')
                            
                              let result= s:LP_PatPop(1)
                            "  call Decho("result=".result)
                            
                              " sanity checks and cleanup
                              if s:npatstack > 0
                               echoerr s:npatstack." patterns left on stack!"
                               let s:npatstack= 0
                              endif
                              if s:nopstack > 0
                               echoerr s:nopstack." operators left on stack!"
                               let s:nopstack= 0
                              endif
                            
                              " perform the indicated search
                              if dosearch
                               if exists("s:LogiPatFlags") && s:LogiPatFlags != ""
                            "  call Decho("search(result<".result."> LogiPatFlags<".s:LogiPatFlags.">)")
                                call search(result,s:LogiPatFlags)
                               else
                            "  call Decho("search(result<".result.">)")
                                call search(result)
                               endif
                               let @/= result
                              endif
                            
                            "  call Dret("LogiPat ".result)
                              return result
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:String: Vim6.4 doesn't have string() {{{2
    1              0.000001000 func! s:String(str)
                              return "'".escape(a:str, '"')."'"
                            endfunc
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPush: {{{2
    1              0.000001000 fun! s:LP_PatPush(pat)
                            "  call Dfunc("LP_PatPush(pat<".a:pat.">)")
                              let s:npatstack              = s:npatstack + 1
                              let s:patstack_{s:npatstack} = a:pat
                            "  call s:StackLook("patpush") "Decho
                            "  call Dret("LP_PatPush : npatstack=".s:npatstack)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
    1              0.000001000 fun! s:LP_PatPop(lookup)
                            "  call Dfunc("LP_PatPop(lookup=".a:lookup.")")
                              if s:npatstack > 0
                               let ret         = s:patstack_{s:npatstack}
                               let s:npatstack = s:npatstack - 1
                              else
                               let ret= "---error---"
                               echoerr "(LogiPat) invalid expression"
                              endif
                            "  call s:StackLook("patpop") "Decho
                            "  call Dret("LP_PatPop ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_OpPush: {{{2
    1              0.000001000 fun! s:LP_OpPush(op)
                            "  call Dfunc("LP_OpPush(op<".a:op.">)")
                            
                              " determine new operator's precedence level
                              if a:op == '('
                              	let s:preclvl= s:preclvl + 10
                            	let preclvl  = s:preclvl
                              elseif a:op == ')'
                              	let s:preclvl= s:preclvl - 10
                               if s:preclvl < 0
                                let s:preclvl= 0
                                echoerr "too many )s"
                               endif
                               let preclvl= s:preclvl
                              elseif a:op =~ '|'
                               let preclvl= s:preclvl + 2
                              elseif a:op =~ '&'
                               let preclvl= s:preclvl + 4
                              elseif a:op == '!'
                               let preclvl= s:preclvl + 6
                              elseif a:op == 'Z'
                               let preclvl= -1
                              else
                               echoerr "expr<".expr."> not supported (yet)"
                               let preclvl= s:preclvl
                              endif
                            "  call Decho("new operator<".a:op."> preclvl=".preclvl)
                            
                              " execute higher-precdence operators
                            "  call Decho("execute higher-precedence operators")
                              call s:LP_Execute(preclvl)
                            
                              " push new operator onto operator-stack
                            "  call Decho("push new operator<".a:op."> onto stack with preclvl=".preclvl." at nopstack=".(s:nopstack+1))
                              if a:op =~ '!'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op =~ '|'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op == '&'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              endif
                            
                            "  call s:StackLook("oppush") "Decho
                            "  call Dret("LP_OpPush : s:preclvl=".s:preclvl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Execute: execute operators from opstack using pattern stack {{{2
    1              0.000001000 fun! s:LP_Execute(preclvl)
                            "  call Dfunc("LP_Execute(preclvl=".a:preclvl.") npatstack=".s:npatstack." nopstack=".s:nopstack)
                            
                              " execute all higher precedence operators
                              while s:nopstack > 0 && a:preclvl < s:opprec_{s:nopstack}
                               let op= s:opstack_{s:nopstack}
                            "   call Decho("op<".op."> nop=".s:nopstack." [preclvl=".a:preclvl."] < [opprec_".s:nopstack."=".s:opprec_{s:nopstack}."]")
                            
                               let s:nopstack = s:nopstack - 1
                             
                               if     op == '!'
                                let n1= s:LP_PatPop(1)
                            	call s:LP_PatPush(s:LP_Not(n1))
                             
                               elseif op == '|'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_Or(n2,n1))
                             
                               elseif op =~ '&'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_And(n2,n1))
                               endif
                             
                            "   call s:StackLook("execute") "Decho
                              endwhile
                            
                            "  call Dret("LP_Execute")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Not: writes a logical-not for a pattern {{{2
    1              0.000001000 fun! s:LP_Not(pat)
                            "  call Dfunc("LP_Not(pat<".a:pat.">)")
                              if a:pat =~ '^\.\*' && a:pat =~ '\.\*$'
                               let pat= substitute(a:pat,'^\.\*\(.*\)\.\*$','\1','')
                               let ret= '^\%(\%('.pat.'\)\@!.\)*$'
                              else
                               let ret= '^\%(\%('.a:pat.'\)\@!.\)*$'
                              endif
                            "  call Dret("LP_Not ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Or: writes a logical-or branch using two patterns {{{2
    1              0.000001000 fun! s:LP_Or(pat1,pat2)
                            "  call Dfunc("LP_Or(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\|'.a:pat2.'\)'
                            "  call Dret("LP_Or ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_And: writes a logical-and concat using two patterns {{{2
    1              0.000001000 fun! s:LP_And(pat1,pat2)
                            "  call Dfunc("LP_And(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\&'.a:pat2.'\)'
                            "  call Dret("LP_And ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " StackLook: {{{2
    1              0.000000000 fun! s:StackLook(description)
                            "  call Dfunc("StackLook(description<".a:description.">)")
                              let iop = 1
                              let ifp = 1
                            "  call Decho("Pattern                       Operator")
                            
                              " print both pattern and operator
                              while ifp <= s:npatstack && iop <= s:nopstack
                               let fp = s:patstack_{ifp}
                               let op = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                               let fplen= strlen(fp)
                               if fplen < 30
                               	let fp= fp.strpart("                              ",1,30-fplen)
                               endif
                            "   call Decho(fp.op)
                               let ifp = ifp + 1
                               let iop = iop + 1
                              endwhile
                            
                              " print just pattern
                              while ifp <= s:npatstack
                               let fp  = s:patstack_{ifp}
                            "   call Decho(fp)
                               let ifp = ifp + 1
                              endwhile
                            
                              " print just operator
                              while iop <= s:nopstack
                               let op  = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                            "   call Decho("                              ".op)
                               let iop = iop + 1
                              endwhile
                            "  call Dret("StackLook")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Cleanup And Modeline: {{{1
    1              0.000002000 let &cpo= s:keepcpo
    1              0.000001000 unlet s:keepcpo
                            " vim: ts=4 fdm=marker

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/manpager.vim
Sourced 1 time
Total time:   0.000021000
 Self time:   0.000021000

count     total (s)      self (s)
                            " Vim plugin for using Vim as manpager.
                            " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
                            " Last Change: 2024 Jul 03
                            
    1              0.000002000 if exists('g:loaded_manpager_plugin')
                              finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_manpager_plugin = 1
                            
                            " Set up the current buffer (likely read from stdin) as a manpage
    1              0.000002000 command MANPAGER call s:ManPager()
                            
    1              0.000001000 function s:ManPager()
                              " global options, keep these to a minimum to avoid side effects
                              if &compatible
                                set nocompatible
                              endif
                              if exists('+viminfofile')
                                set viminfofile=NONE
                              endif
                              syntax on
                            
                              " Ensure text width matches window width
                              setlocal foldcolumn& nofoldenable nonumber norelativenumber
                            
                              " In case Vim was invoked with -M
                              setlocal modifiable
                            
                              " Emulate 'col -b'
                              exe 'silent! keepj keepp %s/\v(.)\b\ze\1?//e' .. (&gdefault ? '' : 'g')
                            
                              " Remove ansi sequences
                              exe 'silent! keepj keepp %s/\v\e\[%(%(\d;)?\d{1,2})?[mK]//e' .. (&gdefault ? '' : 'g')
                            
                              " Remove empty lines above the header
                              call cursor(1, 1)
                              let n = search(".*(.*)", "c")
                              if n > 1
                                exe "1," . n-1 . "d"
                              endif
                            
                              " Finished preprocessing the buffer, prevent any further modifications
                              setlocal nomodified nomodifiable
                            
                              " Make this an unlisted, readonly scratch buffer
                              setlocal buftype=nofile noswapfile bufhidden=hide nobuflisted readonly
                            
                              " Set filetype to man even if ftplugin is disabled
                              setlocal filetype=man
                              runtime ftplugin/man.vim
                            endfunction

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000099000
 Self time:   0.000099000

count     total (s)      self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2024 May 18
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
    1              0.000002000 if exists("g:loaded_matchparen") || &cp
                              finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_matchparen = 1
                            
    1              0.000001000 if !exists("g:matchparen_timeout")
    1              0.000001000   let g:matchparen_timeout = 300
    1              0.000001000 endif
    1              0.000001000 if !exists("g:matchparen_insert_timeout")
    1              0.000001000   let g:matchparen_insert_timeout = 60
    1              0.000000000 endif
                            
    1              0.000002000 let s:has_matchaddpos = exists('*matchaddpos')
                            
    1              0.000001000 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000004000   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
    1              0.000001000   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
    1              0.000002000   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
    1              0.000001000   if exists('##TextChanged')
    1              0.000002000     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001000     autocmd! TextChangedP * call s:Remove_Matches()
    1              0.000001000   endif
    1              0.000000000 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000001000 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000000000 endif
                            
    1              0.000002000 let s:cpo_save = &cpo
    1              0.000001000 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000001000 func s:Highlight_Matching_Pair()
                              if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
                              endif
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let c_before = text->strpart(0, c_col - 1)->slice(-1)
                              let c = text->strpart(c_col - 1)->slice(0, 1)
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))'
                                    \ . '->indexof({_, id -> synIDattr(id, "name") =~? '
                                    \ . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000001000 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000002000 command DoMatchParen call s:DoMatchParen()
    1              0.000001000 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000001000 func s:NoMatchParen()
                              let w = winnr()
                              noau windo call s:Remove_Matches()
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001000 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000002000 let &cpo = s:cpo_save
    1              0.000001000 unlet s:cpo_save

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000247000
 Self time:   0.000247000

count     total (s)      self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Date:		Feb 09, 2021
                            " Last Change:
                            "   2024 May 08 by Vim Project: cleanup legacy Win9X checks
                            " Former Maintainer:   Charles E Campbell
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000002000 if &cp || exists("g:loaded_netrwPlugin")
                             finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_netrwPlugin = "v173"
    1              0.000001000 let s:keepcpo = &cpo
    1              0.000001000 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000000000 augroup FileExplorer
    1              0.000014000  au!
    1              0.000002000  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000001000  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000001000  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000002000  if has("win32")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000000000  endif
    1              0.000001000 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001000 augroup Network
    1              0.000013000  au!
    1              0.000004000  au BufReadCmd   file://*											call netrw#FileUrlEdit(expand("<amatch>"))
    1              0.000011000  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000009000  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000015000  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000010000  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000001000  try
    1              0.000007000   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000001000  endtry
    1              0.000000000 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000004000 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000005000 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000002000 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000003000 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000002000 com! -nargs=?		Ntree		call netrw#SetTreetop(1,<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000005000 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000004000 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000002000 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000003000 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000003000 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000002000 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000001000 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000003000 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000001000 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000002000 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000002000 if !exists("g:netrw_nogx")
    1              0.000004000  if maparg('gx','n') == ""
    1              0.000013000   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000003000    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000000000   endif
    1              0.000005000   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
    1              0.000000000  endif
    1              0.000003000  if maparg('gx','x') == ""
    1              0.000008000   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000002000    xmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000001000   endif
    1              0.000003000   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000000000  endif
    1              0.000001000 endif
    1              0.000001000 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
    1              0.000000000 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000001000 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000001000 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              if has('nvim') || v:version < 802
                              " Johann Höchtl: reported that the call range... line causes an E488: Trailing characters
                              "                error with neovim. I suspect its because neovim hasn't updated with recent
                              "                vim patches. As is, this code will have problems with popup terminals
                              "                instantiated before the VimEnter event runs.
                              " Ingo Karkat  : E488 also in Vim 8.1.1602
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                             else
                              " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
                              " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
                              let s:vimentered = 1
                              call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
                             endif
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001000 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000000000 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000002000 let &cpo= s:keepcpo
    1              0.000001000 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000020000
 Self time:   0.000020000

count     total (s)      self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000002000 if exists("loaded_rrhelper") || !has("clientserver")
                              finish
    1              0.000000000 endif
    1              0.000001000 let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
    1              0.000001000 function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
    1              0.000001000 function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000012000
 Self time:   0.000012000

count     total (s)      self (s)
                            " Vim plugin for downloading spell files
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of spell files
    1              0.000003000 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000000000 endif
    1              0.000001000 let loaded_spellfile_plugin = 1
                            
                            " The function is in the autoload directory.
    1              0.000003000 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000067000
 Self time:   0.000067000

count     total (s)      self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000002000 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_tarPlugin = "v32"
    1              0.000001000 let s:keepcpo          = &cpo
    1              0.000001000 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000001000 augroup tar
    1              0.000016000   au!
    1              0.000002000   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000002000   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000001000   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000002000   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000001000   if has("unix")
    1              0.000002000    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000002000    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000001000    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000002000    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000000000   endif
                            
    1              0.000002000   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000002000   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000002000   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000001000   au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
    1              0.000002000   au BufReadCmd   *.tzst			call tar#Browse(expand("<amatch>"))
    1              0.000000000 augroup END
    1              0.000002000 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000001000 let &cpo= s:keepcpo
    1              0.000001000 unlet s:keepcpo

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000074000
 Self time:   0.000074000

count     total (s)      self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2023 Sep 07
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
    1              0.000001000 if exists('g:loaded_2html_plugin')
                              finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_2html_plugin = 'vim9.0_v2'
                            
                            "
                            " Changelog: {{{
                            "   9.0_v2  (this version): - Warn if using deprecated g:use_xhtml option
                            "                           - Change default g:html_use_input_for_pc to "none"
                            "                             instead of "fallback". All modern browsers support
                            "                             the "user-select: none" and "content:" CSS
                            "                             properties so the older method relying on extra
                            "                             markup and unspecified browser/app clipboard
                            "                             handling is only needed in rare special cases.
                            "                           - Fix SourceForge issue #33: generate diff filler
                            "                             correctly when new lines have been added to or
                            "                             removed from end of buffer.
                            "                           - Fix SourceForge issue #32/Vim Github issue #8547:
                            "                             use translated highlight ID for styling the
                            "                             special-use group names (e.g. LineNr) used
                            "                             directly by name in the 2html processing.
                            "                           - Fix SourceForge issue #26, refactoring to use
                            "                             :let-heredoc style string assignment and
                            "                             additional fixes for ".." vs. "." style string
                            "                             concatenation. Requires Vim v8.1.1354 or higher.
                            "   9.0_v1  (Vim 9.0.1275): - Implement g:html_no_doc and g:html_no_modeline
                            "                             for diff mode. Add tests.
                            "           (Vim 9.0.1122): NOTE: no version string update for this version!
                            "                           - Bugfix for variable name in g:html_no_doc
                            "           (Vim 9.0.0819): NOTE: no version string update for this version!
                            "                           - Add options g:html_no_doc, g:html_no_lines,
                            "                             and g:html_no_modeline (partially included in Vim
                            "                             runtime prior to version string update).
                            "                           - Updates for new Vim9 string append style (i.e. use
                            "                             ".." instead of "."). Requires Vim version
                            "                             8.1.1114 or higher.
                            "
                            "   8.1 updates: {{{
                            "   8.1_v2  (Vim 8.1.2312): - Fix SourceForge issue #19: fix calculation of tab
                            "                             stop position to use in expanding a tab, when that
                            "                             tab occurs after a syntax match which in turn
                            "                             comes after previously expanded tabs.
                            "                           - Set eventignore while splitting a window for the
                            "                             destination file to ignore FileType events;
                            "                             speeds up processing when the destination file
                            "                             already exists and HTML highlight takes too long.
                            "                           - Fix SourceForge issue #20: progress bar could not be
                            "                             seen when DiffDelete background color matched
                            "                             StatusLine background color. Added TOhtmlProgress
                            "                             highlight group for manual user override, but
                            "                             calculate it to be visible compared to StatusLine
                            "                             by default.
                            "                           - Fix SourceForge issue #1: Remove workaround for old
                            "                             browsers which don't support 'ch' CSS unit, since
                            "                             all modern browsers, including IE>=9, support it.
                            "                           - Fix SourceForge issue #10: support termguicolors
                            "                           - Fix SourceForge issue #21: default to using
                            "                             generated content instead of <input> tags for
                            "                             uncopyable text, so that text is correctly
                            "                             prevented from being copied in chrome. Use
                            "                             g:html_use_input_for_pc option to control the
                            "                             method used.
                            "                           - Switch to HTML5 to allow using vnu as a validator
                            "                             in unit test.
                            "                           - Fix fallback sizing of <input> tags for browsers
                            "                             without "ch" support.
                            "                           - Fix cursor on unselectable diff filler text.
                            "   8.1_v1  (Vim 8.1.0528): - Fix SourceForge issue #6: Don't generate empty
                            "                             script tag.
                            "                           - Fix SourceForge issue #5: javascript should
                            "                             declare variables with "var".
                            "                           - Fix SourceForge issue #13: errors thrown sourcing
                            "                             2html.vim directly when plugins not loaded.
                            "                           - Fix SourceForge issue #16: support 'vartabstop'.
                            "}}}
                            "
                            "   7.4 updates: {{{
                            "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "}}}
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evaluated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " TODO: {{{
                            "   * Check the issue tracker:
                            "     https://sourceforge.net/p/vim-tohtml/issues/search/?q=%21status%3Aclosed
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin or user override was not already loaded
                            " - user commands are available. {{{
    1              0.000003000 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000003000   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001000 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim
Sourced 1 time
Total time:   0.000065000
 Self time:   0.000065000

count     total (s)      self (s)
                            " vimballPlugin : construct a file containing both paths and files
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Original Author: Charles E. Campbell
                            " Copyright: (c) 2004-2014 by Charles E. Campbell
                            "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
                            "            (see |copyright|) except use "Vimball" instead of "Vim".
                            "            No warranty, express or implied.
                            "  *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
                            "      judge. For in that which you judge another, you condemn yourself. For
                            "      you who judge practice the same things.
                            " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
                            
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000002000 if &cp || exists("g:loaded_vimballPlugin")
                             finish
    1              0.000001000 endif
    1              0.000001000 let g:loaded_vimballPlugin = "v37"
    1              0.000001000 let s:keepcpo              = &cpo
    1              0.000001000 set cpo&vim
                            
                            " ------------------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000004000 com! -range   -complete=file -nargs=+ -bang MkVimball		call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
    1              0.000002000 com! -nargs=? -complete=dir  UseVimball						call vimball#Vimball(1,<f-args>)
    1              0.000001000 com! -nargs=0                VimballList					call vimball#Vimball(0)
    1              0.000003000 com! -nargs=* -complete=dir  RmVimball						call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
    1              0.000001000 augroup Vimball
    1              0.000013000  au!
    1              0.000006000  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz
                            	   \ if getline(1) =~ '^" Vimball Archiver' |
                            	   \  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0, "Source this file to extract it! (:so %)")|endif |
                            	   \ endif
    1              0.000004000  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000002000  au SourceCmd *.vba											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000004000  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz
                            	   \ if getline(1) =~ '^" Vimball Archiver' |
                            	   \  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif |
                            	   \ endif
    1              0.000006000  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000001000  au SourceCmd *.vmb											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000001000 augroup END
                            
                            " =====================================================================
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000002000 let &cpo= s:keepcpo
    1              0.000001000 unlet s:keepcpo
                            
                            " vim: ts=4:

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000104000
 Self time:   0.000104000

count     total (s)      self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Dec 07, 2021
                            " Maintainer:	This runtime file is looking for a new maintainer.
                            " Former Maintainer:	Charles E Campbell
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000002000 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000000000 endif
    1              0.000001000 let g:loaded_zipPlugin = "v33"
    1              0.000001000 let s:keepcpo          = &cpo
    1              0.000001000 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000001000 if !exists("g:zipPlugin_ext")
    1              0.000003000  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001000 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001000 augroup zip
    1              0.000017000  au!
    1              0.000002000  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000002000  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000001000  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000001000  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000001000  if has("unix")
    1              0.000002000   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000003000   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000004000   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000002000   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000000000  endif
                            
    1              0.000040000  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001000 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000001000 let &cpo= s:keepcpo
    1              0.000001000 unlet s:keepcpo

SCRIPT  /Users/danbradbury/.vim/bundle/tabular/after/plugin/TabularMaps.vim
Sourced 1 time
Total time:   0.001395000
 Self time:   0.001395000

count     total (s)      self (s)
                            " Copyright (c) 2016, Matthew J. Wozniski
                            " All rights reserved.
                            "
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            "     * Redistributions of source code must retain the above copyright notice,
                            "       this list of conditions and the following disclaimer.
                            "     * Redistributions in binary form must reproduce the above copyright
                            "       notice, this list of conditions and the following disclaimer in the
                            "       documentation and/or other materials provided with the distribution.
                            "     * The names of the contributors may not be used to endorse or promote
                            "       products derived from this software without specific prior written
                            "       permission.
                            "
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
                            " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                            " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
                            " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
                            " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                            " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
                            " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
                            " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            
    1              0.000003000 if !exists(':Tabularize') || get(g:, 'no_default_tabular_maps', 0)
                              finish " Tabular.vim wasn't loaded or the default maps are unwanted
    1              0.000000000 endif
                            
    1              0.000002000 let s:save_cpo = &cpo
    1              0.000001000 set cpo&vim
                            
    1              0.000371000 AddTabularPattern!  assignment      /[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1
    1              0.000061000 AddTabularPattern!  two_spaces      /  /l0
                            
    1              0.000165000 AddTabularPipeline! multiple_spaces /  / map(a:lines, "substitute(v:val, '   *', '  ', 'g')") | tabular#TabularizeStrings(a:lines, '  ', 'l0')
    1              0.000157000 AddTabularPipeline! spaces          / /  map(a:lines, "substitute(v:val, '  *' , ' ' , 'g')") | tabular#TabularizeStrings(a:lines, ' ' , 'l0')
                            
    1              0.000345000 AddTabularPipeline! argument_list   /(.*)/ map(a:lines, 'substitute(v:val, ''\s*\([(,)]\)\s*'', ''\1'', ''g'')')
                                                                   \ | tabular#TabularizeStrings(a:lines, '[(,)]', 'l0')
                                                                   \ | map(a:lines, 'substitute(v:val, ''\(\s*\),'', '',\1 '', "g")')
                                                                   \ | map(a:lines, 'substitute(v:val, ''\s*)'', ")", "g")')
                            
    1              0.000001000 function! SplitCDeclarations(lines)
                              let rv = []
                              for line in a:lines
                                " split the line into declaractions
                                let split = split(line, '\s*[,;]\s*')
                                " separate the type from the first declaration
                                let type = substitute(split[0], '\%(\%([&*]\s*\)*\)\=\k\+$', '', '')
                                " add the ; back on every declaration
                                call map(split, 'v:val . ";"')
                                " add the first element to the return as-is, and remove it from the list
                                let rv += [ remove(split, 0) ]
                                " transform the other elements by adding the type on at the beginning
                                call map(split, 'type . v:val')
                                " and add them all to the return
                                let rv += split
                              endfor
                              return rv
                            endfunction
                            
    1              0.000065000 AddTabularPipeline! split_declarations /,.*;/ SplitCDeclarations(a:lines)
                            
    1              0.000053000 AddTabularPattern! ternary_operator /^.\{-}\zs?\|:/l1
                            
    1              0.000048000 AddTabularPattern! cpp_io /<<\|>>/l1
                            
    1              0.000048000 AddTabularPattern! pascal_assign /:=/l1
                            
    1              0.000052000 AddTabularPattern! trailing_c_comments /\/\*\|\*\/\|\/\//l1
                            
    1              0.000001000 let &cpo = s:save_cpo
    1              0.000002000 unlet s:save_cpo

SCRIPT  /Users/danbradbury/.vim/bundle/tabular/autoload/tabular.vim
Sourced 1 time
Total time:   0.000149000
 Self time:   0.000149000

count     total (s)      self (s)
                            " Tabular:     Align columnar data using regex-designated column boundaries
                            " Maintainer:  Matthew Wozniski (godlygeek@gmail.com)
                            " Date:        Thu, 03 May 2012 20:49:32 -0400
                            " Version:     1.0
                            "
                            " Long Description:
                            " Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
                            " computer do this for you, since aligning things by hand quickly becomes
                            " unpleasant.  While there are other plugins for aligning text, the ones I've
                            " tried are either impossibly difficult to understand and use, or too simplistic
                            " to handle complicated tasks.  This plugin aims to make the easy things easy
                            " and the hard things possible, without providing an unnecessarily obtuse
                            " interface.  It's still a work in progress, and criticisms are welcome.
                            "
                            " License:
                            " Copyright (c) 2012, Matthew J. Wozniski
                            " All rights reserved.
                            "
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            "     * Redistributions of source code must retain the above copyright notice,
                            "       this list of conditions and the following disclaimer.
                            "     * Redistributions in binary form must reproduce the above copyright
                            "       notice, this list of conditions and the following disclaimer in the
                            "       documentation and/or other materials provided with the distribution.
                            "     * The names of the contributors may not be used to endorse or promote
                            "       products derived from this software without specific prior written
                            "       permission.
                            "
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
                            " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                            " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
                            " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
                            " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                            " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
                            " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
                            " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            
                            " Stupid vimscript crap                                                   {{{1
    1              0.000001000 let s:savecpo = &cpo
    1              0.000001000 set cpo&vim
                            
                            " Private Functions                                                       {{{1
                            
                            " Return the number of bytes in a string after expanding tabs to spaces.  {{{2
                            " This expansion is done based on the current value of 'tabstop'
    1              0.000001000 if exists('*strdisplaywidth')
                              " Needs vim 7.3
    1              0.000002000   let s:Strlen = function("strdisplaywidth")
                            else
                              function! s:Strlen(string)
                                " Implement the tab handling part of strdisplaywidth for vim 7.2 and
                                " earlier - not much that can be done about handling doublewidth
                                " characters.
                                let rv = 0
                                let i = 0
                            
                                for char in split(a:string, '\zs')
                                  if char == "\t"
                                    let rv += &ts - i
                                    let i = 0
                                  else
                                    let rv += 1
                                    let i = (i + 1) % &ts
                                  endif
                                endfor
                            
                                return rv
                              endfunction
    1              0.000001000 endif
                            
                            " Align a string within a field                                           {{{2
                            " These functions do not trim leading and trailing spaces.
                            
                            " Right align 'string' in a field of size 'fieldwidth'
    1              0.000001000 function! s:Right(string, fieldwidth)
                              let spaces = a:fieldwidth - s:Strlen(a:string)
                              return matchstr(a:string, '^\s*') . repeat(" ", spaces) . substitute(a:string, '^\s*', '', '')
                            endfunction
                            
                            " Left align 'string' in a field of size 'fieldwidth'
    1              0.000001000 function! s:Left(string, fieldwidth)
                              let spaces = a:fieldwidth - s:Strlen(a:string)
                              return a:string . repeat(" ", spaces)
                            endfunction
                            
                            " Center align 'string' in a field of size 'fieldwidth'
    1              0.000001000 function! s:Center(string, fieldwidth)
                              let spaces = a:fieldwidth - s:Strlen(a:string)
                              let right = spaces / 2
                              let left = right + (right * 2 != spaces)
                              return repeat(" ", left) . a:string . repeat(" ", right)
                            endfunction
                            
                            " Remove spaces around a string                                           {{{2
                            
                            " Remove all trailing spaces from a string.
    1              0.000001000 function! s:StripTrailingSpaces(string)
                              return matchstr(a:string, '^.\{-}\ze\s*$')
                            endfunction
                            
                            " Remove all leading spaces from a string.
    1              0.000001000 function! s:StripLeadingSpaces(string)
                              return matchstr(a:string, '^\s*\zs.*$')
                            endfunction
                            
                            " Find the longest common indent for a list of strings                    {{{2
                            " If a string is shorter than the others but contains no non-whitespace
                            " characters, it does not end the match.  This provides consistency with
                            " vim's behavior that blank lines don't have trailing spaces.
    1              0.000001000 function! s:LongestCommonIndent(strings)
                              if empty(a:strings)
                                return ''
                              endif
                            
                              let n = 0
                              while 1
                                let ns = join(map(copy(a:strings), 'v:val[n]'), '')
                                if ns !~ '^ \+$\|^\t\+$'
                                  break
                                endif
                                let n += 1
                              endwhile
                            
                              return strpart(a:strings[0], 0, n)
                            endfunction
                            
                            " Split a string into fields and delimiters                               {{{2
                            " Like split(), but include the delimiters as elements
                            " All odd numbered elements are delimiters
                            " All even numbered elements are non-delimiters (including zero)
    1              0.000001000 function! s:SplitDelim(string, delim)
                              let rv = []
                              let beg = 0
                            
                              let len = len(a:string)
                              let searchoff = 0
                            
                              while 1
                                let mid = match(a:string, a:delim, beg + searchoff, 1)
                                if mid == -1 || mid == len
                                  break
                                endif
                            
                                let matchstr = matchstr(a:string, a:delim, beg + searchoff, 1)
                                let length = strlen(matchstr)
                            
                                if length == 0 && beg == mid
                                  " Zero-length match for a zero-length delimiter - advance past it
                                  let searchoff += 1
                                  continue
                                endif
                            
                                if beg == mid
                                  let rv += [ "" ]
                                else
                                  let rv += [ a:string[beg : mid-1] ]
                                endif
                            
                                let rv += [ matchstr ]
                            
                                let beg = mid + length
                                let searchoff = 0
                              endwhile
                            
                              let rv += [ strpart(a:string, beg) ]
                            
                              return rv
                            endfunction
                            
                            " Replace lines from `start' to `start + len - 1' with the given strings. {{{2
                            " If more lines are needed to show all strings, they will be added.
                            " If there are too few strings to fill all lines, lines will be removed.
    1              0.000001000 function! s:SetLines(start, len, strings)
                              if a:start > line('$') + 1 || a:start < 1
                                throw "Invalid start line!"
                              endif
                            
                              if len(a:strings) > a:len
                                let fensave = &fen
                                let view = winsaveview()
                                call append(a:start + a:len - 1, repeat([''], len(a:strings) - a:len))
                                call winrestview(view)
                                let &fen = fensave
                              elseif len(a:strings) < a:len
                                let fensave = &fen
                                let view = winsaveview()
                                sil exe (a:start + len(a:strings)) . ',' .  (a:start + a:len - 1) . 'd_'
                                call winrestview(view)
                                let &fen = fensave
                              endif
                            
                              call setline(a:start, a:strings)
                            endfunction
                            
                            " Runs the given commandstring argument as an expression.                 {{{2
                            " The commandstring expression is expected to reference the a:lines argument.
                            " If the commandstring expression returns a list the items of that list will
                            " replace the items in a:lines, otherwise the expression is assumed to have
                            " modified a:lines itself.
    1              0.000001000 function! s:FilterString(lines, commandstring)
                              exe 'let rv = ' . a:commandstring
                            
                              if type(rv) == type(a:lines) && rv isnot a:lines
                                call filter(a:lines, 0)
                                call extend(a:lines, rv)
                              endif
                            endfunction
                            
                            " Public API                                                              {{{1
                            
    1              0.000001000 if !exists("g:tabular_default_format")
    1              0.000001000   let g:tabular_default_format = "l1"
    1              0.000000000 endif
                            
    1              0.000001000 let s:formatelempat = '\%([lrc]\d\+\)'
                            
    1              0.000001000 function! tabular#ElementFormatPattern()
                              return s:formatelempat
                            endfunction
                            
                            " Given a list of strings and a delimiter, split each string on every
                            " occurrence of the delimiter pattern, format each element according to either
                            " the provided format (optional) or the default format, and join them back
                            " together with enough space padding to guarantee that the nth delimiter of
                            " each string is aligned.
    1              0.000001000 function! tabular#TabularizeStrings(strings, delim, ...)
                              if a:0 > 1
                                echoerr "TabularizeStrings accepts only 2 or 3 arguments (got ".(a:0+2).")"
                                return 1
                              endif
                            
                              let formatstr = (a:0 ? a:1 : g:tabular_default_format)
                            
                              if formatstr !~? s:formatelempat . '\+'
                                echoerr "Tabular: Invalid format \"" . formatstr . "\" specified!"
                                return 1
                              endif
                            
                              let format = split(formatstr, s:formatelempat . '\zs')
                            
                              let lines = a:strings
                            
                              call map(lines, 's:SplitDelim(v:val, a:delim)')
                            
                              let first_fields = []
                            
                              " Strip spaces from non-delimiters; spaces in delimiters must have been
                              " matched intentionally
                              for line in lines
                                if len(line) == 1 && s:do_gtabularize
                                  continue " Leave non-matching lines unchanged for GTabularize
                                endif
                            
                                call add(first_fields, line[0])
                            
                                if len(line) >= 1
                                  for i in range(0, len(line)-1, 2)
                                    let line[i] = s:StripLeadingSpaces(s:StripTrailingSpaces(line[i]))
                                  endfor
                                endif
                              endfor
                            
                              let common_indent = s:LongestCommonIndent(first_fields)
                            
                              " Find the max length of each field
                              let maxes = []
                              for line in lines
                                if len(line) == 1 && s:do_gtabularize
                                  continue " non-matching lines don't affect field widths for GTabularize
                                endif
                            
                                for i in range(len(line))
                                  if i == len(maxes)
                                    let maxes += [ s:Strlen(line[i]) ]
                                  else
                                    let maxes[i] = max( [ maxes[i], s:Strlen(line[i]) ] )
                                  endif
                                endfor
                              endfor
                            
                              " Concatenate the fields, according to the format pattern.
                              for idx in range(len(lines))
                                let line = lines[idx]
                            
                                if len(line) == 1 && s:do_gtabularize
                                  let lines[idx] = line[0] " GTabularize doesn't change non-matching lines
                                  continue
                                endif
                            
                                for i in range(len(line))
                                  let how = format[i % len(format)][0]
                                  let pad = format[i % len(format)][1:-1]
                            
                                  if how =~? 'l'
                                    let field = s:Left(line[i], maxes[i])
                                  elseif how =~? 'r'
                                    let field = s:Right(line[i], maxes[i])
                                  elseif how =~? 'c'
                                    let field = s:Center(line[i], maxes[i])
                                  endif
                            
                                  let line[i] = field . repeat(" ", pad)
                                endfor
                            
                                let prefix = common_indent
                                if len(line) == 1 && s:do_gtabularize
                                  " We didn't strip the indent in this case; nothing to put back.
                                  let prefix = ''
                                endif
                            
                                let lines[idx] = s:StripTrailingSpaces(prefix . join(line, ''))
                              endfor
                            endfunction
                            
                            " Apply 0 or more filters, in sequence, to selected text in the buffer    {{{2
                            " The lines to be filtered are determined as follows:
                            "   If the function is called with a range containing multiple lines, then
                            "     those lines will be used as the range.
                            "   If the function is called with no range or with a range of 1 line, then
                            "     if GTabularize mode is being used,
                            "       the range will not be adjusted
                            "     if "includepat" is not specified,
                            "       that 1 line will be filtered,
                            "     if "includepat" is specified and that line does not match it,
                            "       no lines will be filtered
                            "     if "includepat" is specified and that line does match it,
                            "       all contiguous lines above and below the specified line matching the
                            "       pattern will be filtered.
                            "
                            " The remaining arguments must each be a filter to apply to the text.
                            " Each filter must either be a String evaluating to a function to be called.
    1              0.000001000 function! tabular#PipeRange(includepat, ...) range
                              exe a:firstline . ',' . a:lastline
                                  \ . 'call tabular#PipeRangeWithOptions(a:includepat, a:000, {})'
                            endfunction
                            
                            " Extended version of tabular#PipeRange, which
                            " 1) Takes the list of filters as an explicit list rather than as varargs
                            " 2) Supports passing a dictionary of options to control the routine.
                            "    Currently, the only supported option is 'mode', which determines whether
                            "    to behave as :Tabularize or as :GTabularize
                            " This allows me to add new features here without breaking API compatibility
                            " in the future.
    1              0.000001000 function! tabular#PipeRangeWithOptions(includepat, filterlist, options) range
                              let top = a:firstline
                              let bot = a:lastline
                            
                              let s:do_gtabularize = (get(a:options, 'mode', '') ==# 'GTabularize')
                            
                              if !s:do_gtabularize
                                " In the default mode, apply range extension logic
                                if a:includepat != '' && top == bot
                                  if top < 0 || top > line('$') || getline(top) !~ a:includepat
                                    return
                                  endif
                                  while top > 1 && getline(top-1) =~ a:includepat
                                    let top -= 1
                                  endwhile
                                  while bot < line('$') && getline(bot+1) =~ a:includepat
                                    let bot += 1
                                  endwhile
                                endif
                              endif
                            
                              let lines = map(range(top, bot), 'getline(v:val)')
                            
                              for filter in a:filterlist
                                if type(filter) != type("")
                                  echoerr "PipeRange: Bad filter: " . string(filter)
                                endif
                            
                                call s:FilterString(lines, filter)
                            
                                unlet filter
                              endfor
                            
                              call s:SetLines(top, bot - top + 1, lines)
                            endfunction
                            
                            " Part of the public interface so interested pipelines can query this and
                            " adjust their behavior appropriately.
    1              0.000000000 function! tabular#DoGTabularize()
                              return s:do_gtabularize
                            endfunction
                            
    1              0.000001000 function! s:SplitDelimTest(string, delim, expected)
                              let result = s:SplitDelim(a:string, a:delim)
                            
                              if result !=# a:expected
                                echomsg 'Test failed!'
                                echomsg '  string=' . string(a:string) . '  delim=' . string(a:delim)
                                echomsg '  Returned=' . string(result)
                                echomsg '  Expected=' . string(a:expected)
                              endif
                            endfunction
                            
    1              0.000000000 function! tabular#SplitDelimUnitTest()
                              let assignment = '[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*='
                              let two_spaces = '  '
                              let ternary_operator = '^.\{-}\zs?\|:'
                              let cpp_io = '<<\|>>'
                              let pascal_assign = ':='
                              let trailing_c_comments = '\/\*\|\*\/\|\/\/'
                            
                              call s:SplitDelimTest('a+=b',    assignment, ['a', '+=', 'b'])
                              call s:SplitDelimTest('a-=b',    assignment, ['a', '-=', 'b'])
                              call s:SplitDelimTest('a!=b',    assignment, ['a!=b'])
                              call s:SplitDelimTest('a==b',    assignment, ['a==b'])
                              call s:SplitDelimTest('a&=b',    assignment, ['a', '&=', 'b'])
                              call s:SplitDelimTest('a|=b',    assignment, ['a', '|=', 'b'])
                              call s:SplitDelimTest('a=b=c',   assignment, ['a', '=', 'b', '=', 'c'])
                            
                              call s:SplitDelimTest('a  b  c', two_spaces, ['a', '  ', 'b', '  ', 'c'])
                              call s:SplitDelimTest('a b   c', two_spaces, ['a b', '  ', ' c'])
                              call s:SplitDelimTest('ab    c', two_spaces, ['ab', '  ', '', '  ', 'c'])
                            
                              call s:SplitDelimTest('a?b:c',   ternary_operator, ['a', '?', 'b', ':', 'c'])
                            
                              call s:SplitDelimTest('a<<b<<c', cpp_io, ['a', '<<', 'b', '<<', 'c'])
                            
                              call s:SplitDelimTest('a:=b=c',  pascal_assign, ['a', ':=', 'b=c'])
                            
                              call s:SplitDelimTest('x//foo',  trailing_c_comments, ['x', '//', 'foo'])
                              call s:SplitDelimTest('x/*foo*/',trailing_c_comments, ['x', '/*', 'foo', '*/', ''])
                            
                              call s:SplitDelimTest('#ab#cd#ef', '[^#]*', ['#', 'ab', '#', 'cd', '#', 'ef', ''])
                              call s:SplitDelimTest('#ab#cd#ef', '#\zs',  ['#', '', 'ab#', '', 'cd#', '', 'ef'])
                            endfunction
                            
                            " Stupid vimscript crap, part 2                                           {{{1
    1              0.000002000 let &cpo = s:savecpo
    1              0.000000000 unlet s:savecpo
                            
                            " vim:set sw=2 sts=2 fdm=marker:

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/gvimrc
Sourced 1 time
Total time:   0.000272000
 Self time:   0.000272000

count     total (s)      self (s)
                            " System gvimrc file for MacVim
                            "
                            " Author:       Bjorn Winckler <bjorn.winckler@gmail.com>
                            " Maintainer:   macvim-dev (https://github.com/macvim-dev)
                            
                            
                            " Make sure the '<' and 'C' flags are not included in 'cpoptions', otherwise
                            " <CR> would not be recognized.  See ":help 'cpoptions'".
    1              0.000003000 let s:cpo_save = &cpo
    1              0.000002000 set cpo&vim
                            
                            
                            "
                            " Global default options
                            "
                            
    1              0.000002000 if !exists("syntax_on")
                              syntax on
    1              0.000001000 endif
                            
                            " Load the MacVim color scheme.  This can be disabled by loading another color
                            " scheme with the :colorscheme command, or by adding the line
                            "   let macvim_skip_colorscheme=1
                            " to ~/.vimrc.
    1              0.000003000 if !exists("macvim_skip_colorscheme") && !exists("colors_name")
                                colorscheme macvim
    1              0.000000000 endif
                            
                            " To make tabs more readable, the label only contains the tail of the file
                            " name and the buffer modified flag.
    1              0.000001000 if empty(&guitablabel)
    1              0.000001000   set guitablabel=%M%t
    1              0.000001000 endif
                            
                            " Send print jobs to Preview.app.  The user can then print from it.
    1              0.000001000 set printexpr=macvim#PreviewConvertPostScript()
                            
                            " askpass
    1              0.000014000 let $SSH_ASKPASS = simplify($VIM . '/../../Resources') . '/macvim-askpass'
    1              0.000002000 let $SUDO_ASKPASS = $SSH_ASKPASS
                            
                            
                            " This is so that HIG Cmd and Option movement mappings can be disabled by
                            " adding the line
                            "   let macvim_skip_cmd_opt_movement = 1
                            " to ~/.vimrc.
    1              0.000001000 if !exists("macvim_skip_cmd_opt_movement")
    1              0.000005000   no   <D-Left>       <Home>
    1              0.000002000   no!  <D-Left>       <Home>
    1              0.000002000   no   <M-Left>       <C-Left>
    1              0.000002000   no!  <M-Left>       <C-Left>
                            
    1              0.000002000   no   <D-Right>      <End>
    1              0.000002000   no!  <D-Right>      <End>
    1              0.000002000   no   <M-Right>      <C-Right>
    1              0.000002000   no!  <M-Right>      <C-Right>
                            
    1              0.000002000   no   <D-Up>         <C-Home>
    1              0.000002000   ino  <D-Up>         <C-Home>
    1              0.000002000   no   <M-Up>         {
    1              0.000002000   ino  <M-Up>         <C-o>{
                            
    1              0.000002000   no   <D-Down>       <C-End>
    1              0.000002000   ino  <D-Down>       <C-End>
    1              0.000001000   no   <M-Down>       }
    1              0.000002000   ino  <M-Down>       <C-o>}
                            
    1              0.000002000   ino  <M-BS>         <C-w>
    1              0.000001000   ino  <D-BS>         <C-u>
    1              0.000001000 endif " !exists("macvim_skip_cmd_opt_movement")
                            
                            
                            " This is so that the HIG shift movement related settings can be enabled by
                            " adding the line
                            "   let macvim_hig_shift_movement = 1
                            " to ~/.vimrc.
    1              0.000001000 if exists("macvim_hig_shift_movement")
                              " Shift + special movement key (<S-Left>, etc.) and mouse starts insert mode
                              set selectmode=mouse,key
                              set keymodel=startsel,stopsel
                            
                              " HIG related shift + special movement key mappings
                              nn   <S-D-Left>     <S-Home>
                              vn   <S-D-Left>     <S-Home>
                              ino  <S-D-Left>     <S-Home>
                              nn   <S-M-Left>     <S-C-Left>
                              vn   <S-M-Left>     <S-C-Left>
                              ino  <S-M-Left>     <S-C-Left>
                            
                              nn   <S-D-Right>    <S-End>
                              vn   <S-D-Right>    <S-End>
                              ino  <S-D-Right>    <S-End>
                              nn   <S-M-Right>    <S-C-Right>
                              vn   <S-M-Right>    <S-C-Right>
                              ino  <S-M-Right>    <S-C-Right>
                            
                              nn   <S-D-Up>       <S-C-Home>
                              vn   <S-D-Up>       <S-C-Home>
                              ino  <S-D-Up>       <S-C-Home>
                            
                              nn   <S-D-Down>     <S-C-End>
                              vn   <S-D-Down>     <S-C-End>
                              ino  <S-D-Down>     <S-C-End>
    1              0.000001000 endif " exists("macvim_hig_shift_movement")
                            
                            
                            " Restore the previous value of 'cpoptions'.
    1              0.000001000 let &cpo = s:cpo_save
    1              0.000002000 unlet s:cpo_save

SCRIPT  /Users/danbradbury/.vim/bundle/vim9-conversion-aid/ftplugin/vim_9.vim
Sourced 11 times
Total time:   0.002787000
 Self time:   0.002787000

count     total (s)      self (s)
   11              0.000839000 vim9script
                            
   11              0.000406000 import autoload '../autoload/vim9_convert_functions.vim' as vim9conv
   11              0.000190000 command! -nargs=? -complete=buffer -buffer Vim9Convert vim9conv.TransformBuffer(<f-args>)

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/ftplugin/vim.vim
Sourced 11 times
Total time:   0.004425000
 Self time:   0.004425000

count     total (s)      self (s)
                            " Vim filetype plugin
                            " Language:		Vim
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2024 Apr 13
                            " 			2024 May 23 by Riley Bruins <ribru17@gmail.com> ('commentstring')
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Only do this when not done yet for this buffer
   11              0.000088000 if exists("b:did_ftplugin")
                              finish
   11              0.000014000 endif
                            
                            " Don't load another plugin for this buffer
   11              0.000042000 let b:did_ftplugin = 1
                            
   11              0.000078000 let s:cpo_save = &cpo
   11              0.000094000 set cpo&vim
                            
   11              0.000045000 if !exists('*VimFtpluginUndo')
    1              0.000001000   func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< include< define<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
   11              0.000010000 endif
                            
   11              0.000024000 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
   11              0.000074000 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
   11              0.000430000 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
   11              0.000029000 setlocal keywordprg=:help
                            
                            " Comments starts with # in Vim9 script.  We have to guess which one to use.
   11              0.000259000 if "\n" .. getline(1, 32)->join("\n") =~# '\n\s*vim9\%[script]\>'
    6              0.000015000   setlocal commentstring=#\ %s
    5              0.000005000 else
    5              0.000016000   setlocal commentstring=\"%s
   11              0.000010000 endif
                            
                            " Set 'comments' to format dashed lists in comments, both in Vim9 and legacy
                            " script.
   11              0.000064000 setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#\\\ ,:#,sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"\\\ ,:\"
                            
                            " set 'include' to recognize import commands
   11              0.000033000 setlocal include=\\v^\\s*import\\s*(autoload)?
                            
                            " set 'define' to recognize export commands
   11              0.000029000 setlocal define=\\v^\\s*export\\s*(def\|const\|var\|final)
                            
                            " Format comments to be up to 78 characters long
   11              0.000029000 if &tw == 0
                              setlocal tw=78
   11              0.000010000 endif
                            
   11              0.000058000 if !exists("no_plugin_maps") && !exists("no_vim_maps")
   11              0.000022000   let b:did_add_maps = 1
                            
                              " Move around functions.
   11              0.000125000   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
   11              0.000105000   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
   11              0.000067000   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
   11              0.000081000   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
   11              0.000067000   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
   11              0.000084000   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
   11              0.000064000   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
   11              0.000081000   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
                            
                              " Move around comments
   11              0.000064000   nnoremap <silent><buffer> ]" :call search('\%(^\s*".*\n\)\@<!\%(^\s*"\)', "W")<CR>
   11              0.000070000   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\@<!\%(^\s*"\)', "W")<CR>
   11              0.000054000   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
   11              0.000067000   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
   11              0.000010000 endif
                            
                            " Let the matchit plugin know what items can be matched.
   11              0.000027000 if exists("loaded_matchit")
                              let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
                              let b:match_words =
                            	\ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+\s*(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' ..
                            	\ '\<\%(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\%(w\%[hile]\|fo\%[r]\)\>,' ..
                            	\ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' ..
                            	\ '{:},' ..
                            	\ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' ..
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' ..
                            	\ '\<class\>:\<endclass\>,' ..
                            	\ '\<inte\%[rface]\>:\<endinterface\>,' ..
                            	\ '\<enu\%[m]\>:\<endenum\>,'
                            
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
                              " Also ignore here-doc and dictionary keys (vimVar).
                              let b:match_skip = 'synIDattr(synID(line("."), col("."), 1), "name")
                            	\ =~? "comment\\|string\\|vimSynReg\\|vimSet\\|vimLetHereDoc\\|vimVar"'
   11              0.000007000 endif
                            
   11              0.000062000 let &cpo = s:cpo_save
   11              0.000025000 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/indent/vim.vim
Sourced 11 times
Total time:   0.004725000
 Self time:   0.004725000

count     total (s)      self (s)
   11              0.000506000 vim9script
                            
                            # Vim indent file
                            # Language:	Vim script
                            # Maintainer:	The Vim Project <https://github.com/vim/vim>
                            # Last Change:	2024 Jul 12
                            # Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            # Only load this indent file when no other was loaded.
   11              0.000063000 if exists('b:did_indent')
                                finish
   11              0.000011000 endif
                            
   11              0.000047000 b:did_indent = true
   11              0.000018000 b:undo_indent = 'setlocal indentkeys< indentexpr<'
                            
   11              0.000017000 import autoload '../autoload/dist/vimindent.vim'
                            
                            # export indentexpr as a global function, so it can be easily manipulated by plugins
   11              0.002473000 g:VimIndent = vimindent.Expr
   11              0.000054000 setlocal indentexpr=g:VimIndent()
   11              0.000044000 setlocal indentkeys+==endif,=enddef,=endfu,=endfor,=endwh,=endtry,=endclass,=endinterface,=endenum,=},=else,=cat,=finall,=END,0\\
   11              0.000100000 execute('setlocal indentkeys+=0=\"\\\ ,0=#\\\ ')
   11              0.000025000 setlocal indentkeys-=0#
   11              0.000039000 setlocal indentkeys-=:

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim
Sourced 1 time
Total time:   0.001655000
 Self time:   0.001655000

count     total (s)      self (s)
    1              0.000001000 vim9script
                            
                            # Language:     Vim script
                            # Maintainer:   github user lacygoill
                            # Last Change:  2023 Jun 29
                            #
                            # Includes Changes from Vim:
                            #  - 2024 Feb 09: Fix indent after literal Dict (A. Radev via #13966)
                            
                            # NOTE: Whenever you change the code, make sure the tests are still passing:
                            #
                            #     $ cd runtime/indent/
                            #     $ make clean; make test || vimdiff testdir/vim.{ok,fail}
                            
                            # Config {{{1
                            
    1              0.000003000 const TIMEOUT: number = get(g:, 'vim_indent', {})
                                ->get('searchpair_timeout', 100)
                            
    1              0.000002000 def IndentMoreInBracketBlock(): number # {{{2
                                if get(g:, 'vim_indent', {})
                                        ->get('more_in_bracket_block', false)
                                    return shiftwidth()
                                else
                                    return 0
                                endif
                            enddef
                            
    1              0.000001000 def IndentMoreLineContinuation(): number # {{{2
                                var n: any = get(g:, 'vim_indent', {})
                                    # We inspect `g:vim_indent_cont` to stay backward compatible.
                                    ->get('line_continuation', get(g:, 'vim_indent_cont', shiftwidth() * 3))
                            
                                if n->typename() == 'string'
                                    return n->eval()
                                else
                                    return n
                                endif
                            enddef
                            # }}}2
                            
                            # Init {{{1
    1              0.000002000 var patterns: list<string>
                            # Tokens {{{2
                            # BAR_SEPARATION {{{3
                            
    1              0.000001000 const BAR_SEPARATION: string = '[^|\\]\@1<=|'
                            
                            # OPENING_BRACKET {{{3
                            
    1              0.000000000 const OPENING_BRACKET: string = '[[{(]'
                            
                            # CLOSING_BRACKET {{{3
                            
    1              0.000000000 const CLOSING_BRACKET: string = '[]})]'
                            
                            # NON_BRACKET {{{3
                            
    1              0.000001000 const NON_BRACKET: string = '[^[\]{}()]'
                            
                            # LIST_OR_DICT_CLOSING_BRACKET {{{3
                            
    1              0.000001000 const LIST_OR_DICT_CLOSING_BRACKET: string = '[]}]'
                            
                            # LIST_OR_DICT_OPENING_BRACKET {{{3
                            
    1              0.000001000 const LIST_OR_DICT_OPENING_BRACKET: string = '[[{]'
                            
                            # CHARACTER_UNDER_CURSOR {{{3
                            
    1              0.000001000 const CHARACTER_UNDER_CURSOR: string = '\%.c.'
                            
                            # INLINE_COMMENT {{{3
                            
                            # TODO: It is not required for an inline comment to be surrounded by whitespace.
                            # But it might help against false positives.
                            # To be more reliable, we should inspect the syntax, and only require whitespace
                            # before  the `#`  comment leader.   But that  might be  too costly  (because of
                            # `synstack()`).
    1              0.000001000 const INLINE_COMMENT: string = '\s[#"]\%(\s\|[{}]\{3}\)'
                            
                            # INLINE_VIM9_COMMENT {{{3
                            
    1              0.000000000 const INLINE_VIM9_COMMENT: string = '\s#'
                            
                            # COMMENT {{{3
                            
                            # TODO: Technically, `"\s` is wrong.
                            #
                            # First, whitespace is not required.
                            # Second, in Vim9, a string might appear at the start of the line.
                            # To be sure, we should also inspect the syntax.
                            # We can't use `INLINE_COMMENT` here. {{{
                            #
                            #     const COMMENT: string = $'^\s*{INLINE_COMMENT}'
                            #                                    ^------------^
                            #                                          ✘
                            #
                            # Because  `INLINE_COMMENT` asserts  the  presence of  a  whitespace before  the
                            # comment leader.  This assertion is not satisfied for a comment starting at the
                            # start of the line.
                            #}}}
    1              0.000001000 const COMMENT: string = '^\s*\%(#\|"\\\=\s\).*$'
                            
                            # DICT_KEY {{{3
                            
    1              0.000001000 const DICT_KEY: string = '^\s*\%('
                                .. '\%(\w\|-\)\+'
                                .. '\|'
                                .. '"[^"]*"'
                                .. '\|'
                                .. "'[^']*'"
                                .. '\|'
                                .. '\[[^]]\+\]'
                                .. '\)'
                                .. ':\%(\s\|$\)'
                            
                            # END_OF_COMMAND {{{3
                            
    1              0.000002000 const END_OF_COMMAND: string = $'\s*\%($\|||\@!\|{INLINE_COMMENT}\)'
                            
                            # END_OF_LINE {{{3
                            
    1              0.000002000 const END_OF_LINE: string = $'\s*\%($\|{INLINE_COMMENT}\)'
                            
                            # END_OF_VIM9_LINE {{{3
                            
    1              0.000002000 const END_OF_VIM9_LINE: string = $'\s*\%($\|{INLINE_VIM9_COMMENT}\)'
                            
                            # OPERATOR {{{3
                            
    1              0.000002000 const OPERATOR: string = '\%(^\|\s\)\%([-+*/%]\|\.\.\|||\|&&\|??\|?\|<<\|>>\|\%([=!]=\|[<>]=\=\|[=!]\~\|is\|isnot\)[?#]\=\)\%(\s\|$\)\@=\%(\s*[|<]\)\@!'
                                # assignment operators
                                .. '\|' .. '\s\%([-+*/%]\|\.\.\)\==\%(\s\|$\)\@='
                                # support `:` when used inside conditional operator `?:`
                                .. '\|' .. '\%(\s\|^\):\%(\s\|$\)'
                            
                            # HEREDOC_OPERATOR {{{3
                            
    1              0.000001000 const HEREDOC_OPERATOR: string = '\s=<<\s\@=\%(\s\+\%(trim\|eval\)\)\{,2}'
                            
                            # PATTERN_DELIMITER {{{3
                            
                            # A better regex would be:
                            #
                            #     [^-+*/%.:# \t[:alnum:]\"|]\@=.\|->\@!\%(=\s\)\@!\|[+*/%]\%(=\s\)\@!
                            #
                            # But sometimes, it can be too costly and cause `E363` to be given.
    1              0.000001000 const PATTERN_DELIMITER: string = '[-+*/%]\%(=\s\)\@!'
                            # }}}2
                            # Syntaxes {{{2
                            # BLOCKS {{{3
                            
    1              0.000001000 const BLOCKS: list<list<string>> = [
                                ['if', 'el\%[se]', 'elseif\=', 'en\%[dif]'],
                                ['for', 'endfor\='],
                                ['wh\%[ile]', 'endw\%[hile]'],
                                ['try', 'cat\%[ch]', 'fina\|finally\=', 'endt\%[ry]'],
                                ['def', 'enddef'],
                                ['fu\%[nction](\@!', 'endf\%[unction]'],
                                ['class', 'endclass'],
                                ['interface', 'endinterface'],
                                ['enum', 'endenum'],
                                ['aug\%[roup]\%(\s\+[eE][nN][dD]\)\@!\s\+\S\+', 'aug\%[roup]\s\+[eE][nN][dD]'],
                            ]
                            
                            # MODIFIERS {{{3
                            
                            # some keywords can be prefixed by modifiers (e.g. `def` can be prefixed by `export`)
    1              0.000001000 const MODIFIERS: dict<string> = {
                                def: ['export', 'static'],
                                class: ['export', 'abstract', 'export abstract'],
                                interface: ['export'],
                            }
                            #     ...
                            #     class: ['export', 'abstract', 'export abstract'],
                            #     ...
                            #     →
                            #     ...
                            #     class: '\%(export\|abstract\|export\s\+abstract\)\s\+',
                            #     ...
                            ->map((_, mods: list<string>): string =>
                                '\%(' .. mods
                                ->join('\|')
                                ->substitute('\s\+', '\\s\\+', 'g')
                                .. '\)' .. '\s\+')
                            
                            # HIGHER_ORDER_COMMAND {{{3
                            
    1              0.000001000 patterns =<< trim eval END
                                argdo\>!\=
                                bufdo\>!\=
                                cdo\>!\=
                                folddoc\%[losed]\>
                                foldd\%[oopen]\>
                                ldo\=\>!\=
                                tabdo\=\>
                                windo\>
                                au\%[tocmd]\>!\=.*
                                com\%[mand]\>!\=.*
                                g\%[lobal]!\={PATTERN_DELIMITER}.*
                                v\%[global]!\={PATTERN_DELIMITER}.*
                            END
                            
    1              0.000004000 const HIGHER_ORDER_COMMAND: string = $'\%(^\|{BAR_SEPARATION}\)\s*\<\%({patterns->join('\|')}\)\%(\s\|$\)\@='
                            
                            # START_MIDDLE_END {{{3
                            
                            # Let's derive this constant from `BLOCKS`:
                            #
                            #     [['if', 'el\%[se]', 'elseif\=', 'en\%[dif]'],
                            #      ['for', 'endfor\='],
                            #      ...,
                            #      [...]]
                            #     →
                            #     {
                            #      'for': ['for', '', 'endfor\='],
                            #      'endfor': ['for', '', 'endfor\='],
                            #      'if': ['if', 'el\%[se]\|elseif\=', 'en\%[dif]'],
                            #      'else': ['if', 'el\%[se]\|elseif\=', 'en\%[dif]'],
                            #      'elseif': ['if', 'el\%[se]\|elseif\=', 'en\%[dif]'],
                            #      'endif': ['if', 'el\%[se]\|elseif\=', 'en\%[dif]'],
                            #      ...
                            #     }
    1              0.000002000 var START_MIDDLE_END: dict<list<string>>
                            
    1              0.000002000 def Unshorten(kwd: string): string
                                return BlockStartKeyword(kwd)
                            enddef
                            
    1              0.000002000 def BlockStartKeyword(line: string): string
                                var kwd: string = line->matchstr('\l\+')
                                return fullcommand(kwd, false)
                            enddef
                            
    1              0.000001000 {
   11              0.000012000     for kwds: list<string> in BLOCKS
   10              0.000038000         var [start: string, middle: string, end: string] = [kwds[0], '', kwds[-1]]
   10              0.000054000         if MODIFIERS->has_key(start->Unshorten())
    3              0.000006000             start = $'\%({MODIFIERS[start]}\)\={start}'
   10              0.000006000         endif
   10              0.000012000         if kwds->len() > 2
    2              0.000005000             middle = kwds[1 : -2]->join('\|')
   10              0.000003000         endif
   34              0.000026000         for kwd: string in kwds
   24              0.000113000             START_MIDDLE_END->extend({[kwd->Unshorten()]: [start, middle, end]})
   34              0.000018000         endfor
   11              0.000007000     endfor
    1              0.000001000 }
                            
    1              0.000001000 START_MIDDLE_END = START_MIDDLE_END
                                ->map((_, kwds: list<string>) =>
                                    kwds->map((_, kwd: string) => kwd == ''
                                    ? ''
                                    : $'\%(^\|{BAR_SEPARATION}\|\<sil\%[ent]\|{HIGHER_ORDER_COMMAND}\)\s*'
                                    .. $'\<\%({kwd}\)\>\%(\s\|$\|!\)\@=\%(\s*{OPERATOR}\)\@!'))
                            
    1              0.000001000 lockvar! START_MIDDLE_END
                            
                            # ENDS_BLOCK {{{3
                            
    1              0.000001000 const ENDS_BLOCK: string = '^\s*\%('
                                .. BLOCKS
                                ->copy()
                                ->map((_, kwds: list<string>): string => kwds[-1])
                                ->join('\|')
                                .. '\|' .. CLOSING_BRACKET
                                .. $'\){END_OF_COMMAND}'
                            
                            # ENDS_BLOCK_OR_CLAUSE {{{3
                            
    1              0.000001000 patterns = BLOCKS
                                ->copy()
                                ->map((_, kwds: list<string>) => kwds[1 :])
                                ->flattennew()
                                # `catch` and `elseif` need to be handled as special cases
                                ->filter((_, pat: string): bool => pat->Unshorten() !~ '^\%(catch\|elseif\)\>')
                            
    1              0.000003000 const ENDS_BLOCK_OR_CLAUSE: string = '^\s*\%(' .. patterns->join('\|') .. $'\){END_OF_COMMAND}'
                                .. $'\|^\s*cat\%[ch]\%(\s\+\({PATTERN_DELIMITER}\).*\1\)\={END_OF_COMMAND}'
                                .. $'\|^\s*elseif\=\>\%(\s\|$\)\@=\%(\s*{OPERATOR}\)\@!'
                            
                            # STARTS_NAMED_BLOCK {{{3
                            
    1              0.000001000 patterns = []
    1              0.000000000 {
   11              0.000010000     for kwds: list<string> in BLOCKS
   24              0.000024000         for kwd: string in kwds[0 : -2]
   14              0.000045000             if MODIFIERS->has_key(kwd->Unshorten())
    3              0.000007000                 patterns += [$'\%({MODIFIERS[kwd]}\)\={kwd}']
   11              0.000004000             else
   11              0.000013000                 patterns += [kwd]
   14              0.000006000             endif
   24              0.000009000         endfor
   11              0.000004000     endfor
    1              0.000001000 }
                            
    1              0.000004000 const STARTS_NAMED_BLOCK: string = $'^\s*\%(sil\%[ent]\s\+\)\=\%({patterns->join('\|')}\)\>\%(\s\|$\|!\)\@='
                            
                            # STARTS_CURLY_BLOCK {{{3
                            
                            # TODO: `{` alone on a line is not necessarily the start of a block.
                            # It  could be  a dictionary  if the  previous line  ends with  a binary/ternary
                            # operator.  This  can cause  an issue whenever  we use  `STARTS_CURLY_BLOCK` or
                            # `LINE_CONTINUATION_AT_EOL`.
    1              0.000001000 const STARTS_CURLY_BLOCK: string = '\%('
                                .. '^\s*{'
                                .. '\|' .. '^.*\zs\s=>\s\+{'
                                .. '\|' ..  $'^\%(\s*\|.*{BAR_SEPARATION}\s*\)\%(com\%[mand]\|au\%[tocmd]\).*\zs\s{{'
                                .. '\)' .. END_OF_COMMAND
                            
                            # STARTS_FUNCTION {{{3
                            
    1              0.000001000 const STARTS_FUNCTION: string = $'^\s*\%({MODIFIERS.def}\)\=def\>!\=\s\@='
                            
                            # ENDS_FUNCTION {{{3
                            
    1              0.000001000 const ENDS_FUNCTION: string = $'^\s*enddef\>{END_OF_COMMAND}'
                            
                            # ASSIGNS_HEREDOC {{{3
                            
    1              0.000002000 const ASSIGNS_HEREDOC: string = $'^\%({COMMENT}\)\@!.*\%({HEREDOC_OPERATOR}\)\s\+\zs[A-Z]\+{END_OF_LINE}'
                            
                            # PLUS_MINUS_COMMAND {{{3
                            
                            # In legacy, the `:+` and `:-` commands are not required to be preceded by a colon.
                            # As a result, when `+` or `-` is alone on a line, there is ambiguity.
                            # It might be an operator or a command.
                            # To not break the indentation in legacy scripts, we might need to consider such
                            # lines as commands.
    1              0.000000000 const PLUS_MINUS_COMMAND: string = '^\s*[+-]\s*$'
                            
                            # TRICKY_COMMANDS {{{3
                            
                            # Some  commands  are tricky  because  they  accept  an  argument which  can  be
                            # conflated with an operator.  Examples:
                            #
                            #     argdelete *
                            #     cd -
                            #     normal! ==
                            #     nunmap <buffer> (
                            #
                            # TODO: Other commands might accept operators as argument.  Handle them too.
    1              0.000000000 patterns =<< trim eval END
                                {'\'}<argd\%[elete]\s\+\*\s*$
                                \<[lt]\=cd!\=\s\+-\s*$
                                \<norm\%[al]!\=\s*\S\+$
                                \%(\<sil\%[ent]!\=\s\+\)\=\<[nvxsoilct]\=\%(nore\|un\)map!\=\s
                                {PLUS_MINUS_COMMAND}
                            END
                            
    1              0.000001000 const TRICKY_COMMANDS: string = patterns->join('\|')
                            # }}}2
                            # EOL {{{2
                            # OPENING_BRACKET_AT_EOL {{{3
                            
    1              0.000001000 const OPENING_BRACKET_AT_EOL: string = OPENING_BRACKET .. END_OF_VIM9_LINE
                            
                            # CLOSING_BRACKET_AT_EOL {{{3
                            
    1              0.000001000 const CLOSING_BRACKET_AT_EOL: string = CLOSING_BRACKET .. END_OF_VIM9_LINE
                            
                            # COMMA_AT_EOL {{{3
                            
    1              0.000001000 const COMMA_AT_EOL: string = $',{END_OF_VIM9_LINE}'
                            
                            # COMMA_OR_DICT_KEY_AT_EOL {{{3
                            
    1              0.000002000 const COMMA_OR_DICT_KEY_AT_EOL: string = $'\%(,\|{DICT_KEY}\){END_OF_VIM9_LINE}'
                            
                            # LAMBDA_ARROW_AT_EOL {{{3
                            
    1              0.000001000 const LAMBDA_ARROW_AT_EOL: string = $'\s=>{END_OF_VIM9_LINE}'
                            
                            # LINE_CONTINUATION_AT_EOL {{{3
                            
    1              0.000001000 const LINE_CONTINUATION_AT_EOL: string = '\%('
                                .. ','
                                .. '\|' .. OPERATOR
                                .. '\|' .. '\s=>'
                                .. '\|' .. '[^=]\zs[[(]'
                                .. '\|' .. DICT_KEY
                                # `{` is ambiguous.
                                # It can be the start of a dictionary or a block.
                                # We only want to match the former.
                                .. '\|' .. $'^\%({STARTS_CURLY_BLOCK}\)\@!.*\zs{{'
                                .. '\)\s*\%(\s#[^{].*\)\=$'
                            # }}}2
                            # SOL {{{2
                            # BACKSLASH_AT_SOL {{{3
                            
    1              0.000001000 const BACKSLASH_AT_SOL: string = '^\s*\%(\\\|[#"]\\ \)'
                            
                            # CLOSING_BRACKET_AT_SOL {{{3
                            
    1              0.000001000 const CLOSING_BRACKET_AT_SOL: string = $'^\s*{CLOSING_BRACKET}'
                            
                            # LINE_CONTINUATION_AT_SOL {{{3
                            
    1              0.000001000 const LINE_CONTINUATION_AT_SOL: string = '^\s*\%('
                                .. '\\'
                                .. '\|' .. '[#"]\\ '
                                .. '\|' .. OPERATOR
                                .. '\|' .. '->\s*\h'
                                .. '\|' .. '\.\h'  # dict member
                                .. '\|' .. '|'
                                # TODO: `}` at the start of a line is not necessarily a line continuation.
                                # Could be the end of a block.
                                .. '\|' .. CLOSING_BRACKET
                                .. '\)'
                            
                            # RANGE_AT_SOL {{{3
                            
    1              0.000000000 const RANGE_AT_SOL: string = '^\s*:\S'
                            # }}}1
                            # Interface {{{1
    1              0.000002000 export def Expr(lnum = v:lnum): number # {{{2
                                # line which is indented
                                var line_A: dict<any> = {text: getline(lnum), lnum: lnum}
                                # line above, on which we'll base the indent of line A
                                var line_B: dict<any>
                            
                                if line_A->AtStartOf('HereDoc')
                                    line_A->CacheHeredoc()
                                elseif line_A.lnum->IsInside('HereDoc')
                                    return line_A.text->HereDocIndent()
                                elseif line_A.lnum->IsRightBelow('HereDoc')
                                    var ind: number = b:vimindent.startindent
                                    unlet! b:vimindent
                                    return ind
                                endif
                            
                                # Don't move this block after the function header one.
                                # Otherwise, we  might clear the cache  too early if the  line following the
                                # header is a comment.
                                if line_A.text =~ COMMENT
                                    return CommentIndent()
                                endif
                            
                                line_B = PrevCodeLine(line_A.lnum)
                                if line_A.text =~ BACKSLASH_AT_SOL
                                    if line_B.text =~ BACKSLASH_AT_SOL
                                        return Indent(line_B.lnum)
                                    else
                                        return Indent(line_B.lnum) + IndentMoreLineContinuation()
                                    endif
                                endif
                            
                                if line_A->AtStartOf('FuncHeader')
                                        && !IsInInterface()
                                    line_A.lnum->CacheFuncHeader()
                                elseif line_A.lnum->IsInside('FuncHeader')
                                    return b:vimindent.startindent + 2 * shiftwidth()
                                elseif line_A.lnum->IsRightBelow('FuncHeader')
                                    var startindent: number = b:vimindent.startindent
                                    unlet! b:vimindent
                                    if line_A.text =~ ENDS_FUNCTION
                                        return startindent
                                    else
                                        return startindent + shiftwidth()
                                    endif
                                endif
                            
                                var past_bracket_block: dict<any>
                                if exists('b:vimindent')
                                        && b:vimindent->has_key('is_BracketBlock')
                                    past_bracket_block = RemovePastBracketBlock(line_A)
                                endif
                                if line_A->AtStartOf('BracketBlock')
                                    line_A->CacheBracketBlock()
                                endif
                                if line_A.lnum->IsInside('BracketBlock')
                                    var is_in_curly_block: bool = IsInCurlyBlock()
                                    for block: dict<any> in b:vimindent.block_stack
                                        if line_A.lnum <= block.startlnum
                                            continue
                                        endif
                                        if !block->has_key('startindent')
                                            block.startindent = Indent(block.startlnum)
                                        endif
                                        if !is_in_curly_block
                                            return BracketBlockIndent(line_A, block)
                                        endif
                                    endfor
                                endif
                                if line_A.text->ContinuesBelowBracketBlock(line_B, past_bracket_block)
                                        && line_A.text !~ CLOSING_BRACKET_AT_SOL
                                    return past_bracket_block.startindent
                                        + (past_bracket_block.startline =~ STARTS_NAMED_BLOCK ? 2 * shiftwidth() : 0)
                                endif
                            
                                # Problem: If we press `==` on the line right below the start of a multiline
                                # lambda (split after its arrow `=>`), the indent is not correct.
                                # Solution: Indent relative to the line above.
                                if line_B->EndsWithLambdaArrow()
                                    return Indent(line_B.lnum) + shiftwidth() + IndentMoreInBracketBlock()
                                endif
                                # FIXME: Similar issue here:
                                #
                                #     var x = []
                                #         ->filter((_, _) =>
                                #             true)
                                #         ->items()
                                #
                                # Press `==` on last line.
                                # Expected: The `->items()` line is indented like `->filter(...)`.
                                # Actual: It's indented like `true)`.
                                # Is it worth fixing? `=ip` gives  the correct indentation, because then the
                                # cache is used.
                            
                                # Don't move this block before the heredoc one.{{{
                                #
                                # A heredoc might be assigned on the very first line.
                                # And if it is, we need to cache some info.
                                #}}}
                                # Don't move it before the function header and bracket block ones either.{{{
                                #
                                # You could, because these blocks of code deal with construct which can only
                                # appear  in a  Vim9  script.  And  in  a  Vim9 script,  the  first line  is
                                # `vim9script`.  Or  maybe some legacy code/comment  (see `:help vim9-mix`).
                                # But you  can't find a  Vim9 function header or  Vim9 bracket block  on the
                                # first line.
                                #
                                # Anyway, even if you could, don't.  First, it would be inconsistent.
                                # Second, it  could give unexpected results  while we're trying to  fix some
                                # failing test.
                                #}}}
                                if line_A.lnum == 1
                                    return 0
                                endif
                            
                                # Don't do that:
                                #     if line_A.text !~ '\S'
                                #         return -1
                                #     endif
                                # It would prevent  a line from being automatically indented  when using the
                                # normal command `o`.
                                # TODO: Can we write a test for this?
                            
                                if line_B.text =~ STARTS_CURLY_BLOCK
                                    return Indent(line_B.lnum) + shiftwidth() + IndentMoreInBracketBlock()
                            
                                elseif line_A.text =~ CLOSING_BRACKET_AT_SOL
                                    var start: number = MatchingOpenBracket(line_A)
                                    if start <= 0
                                        return -1
                                    endif
                                    return Indent(start) + IndentMoreInBracketBlock()
                            
                                elseif line_A.text =~ ENDS_BLOCK_OR_CLAUSE
                                        && !line_B->EndsWithLineContinuation()
                                    var kwd: string = BlockStartKeyword(line_A.text)
                                    if !START_MIDDLE_END->has_key(kwd)
                                        return -1
                                    endif
                            
                                    # If the cursor  is after the match  for the end pattern,  we won't find
                                    # the start of the block.  Let's make sure that doesn't happen.
                                    cursor(line_A.lnum, 1)
                            
                                    var [start: string, middle: string, end: string] = START_MIDDLE_END[kwd]
                                    var block_start: number = SearchPairStart(start, middle, end)
                                    if block_start > 0
                                        return Indent(block_start)
                                    else
                                        return -1
                                    endif
                                endif
                            
                                var base_ind: number
                                if line_A->IsFirstLineOfCommand(line_B)
                                    line_A.isfirst = true
                                    line_B = line_B->FirstLinePreviousCommand()
                                    base_ind = Indent(line_B.lnum)
                            
                                    if line_B->EndsWithCurlyBlock()
                                            && !line_A->IsInThisBlock(line_B.lnum)
                                        return base_ind
                                    endif
                            
                                else
                                    line_A.isfirst = false
                                    base_ind = Indent(line_B.lnum)
                            
                                    var line_C: dict<any> = PrevCodeLine(line_B.lnum)
                                    if !line_B->IsFirstLineOfCommand(line_C) || line_C.lnum <= 0
                                        return base_ind
                                    endif
                                endif
                            
                                var ind: number = base_ind + Offset(line_A, line_B)
                                return [ind, 0]->max()
                            enddef
                            
    1              0.000001000 def g:GetVimIndent(): number # {{{2
                                # for backward compatibility
                                return Expr()
                            enddef
                            # }}}1
                            # Core {{{1
    1              0.000002000 def Offset( # {{{2
                                    # we indent this line ...
                                    line_A: dict<any>,
                                    # ... relatively to this line
                                    line_B: dict<any>,
                                    ): number
                            
                                if line_B->AtStartOf('FuncHeader')
                                        && IsInInterface()
                                    return 0
                            
                                # increase indentation inside a block
                                elseif line_B.text =~ STARTS_NAMED_BLOCK
                                        || line_B->EndsWithCurlyBlock()
                                    # But don't indent if the line starting the block also closes it.
                                    if line_B->AlsoClosesBlock()
                                        return 0
                                    # Indent twice for  a line continuation in the block  header itself, so that
                                    # we can easily  distinguish the end of  the block header from  the start of
                                    # the block body.
                                    elseif (line_B->EndsWithLineContinuation()
                                            && !line_A.isfirst)
                                            || (line_A.text =~ LINE_CONTINUATION_AT_SOL
                                            && line_A.text !~ PLUS_MINUS_COMMAND)
                                            || line_A.text->Is_IN_KeywordForLoop(line_B.text)
                                        return 2 * shiftwidth()
                                    else
                                        return shiftwidth()
                                    endif
                            
                                # increase indentation of  a line if it's the continuation  of a command which
                                # started on a previous line
                                elseif !line_A.isfirst
                                        && (line_B->EndsWithLineContinuation()
                                        || line_A.text =~ LINE_CONTINUATION_AT_SOL)
                                    return shiftwidth()
                                endif
                            
                                return 0
                            enddef
                            
    1              0.000002000 def HereDocIndent(line_A: string): number # {{{2
                                # at the end of a heredoc
                                if line_A =~ $'^\s*{b:vimindent.endmarker}$'
                                    # `END` must be at the very start of the line if the heredoc is not trimmed
                                    if !b:vimindent.is_trimmed
                                        # We can't invalidate the cache just yet.
                                        # The indent of `END` is meaningless;  it's always 0.  The next line
                                        # will need to be indented relative to the start of the heredoc.  It
                                        # must know where it starts; it needs the cache.
                                        return 0
                                    else
                                        var ind: number = b:vimindent.startindent
                                        # invalidate the cache so that it's not used for the next heredoc
                                        unlet! b:vimindent
                                        return ind
                                    endif
                                endif
                            
                                # In a non-trimmed heredoc, all of leading whitespace is semantic.
                                # Leave it alone.
                                if !b:vimindent.is_trimmed
                                    # But do save the indent of the assignment line.
                                    if !b:vimindent->has_key('startindent')
                                        b:vimindent.startindent = b:vimindent.startlnum->Indent()
                                    endif
                                    return -1
                                endif
                            
                                # In a trimmed heredoc, *some* of the leading whitespace is semantic.
                                # We want to preserve  it, so we can't just indent  relative to the assignment
                                # line.  That's because we're dealing with data, not with code.
                                # Instead, we need  to compute by how  much the indent of  the assignment line
                                # was increased  or decreased.   Then, we  need to apply  that same  change to
                                # every line inside the body.
                                var offset: number
                                if !b:vimindent->has_key('offset')
                                    var old_startindent: number = b:vimindent.startindent
                                    var new_startindent: number = b:vimindent.startlnum->Indent()
                                    offset = new_startindent - old_startindent
                            
                                    # If all the non-empty lines in  the body have a higher indentation relative
                                    # to the assignment, there is no need to indent them more.
                                    # But if  at least one of  them does have  the same indentation level  (or a
                                    # lower one), then we want to indent it further (and the whole block with it).
                                    # This way,  we can clearly distinguish  the heredoc block from  the rest of
                                    # the code.
                                    var end: number = search($'^\s*{b:vimindent.endmarker}$', 'nW')
                                    var should_indent_more: bool = range(v:lnum, end - 1)
                                        ->indexof((_, lnum: number): bool => Indent(lnum) <= old_startindent && getline(lnum) != '') >= 0
                                    if should_indent_more
                                        offset += shiftwidth()
                                    endif
                            
                                    b:vimindent.offset = offset
                                    b:vimindent.startindent = new_startindent
                                endif
                            
                                return [0, Indent(v:lnum) + b:vimindent.offset]->max()
                            enddef
                            
    1              0.000001000 def CommentIndent(): number # {{{2
                                var line_B: dict<any>
                                line_B.lnum = prevnonblank(v:lnum - 1)
                                line_B.text = getline(line_B.lnum)
                                if line_B.text =~ COMMENT
                                    return Indent(line_B.lnum)
                                endif
                            
                                var next: number = NextCodeLine()
                                if next == 0
                                    return 0
                                endif
                                var vimindent_save: dict<any> = get(b:, 'vimindent', {})->deepcopy()
                                var ind: number = next->Expr()
                                # The previous `Expr()` might have set or deleted `b:vimindent`.
                                # This could  cause issues (e.g.  when indenting  2 commented lines  above a
                                # heredoc).  Let's make sure the state of the variable is not altered.
                                if vimindent_save->empty()
                                    unlet! b:vimindent
                                else
                                    b:vimindent = vimindent_save
                                endif
                                if getline(next) =~ ENDS_BLOCK
                                    return ind + shiftwidth()
                                else
                                    return ind
                                endif
                            enddef
                            
    1              0.000003000 def BracketBlockIndent(line_A: dict<any>, block: dict<any>): number # {{{2
                                var ind: number = block.startindent
                            
                                if line_A.text =~ CLOSING_BRACKET_AT_SOL
                                    if b:vimindent.is_on_named_block_line
                                        ind += 2 * shiftwidth()
                                    endif
                                    return ind + IndentMoreInBracketBlock()
                                endif
                            
                                var startline: dict<any> = {
                                    text: block.startline,
                                    lnum: block.startlnum
                                }
                                if startline->EndsWithComma()
                                        || startline->EndsWithLambdaArrow()
                                        || (startline->EndsWithOpeningBracket()
                                        # TODO: Is that reliable?
                                        && block.startline !~
                                        $'^\s*{NON_BRACKET}\+{LIST_OR_DICT_CLOSING_BRACKET},\s\+{LIST_OR_DICT_OPENING_BRACKET}')
                                    ind += shiftwidth() + IndentMoreInBracketBlock()
                                endif
                            
                                if b:vimindent.is_on_named_block_line
                                    ind += shiftwidth()
                                endif
                            
                                if block.is_dict
                                        && line_A.text !~ DICT_KEY
                                    ind += shiftwidth()
                                endif
                            
                                return ind
                            enddef
                            
    1              0.000001000 def CacheHeredoc(line_A: dict<any>) # {{{2
                                var endmarker: string = line_A.text->matchstr(ASSIGNS_HEREDOC)
                                var endlnum: number = search($'^\s*{endmarker}$', 'nW')
                                var is_trimmed: bool = line_A.text =~ $'.*\s\%(trim\%(\s\+eval\)\=\)\s\+[A-Z]\+{END_OF_LINE}'
                                b:vimindent = {
                                    is_HereDoc: true,
                                    startlnum: line_A.lnum,
                                    endlnum: endlnum,
                                    endmarker: endmarker,
                                    is_trimmed: is_trimmed,
                                }
                                if is_trimmed
                                    b:vimindent.startindent = Indent(line_A.lnum)
                                endif
                                RegisterCacheInvalidation()
                            enddef
                            
    1              0.000002000 def CacheFuncHeader(startlnum: number) # {{{2
                                var pos: list<number> = getcurpos()
                                cursor(startlnum, 1)
                                if search('(', 'W', startlnum) <= 0
                                    return
                                endif
                                var endlnum: number = SearchPair('(', '', ')', 'nW')
                                setpos('.', pos)
                                if endlnum == startlnum
                                    return
                                endif
                            
                                b:vimindent = {
                                    is_FuncHeader: true,
                                    startindent: startlnum->Indent(),
                                    endlnum: endlnum,
                                }
                                RegisterCacheInvalidation()
                            enddef
                            
    1              0.000003000 def CacheBracketBlock(line_A: dict<any>) # {{{2
                                var pos: list<number> = getcurpos()
                                var opening: string = line_A.text->matchstr(CHARACTER_UNDER_CURSOR)
                                var closing: string = {'[': ']', '{': '}', '(': ')'}[opening]
                                var endlnum: number = SearchPair(opening, '', closing, 'nW')
                                setpos('.', pos)
                                if endlnum <= line_A.lnum
                                    return
                                endif
                            
                                if !exists('b:vimindent')
                                    b:vimindent = {
                                        is_BracketBlock: true,
                                        is_on_named_block_line: line_A.text =~ STARTS_NAMED_BLOCK,
                                        block_stack: [],
                                    }
                                endif
                            
                                var is_dict: bool
                                var is_curly_block: bool
                                if opening == '{'
                                    if line_A.text =~ STARTS_CURLY_BLOCK
                                        [is_dict, is_curly_block] = [false, true]
                                    else
                                        [is_dict, is_curly_block] = [true, false]
                                    endif
                                endif
                                b:vimindent.block_stack->insert({
                                    is_dict: is_dict,
                                    is_curly_block: is_curly_block,
                                    startline: line_A.text,
                                    startlnum: line_A.lnum,
                                    endlnum: endlnum,
                                })
                            
                                RegisterCacheInvalidation()
                            enddef
                            
    1              0.000002000 def RegisterCacheInvalidation() # {{{2
                                # invalidate the cache so that it's not used for the next `=` normal command
                                autocmd_add([{
                                    cmd: 'unlet! b:vimindent',
                                    event: 'ModeChanged',
                                    group: '__VimIndent__',
                                    once: true,
                                    pattern: '*:n',
                                    replace: true,
                                }])
                            enddef
                            
    1              0.000002000 def RemovePastBracketBlock(line_A: dict<any>): dict<any> # {{{2
                                var stack: list<dict<any>> = b:vimindent.block_stack
                            
                                var removed: dict<any>
                                if line_A.lnum > stack[0].endlnum
                                    removed = stack[0]
                                endif
                            
                                stack->filter((_, block: dict<any>): bool => line_A.lnum <= block.endlnum)
                                if stack->empty()
                                    unlet! b:vimindent
                                endif
                                return removed
                            enddef
                            # }}}1
                            # Util {{{1
                            # Get {{{2
    1              0.000002000 def Indent(lnum: number): number # {{{3
                                if lnum <= 0
                                    # Don't  return `-1`.  It could cause `Expr()` to return a non-multiple of `'shiftwidth'`.{{{
                                    #
                                    # It would be  OK if we were always returning  `Indent()` directly.  But
                                    # we  don't.  Most  of  the  time, we  include  it  in some  computation
                                    # like  `Indent(...) + shiftwidth()`.   If  `'shiftwidth'` is  `4`,  and
                                    # `Indent()` returns `-1`, `Expr()` will end up returning `3`.
                                    #}}}
                                    return 0
                                endif
                                return indent(lnum)
                            enddef
                            
    1              0.000002000 def MatchingOpenBracket(line: dict<any>): number # {{{3
                                var end: string = line.text->matchstr(CLOSING_BRACKET)
                                var start: string = {']': '[', '}': '{', ')': '('}[end]
                                cursor(line.lnum, 1)
                                return SearchPairStart(start, '', end)
                            enddef
                            
    1              0.000001000 def FirstLinePreviousCommand(line: dict<any>): dict<any> # {{{3
                                var line_B: dict<any> = line
                            
                                while line_B.lnum > 1
                                    var code_line_above: dict<any> = PrevCodeLine(line_B.lnum)
                            
                                    if line_B.text =~ CLOSING_BRACKET_AT_SOL
                                        var n: number = MatchingOpenBracket(line_B)
                            
                                        if n <= 0
                                            break
                                        endif
                            
                                        line_B.lnum = n
                                        line_B.text = getline(line_B.lnum)
                                        continue
                            
                                    elseif line_B->IsFirstLineOfCommand(code_line_above)
                                        break
                                    endif
                            
                                    line_B = code_line_above
                                endwhile
                            
                                return line_B
                            enddef
                            
    1              0.000001000 def PrevCodeLine(lnum: number): dict<any> # {{{3
                                var line: string = getline(lnum)
                                if line =~ '^\s*[A-Z]\+$'
                                    var endmarker: string = line->matchstr('[A-Z]\+')
                                    var pos: list<number> = getcurpos()
                                    cursor(lnum, 1)
                                    var n: number = search(ASSIGNS_HEREDOC, 'bnW')
                                    setpos('.', pos)
                                    if n > 0
                                        line = getline(n)
                                        if line =~ $'{HEREDOC_OPERATOR}\s\+{endmarker}'
                                            return {lnum: n, text: line}
                                        endif
                                    endif
                                endif
                            
                                var n: number = prevnonblank(lnum - 1)
                                line = getline(n)
                                while line =~ COMMENT && n > 1
                                    n = prevnonblank(n - 1)
                                    line = getline(n)
                                endwhile
                                # If we get back to the first line, we return 1 no matter what; even if it's a
                                # commented line.   That should not  cause an issue  though.  We just  want to
                                # avoid a  commented line above which  there is a  line of code which  is more
                                # relevant.  There is nothing above the first line.
                                return {lnum: n, text: line}
                            enddef
                            
    1              0.000002000 def NextCodeLine(): number # {{{3
                                var last: number = line('$')
                                if v:lnum == last
                                    return 0
                                endif
                            
                                var lnum: number = v:lnum + 1
                                while lnum <= last
                                    var line: string = getline(lnum)
                                    if line != '' && line !~ COMMENT
                                        return lnum
                                    endif
                                    ++lnum
                                endwhile
                                return 0
                            enddef
                            
    1              0.000001000 def SearchPair( # {{{3
                                    start: string,
                                    middle: string,
                                    end: string,
                                    flags: string,
                                    stopline = 0,
                                    ): number
                            
                                var s: string = start
                                var e: string = end
                                if start == '[' || start == ']'
                                    s = s->escape('[]')
                                endif
                                if end == '[' || end == ']'
                                    e = e->escape('[]')
                                endif
                                return searchpair('\C' .. s, (middle == '' ? '' : '\C' .. middle), '\C' .. e,
                                    flags, (): bool => InCommentOrString(), stopline, TIMEOUT)
                            enddef
                            
    1              0.000001000 def SearchPairStart( # {{{3
                                    start: string,
                                    middle: string,
                                    end: string,
                                    ): number
                                return SearchPair(start, middle, end, 'bnW')
                            enddef
                            
    1              0.000001000 def SearchPairEnd( # {{{3
                                    start: string,
                                    middle: string,
                                    end: string,
                                    stopline = 0,
                                    ): number
                                return SearchPair(start, middle, end, 'nW', stopline)
                            enddef
                            # }}}2
                            # Test {{{2
    1              0.000003000 def AtStartOf(line_A: dict<any>, syntax: string): bool # {{{3
                                if syntax == 'BracketBlock'
                                    return AtStartOfBracketBlock(line_A)
                                endif
                            
                                var pat: string = {
                                    HereDoc: ASSIGNS_HEREDOC,
                                    FuncHeader: STARTS_FUNCTION
                                }[syntax]
                                return line_A.text =~ pat
                                    && (!exists('b:vimindent') || !b:vimindent->has_key('is_HereDoc'))
                            enddef
                            
    1              0.000002000 def AtStartOfBracketBlock(line_A: dict<any>): bool # {{{3
                                # We  ignore bracket  blocks  while we're  indenting  a function  header
                                # because  it makes  the logic  simpler.  It  might mean  that we  don't
                                # indent correctly a  multiline bracket block inside  a function header,
                                # but that's  a corner case for  which it doesn't seem  worth making the
                                # code more complex.
                                if exists('b:vimindent')
                                        && !b:vimindent->has_key('is_BracketBlock')
                                    return false
                                endif
                            
                                var pos: list<number> = getcurpos()
                                cursor(line_A.lnum, [line_A.lnum, '$']->col())
                            
                                if SearchPair(OPENING_BRACKET, '', CLOSING_BRACKET, 'bcW', line_A.lnum) <= 0
                                    setpos('.', pos)
                                    return false
                                endif
                                # Don't restore the cursor position.
                                # It needs to be on a bracket for `CacheBracketBlock()` to work as intended.
                            
                                return line_A->EndsWithOpeningBracket()
                                    || line_A->EndsWithCommaOrDictKey()
                                    || line_A->EndsWithLambdaArrow()
                            enddef
                            
    1              0.000001000 def ContinuesBelowBracketBlock( # {{{3
                                    line_A: string,
                                    line_B: dict<any>,
                                    block: dict<any>
                                    ): bool
                            
                                return !block->empty()
                                    && (line_A =~ LINE_CONTINUATION_AT_SOL
                                    || line_B->EndsWithLineContinuation())
                            enddef
                            
    1              0.000001000 def IsInside(lnum: number, syntax: string): bool # {{{3
                                if !exists('b:vimindent')
                                        || !b:vimindent->has_key($'is_{syntax}')
                                    return false
                                endif
                            
                                if syntax == 'BracketBlock'
                                    if !b:vimindent->has_key('block_stack')
                                            || b:vimindent.block_stack->empty()
                                        return false
                                    endif
                                    return lnum <= b:vimindent.block_stack[0].endlnum
                                endif
                            
                                return lnum <= b:vimindent.endlnum
                            enddef
                            
    1              0.000001000 def IsRightBelow(lnum: number, syntax: string): bool # {{{3
                                return exists('b:vimindent')
                                    && b:vimindent->has_key($'is_{syntax}')
                                    && lnum > b:vimindent.endlnum
                            enddef
                            
    1              0.000001000 def IsInCurlyBlock(): bool # {{{3
                                return b:vimindent.block_stack
                                    ->indexof((_, block: dict<any>): bool => block.is_curly_block) >= 0
                            enddef
                            
    1              0.000002000 def IsInThisBlock(line_A: dict<any>, lnum: number): bool # {{{3
                                var pos: list<number> = getcurpos()
                                cursor(lnum, [lnum, '$']->col())
                                var end: number = SearchPairEnd('{', '', '}')
                                setpos('.', pos)
                            
                                return line_A.lnum <= end
                            enddef
                            
    1              0.000001000 def IsInInterface(): bool # {{{3
                                return SearchPair('interface', '', 'endinterface', 'nW') > 0
                            enddef
                            
    1              0.000002000 def IsFirstLineOfCommand(line_1: dict<any>, line_2: dict<any>): bool # {{{3
                                if line_1.text->Is_IN_KeywordForLoop(line_2.text)
                                    return false
                                endif
                            
                                if line_1.text =~ RANGE_AT_SOL
                                        || line_1.text =~ PLUS_MINUS_COMMAND
                                    return true
                                endif
                            
                                if line_2.text =~ DICT_KEY
                                        && !line_1->IsInThisBlock(line_2.lnum)
                                    return true
                                endif
                            
                                var line_1_is_good: bool = line_1.text !~ COMMENT
                                    && line_1.text !~ DICT_KEY
                                    && line_1.text !~ LINE_CONTINUATION_AT_SOL
                            
                                var line_2_is_good: bool = !line_2->EndsWithLineContinuation()
                            
                                return line_1_is_good && line_2_is_good
                            enddef
                            
    1              0.000002000 def Is_IN_KeywordForLoop(line_1: string, line_2: string): bool # {{{3
                                return line_2 =~ '^\s*for\s'
                                    && line_1 =~ '^\s*in\s'
                            enddef
                            
    1              0.000001000 def InCommentOrString(): bool # {{{3
                                return synstack('.', col('.'))
                                    ->indexof((_, id: number): bool => synIDattr(id, 'name') =~ '\ccomment\|string\|heredoc') >= 0
                            enddef
                            
    1              0.000002000 def AlsoClosesBlock(line_B: dict<any>): bool # {{{3
                                # We know that `line_B` opens a block.
                                # Let's see if it also closes that block.
                                var kwd: string = BlockStartKeyword(line_B.text)
                                if !START_MIDDLE_END->has_key(kwd)
                                    return false
                                endif
                            
                                var [start: string, middle: string, end: string] = START_MIDDLE_END[kwd]
                                var pos: list<number> = getcurpos()
                                cursor(line_B.lnum, 1)
                                var block_end: number = SearchPairEnd(start, middle, end, line_B.lnum)
                                setpos('.', pos)
                            
                                return block_end > 0
                            enddef
                            
    1              0.000002000 def EndsWithComma(line: dict<any>): bool # {{{3
                                return NonCommentedMatch(line, COMMA_AT_EOL)
                            enddef
                            
    1              0.000002000 def EndsWithCommaOrDictKey(line_A: dict<any>): bool # {{{3
                                return NonCommentedMatch(line_A, COMMA_OR_DICT_KEY_AT_EOL)
                            enddef
                            
    1              0.000002000 def EndsWithCurlyBlock(line_B: dict<any>): bool # {{{3
                                return NonCommentedMatch(line_B, STARTS_CURLY_BLOCK)
                            enddef
                            
    1              0.000002000 def EndsWithLambdaArrow(line_A: dict<any>): bool # {{{3
                                return NonCommentedMatch(line_A, LAMBDA_ARROW_AT_EOL)
                            enddef
                            
    1              0.000002000 def EndsWithLineContinuation(line_B: dict<any>): bool # {{{3
                                return NonCommentedMatch(line_B, LINE_CONTINUATION_AT_EOL)
                            enddef
                            
    1              0.000001000 def EndsWithOpeningBracket(line: dict<any>): bool # {{{3
                                return NonCommentedMatch(line, OPENING_BRACKET_AT_EOL)
                            enddef
                            
    1              0.000001000 def EndsWithClosingBracket(line: dict<any>): bool # {{{3
                                return NonCommentedMatch(line, CLOSING_BRACKET_AT_EOL)
                            enddef
                            
    1              0.000002000 def NonCommentedMatch(line: dict<any>, pat: string): bool # {{{3
                                # Could happen if there is no code above us, and we're not on the 1st line.
                                # In that case, `PrevCodeLine()` returns `{lnum: 0, line: ''}`.
                                if line.lnum == 0
                                    return false
                                endif
                            
                                # Technically, that's wrong.  A  line might start with a range  and end with a
                                # line continuation symbol.  But it's unlikely.  And it's useful to assume the
                                # opposite because it  prevents us from conflating a mark  with an operator or
                                # the start of a list:
                                #
                                #              not a comparison operator
                                #              v
                                #     :'< mark <
                                #     :'< mark [
                                #              ^
                                #              not the start of a list
                                if line.text =~ RANGE_AT_SOL
                                    return false
                                endif
                            
                                #                    that's not an arithmetic operator
                                #                    v
                                #     catch /pattern /
                                #
                                # When `/` is used as a pattern delimiter, it's always present twice.
                                # And  usually, the  first occurrence  is  in the  middle of  a sequence  of
                                # non-whitespace characters.  If we can find  such a `/`, we assume that the
                                # trailing `/` is not an operator.
                                # Warning: Here, don't use a too complex pattern.{{{
                                #
                                # In particular, avoid backreferences.
                                # For example, this would be too costly:
                                #
                                #     if line.text =~ $'\%(\S*\({PATTERN_DELIMITER}\)\S\+\|\S\+\({PATTERN_DELIMITER}\)\S*\)'
                                #             .. $'\s\+\1{END_OF_COMMAND}'
                                #
                                # Sometimes, it could even give `E363`.
                                #}}}
                                var delim: string = line.text
                                    ->matchstr($'\s\+\zs{PATTERN_DELIMITER}\ze{END_OF_COMMAND}')
                                if !delim->empty()
                                    delim = $'\V{delim}\m'
                                    if line.text =~ $'\%(\S*{delim}\S\+\|\S\+{delim}\S*\)\s\+{delim}{END_OF_COMMAND}'
                                        return false
                                    endif
                                endif
                                # TODO: We might still miss some corner cases:{{{
                                #
                                #                          conflated with arithmetic division
                                #                          v
                                #     substitute/pat / rep /
                                #         echo
                                #     ^--^
                                #      ✘
                                #
                                # A better way to handle all these corner cases, would be to inspect the top
                                # of the syntax stack:
                                #
                                #     :echo synID('.', col('.'), v:false)->synIDattr('name')
                                #
                                # Unfortunately, the legacy syntax plugin is not accurate enough.
                                # For example, it doesn't highlight a slash as an operator.
                                # }}}
                            
                                # `%` at the end of a line is tricky.
                                # It might be the modulo operator or the current file (e.g. `edit %`).
                                # Let's assume it's the latter.
                                if line.text =~ $'%{END_OF_COMMAND}'
                                    return false
                                endif
                            
                                if line.text =~ TRICKY_COMMANDS
                                    return false
                                endif
                            
                                var pos: list<number> = getcurpos()
                                cursor(line.lnum, 1)
                                var match_lnum: number = search(pat, 'cnW', line.lnum, TIMEOUT, (): bool => InCommentOrString())
                                setpos('.', pos)
                                return match_lnum > 0
                            enddef
                            # }}}1
                            # vim:sw=4

SCRIPT  /Users/danbradbury/.vim/bundle/vim9-syntax/syntax/vim.vim
Sourced 14 times
Total time:   0.079407000
 Self time:   0.079407000

count     total (s)      self (s)
   14              0.000122000 vim9script noclear
                            
                            # Credits: Charles E. Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            # Author of syntax plugin for Vim script legacy.
                            
   14              0.000269000 if (exists('b:current_syntax')
                                    # bail out for a file written in legacy Vim script
                                    || "\n" .. getline(1, 10)->join("\n") !~ '\nvim9\%[script]\>'
                                    # Bail out if we're included from another filetype (e.g. `markdown`).{{{
                                    #
                                    # Rationale: If we're  included, we don't  know which type of  syntax does
                                    # the codeblock  use.  Legacy or  Vim9?  In  doubt, let the  legacy plugin
                                    # win, to respect the principle of least astonishment.
                                    #}}}
                                    || &filetype != 'vim'
                                    # provide  an ad-hoc  mechanism to  let the  user disable  the plugin  on a
                                    # per-buffer basis
                                    || get(b:, 'force_legacy_syntax'))
                                    # provide   an  ad-hoc   mechanism   to  let   the   user  force   the
                                    # plugin   on  a   per-buffer   basis  (useful   for  something   like
                                    # `syntax include @vi9Script syntax/vim.vim`)
                                    && !get(b:, 'force_vim9_syntax')
    8              0.000026000     finish
    6              0.000008000 endif
                            
                            # Requirement: Any syntax group should be prefixed with `vi9`; not `vim`.{{{
                            #
                            # To avoid  any interference from  the legacy syntax plugin,  in case we  load a
                            # legacy script at some point.
                            #
                            # In particular,  we don't want  the color choices we  make for Vim9  scripts to
                            # affect legacy Vim scripts.
                            # That could happen if  we use a syntax group name which is  already used in the
                            # legacy syntax plugin, and we load a Vim9 script file after a legacy Vim script
                            # file.
                            #
                            # Remember that the name  you choose for a syntax group  affects the name you'll
                            # have  to use  in a  `:highlight  link` command.   And while  syntax items  are
                            # buffer-local, highlight groups are *global*.
                            #}}}
                            # Known limitation: The plugin does not highlight legacy functions.{{{
                            #
                            # Only the `function` and `endfunction` keywords, as well as legacy comments inside.
                            # We could support more; we would  need to allow `vi9StartOfLine` to start from
                            # the `vi9LegacyFuncBody` region:
                            #
                            #     syntax region vi9LegacyFuncBody
                            #         \ start=/\ze\s*(/
                            #         \ matchgroup=vi9DefKey
                            #         \ end=/^\s*\<endf\%[unction]/
                            #         \ contained
                            #         \ contains=vi9LegacyComment,vi9StartOfLine
                            #                                     ^------------^
                            #
                            # But we don't do it, because there would be many subtle issues to handle, which
                            # would make the overall plugin too complex (e.g. literal dictionaries).
                            # It's not worth the  trouble: we want a plugin which  is easy to read/maintain,
                            # and performant.
                            #
                            # Besides, writing  a legacy function  in a Vim9 script  is a corner  case which
                            # we'll rarely encounter.  Also, I prefer no highlighting rather than a slightly
                            # broken one; and the absence of highlighting gives an easy visual clue to avoid
                            # any confusion between legacy and Vim9 functions.
                            #
                            # Finally, dropping the legacy syntax should give us the opportunity to optimize
                            # the code here and there.
                            #}}}
                            # Warning: If you change these syntax group names:{{{
                            #
                            #     vi9FuncNameBuiltin
                            #     vi9IsOption
                            #     vi9MapModKey
                            #
                            # Make sure to update `HelpTopic()` in:
                            #
                            #     ~/.vim/pack/mine/opt/doc/autoload/doc/mapping.vim
                            #}}}
                            
                            # TODO: Try to extract as many complex regexes into importable items.
                            # Look for the pattern `^\s*exe\%[cute]`.
                            
                            # TODO: Try to remove as many `Order:` requirements as possible.
                            #
                            # If such a requirement  involves 2 rules in the same  section, that should be
                            # fine.  But not if it involves 2 rules in different sections; because in that
                            # case, you  might one day  re-order the  sections, and unknowingly  break the
                            # requirement.
                            #
                            # To remove such a requirement, try to improve some of your regexes.
                            
                            # TODO: The following  command will give  you the list  of all groups  for which
                            # there is at least one item matching at the top level:
                            #
                            #     $ vim +'set filetype=vim' \
                            #         +'unlet! b:current_syntax' +'call setline(1, "vim9script")' \
                            #         +'syntax include @Foo syntax/vim.vim | syntax list @Foo'
                            #
                            # Check whether  those items  should be contained  to avoid  spurious matches.
                            # For  example, right  now, we  match backtick  expansions at  the top  level.
                            # That's wrong; this syntax is only  valid where a command expects a filename.
                            # In  the future,  make  sure  it's contained.   You'll  first  need to  match
                            # commands expecting file arguments, then those arguments.
                            
                            # TODO: Some commands accept a `++option` argument.
                            # Highlight it properly.  Example:
                            #
                            #                    as an assignment operator
                            #                    v
                            #     edit ++encoding=cp437
                            #          ^--------^
                            #          as a Vim option?
                            #
                            # Same thing with `+cmd`.
                            #
                            #     :helpgrep ^:.*\[+cmd\]
                            #     :helpgrep ^:.*\[++opt\]
                            
                            # TODO:
                            #
                            #     nnoremap <expr> <F3> true ? '<C-A>' : '<C-B>'
                            #                                  ^---^
                            #                                  should be highlighted as a translated keycode?
                            
                            # TODO: These command expect a pattern as argument:
                            #
                            #     :2match
                            #     :3match
                            #     :argdelete
                            #     :filter
                            #     :function /
                            #     :helpgrep
                            #     :lhelpgrep
                            #     :match
                            #     :prof[ile] func {pattern}
                            #     :prof[ile][!] file {pattern}
                            #     :sort
                            #     :tag
                            #
                            # Highlight it as a string.
                            
                            # TODO: Some commands expect another command as argument.
                            # Highlight the latter properly.
                            
                            # TODO: Try to simplify the values of all the `contains=` arguments.
                            # Remove  any  cluster  or  syntax  group   which  is  useless.   Try  to  use
                            # intermediate clusters to group related syntax groups, and use them to reduce
                            # the verbosity of some `contains=`.
                            
                            # TODO: Whenever we've  used `syntax case ignore`,  should we have  enforced a
                            # specific case?  Similar to what we did for the names of autocmds events.
                            
                            
                            # Imports {{{1
                            
    6              0.001620000 import 'vim9Language.vim' as lang
                            
    6              0.000768000 import 'vim9SyntaxUtil.vim' as util
    6              0.000080000 const Derive: func = util.Derive
    6              0.000014000 const HighlightUserTypes: func = util.HighlightUserTypes
                            #}}}1
                            
                            # Early {{{1
                            # These rules need to be sourced early.
                            # Angle-Bracket Notation {{{2
                            
                            # This could break the highlighting of an expression in a mapping between `<C-\>e` and `<CR>`.
    6              0.000013000 execute 'syntax match vi9BracketNotation'
                                .. ' /\c'
                                # opening angle bracket
                                .. '<'
                                # possible modifiers; for `2-4`, see `:help <2-LeftMouse>`
                                .. '\%([scmad2-4]-\)\{,3}'
                                # key name
                                .. '\%(' .. lang.key_name .. '\)'
                                # closing angle bracket
                                .. '>'
                                .. '/'
                                .. ' contains=vi9BracketKey'
                                .. ' nextgroup=vi9SetBracketEqual'
    6              0.000912000     .. ' display'
                                #     set <Up>=^[OA
                                #             ^
    6              0.000187000     syntax match vi9SetBracketEqual /=[[:cntrl:]]\@=/ contained nextgroup=vi9SetBracketKeycode
                                #     set <Up>=^[OA
                                #              ^--^
    6              0.000078000     syntax match vi9SetBracketKeycode /\S\+/ contained
                            
                            # This could break the highlighting of a command after `<Bar>` (between `<ScriptCmd>` and `<CR>`).
    6              0.000192000 syntax match vi9BracketNotation /\c<Bar>/ contains=vi9BracketKey skipwhite
                            
                            # This could break the highlighting of a command in a mapping (between `<ScriptCmd>` and `<CR>`).
                            # Especially if `<ScriptCmd>` is preceded by some key(s).
    6              0.000231000 syntax match vi9BracketNotation /\c<ScriptCmd>/hs=s+1
                                \ contains=vi9BracketKey
                                \ nextgroup=@vi9CanBeAtStartOfLine,@vi9Range,vi9RangeIntroducer2
                                \ skipwhite
    6              0.000108000     syntax match vi9RangeIntroducer2 /:/ contained nextgroup=@vi9Range,vi9RangeMissingSpecifier1
                            
                            # We only highlight `<Cmd>`; not the command which comes right after.{{{
                            #
                            # That's because this command is run in the global context, thus with the legacy
                            # syntax.  And handling the legacy syntax adds too much complexity.
                            #
                            # Besides, the fact  that it's not highlighted gives us  some feedback: it tells
                            # us  that the  command  is not  run  with  the Vim9  syntax.   Just like  after
                            # `:legacy`, and inside a `:function`.
                            #}}}
    6              0.000103000 syntax match vi9BracketNotation /\c<Cmd>/hs=s+1 contains=vi9BracketKey
                            
                            # let's put this here for consistency
    6              0.000034000 execute 'syntax match vi9ExSpecialCharacters'
                                .. ' /\c'
                                .. '<'
                                ..     '\%('
                                ..         lang.ex_special_characters
                                ..     '\)'
                                .. '>'
                                .. '/'
    6              0.000282000     .. ' contains=vi9BracketKey'
                            
    6              0.000294000 syntax match vi9BracketKey /[<>]/ contained
                            
                            # Unbalanced paren {{{2
                            
    6              0.000064000 syntax match vi9OperError /[)\]}]/
                            # This needs to be installed early because it could break `>` when used as a comparison operator.
                            # We also want to disallow a hyphen before.{{{
                            #
                            # To  prevent a  distracting highlighting  while  we're typing  a method  call
                            # (which is quite frequent), and we haven't typed yet the name of the function
                            # afterward.
                            #
                            # Besides, the highlighting would be applied inconsistently.
                            # That's because, if  the next non-whitespace character is a  head of word (even
                            # on a different line),  then `->` is parsed as a method call  (even if it's not
                            # the correct one).
                            #}}}
    6              0.000053000 syntax match vi9OperError /-\@1<!>/
                            
                            # Special brackets in interpolated strings and heredocs {{{2
                            
                            # This must  come *before*  the rules  matching expressions  inside interpolated
                            # strings and heredocs.
                            
                            # String Interpolated Unbalanced Bracket
    6              0.000045000 syntax match vi9SIUB /[{}]/ contained
                            # String Interpolated Literal Bracket
    6              0.000051000 syntax match vi9SILB /{{\|}}/ contained
                            
                            # :++ / :-- {{{2
                            # Order: Must come before `vi9AutocmdMod`, to not break `++nested` and `++once`.
                            
                            # increment/decrement
                            # The `++` and `--` operators are implemented as Ex commands:{{{
                            #
                            #     :echo getcompletion('[-+]', 'command')
                            #     ['++', '--']
                            #
                            # Which makes sense.  They can only appear at the start of a line.
                            #}}}
    6              0.000059000 syntax match vi9Increment /\%(++\|--\)\%(\h\|&\)\@=/ contained
                            
    6              0.000009000 execute 'syntax match vi9IncrementError'
                                .. ' /' .. lang.increment_invalid .. '/'
    6              0.000096000     .. ' contained'
                            #}}}1
                            
                            # Range {{{1
                            
    6              0.000567000 syntax cluster vi9Range contains=
                                \ vi9RangeDelimiter,
                                \ vi9RangeLnumNotation,
                                \ vi9RangeMark,
                                \ vi9RangeMissingSpecifier2,
                                \ vi9RangeNumber,
                                \ vi9RangeOffset,
                                \ vi9RangePattern,
                                \ vi9RangeSpecialSpecifier
                            
                            # Make sure there is nothing before, to avoid a wrong match in sth like:
                            #     g:name = 'value'
                            #      ^
                            # Warning: If you want to use `\_s`, you need to use a lookbehind.{{{
                            #
                            #      ✘
                            #     vvv
                            #     \_s:\S\@=
                            #
                            #     \_s\@1<=:\S\@=
                            #     ^------^
                            #        ✔
                            #
                            # Otherwise, it would not  work at the start of a line,  unless the previous one
                            # is empty.
                            #}}}
    6              0.000123000 syntax match vi9RangeIntroducer /\%(^\|\s\):\S\@=/
                                \ contained
                                \ nextgroup=@vi9Range,vi9RangeMissingSpecifier1
                            
                                # Sometimes, we might want to add a colon in front of an Ex command, even if it's not necessary.{{{
                                #
                                # Maybe for the sake of consistency:
                                #
                                #     :1,2 substitute/.../.../
                                #     :3,4 substitute/.../.../
                                #     :substitute/.../.../
                                #     ^
                                #     to get a column of colons
                                #
                                # Or  maybe  to   remove  an  ambiguity  where  the  next   token  could  be
                                # misinterpreted as something else than an Ex command:
                                #
                                #     :!shellCmd
                                #     ^
                                #
                                # Here, `:` asserts that `!` is an Ex command, and not the logical operator NOT.
                                #
                                # ---
                                #
                                # Note that  we assert the presence  of a lowercase character  afterward, so
                                # that  we don't  break the  highlighting  of a  colon used  in the  ternary
                                # operator `?:`:
                                #
                                #     var name = test
                                #         ? value1
                                #         : value2
                                #         ^
                                #
                                # And we don't break a range introducer either:
                                #
                                #     :% substitute/pat/rep/
                                #     ^
                                #}}}
                                # Order: Must come after `vi9RangeIntroducer`.
    6              0.000063000     syntax match vi9DisambiguatingColon /\s\=:[a-zA-Z!]\@=/
                                    \ contained
                                    \ nextgroup=@vi9CanBeAtStartOfLine
                            
    6              0.000090000 syntax cluster vi9RangeAfterSpecifier contains=
                                \ @vi9CanBeAtStartOfLine,
                                \ @vi9Range,
                                \ vi9RangeMissingSpace
                            
                            #                     v-----v v-----v
                            #     command MySort :<line1>,<line2> sort
    6              0.000179000 syntax match vi9RangeLnumNotation /\c<line[12]>/
                                \ contained
                                \ contains=vi9BracketNotation,vi9UserCmdRhsEscapeSeq
                                \ nextgroup=@vi9RangeAfterSpecifier
                                \ skipwhite
                            
    6              0.000021000 execute 'syntax match vi9RangeMark /' .. "'" .. lang.mark_valid .. '/'
                                .. ' contained'
                                .. ' nextgroup=@vi9RangeAfterSpecifier'
    6              0.000070000     .. ' skipwhite'
                            
    6              0.000050000 syntax match vi9RangeNumber /\d\+/
                                \ contained
                                \ nextgroup=@vi9RangeAfterSpecifier
                                \ skipwhite
                            
    6              0.000055000 syntax match vi9RangeOffset /[-+]\+\d*/
                                \ contained
                                \ nextgroup=@vi9RangeAfterSpecifier
                                \ skipwhite
                            
    6              0.000112000 syntax match vi9RangePattern +/[^/]*/+
                                \ contained
                                \ contains=vi9RangePatternFwdDelim
                                \ nextgroup=@vi9RangeAfterSpecifier
                                \ skipwhite
    6              0.000039000 syntax match vi9RangePatternFwdDelim +/+ contained
                            
    6              0.000105000 syntax match vi9RangePattern +?[^?]*?+
                                \ contained
                                \ contains=vi9RangePatternBwdDelim
                                \ nextgroup=@vi9RangeAfterSpecifier
                                \ skipwhite
    6              0.000039000 syntax match vi9RangePatternBwdDelim /?/ contained
                            
    6              0.000048000 syntax match vi9RangeSpecialSpecifier /[.$%*]/
                                \ contained
                                \ nextgroup=@vi9RangeAfterSpecifier
                                \ skipwhite
                            
    6              0.000046000 syntax match vi9RangeDelimiter /[,;]/
                                \ contained
                                \ nextgroup=@vi9RangeAfterSpecifier
                            
                            # Ex commands {{{1
                            # Assert where Ex commands can match {{{2
                            
                            # `vi9GenericCmd` handles most Ex commands.
                            # But some of them are special.{{{
                            #
                            # Either they  – or one  of their  arguments – need  to be highlighted  in a
                            # certain way.   For example, `:if`  is a control  flow statement and  should be
                            # highighted differently than – say – `:delete`.
                            #
                            # Similarly, while `:map` is not a  control flow statement, and does not require
                            # a specific highlighting, its arguments do.
                            #}}}
                            # Let's list them in this cluster.
                            # One of them is not properly highlighted!{{{
                            #
                            # First, as mentioned before, make sure it's listed in this cluster.
                            # Second, make sure it's listed in `SPECIAL_CMDS` in `./tools/GenerateImport.vim`.
                            # So that it's removed from `lang.command_name`, and in turn from the `vi9GenericCmd` rule.
                            #}}}
    6              0.001918000 syntax cluster vi9IsCmd contains=
                                \ @vi9ControlFlow,
                                \ @vi9OOP,
                                \ vi9AbbrevCmd,
                                \ vi9Augroup,
                                \ vi9Autocmd,
                                \ vi9BangCmd,
                                \ vi9Cd,
                                \ vi9CmdModifier,
                                \ vi9CopyMove,
                                \ vi9Declare,
                                \ vi9DeclareError,
                                \ vi9DigraphsCmd,
                                \ vi9DoCmds,
                                \ vi9Doautocmd,
                                \ vi9EchoHL,
                                \ vi9Export,
                                \ vi9Filetype,
                                \ vi9GenericCmd,
                                \ vi9Global,
                                \ vi9Highlight,
                                \ vi9Import,
                                \ vi9DeprecatedLet,
                                \ vi9Map,
                                \ vi9MarkCmd,
                                \ vi9Norm,
                                \ vi9ProfileCmd,
                                \ vi9RegistersCmd,
                                \ vi9Set,
                                \ vi9Subst,
                                \ vi9Syntax,
                                \ vi9Unmap,
                                \ vi9UserCmdDef,
                                \ vi9UserCmdExe,
                                \ vi9VimGrep,
                                \ vi9Wincmd
                            
                            # Problem: a token might look like a command, but be something else.{{{
                            #
                            # For example:
                            #
                            #     var set: bool
                            #     set = true
                            #     ^^^
                            #
                            # This is not the `:set` command.  This is just a variable.
                            #}}}
                            # Solution: Before matching a command, let's match a suitable position.{{{
                            #
                            # That is,  in addition to assert  the presence of a  name which is valid  for a
                            # builtin Ex command (`\<\h\w*\>`), we also want to assert some properties about
                            # the position at  the end of this name  which are necessary for the  name to be
                            # parsed as a command; like the presence of a whitespace.
                            #}}}
                            
                            # Special Case: `:!`
    6              0.000047000 syntax match vi9MayBeCmd /!\@=/ contained nextgroup=@vi9IsCmd
                            
                            # Special Case: Some commands (like `:g` and `:s`) *can* be followed by a non-whitespace.
    6              0.000156000 syntax match vi9MayBeCmd /\%(\<\h\w*\>\)\@=/
                                \ contained
                                \ nextgroup=vi9Global,vi9Subst
                            
                                # General case
                                # Order: Must come after the previous rule handling the special case.
    6              0.000010000     execute 'syntax match vi9MayBeCmd'
                                    .. ' /\%(' .. '\<\h\w*\>' .. '!\=' .. lang.command_can_be_before .. '\)\@=/'
                                    .. ' contained'
    6              0.000110000         .. ' nextgroup=@vi9IsCmd'
                            
                            # Now, let's build a cluster containing all groups which can appear at the start of a line.
    6              0.000757000 syntax cluster vi9CanBeAtStartOfLine contains=
                                \ @vi9FuncCall,
                                \ vi9Block,
                                \ vi9Comment,
                                \ vi9DeprecatedDictLiteralLegacy,
                                \ vi9DeprecatedScopes,
                                \ vi9DisambiguatingColon,
                                \ vi9FuncEnd,
                                \ vi9FuncHeader,
                                \ vi9Increment,
                                \ vi9IncrementError,
                                \ vi9LegacyFunction,
                                \ vi9MayBeCmd,
                                \ vi9RangeIntroducer,
                                \ vi9This
                            
                            # Let's use it in all relevant contexts.   We won't list them all here; only the
                            # ones which  don't have a  dedicated section (i.e. start  of line, and  after a
                            # bar).
    6              0.000051000 syntax match vi9StartOfLine /^/
                                \ nextgroup=@vi9CanBeAtStartOfLine
                                \ skipwhite
                                # This rule  is useful to  disallow some constructs at  the start of  a line
                                # where an expression is meant to be written.
    6              0.000047000     syntax match vi9SOLExpr /^/ contained skipwhite nextgroup=@vi9Expr
                            
    6              0.000043000 syntax match vi9CmdSep /|/ skipwhite nextgroup=@vi9CanBeAtStartOfLine
                            
                            # Generic {{{2
                            
    6              0.000037000 execute 'syntax keyword vi9GenericCmd' .. ' ' .. lang.command_name .. ' contained'
    6              0.001313000 
    6              0.000051000 syntax match vi9GenericCmd /\<z[-+^.=]\=\>/ contained
                            
                            # Special {{{2
                            # A command is special iff it needs a special highlighting.{{{
                            #
                            # For example, `:for` – as a  control flow statement – should be highlighted
                            # differently than `:delete`.   Same thing for `:autocmd`; not  because it needs
                            # to be  highlighted differently, but because  some of its arguments  need to be
                            # highlighted.
                            #}}}
                            # Some commands need to be handled as special because of their argument, which can contain problematic characters.{{{
                            #
                            # This is the case of `:digraph`, `:normal`, `:mark`, `:wincmd`, ...
                            #
                            # Examples:
                            #
                            #     mark {
                            #     normal! >
                            #     wincmd +
                            #
                            # Those could be wrongly highlighted as  operators, or as errors (for unbalanced
                            # brackets), or break the highlighting of a subsequent command.
                            #
                            # The  solution is  to  highlight  these arguments  as  strings,  or as  special
                            # characters.
                            #
                            # In the case of `:normal`, it makes  sense to highlight the command argument as
                            # a string, because – in effect – that's what it is: a string of characters,
                            # just like the one we can find in a register after a recording (`:echo @q`).
                            #
                            # In the case of `:mark`, it makes  sense to highlight the argument as a special
                            # character,  because  that's how  we  highlight  a mark  when  used  as a  line
                            # specifier (in front of an Ex command name).
                            #}}}
                            
                            # Autocmd {{{3
                            # `:augroup` {{{4
                            
                            # The legacy syntax plugin wraps all the contents of an augroup inside a region.{{{
                            #
                            # I think it does  that to highlight a possible error, in case  we wrote the end
                            # statement without the starting one:
                            #
                            #         autocmd ...
                            #         ...
                            #     augroup END
                            #     ^---------^
                            #        error, because orphan
                            #}}}
                            #   We don't.{{{
                            #
                            # It creates too many issues and complexity.
                            # Technically, you can write any statement between the start and end of an augroup.
                            # That includes, for example, a function.
                            # But the legacy syntax plugin wrongly handles such a situation:
                            #
                            #     augroup Name
                            #        autocmd!
                            #         def Func()
                            #         ^^^
                            #         wrongly highlighted as an option (:def is confused with 'def')
                            #         enddef
                            #     augroup END
                            #
                            # That's because the region doesn't include the right syntax group(s).
                            # Finding and writing the right ones is cumbersome and brittle.
                            #
                            # Besides, the  gain is dubious; I  can't remember the  last time we did  such a
                            # mistake.
                            #
                            # Finally,  it's inconsistent.   Why warning  against  the missing  start of  an
                            # augroup, but not the missing start of a function?
                            #
                            #         eval 0
                            #     endfunction
                            #     ^---------^
                            #     orphan, but still highlighted as a command; not as an error
                            #
                            # It's not worth the trouble.
                            #}}}
                            
    6              0.000130000 syntax match vi9Augroup
                                \ /\<aug\%[roup]\ze!\=\s\+\h\%(\w\|-\)*/
                                \ contained
                                \ nextgroup=vi9AugroupNameEnd
                                \ skipwhite
                            
                            #          v--v
                            # :augroup Name
                            # :augroup END
                            #          ^^^
    6              0.000042000 syntax match vi9AugroupNameEnd /\h\%(\w\|-\)*/ contained
                            
                            # `:autocmd` {{{4
                            
                            # :au[tocmd] [group] {event} {pat} [++once] [++nested] {cmd}
    6              0.000333000 syntax match vi9Autocmd /\<au\%[tocmd]\>/
                                \ contained
                                \ nextgroup=
                                \     vi9AutocmdAllEvents,
                                \     vi9AutocmdEventBadCase,
                                \     vi9AutocmdEventGoodCase,
                                \     vi9AutocmdGroup,
                                \     vi9AutocmdMod
                                \ skipwhite
                            
                            #           v
                            # :au[tocmd]! ...
    6              0.000274000 syntax match vi9Autocmd /\<au\%[tocmd]\>!/he=e-1
                                \ contained
                                \ nextgroup=
                                \     vi9AutocmdAllEvents,
                                \     vi9AutocmdEventBadCase,
                                \     vi9AutocmdEventGoodCase,
                                \     vi9AutocmdGroup
                                \ skipwhite
                            
                            # The trailing whitespace is useful to prevent a correct but still noisy/useless
                            # match when we simply clear an augroup.
    6              0.000224000 syntax match vi9AutocmdGroup /\S\+\s\@=/
                                \ contained
                                \ nextgroup=
                                \     vi9AutocmdAllEvents,
                                \     vi9AutocmdEventBadCase,
                                \     vi9AutocmdEventGoodCase
                                \ skipwhite
                            
                            # Special Case: A wildcard can be used for all events.{{{
                            #
                            #     autocmd! * <buffer>
                            #              ^
                            #
                            # This is *not* the same syntax token as the pattern which follows an event.
                            #}}}
    6              0.000109000 syntax match vi9AutocmdAllEvents /\*\_s\@=/
                                \ contained
                                \ nextgroup=vi9AutocmdPat
                                \ skipwhite
                            
                            # An autocmd pattern cannot start with a bar.{{{
                            #
                            #     autocmd BufWinEnter |pat echomsg '...'
                            #                         ^
                            #                         this is not the start of a pattern
                            #
                            #     if exists('#BufEnter') | doautocmd BufEnter | endif
                            #                                                 ^
                            #                                                 this is not a pattern
                            #}}}
    6              0.000230000 syntax match vi9AutocmdPat /[^[:blank:]|]\S*/
                                \ contained
                                \ nextgroup=@vi9CanBeAtStartOfLine,
                                \     vi9AutocmdMod,
                                \     vi9BlockUserCmd,
                                \     vi9ContinuationBeforeCmd
                                \ skipnl
                                \ skipwhite
                            
    6              0.000170000 syntax match vi9AutocmdMod /++\%(nested\|once\)/
                                \ contained
                                \ nextgroup=
                                \     @vi9CanBeAtStartOfLine,
                                \     vi9BlockUserCmd,
                                \     vi9ContinuationBeforeCmd
                                \ skipnl
                                \ skipwhite
                            
                            # Events {{{4
                            
    6              0.000007000 syntax case ignore
    6              0.000030000 if get(g:, 'vim9_syntax', {})
                             ->get('errors', {})
                             ->get('event_wrong_case', false)
                                execute 'syntax keyword vi9AutocmdEventBadCase' .. ' ' .. lang.event
                                    .. ' contained'
                                    .. ' nextgroup=vi9AutocmdPat,vi9AutocmdEndOfEventList'
                                    .. ' skipwhite'
                                syntax case match
    6              0.000007000 endif
                            # Order: Must come after `vi9AutocmdEventBadCase`.
    6              0.000023000 execute 'syntax keyword vi9AutocmdEventGoodCase' .. ' ' .. lang.event
                                .. ' contained'
                                .. ' nextgroup=vi9AutocmdPat,vi9AutocmdEndOfEventList'
    6              0.000499000     .. ' skipwhite'
    6              0.000007000 syntax case match
                            
    6              0.000216000 syntax match vi9AutocmdEndOfEventList /,\%(\a\+,\)*\a\+/
                                \ contained
                                \ contains=vi9AutocmdEventBadCase,vi9AutocmdEventGoodCase
                                \ nextgroup=vi9AutocmdPat
                                \ skipwhite
                            
                            # `:doautocmd`, `:doautoall` {{{4
                            
                            # :do[autocmd] [<nomodeline>] [group] {event} [fname]
                            # :doautoa[ll] [<nomodeline>] [group] {event} [fname]
    6              0.000270000 syntax keyword vi9Doautocmd do[autocmd] doautoa[ll]
                                \ contained
                                \ nextgroup=
                                \     vi9AutocmdEventBadCase,
                                \     vi9AutocmdEventGoodCase,
                                \     vi9AutocmdGroup,
                                \     vi9AutocmdMod
                                \ skipwhite
                            
    6              0.000225000 syntax match vi9AutocmdMod /<nomodeline>/
                                \ contained
                                \ nextgroup=
                                \     vi9AutocmdEventBadCase,
                                \     vi9AutocmdEventGoodCase,
                                \     vi9AutocmdGroup
                                \ skipwhite
                            #}}}3
                            # Control Flow {{{3
                            
    6              0.000336000 syntax cluster vi9ControlFlow contains=
                                \ vi9BreakContinue,
                                \ vi9Conditional,
                                \ vi9Finish,
                                \ vi9Repeat,
                                \ vi9Return,
                                \ vi9TryCatch
                            
                            # :return
    6              0.000039000 syntax keyword vi9Return return contained nextgroup=@vi9Expr skipwhite
                            
                            # :break
                            # :continue
    6              0.000038000 syntax keyword vi9BreakContinue break continue contained
                            # :finish
    6              0.000032000 syntax keyword vi9Finish finish contained
                            
                            # :if
                            # :elseif
    6              0.000039000 syntax keyword vi9Conditional if elseif contained nextgroup=@vi9Expr skipwhite
                            
                            # :else
                            # :endif
    6              0.000034000 syntax keyword vi9Conditional else endif contained
                            
                            # :for
    6              0.000157000 syntax keyword vi9Repeat for
                                \ contained
                                \ nextgroup=vi9RepeatForDeclareName,vi9RepeatForListUnpackDeclaration
                                \ skipwhite
                            
                            # :for [name, ...]
                            #      ^---------^
                            # `contains=vi9DataType` to support the return type of a funcref:{{{
                            #
                            #     for [a: string, B: func(string): bool] in []
                            #                                      ^--^
                            #}}}
    6              0.000263000 syntax region vi9RepeatForListUnpackDeclaration
                                \ matchgroup=vi9Sep
                                \ start=/[[(]/
                                \ end=/[])]/
                                \ contained
                                \ contains=vi9RepeatForDeclareName,vi9DataType
                                \ nextgroup=vi9RepeatForIn
                                \ oneline
                                \ skipwhite
                                \ skipnl
                            
                            # :for name
                            #      ^--^
                            # In the positive lookahead, we need to allow whitespace in front of the colon.{{{
                            #
                            # Even though it's wrong.
                            #
                            #             we want this highlighted as an error
                            #             v
                            #     for name : string in []
                            #         ^--^
                            #         we want this highlighted as an iteration variable
                            #
                            # This is even more necessary when iterating over a list.
                            #}}}
                            #   And we need to match a whitespace afterward.{{{
                            #
                            # To highlight `a:`, `l:` and `s:` as errors.
                            #
                            #         this is a scope which is only valid in legacy
                            #         vv
                            #     for l:legacy_var in ...
                            #         ^
                            #         this is NOT an iteration variable
                            #}}}
                            # We also match  a possible comma or  closing bracket in case we  iterate over a
                            # list of lists.
    6              0.000183000 syntax match vi9RepeatForDeclareName /\<\h\w*\>\%(\s*\%(:\s\|\<in\>\)\|,\|\s*[)\]]\)\@=/
                                \ contained
                                \ nextgroup=@vi9DataTypeCluster,vi9RepeatForIn,vi9NoWhitespaceBeforeInit
                                \ skipwhite
                            
                            # for name in
                            #          ^^
    6              0.000036000 syntax keyword vi9RepeatForIn in contained
                            
                            # :while
    6              0.000035000 syntax keyword vi9Repeat while contained nextgroup=@vi9Expr skipwhite
                            
                            # :endfor
                            # :endwhile
    6              0.000034000 syntax keyword vi9Repeat endfor endwhile contained
                            
                            # :try
                            # :finally
                            # :endtry
    6              0.000054000 syntax keyword vi9TryCatch try finally endtry contained
                            
                            # :throw
    6              0.000039000 syntax keyword vi9TryCatch throw contained nextgroup=@vi9Expr skipwhite
                            
                            # :catch
    6              0.000092000 syntax keyword vi9TryCatch catch contained nextgroup=vi9TryCatchPattern skipwhite
    6              0.000010000 execute 'syntax region vi9TryCatchPattern'
                                .. ' matchgroup=vi9SubstDelim'
                                .. ' start=/\z(' .. lang.pattern_delimiter .. '\)/rs=s+1'
                                .. ' skip=/\\\\\|\\\z1/'
                                .. ' end=/\z1/'
                                .. ' contained'
                                .. ' contains=@vi9SubstList'
                                .. ' contains=vi9TryCatchPatternDelim'
    6              0.000199000     .. ' oneline'
                            
                            # Declaration {{{3
                            
                            # Don't rewrite this rule with `:help syn-keyword`.
                            # The `vi9DeclareError` rule needs to be able to override `vi9Declare`.
                            # But it uses a match, and thus can only win against another match/region.
    6              0.000224000 syntax match vi9Declare /\<\%(const\=\|final\|unl\%[et]\|var\)\>/
                                \ contained
                                \ nextgroup=
                                \     vi9DeclareName,
                                \     vi9ListUnpackDeclaration,
                                \     vi9ReservedNames
                                \ skipwhite
                                # “Public” variables cannot be declared:{{{
                                #
                                #      ✘
                                #     vvv
                                #     var b:name = ...
                                #     var g:name = ...
                                #     var t:name = ...
                                #     var v:name = ...
                                #     var w:name = ...
                                #     ^^^
                                #      ✘
                                #
                                # Same thing for environment variables, Vim options, and Vim registers:
                                #
                                #      ✘
                                #     vvv
                                #     var $ENV = ...
                                #     var &g:name = ...
                                #     var &l:name = ...
                                #     var &name = ...
                                #     var @r = ...
                                #     ^^^
                                #      ✘
                                #}}}
    6              0.000060000     syntax match vi9DeclareError /\<var\ze\s\+\%([bgstvw]:\h\|[$&@]\)/
                                    \ contained
    6              0.000050000     syntax match vi9DeclareError /\<\%(const\=\|final\)\ze\s\+[$&@]/
                                    \ contained
                                # `:unlet` cannot delete a Vim option/register:{{{
                                #
                                #     unlet &shiftwidth
                                #     ^---^
                                #       ✘
                                #
                                #     unlet @r
                                #     ^---^
                                #       ✘
                                #}}}
    6              0.000061000     syntax match vi9DeclareError /\<unlet\ze\s\+[&@]/ contained
                            
    6              0.000137000 syntax region vi9ListUnpackDeclaration
                                \ contained
                                \ contains=vi9DeclareName
                                \ matchgroup=vi9Sep
                                \ start=/\[/
                                \ end=/\]/
                                \ keepend
                                \ oneline
                            
    6              0.000104000 syntax match vi9DeclareName /\<\h\w*\>/
                                \ contained
                                \ nextgroup=@vi9DataTypeCluster,vi9NoWhitespaceBeforeInit
                            
                            #     var name : string = 'value'
                            #             ^
                            #             ✘
    6              0.000046000 syntax match vi9NoWhitespaceBeforeInit /\s\+:\@=/
                                \ contained
                                \ nextgroup=@vi9DataTypeCluster
                                # Necessary if we want a broken type specification to be still highlighted.{{{
                                #
                                #     for [name : string] in []
                                #                 ^----^
                                #                 even though it's broken by the space before the colon,
                                #                 we still want this to be recognized as a type
                                #}}}
                            
                            # In the legacy syntax plugin, `vimLetHereDoc` contains `vimComment` and `vim9Comment`.  That's wrong.{{{
                            #
                            # It causes  any text  following a double  quote at  the start of  a line  to be
                            # highlighted as a Vim comment.  But that's  not a comment; that's a part of the
                            # heredoc; i.e. a string.
                            #
                            # Besides, we apply various styles inside comments, such as bold or italics.
                            # It would be unexpected and distracting to see those styles in a heredoc.
                            #}}}
                            # Don't assign `vi9Declare` instead of `vi9DeclareHereDoc` to `matchgroup`.{{{
                            #
                            # We want the syntax  item on the text at the start/end of  a heredoc to contain
                            # the keyword `heredoc`.  It might be useful for other plugins; for example, for
                            # the Vim indent plugin.
                            #}}}
                            # Similarly, don't change the name of `vi9DeclareHereDocStop`.{{{
                            #
                            # The Vim indent plugin relies on the keyword `HereDocStop` to find the end of a
                            # heredoc.
                            #}}}
    6              0.000133000 syntax region vi9HereDoc
                                \ matchgroup=vi9DeclareHereDoc
                                \ start=/\s\@1<==<<\s\+\%(trim\s\)\=\s*\z(\L\S*\)/
                                \ matchgroup=vi9DeclareHereDocStop
                                \ end=/^\s*\z1$/
                            
    6              0.000308000 syntax region vi9HereDoc
                                \ matchgroup=vi9DeclareHereDoc
                                \ start=/\s\@1<==<<\s\+\%(.*\<eval\>\)\@=\%(\%(trim\|eval\)\s\)\{1,2}\s*\z(\L\S*\)/
                                \ matchgroup=vi9DeclareHereDocStop
                                \ end=/^\s*\z1$/
                                \ contains=vi9HereDocExpr,vi9SILB,vi9SIUB
                            
    6              0.000117000 syntax region vi9HereDocExpr
                                \ matchgroup=PreProc
                                \ start=/{{\@!/
                                \ end=/}/
                                \ contained
                                \ contains=@vi9Expr
                                \ oneline
                            
                            # Modifier {{{3
                            
    6              0.000007000 execute 'syntax match vi9CmdModifier'
                                .. ' /\<\%(' .. lang.command_modifier .. '\)\>/'
                                .. ' contained'
                                .. ' nextgroup=@vi9CanBeAtStartOfLine,vi9CmdBangModifier,vi9Line12MissingColon'
    6              0.000291000     .. ' skipwhite'
                            
                            # A command modifier can be followed by a bang.
                            # We need to match it, otherwise, we can't match the command which comes afterward.
                            # The negative lookbehind is necessary because of the previous `skipwhite`.
    6              0.000043000 syntax match vi9CmdBangModifier /\s\@1<!!/ contained nextgroup=@vi9CanBeAtStartOfLine skipwhite
                            
                            # Highlight a legacy command (run with `:legacy`) to a minimum.{{{
                            #
                            # In particular, we don't want `:let` to be wrongly highlighted as an error:
                            #
                            #     legacy let g:name = 'value'
                            #            ^^^
                            #            not an error because valid in legacy
                            #}}}
    6              0.000009000 execute 'syntax match vi9CmdModifier'
                                .. ' /\<legacy\>/'
                                .. ' contained'
                                .. ' nextgroup=vi9LegacyCmd'
    6              0.000114000     .. ' skipwhite'
                            
    6              0.000054000 syntax match vi9LegacyCmd /.\{-}\%(\\\@1<!|\|$\)\@=/ contained contains=@vi9LegacyCluster
                            
                            # User {{{3
                            # Definition {{{4
                            # :command {{{5
                            
                            # Warning: Do not turn `:syntax match` into `:syntax keyword`.
                            # It would break the highlighting of a possible following bang.
    6              0.000050000 syntax match vi9UserCmdDef /\<com\%[mand]\>/
                                \ contained
                                \ nextgroup=@vi9UserCmdAttr
                                \ skipwhite
                            
    6              0.000051000 syntax match vi9UserCmdDef /\<com\%[mand]\>!/he=e-1
                                \ contained
                                \ nextgroup=@vi9UserCmdAttr
                                \ skipwhite
                            
                            # error handling {{{5
                            # Order: should come before highlighting valid attributes.
                            
    6              0.000278000 syntax cluster vi9UserCmdAttr contains=
                                \ vi9UserCmdAttrEqual,
                                \ vi9UserCmdAttrError,
                                \ vi9UserCmdAttrErrorValue,
                                \ vi9UserCmdAttrName,
                                \ vi9UserCmdLhs
                            
                            # Order: should come before the next rule highlighting errors in attribute names
                            # An attribute error should not break the highlighting of the following attributes.{{{
                            #
                            # Example1:
                            #
                            #     command -addrX=other -nargs=1 Cmd Func()
                            #                  ^       ^-----------------^
                            #                  ✘       highlighting should still work, in spite of the previous typo
                            #                  typo
                            #
                            # Example2:
                            #
                            #     command -nargs=123 -buffer Cmd Func()
                            #                     ^^ ^----------------^
                            #                     ✘  highlighting should still work, in spite of the previous error
                            #                     error
                            #}}}
    6              0.000105000 syntax match vi9UserCmdAttrErrorValue /\S\+/
                                \ contained
                                \ nextgroup=vi9UserCmdAttrName
                                \ skipwhite
                            
                            # an invalid attribute name is an error
    6              0.000161000 syntax match vi9UserCmdAttrError /-[^[:blank:]=]\+/
                                \ contained
                                \ contains=vi9UserCmdAttrName
                                \ nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
                            # boolean attributes {{{5
                            
    6              0.000120000 syntax match vi9UserCmdAttrName /-\%(bang\|bar\|buffer\|register\)\>/
                                \ contained
                                \ nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
                            # attributes with values {{{5
                            # = {{{6
                            
    6              0.000034000 syntax match vi9UserCmdAttrEqual /=/ contained
                            
                            # -addr {{{6
                            
    6              0.000145000 syntax match vi9UserCmdAttrName /-addr\>/
                                \ contained
                                \ nextgroup=vi9UserCmdAttrAddress,vi9UserCmdAttrErrorValue
                            
    6              0.000007000 execute 'syntax match vi9UserCmdAttrAddress'
                                .. ' /=\%(' .. lang.command_address_type .. '\)\>/'
                                .. ' contained'
                                .. ' contains=vi9UserCmdAttrEqual'
                                .. ' nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd'
                                .. ' skipnl'
    6              0.000186000     .. ' skipwhite'
                            
                            # -complete {{{6
                            
    6              0.000235000 syntax match vi9UserCmdAttrName /-complete\>/
                                \ contained
                                \ nextgroup=vi9UserCmdAttrComplete,vi9UserCmdAttrErrorValue
                            
                            # -complete=arglist
                            # -complete=buffer
                            # -complete=...
    6              0.000010000 execute 'syntax match vi9UserCmdAttrComplete'
                                .. ' /'
                                ..     '=\%(' .. lang.command_complete_type .. '\)'
                                .. '/'
                                .. ' contained'
                                .. ' contains=vi9UserCmdAttrEqual'
                                .. ' nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd'
                                .. ' skipnl'
    6              0.000298000     .. ' skipwhite'
                            
                            # -complete=custom,Func
                            # -complete=customlist,Func
    6              0.000225000 syntax match vi9UserCmdAttrComplete /=custom\%(list\)\=,\%([gs]:\)\=\%(\w\|[#.]\)*/
                                \ contained
                                \ contains=vi9UserCmdAttrEqual,vi9UserCmdAttrComma
                                \ nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
    6              0.000037000 syntax match vi9UserCmdAttrComma /,/ contained
                            
                            # -count {{{6
                            
    6              0.000210000 syntax match vi9UserCmdAttrName /-count\>/
                                \ contained
                                \ nextgroup=
                                \     @vi9UserCmdAttr,
                                \     vi9UserCmdAttrCount,
                                \     vi9UserCmdAttrErrorValue,
                                \     vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
    6              0.000201000 syntax match vi9UserCmdAttrCount
                                \ /=\d\+/
                                \ contained
                                \ contains=vi9Number,vi9UserCmdAttrEqual
                                \ nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
                            # -nargs {{{6
                            
    6              0.000144000 syntax match vi9UserCmdAttrName /-nargs\>/
                                \ contained
                                \ nextgroup=vi9UserCmdAttrNargs,vi9UserCmdAttrErrorValue
                            
    6              0.000205000 syntax match vi9UserCmdAttrNargs
                                \ /=[01*?+]/
                                \ contained
                                \ contains=vi9UserCmdAttrEqual,vi9UserCmdAttrNargsNumber
                                \ nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
    6              0.000037000 syntax match vi9UserCmdAttrNargsNumber /[01]/ contained
                            
                            # -range {{{6
                            
                            # `-range` is a special case:
                            # it can accept a value, *or* be used as a boolean.
    6              0.000218000 syntax match vi9UserCmdAttrName /-range\>/
                                \ contained
                                \ nextgroup=
                                \     @vi9UserCmdAttr,
                                \     vi9UserCmdAttrErrorValue,
                                \     vi9UserCmdAttrRange,
                                \     vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            
    6              0.000201000 syntax match vi9UserCmdAttrRange /=\%(%\|-\=\d\+\)/
                                \ contained
                                \ contains=vi9Number,vi9UserCmdAttrEqual
                                \ nextgroup=@vi9UserCmdAttr,vi9ContinuationBeforeUserCmd
                                \ skipnl
                                \ skipwhite
                            #}}}5
                            # LHS {{{5
                            
    6              0.000210000 syntax match vi9UserCmdLhs /\u\w*/
                                \ contained
                                \ nextgroup=
                                \     @vi9CanBeAtStartOfLine,
                                \     vi9BlockUserCmd,
                                \     vi9ContinuationBeforeCmd,
                                \     vi9Line12MissingColon
                                \ skipnl
                                \ skipwhite
                            
                            #     command Cmd <line1>,<line2>yank
                            #                 ^
                            #                 ✘
                            #
                            #     command Cmd :<line1>,<line2>yank
                            #                 ^
                            #                 ✔
    6              0.000049000 syntax match vi9Line12MissingColon /<line[12]>/ contained
                            
                            # escape sequences in RHS {{{5
                            
                            # We should limit this match to the RHS of a user command.{{{
                            #
                            # But that would add too much complexity, so we don't.
                            # Besides, it's unlikely we would write something like `<line1>` outside the RHS
                            # of a user command.
                            #}}}
    6              0.000012000 execute 'syntax match vi9UserCmdRhsEscapeSeq'
                                .. ' /'
                                .. '<'
                                .. '\%([fq]-\)\='
                                # `:help <line1>`
                                .. '\%(args\|bang\|count\|line[12]\|mods\|range\|reg\)'
                                .. '>'
                                .. '/'
                                .. ' contains=vi9BracketKey'
                                # An escape sequence might be embedded inside a string:{{{
                                #
                                #     command -nargs=1 Locate Wrap({source: 'locate <q-args>', options: '-m'})->Run()
                                #                                                   ^------^
                                #}}}
    6              0.000241000     .. ' containedin=vi9String,vi9StringInterpolated'
                            #}}}4
                            # Execution {{{4
                            
    6              0.000147000 syntax match vi9UserCmdExe /\u\w*/ contained nextgroup=vi9SpaceExtraAfterFuncname,vi9UserCmdArgs
                            # Don't highlight the arguments of a user-defined command.{{{
                            #
                            # We don't know their semantics, so assuming anything might lead to mistakes.
                            # For example:
                            #
                            #             those are not dictionary delimiters
                            #             v       v
                            #     Abolish {hte,teh} the
                            #                 ^
                            #                 there is no error here;
                            #                 no missing whitespace after a comma between items in a dictionary
                            #}}}
    6              0.000051000 syntax match vi9UserCmdArgs /\s*[^[:blank:]|].\{-}[|\n]/ contained
                            
                            # This lets Vim highlight the name of an option and its value, when we set it with `:CompilerSet`.{{{
                            #
                            #     CompilerSet mp=pandoc
                            #                 ^-------^
                            #
                            # See: `:help :CompilerSet`
                            #}}}
                            # But it breaks the highlighting of `:CompilerSet`.  It should be highlighted as a *user* command!{{{
                            #
                            # No,  it  should not.   The  fact  that its  name  starts  with an  uppercase
                            # character does not mean it's a user command.  It's definitely not one:
                            #
                            #     :command CompilerSet
                            #     No user-defined commands found
                            #}}}
    6              0.000106000 syntax keyword vi9Set CompilerSet contained nextgroup=vi9MayBeOptionSet skipwhite
                            #}}}3
                            # :cd {{{3
                            
    6              0.000109000 syntax keyword vi9Cd cd lc[d] tc[d] chd[ir] lch[dir] tch[dir] contained nextgroup=vi9CdPreviousDir
                            
                            # For `:cd`, `-` stands for the previous working directory.
                            # Let's make sure it's not matched as an arithmetic operator.{{{
                            #
                            #     if getcwd() != cwd
                            #       cd -
                            #          ^
                            #          this should not be highlighted as an operator
                            #     endif
                            #     # --^
                            #     # otherwise, this would no longer be matched as a command
                            #}}}
    6              0.000038000 syntax match vi9CdPreviousDir /!\=\s*-/ contained
                            
                            # :copy / :move {{{3
                            # These commands need a special treatment because of the address they receive as argument.{{{
                            #
                            #     move '>+1
                            #           ^
                            #           if we highlight unbalanced brackets as error, this one should be ignored;
                            #           it's not an error;
                            #           it's a valid mark
                            #}}}
                            
    6              0.000047000 syntax keyword vi9CopyMove m[ove] co[py] contained nextgroup=@vi9Range skipwhite
                            
                            # `:digraphs` {{{3
                            
    6              0.000206000 syntax keyword vi9DigraphsCmd dig[raphs]
                                \ contained
                                \ nextgroup=
                                \     vi9DigraphsChars,
                                \     vi9DigraphsCharsInvalid,
                                \     vi9DigraphsCmdBang
                                \ skipwhite
                            
    6              0.000096000 syntax match vi9DigraphsCharsInvalid /\S\+/
                                \ contained
                                \ nextgroup=vi9DigraphsNumber
                                \ skipwhite
    6              0.000033000     syntax match vi9DigraphsCmdBang /!/ contained
                            
                            # A valid `characters` argument is any sequence of 2 non-whitespace characters.
                            # Special Case:  a bar must  be escaped,  so that it's  not parsed as  a command
                            # termination.
    6              0.000106000 syntax match vi9DigraphsChars /\s\@<=\%([^[:blank:]|]\|\\|\)\{2}\_s\@=/
                                \ contained
                                \ nextgroup=vi9DigraphsNumber
                                \ skipwhite
    6              0.000133000 syntax match vi9DigraphsNumber /\d\+/
                                \ contained
                                \ nextgroup=vi9DigraphsChars,vi9DigraphsCharsInvalid
                                \ skipwhite
                            
                            # `:*do` {{{3
                            
    6              0.000054000 syntax keyword vi9DoCmds argdo bufdo cdo cfdo ld[o] lfdo tabd[o] windo
                                \ contained
                                \ nextgroup=@vi9CanBeAtStartOfLine
                                \ skipwhite
                            
                            # :echohl {{{3
                            
    6              0.000181000 syntax keyword vi9EchoHL echoh[l]
                                \ contained
                                \ nextgroup=vi9EchoHLNone,vi9Group,vi9HLGroup
                                \ skipwhite
                            
    6              0.000007000 syntax case ignore
    6              0.000031000 syntax keyword vi9EchoHLNone none contained
    6              0.000005000 syntax case match
                            
                            # :filetype {{{3
                            
    6              0.000193000 syntax match vi9Filetype /\<filet\%[ype]\%(\s\+\I\i*\)*/
                                \ contained
                                \ contains=vi9FTCmd,vi9FTError,vi9FTOption
                                \ skipwhite
                            
    6              0.000033000 syntax match vi9FTError /\I\i*/ contained
    6              0.000031000 syntax keyword vi9FTCmd filet[ype] contained
    6              0.000035000 syntax keyword vi9FTOption detect indent off on plugin contained
                            
                            # :global {{{3
                            
                            # without a bang
    6              0.000007000 execute 'syntax match vi9Global'
                                .. ' /\<g\%[lobal]\>\ze\s*\(' .. lang.pattern_delimiter .. '\).\{-}\1/'
                                .. ' contained'
                                .. ' nextgroup=vi9GlobalPat'
    6              0.000149000     .. ' skipwhite'
                            
                            # with a bang
    6              0.000006000 execute 'syntax match vi9Global'
                                .. ' /\<g\%[lobal]\>!\ze\s*\(' .. lang.pattern_delimiter .. '\).\{-}\1/he=e-1'
                                .. ' contained'
                                .. ' nextgroup=vi9GlobalPat'
    6              0.000117000     .. ' skipwhite'
                            
                            # vglobal/pat/cmd
    6              0.000007000 execute 'syntax match vi9Global'
                                .. ' /\<v\%[global]\>\ze\s*\(' .. lang.pattern_delimiter .. '\).\{-}\1/'
                                .. ' contained'
                                .. ' nextgroup=vi9GlobalPat'
    6              0.000111000     .. ' skipwhite'
                            
    6              0.000006000 execute 'syntax region vi9GlobalPat'
                                .. ' matchgroup=vi9SubstDelim'
                                .. ' start=/\z(' .. lang.pattern_delimiter .. '\)/rs=s+1'
                                .. ' skip=/\\\\\|\\\z1/'
                                .. ' end=/\z1/'
                                .. ' contained'
                                .. ' contains=@vi9SubstList'
                                .. ' nextgroup=@vi9CanBeAtStartOfLine'
                                .. ' oneline'
    6              0.000148000     .. ' skipwhite'
                            
                            # :highlight {{{3
                            # TODO: Review all the rules related to `:highlight`.
                            # command {{{4
                            
    6              0.000200000 syntax cluster vi9HiCluster contains=
                                \ vi9HiClear,
                                \ vi9HiDefault,
                                \ vi9HiGroup,
                                \ vi9HiLink
                            
    6              0.000097000 syntax keyword vi9Highlight hi[ghlight]
                                \ contained
                                \ nextgroup=@vi9HiCluster,vi9HiBang
                                \ skipwhite
                            
    6              0.000033000 syntax match vi9HiBang /!/ contained nextgroup=@vi9HiCluster skipwhite
                            
                            # Group name {{{4
                            
    6              0.000370000 syntax match vi9HiGroup /\w\+/
                                \ contained
                                \ nextgroup=
                                \     vi9HiCterm,
                                \     vi9HiCtermFgBg,
                                \     vi9HiGroup,
                                \     vi9HiGui,
                                \     vi9HiGuiFgBg,
                                \     vi9HiStartStop,
                                \     vi9HiTerm
                                \ skipwhite
                            
                            # :highlight clear {{{4
                            
    6              0.000080000 syntax keyword vi9HiClear clear contained nextgroup=vi9HiGroup skipwhite
                            
                            # :highlight default/link {{{4
                            
    6              0.000127000 syntax keyword vi9HiDefault def[ault] contained nextgroup=vi9HiGroup,vi9HiLink skipwhite
    6              0.000077000 syntax keyword vi9HiLink link contained nextgroup=vi9HiGroup skipwhite
                            
                            # :highlight group key=arg ... {{{4
                            
    6              0.000420000 syntax match vi9HiEqual /=/
                                \ contained
                                \ nextgroup=
                                \     vi9HiAttr,
                                \     vi9HiCtermColor,
                                \     vi9HiFgBgAttr,
                                \     vi9HiFontname,
                                \     vi9HiGroup,
                                \     vi9HiGuiFontname,
                                \     vi9HiGuiRgb,
                                \     vi9HiNumber
                            
    6              0.000084000 syntax keyword vi9HiTerm term contained nextgroup=vi9HiEqual
    6              0.000076000 syntax keyword vi9HiCterm cterm contained nextgroup=vi9HiEqual
    6              0.000079000 syntax keyword vi9HiCtermFgBg ctermfg ctermbg
                                \ contained
                                \ nextgroup=vi9HiEqual
    6              0.000075000 syntax keyword vi9HiGui gui contained nextgroup=vi9HiEqual
    6              0.000078000 syntax keyword vi9HiGuiFgBg guibg guifg guisp
                                \ contained
                                \ nextgroup=vi9HiEqual
                            
    6              0.000136000 syntax match vi9HiStartStop /\%(start\|stop\)=/he=e-1
                                \ contained
                                \ nextgroup=vi9HiTermcap,vi9MayBeOptionScoped
                            
    6              0.000080000 syntax match vi9HiGuiFont /font/ contained nextgroup=vi9HiEqual
                            
    6              0.000175000 syntax match vi9HiCtermul /ctermul=/he=e-1
                                \ contained
                                \ nextgroup=
                                \     vi9HiCtermColor,
                                \     vi9HiFgBgAttr,
                                \     vi9HiNumber
                            
    6              0.000099000 syntax match vi9HiTermcap /\S\+/ contained contains=vi9BracketNotation
    6              0.000125000 syntax match vi9HiNumber /\d\+/ contained nextgroup=vi9HiCterm,vi9HiCtermFgBg skipwhite
                            
                            # attributes {{{4
                            
    6              0.000006000 syntax case ignore
    6              0.000249000 syntax keyword vi9HiAttr
                                \ none bold inverse italic nocombine reverse standout strikethrough
                                \ underline undercurl
                                \ contained
                                \ nextgroup=
                                \     vi9HiAttrComma,
                                \     vi9HiCterm,
                                \     vi9HiCtermFgBg,
                                \     vi9HiGui
                                \ skipwhite
    6              0.000077000 syntax match vi9HiAttrComma /,/ contained nextgroup=vi9HiAttr
                            
    6              0.000219000 syntax keyword vi9HiFgBgAttr none bg background fg foreground
                                \ contained
                                \ nextgroup=vi9HiCterm,vi9HiGui,vi9HiGuiFgBg,vi9HiCtermFgBg
                                \ skipwhite
    6              0.000003000 syntax case match
                            
    6              0.000004000 syntax case ignore
    6              0.000175000 syntax keyword vi9HiCtermColor contained
                                \ black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey
                                \ darkmagenta darkred darkyellow gray green grey lightblue lightcyan
                                \ lightgray lightgreen lightgrey lightmagenta lightred magenta red white
                                \ yellow
                                \ nextgroup=vi9HiCterm,vi9HiCtermFgBg
                                \ skipwhite
    6              0.000004000 syntax case match
                            
    6              0.000053000 syntax match vi9HiFontname /[a-zA-Z\-*]\+/ contained
    6              0.000040000 syntax match vi9HiGuiFontname /'[a-zA-Z\-* ]\+'/ contained
    6              0.000127000 syntax match vi9HiGuiRgb /#\x\{6}/ contained nextgroup=vi9HiGuiFgBg,vi9HiGui skipwhite
                            #}}}3
                            # :import / :export {{{3
                            
                            # :import
                            # :export
    6              0.000123000 syntax keyword vi9Import imp[ort] contained nextgroup=vi9ImportedScript,vi9ImportAutoload skipwhite
    6              0.000259000 syntax keyword vi9Export exp[ort] contained nextgroup=vi9Abstract,vi9Class,vi9Declare,vi9Interface,vi9UserType skipwhite
                            
                            #        v------v
                            # import autoload 'path/to/script.vim'
    6              0.000072000 syntax keyword vi9ImportAutoload autoload
                                \ contained
                                \ nextgroup=vi9ImportedScript
                                \ skipwhite
                            
                            #        v------------v
                            # import 'MyScript.vim' ...
    6              0.000084000 syntax match vi9ImportedScript /\(['"]\)\f\+\1/
                                \ contained
                                \ nextgroup=vi9ImportAs
                                \ skipwhite
                            
                            #                       vv
                            # import 'MyScript.vim' as MyAlias
    6              0.000026000 syntax keyword vi9ImportAs as contained
                            
                            # :inoreabbrev {{{3
                            
    6              0.000128000 syntax keyword vi9AbbrevCmd
                                \ ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev]
                                \ contained
                                \ nextgroup=vi9MapLhs,@vi9MapMod
                                \ skipwhite
                            
                            # :mark {{{3
                            
    6              0.000122000 syntax keyword vi9MarkCmd ma[rk]
                                \ contained
                                \ nextgroup=vi9MarkCmdArg,vi9MarkCmdArgInvalid
                                \ skipwhite
                            
    6              0.000035000 syntax match vi9MarkCmdArgInvalid /[^[:blank:]|]\+/ contained
                            # Need to allow `<` for a bracketed keycode inside a mapping (e.g. `<Bar>`).
    6              0.000015000 execute 'syntax match vi9MarkCmdArg /\s\@1<=' .. lang.mark_valid .. '\%([[:blank:]\n<]\)\@=/ contained'
    6              0.000056000 
                            # :nnoremap {{{3
                            
    6              0.000087000 syntax cluster vi9MapMod contains=vi9MapMod,vi9MapModExpr
                            
    6              0.000162000 syntax match vi9Map /\<map\>!\=\ze\s*[^(]/
                                \ contained
                                \ nextgroup=vi9MapLhs,vi9MapMod,vi9MapModExpr
                                \ skipwhite
                            
                            # Do *not* include `vi9MapLhsExpr` in the `nextgroup` argument.{{{
                            #
                            # `vi9MapLhsExpr`  is  only  possible  after  `<expr>`,  which  is  matched  by
                            # `vi9MapModExpr` which is included in `@vi9MapMod`.
                            #}}}
    6              0.000198000 syntax keyword vi9Map
                                \ cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap]
                                \ no[remap] om[ap] ono[remap] smap snor[emap] tno[remap] tm[ap] vm[ap]
                                \ vn[oremap] xm[ap] xn[oremap]
                                \ contained
                                \ nextgroup=vi9MapBang,vi9MapLhs,@vi9MapMod
                                \ skipwhite
                            
    6              0.000065000 syntax keyword vi9Map
                                \ mapc[lear] smapc[lear] cmapc[lear] imapc[lear] lmapc[lear]
                                \ nmapc[lear] omapc[lear] tmapc[lear] vmapc[lear] xmapc[lear]
                                \ contained
                            
    6              0.000152000 syntax keyword vi9Unmap
                                \ cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap]
                                \ tunma[p] unm[ap] unm[ap] vu[nmap] xu[nmap]
                                \ contained
                                \ nextgroup=vi9MapBang,vi9MapLhs,@vi9MapMod
                                \ skipwhite
                            
    6              0.000170000 syntax match vi9MapLhs /\S\+/
                                \ contained
                                \ contains=vi9BracketNotation,vi9CtrlChar
                                \ nextgroup=vi9MapRhs
                                \ skipwhite
                            
    6              0.000169000 syntax match vi9MapLhsExpr /\S\+/
                                \ contained
                                \ contains=vi9BracketNotation,vi9CtrlChar
                                \ nextgroup=vi9MapRhsExpr
                                \ skipwhite
                            
    6              0.000074000 syntax match vi9MapBang /!/ contained nextgroup=vi9MapLhs,@vi9MapMod skipwhite
                            
    6              0.000005000 execute 'syntax match vi9MapMod'
                                .. ' /'
                                .. '\c'
                                .. '\%(<\%('
                                ..         'buffer\|\%(local\)\=leader\|nowait'
                                .. '\|' .. 'plug\|script\|sid\|unique\|silent'
                                .. '\)>\s*\)\+'
                                .. '/'
                                .. ' contained'
                                .. ' contains=vi9MapModErr,vi9MapModKey'
                                .. ' nextgroup=vi9MapLhs'
    6              0.000219000     .. ' skipwhite'
                            
    6              0.000007000 execute 'syntax match vi9MapModExpr'
                                .. ' /'
                                .. '\c'
                                .. '\%(<\%('
                                ..         'buffer\|\%(local\)\=leader\|nowait'
                                .. '\|' .. 'plug\|script\|sid\|unique\|silent'
                                .. '\)>\s*\)*'
                                .. '<expr>\s*'
                                .. '\%(<\%('
                                ..         'buffer\|\%(local\)\=leader\|nowait'
                                .. '\|' .. 'plug\|script\|sid\|unique\|silent'
                                .. '\)>\s*\)*'
                                .. '/'
                                .. ' contained'
                                .. ' contains=vi9MapModErr,vi9MapModKey'
                                .. ' nextgroup=vi9MapLhsExpr'
    6              0.000224000     .. ' skipwhite'
                            
    6              0.000005000 syntax case ignore
    6              0.000067000 syntax keyword vi9MapModKey contained
                                \ buffer expr leader localleader nowait plug script sid silent unique
    6              0.000004000 syntax case match
                            
    6              0.000305000 syntax match vi9MapRhs /.*/
                                \ contained
                                \ contains=
                                \     vi9BracketNotation,
                                \     vi9CtrlChar,
                                \     vi9MapScriptCmd,
                                \     vi9MapCmdlineExpr,
                                \     vi9MapInsertExpr
                                \ nextgroup=vi9MapRhsExtend
                                \ skipnl
                            
    6              0.000171000 syntax match vi9MapRhsExpr /.*/
                                \ contained
                                \ contains=@vi9Expr,vi9BracketNotation,vi9CtrlChar
                                \ nextgroup=vi9MapRhsExtendExpr
                                \ skipnl
                            
                            # `matchgroup=vi9BracketNotation` is necessary to prevent `<CR>` from being consumed by a contained item.{{{
                            #
                            # Example:
                            #
                            #                                      v--v
                            #     nnoremap x <ScriptCmd>normal! abc<CR>
                            #     nnoremap x <ScriptCmd>doautocmd WinEnter<CR>
                            #                                             ^--^
                            #
                            # In the first command, `<CR>` should not be matched normal commands.
                            # In the second one, `<CR>` should not be matched as a file pattern in an autocmd.
                            #}}}
                            # TODO: Are there other regions where we should make sure to prevent a contained
                            # match in its start/end?
                            #
                            # TODO: Try to highlight bracket keys even inside strings:
                            #
                            #     nnoremap <F3> <ScriptCmd>execute 'normal! <C-\><C-N>'<CR>
                            #                                               ^--------^
                            # We don't add `oneline` because it's convenient to break a RHS on multiple lines.{{{
                            #
                            #     nnoremap <key> <ScriptCmd>Foo(
                            #       \ arg1,
                            #       \ arg2,
                            #       \ arg3,
                            #       \ )
                            #}}}
    6              0.000328000 syntax region vi9MapScriptCmd
                                \ start=/\c<ScriptCmd>/
                                \ matchgroup=vi9BracketNotation
                                \ end=/\c<CR>\|<Enter>\|^\s*$/
                                \ contained
                                \ contains=
                                \     @vi9Expr,
                                \     vi9BracketNotation,
                                \     vi9Continuation,
                                \     vi9MapCmdBar,
                                \     vi9OperAssign,
                                \     vi9SpecFile
                                \ keepend
                            
    6              0.000156000 syntax region vi9MapInsertExpr
                                \ start=/\c<C-R>=\@=/
                                \ end=/\c<CR>\|<Enter>/
                                \ contained
                                \ contains=@vi9Expr,vi9BracketNotation,vi9EvalExpr
                                \ keepend
                                \ oneline
    6              0.000037000 syntax match vi9EvalExpr /\%(<C-R>\)\@5<==/ contained
                            
                            # We don't use  `oneline` here, because it  might be convenient to  split a long
                            # expression on multiple lines (with explicit continuation lines).
    6              0.000181000 syntax region vi9MapCmdlineExpr
                                \ matchgroup=vi9BracketNotation
                                \ start=/\c<C-\\>e/
                                \ matchgroup=NONE
                                \ end=/\c<CR>\|<Enter>/
                                \ contained
                                \ contains=@vi9Expr,vi9BracketNotation,vi9Continuation
                                \ keepend
                            
                            # Highlight what comes after `<Bar>` as a command:{{{
                            #
                            #     nnoremap xxx <ScriptCmd>FuncA() <Bar> eval 1 + 2<CR>
                            #                                           ^--^
                            #
                            # But only if it's between `<ScriptCmd>` and `<CR>`.
                            # Anywhere else, we have no guarantee that we're inside an Ex command.
                            # Actually, we  do between `<Cmd>`  and `<CR>`, but  we don't want  to highlight
                            # anything  in there;  it's processed  in the  global context  where the  legacy
                            # syntax must be used; we're only interested in highlighting the Vim9 syntax.
                            #}}}
    6              0.000091000 syntax match vi9MapCmdBar /\c<Bar>/
                                \ contained
                                \ contains=vi9BracketNotation
                                \ nextgroup=@vi9CanBeAtStartOfLine
                                \ skipwhite
                            
    6              0.000170000 syntax match vi9MapRhsExtend /^\s*\\.*$/
                                \ contained
                                \ contains=vi9Continuation,vi9BracketNotation
                                \ nextgroup=vi9MapRhsExtend
                                \ skipnl
    6              0.000086000 syntax match vi9MapRhsExtendExpr /^\s*\\.*$/
                                \ contained
                                \ contains=@vi9Expr,vi9Continuation
                            
                            # :normal {{{3
                            
                            # Warning: Do not turn `:syntax match` into `:syntax keyword`.
                            # It would break the highlighting of a possible following bang.
    6              0.000081000 syntax match vi9Norm /\<norm\%[al]\>/ nextgroup=vi9NormCmds contained skipwhite
    6              0.000079000 syntax match vi9Norm /\<norm\%[al]\>!/he=e-1 nextgroup=vi9NormCmds contained skipwhite
                            
    6              0.000028000 syntax match vi9NormCmds /.*/ contained
                            
                            # :profile {{{3
                            
    6              0.000171000 syntax keyword vi9ProfileCmd prof[ile]
                                \ contained
                                \ nextgroup=
                                \    vi9ProfileCmdBang,
                                \    vi9ProfileSubCmd,
                                \    vi9ProfileSubCmdInvalid
                                \ skipwhite
                            
    6              0.000074000 syntax match vi9ProfileSubCmdInvalid /\S\+/
                                \ contained
                                \ nextgroup=vi9ProfilePat
                                \ skipwhite
    6              0.000112000     syntax match vi9ProfileCmdBang /!/
                                    \ contained
                                    \ nextgroup=vi9ProfileSubCmd,vi9ProfileSubCmdInvalid
                                    \ skipwhite
                            
                            
    6              0.000097000 syntax keyword vi9ProfileSubcmd continue dump file func pause start stop
                                \ contained
                                \ nextgroup=vi9ProfilePat
                                \ skipwhite
                            
                            # It's important to match the pattern because it could be a wildcard.{{{
                            #
                            # And a wildcard could break the syntax of the next token:
                            #
                            #                  v
                            #     profile func *
                            #
                            #     broken if the previous "*" is matched as an arithmetic operator
                            #     vvv
                            #     def Func()
                            #        ...
                            #}}}
    6              0.000043000 syntax match vi9ProfilePat '\S\+' contained
                            
                            # :registers {{{3
                            
                            # We want to match  a register name so that it's  not conflated with something
                            # else (e.g. in `registers "`, `"` is not the start of a string).
    6              0.000081000 syntax keyword vi9RegistersCmd reg[isters] nextgroup=vi9RegisterNames contained skipwhite
    6              0.000081000 syntax keyword vi9RegistersCmd di[splay] nextgroup=vi9RegisterNames contained skipwhite
    6              0.000082000 syntax match vi9RegisterNames /[-"*+.:%#/=0-9a-z]\+/ nextgroup=vi9RegisterNames contained skipwhite
                            
                            # :substitute {{{3
                            
                            # TODO: Why did we include `vi9BracketNotation` here?
                            #
                            # Some  of its  effects are  really  nice in  a substitution  pattern (like  the
                            # highlighting of capturing groups).  But I  don't think all of its effects make
                            # sense here.   Consider replacing  it with  a similar  group whose  effects are
                            # limited to the ones which make sense.
                            #
                            # Also, make sure to include it in  any pattern supplied to a command (`:catch`,
                            # `:global`, `:vimgrep`)...
    6              0.000267000 syntax cluster vi9SubstList contains=
                                \ vi9BracketNotation,
                                \ vi9Collection,
                                \ vi9PatRegion,
                                \ vi9PatSep,
                                \ vi9PatSepErr,
                                \ vi9SubstTwoBS
                            
    6              0.000033000         syntax match vi9NotPatSep /\\\\/ contained
    6              0.000039000         syntax match vi9PatSep /\\|/ contained
    6              0.000030000         syntax match vi9PatSepErr /\\)/ contained
    6              0.000113000         syntax region vi9PatRegion
                                        \ matchgroup=vi9PatSepR
                                        \ start=/\\[z%]\=(/
                                        \ end=/\\)/
                                        \ contained
                                        \ contains=@vi9SubstList
                                        \ oneline
                                        \ transparent
                            
    6              0.000141000 syntax cluster vi9SubstRepList contains=
                                \ vi9BracketNotation,
                                \ vi9SubstSubstr,
                                \ vi9SubstTwoBS
                            
                            # Warning: Do *not* use `display` here.{{{
                            #
                            # It could break some subsequent highlighting.
                            #
                            # MRE:
                            #
                            #     # test script
                            #     def Foo()
                            #         substitute/(")"//
                            #     enddef
                            #     def Bar()
                            #     enddef
                            #
                            #     # command to execute:
                            #     syntax clear vi9Subst
                            #
                            # Notice that everything gets broken after the substitution command.
                            # In practice, that could happen if:
                            #
                            #    - `Foo()` is folded (hence, not displayed)
                            #    - `vi9Subst` is defined with `display`
                            #}}}
    6              0.000009000 execute 'syntax match vi9Subst'
                                .. ' /\<s\%[ubstitute]\>\s*\ze\(' .. lang.pattern_delimiter .. '\).\{-}\1.\{-}\1/'
                                .. ' contained'
    6              0.000115000     .. ' nextgroup=vi9SubstPat'
                            
    6              0.000008000 execute 'syntax region vi9SubstPat'
                                .. ' matchgroup=vi9SubstDelim'
                                .. ' start=/\z(' .. lang.pattern_delimiter .. '\)/rs=s+1'
                                .. ' skip=/\\\\\|\\\z1/'
                                .. ' end=/\z1/re=e-1,me=e-1'
                                .. ' contained'
                                .. ' contains=@vi9SubstList'
                                .. ' nextgroup=vi9SubstRep,vi9SubstRepExpr'
    6              0.000182000     .. ' oneline'
                            
    6              0.000160000 syntax region vi9SubstRep
                                \ matchgroup=vi9SubstDelim
                                \ start=/\z(.\)/
                                \ skip=/\\\\\|\\\z1/
                                \ end=/\z1/
                                \ matchgroup=vi9BracketNotation
                                \ end=/\c<CR>\|<Enter>/
                                \ contained
                                \ contains=@vi9SubstRepList
                                \ nextgroup=vi9SubstFlagErr
                                \ oneline
                            
    6              0.000192000 syntax region vi9SubstRepExpr
                                \ matchgroup=vi9SubstDelim
                                \ start=/\z(.\)\%(\\=\)\@=/
                                \ skip=/\\\\\|\\\z1/
                                \ end=/\z1/
                                \ matchgroup=vi9BracketNotation
                                \ end=/\c<CR>\|<Enter>/
                                \ contained
                                \ contains=@vi9Expr,vi9EvalExpr
                                \ nextgroup=vi9SubstFlagErr
                                \ oneline
    6              0.000029000 syntax match vi9EvalExpr /\\=/ contained
                            
    6              0.000089000 syntax region vi9Collection
                                \ start=/\\\@1<!\[/
                                \ skip=/\\\[/
                                \ end=/\]/
                                \ contained
                                \ contains=vi9CollationClass
                                \ transparent
                            
    6              0.000034000 syntax match vi9CollationClassErr /\[:.\{-\}:\]/ contained
                            
    6              0.000006000 execute 'syntax match vi9CollationClass'
                                .. ' /\[:'
                                .. '\%(' .. lang.collation_class .. '\)'
                                .. ':\]/'
                                .. ' contained'
    6              0.000079000     .. ' transparent'
                            
    6              0.000030000 syntax match vi9SubstSubstr /\\z\=\d/ contained
    6              0.000028000 syntax match vi9SubstTwoBS /\\\\/ contained
    6              0.000079000 syntax match vi9SubstFlagErr /[^<[:blank:]\r|]\+/ contained contains=vi9SubstFlags
    6              0.000037000 syntax match vi9SubstFlags /[&cegiIlnpr#]\+/ contained
                            
                            # :syntax {{{3
                            # :syntax {{{4
                            
                            # Warning: Do not turn `:syntax match` into `:syntax keyword`.
    6              0.000129000 syntax match vi9Syntax /\<sy\%[ntax]\>/
                                \ contained
                                \ contains=vi9GenericCmd
                                \ nextgroup=vi9SynType
                                \ skipwhite
                            
                            # Must exclude the bar for this to work:{{{
                            #
                            #     syntax clear | eval 0
                            #                  ^
                            #                  not part of a group name
                            #}}}
    6              0.000116000 syntax match vi9GroupList /@\=[^[:blank:],|']\+/
                                \ contained
                                \ contains=vi9GroupSpecial,vi9PatSep
                            
    6              0.000148000 syntax match vi9GroupList /@\=[^[:blank:],|']*,/
                                \ contained
                                \ contains=vi9GroupSpecial,vi9PatSep
                                \ nextgroup=vi9GroupList
                            
                            # Warning: Do not turn `:syntax match` into `:syntax keyword`.
                            # It would fail to match `CONTAINED`.
    6              0.000046000 syntax match vi9GroupSpecial /\<\%(ALL\|ALLBUT\|CONTAINED\|TOP\)\>/ contained
    6              0.000029000 syntax match vi9SynError /\i\+/ contained
    6              0.000064000 syntax match vi9SynError /\i\+=/ contained nextgroup=vi9GroupList
                            
    6              0.000071000 syntax match vi9SynContains /\<contain\%(s\|edin\)/ contained nextgroup=vi9SynEqual
    6              0.000064000 syntax match vi9SynEqual /=/ contained nextgroup=vi9GroupList
                            
    6              0.000067000 syntax match vi9SynKeyContainedin /\<containedin/ contained nextgroup=vi9SynEqual
    6              0.000072000 syntax match vi9SynNextgroup /nextgroup/ contained nextgroup=vi9SynEqual
                            
                            # :syntax case {{{4
                            
    6              0.000108000 syntax keyword vi9SynType contained
                                \ case skipwhite
                                \ nextgroup=vi9SynCase,vi9SynCaseError
                            
    6              0.000026000 syntax match vi9SynCaseError /\i\+/ contained
    6              0.000026000 syntax keyword vi9SynCase ignore match contained
                            
                            # :syntax clear {{{4
                            
                            # `vi9HiGroup` needs  to be in the  `nextgroup` argument, so that  `{group}` is
                            # highlighted in `syntax clear {group}`.
    6              0.000110000 syntax keyword vi9SynType clear
                                \ contained
                                \ nextgroup=vi9GroupList,vi9HiGroup
                                \ skipwhite
                            
                            # :syntax cluster {{{4
                            
    6              0.000067000 syntax keyword vi9SynType cluster contained nextgroup=vi9ClusterName skipwhite
                            
    6              0.000244000 syntax region vi9ClusterName
                                \ matchgroup=vi9GroupName
                                \ start=/\h\w*/
                                \ skip=/\\\\\|\\|/
                                \ matchgroup=vi9Sep
                                \ end=/$\||/
                                \ contained
                                \ contains=vi9GroupAdd,vi9GroupRem,vi9SynContains,vi9SynError
                            
    6              0.000068000 syntax match vi9GroupAdd /add=/ contained nextgroup=vi9GroupList
    6              0.000064000 syntax match vi9GroupRem /remove=/ contained nextgroup=vi9GroupList
                            
                            # :syntax iskeyword {{{4
                            
    6              0.000064000 syntax keyword vi9SynType iskeyword contained nextgroup=vi9IskList skipwhite
    6              0.000065000 syntax match vi9IskList /\S\+/ contained contains=vi9IskSep
    6              0.000026000 syntax match vi9IskSep /,/ contained
                            
                            # :syntax include {{{4
                            
    6              0.000068000 syntax keyword vi9SynType include contained nextgroup=vi9GroupList skipwhite
                            
                            # :syntax keyword {{{4
                            
    6              0.000125000 syntax cluster vi9SynKeyGroup contains=
                                \ vi9SynKeyContainedin,
                                \ vi9SynKeyOpt,
                                \ vi9SynNextgroup
                            
    6              0.000062000 syntax keyword vi9SynType keyword contained nextgroup=vi9SynKeyRegion skipwhite
                            
    6              0.000101000 syntax region vi9SynKeyRegion
                                \ matchgroup=vi9GroupName
                                \ start=/\h\w*/
                                \ skip=/\\\\\|\\|/
                                \ matchgroup=vi9Sep
                                \ end=/|\|$/
                                \ contained
                                \ contains=@vi9SynKeyGroup
                                \ keepend
                                \ oneline
                            
    6              0.000050000 syntax match vi9SynKeyOpt
                                \ /\<\%(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>/
                                \ contained
                            
                            # :syntax match {{{4
                            
    6              0.000292000 syntax cluster vi9SynMatchGroup contains=
                                \ vi9BracketNotation,
                                \ vi9MatchComment,
                                \ vi9SynContains,
                                \ vi9SynError,
                                \ vi9SynMatchOpt,
                                \ vi9SynNextgroup,
                                \ vi9SynRegPat
                            
    6              0.000064000 syntax keyword vi9SynType match contained nextgroup=vi9SynMatchRegion skipwhite
                            
                            # We need to avoid  consuming the bar in the end  pattern; otherwise, the latter
                            # would  be matched  with `vi9GroupName`,  which would  break the  syntax of  a
                            # possible subsequent command.
    6              0.000065000 syntax region vi9SynMatchRegion
                                \ matchgroup=vi9GroupName
                                \ start=/\h\w*/
                                \ end=/|\@=\|$/
                                \ contained
                                \ contains=@vi9SynMatchGroup
                                \ keepend
                            
    6              0.000007000 execute 'syntax match vi9SynMatchOpt'
                                .. ' /'
                                .. '\<\%('
                                ..         'conceal\|transparent\|contained\|excludenl\|keepend\|skipempty'
                                .. '\|' .. 'skipwhite\|display\|extend\|skipnl\|fold'
                                .. '\)\>'
                                .. '/'
    6              0.000068000     .. ' contained'
                            
    6              0.000068000 syntax match vi9SynMatchOpt /\<cchar=/ contained nextgroup=vi9SynMatchCchar
    6              0.000027000 syntax match vi9SynMatchCchar /\S/ contained
                            
                            # :syntax [on|off] {{{4
                            
    6              0.000030000 syntax keyword vi9SynType enable list manual off on reset contained
                            
                            # :syntax region {{{4
                            
    6              0.000335000 syntax cluster vi9SynRegPatGroup contains=
                                \ vi9BracketNotation,
                                \ vi9NotPatSep,
                                \ vi9PatRegion,
                                \ vi9PatSep,
                                \ vi9PatSepErr,
                                \ vi9SubstSubstr,
                                \ vi9SynNotPatRange,
                                \ vi9SynPatRange
                            
    6              0.000220000 syntax cluster vi9SynRegGroup contains=
                                \ vi9SynContains,
                                \ vi9SynMatchgroup,
                                \ vi9SynNextgroup,
                                \ vi9SynRegOpt,
                                \ vi9SynRegStartSkipEnd
                            
    6              0.000073000 syntax keyword vi9SynType region contained nextgroup=vi9SynRegion skipwhite
                            
    6              0.000066000 syntax region vi9SynRegion
                                \ matchgroup=vi9GroupName
                                \ start=/\h\w*/
                                \ skip=/\\\\\|\\|/
                                \ end=/|\|$/
                                \ contained
                                \ contains=@vi9SynRegGroup
                                \ keepend
                            
    6              0.000023000 execute 'syntax match vi9SynRegOpt'
                                .. ' /'
                                .. '\<\%('
                                ..         'conceal\%(ends\)\=\|transparent\|contained\|excludenl'
                                .. '\|' .. 'skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl'
                                .. '\|' .. 'fold'
                                .. '\)\>\_s\@='
                                .. '/'
    6              0.000078000     .. ' contained'
                            
    6              0.000076000 syntax match vi9SynRegStartSkipEnd /\%(start\|skip\|end\)=\@=/
                                \ contained
                                \ nextgroup=vi9SynEqualRegion
    6              0.000064000 syntax match vi9SynEqualRegion /=/ contained nextgroup=vi9SynRegPat
                            
    6              0.000070000 syntax match vi9SynMatchgroup /matchgroup/ contained nextgroup=vi9SynEqualMatchGroup
    6              0.000111000 syntax match vi9SynEqualMatchGroup /=/ contained nextgroup=vi9Group,vi9HLGroup
                            
    6              0.000341000 syntax region vi9SynRegPat
                                \ start=/\z([-`~!@#$%^&*_=+;:'",./?|]\)/
                                \ skip=/\\\\\|\\\z1/
                                \ end=/\z1/
                                \ contained
                                \ contains=@vi9SynRegPatGroup
                                \ extend
                                \ nextgroup=vi9SynPatMod,vi9SynRegStartSkipEnd
                                \ skipwhite
                            
                                # Handles inline comment after a `:help :syn-match` rule.
                                # Order: must come after `vi9SynRegPat`.
    6              0.000035000     syntax match vi9MatchComment contained '#[^#]\+$'
                            
    6              0.000050000 syntax match vi9SynPatMod
                                \ /\%(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\%([-+]\d\+\)\=/
                                \ contained
                            
    6              0.000086000 syntax match vi9SynPatMod
                                \ /\%(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\%([-+]\d\+\)\=,/
                                \ contained
                                \ nextgroup=vi9SynPatMod
                            
    6              0.000041000 syntax region vi9SynPatRange start=/\[/ skip=/\\\\\|\\]/ end=/]/ contained
    6              0.000064000 syntax match vi9SynNotPatRange /\\\\\|\\\[/ contained
                            
                            # :syntax sync {{{4
                            
    6              0.000359000 syntax keyword vi9SynType sync
                                \ contained
                                \ nextgroup=
                                \     vi9SyncC,
                                \     vi9SyncError,
                                \     vi9SyncLinebreak,
                                \     vi9SyncLinecont,
                                \     vi9SyncLines,
                                \     vi9SyncMatch,
                                \     vi9SyncRegion
                                \ skipwhite
                            
    6              0.000048000 syntax match vi9SyncError /\i\+/ contained
    6              0.000038000 syntax keyword vi9SyncC ccomment clear fromstart contained
    6              0.000072000 syntax keyword vi9SyncMatch match contained nextgroup=vi9SyncGroupName skipwhite
    6              0.000072000 syntax keyword vi9SyncRegion region contained nextgroup=vi9SynRegStartSkipEnd skipwhite
                            
    6              0.000101000 syntax match vi9SyncLinebreak /\<linebreaks=/
                                \ contained
                                \ nextgroup=vi9Number
                                \ skipwhite
                            
    6              0.000101000 syntax keyword vi9SyncLinecont linecont contained nextgroup=vi9SynRegPat skipwhite
    6              0.000102000 syntax match vi9SyncLines /\%(min\|max\)\=lines=/ contained nextgroup=vi9Number
    6              0.000076000 syntax match vi9SyncGroupName /\h\w*/ contained nextgroup=vi9SyncKey skipwhite
                            
                            # Warning: Do not turn `:syntax match` into `:syntax keyword`.
    6              0.000099000 syntax match vi9SyncKey /\<\%(groupthere\|grouphere\)\>/
                                \ contained
                                \ nextgroup=vi9SyncGroup
                                \ skipwhite
                            
    6              0.000143000 syntax match vi9SyncGroup /\h\w*/
                                \ contained
                                \ nextgroup=vi9SynRegPat,vi9SyncNone
                                \ skipwhite
                            
    6              0.000028000 syntax keyword vi9SyncNone NONE contained
                            #}}}3
                            # :vimgrep {{{3
                            
                            # without a bang
    6              0.000011000 execute 'syntax match vi9VimGrep'
                                .. ' /\<l\=vim\%[grep]\%(add\)\=\ze\s*\(' .. lang.pattern_delimiter .. '\).\{-}\1/'
                                .. ' nextgroup=vi9VimGrepPat'
                                .. ' contained'
    6              0.000139000     .. ' skipwhite'
                            
                            # with a bang
    6              0.000008000 execute 'syntax match vi9VimGrep'
                                .. ' /\<l\=vim\%[grep]\%(add\)\=!\ze\s*\(' .. lang.pattern_delimiter .. '\).\{-}\1/he=e-1'
                                .. ' nextgroup=vi9VimGrepPat'
                                .. ' contained'
    6              0.000120000     .. ' skipwhite'
                            
    6              0.000007000 execute 'syntax region vi9VimGrepPat'
                                .. ' matchgroup=vi9SubstDelim'
                                .. ' start=/\z(' .. lang.pattern_delimiter .. '\)/rs=s+1'
                                .. ' skip=/\\\\\|\\\z1/'
                                .. ' end=/\z1/'
                                .. ' contained'
                                .. ' contains=@vi9SubstList'
    6              0.000151000     .. ' oneline'
                            
                            # :wincmd {{{3
                            
    6              0.000125000 syntax keyword vi9Wincmd winc[md]
                                \ contained
                                \ nextgroup=vi9WincmdArg,vi9WincmdArgInvalid
                                \ skipwhite
                            
    6              0.000038000 syntax match vi9WincmdArgInvalid /\S\+/ contained
    6              0.000016000 execute 'syntax match vi9WincmdArg ' .. lang.wincmd_valid .. ' contained'
    6              0.000087000 
                            # :! {{{3
                            
                            # We need to match a filter command to avoid breaking the highlighting of the next line.{{{
                            #
                            # Indeed, a  shell command might  end with `-`  (stdin), which our  plugin could
                            # conflate with an arithmetic operator; this could break the highlighting of the
                            # first keyword on the next line (e.g. `:enddef`).
                            #}}}
                            # We do not support `:!` without a colon.{{{
                            #
                            # First, it would be too tricky to distinguish it from the logical NOT operator.
                            #
                            # Second, it's easy to add a colon to clearly lift the ambiguity.
                            #
                            # Third, `:terminal`  is a better  command; it's  more readable, and  provides a
                            # regular buffer in which you can leverage all of your usual commands.
                            #
                            # ---
                            #
                            # Note that we do support `!`, if it's after a command modifier like `:silent`.
                            #}}}
    6              0.000180000 syntax match vi9BangCmd /!/ contained nextgroup=vi9BangShellCmd
    6              0.000069000 syntax match vi9BangShellCmd /.*/ contained contains=vi9BangLastShellCmd
                            # TODO: Support special filenames like `%:p`, `%%`, ...
                            
                            # Inside a bang command, an unescaped `!` has a special meaning:{{{
                            #
                            # From `:help :!`:
                            #
                            #    > Any '!' in {cmd} is replaced with the previous
                            #    > external command (see also 'cpoptions').  But not when
                            #    > there is a backslash before the '!', then that
                            #    > backslash is removed.
                            #}}}
    6              0.000042000 syntax match vi9BangLastShellCmd /\\\@1<!!/ contained display
                            #}}}1
                            # Continuation {{{1
                            
                            # We don't include `vi9Continuation` in `@vi9CanBeAtStartOfLine`.
                            #
                            # It would  somehow create an  order requirement between  `vi9Continuation` and
                            # `vi9ContinuationBeforeCmd`.  The former would have to be installed before the
                            # latter.
    6              0.000456000 syntax match vi9Continuation /^\s*\\/
                                \ nextgroup=
                                \     @vi9OOP,
                                \     vi9SynContains,
                                \     vi9SynContinuePattern,
                                \     vi9SynMatchgroup,
                                \     vi9SynNextgroup,
                                \     vi9SynRegOpt,
                                \     vi9SynRegStartSkipEnd
                                \ skipwhite
                                # TODO: Should we use a cluster? (`@vi9SynMatchGroup`?)
                                # TODO: `nextgroup` should be limited to a continuation after a `:syntax` command.
                                # IOW, we need an extra rule.
                            
                            # When we break a too-long command on multiple lines, we want to be able to preserve the highlighting.{{{
                            #
                            # We can do so by allowing a command  to start after a backslash at the start of
                            # a line, but only  in some positions where it's convenient  to break a too-long
                            # command.
                            #
                            #     command -bar -nargs=? -range=% -complete=custom,SomeFunc
                            #         \ SomeCmd AnotherFunc(<line1>, <line2>, <q-args>)
                            #         ^
                            #         the next rule can be used to match this continuation line
                            #}}}
    6              0.000122000 syntax match vi9ContinuationBeforeCmd /\\/
                                \ contained
                                \ nextgroup=@vi9CanBeAtStartOfLine,vi9Line12MissingColon
                                \ skipwhite
                            
                            # Special Case:  we also  want to  be able  to break  a user  command definition
                            # *before* its name (not just after, which the previous rule handles).
    6              0.000086000 syntax match vi9ContinuationBeforeUserCmd /\\/
                                \ contained
                                \ nextgroup=vi9UserCmdLhs
                                \ skipwhite
                            
                            # Functions {{{1
                            # User Definition {{{2
                            # Vim9 {{{3
                            
    6              0.000007000 execute 'syntax match vi9FuncHeader'
                                .. ' /'
                                .. '\<def!\=\s\+'
                                .. '\%('
                                # Global or script-local function.
                                # The possible underscore is for private methods:{{{
                                #
                                #    > If you want object methods to be accessible only from other methods of the
                                #    > same class and not used from outside the class, then you can make them
                                #    > private.  This is done by prefixing the method name with an underscore:
                                #
                                # Source: `:help E1366`
                                #}}}
                                .. '\%(g:\)\=_\=\u\w*'
                                # *invalid* autoload function name{{{
                                #
                                # In  a Vim9  autoload script,  when  declaring an  autoload function,  we
                                # cannot write `path#to#script#Func()`; `:export` must be used instead:
                                #
                                #     ✘
                                #     def path#to#script#Func()
                                #
                                #     ✔
                                #     export def Func()
                                #
                                # Let's highlight the old way as an error.
                                #
                                # ---
                                #
                                # Note that  we use  the `*` quantifier  at the end,  and not  `+`. That's
                                # because in  legacy, it is  allowed for an  autoload function name  to be
                                # empty:
                                #
                                #     def path#to#script#()
                                #                       ^
                                #
                                # We want to catch the error no matter what.
                                #}}}
                                .. '\|' .. lang.legacy_autoload_invalid
                                # `:help object`
                                # `:help vim9class /Multiple constructors`
                                .. '\|' .. 'new\w*'
                                # `:help E1412`
                                .. '\|' .. '\%(empty\|len\|string\)'
                                .. '\)'
                                .. '\ze\s*[(<]'
                                .. '/'
                                .. ' contains=vi9DefKey,vi9LegacyAutoloadInvalid'
    6              0.000264000     .. ' nextgroup=vi9FuncSignature,vi9GenericFunction,vi9SpaceAfterFuncHeader'
    6              0.000103000     syntax match vi9SpaceAfterFuncHeader /\s\+\ze[(<]/ contained nextgroup=vi9FuncSignature,vi9GenericFunction
                            
    6              0.000106000 syntax keyword vi9DefKey def fu[nction]
                                \ contained
                                \ nextgroup=vi9DefBangError,vi9DefBang
                            # :def! is valid
    6              0.000028000 syntax match vi9DefBang /!/ contained
                            # but only for global functions
    6              0.000030000 syntax match vi9DefBangError /!\%(\s\+g:\)\@!/ contained
                            
    6              0.000007000 execute 'syntax match vi9LegacyAutoloadInvalid'
                                .. ' /'
                                # When `:function` is prefixed by `:legacy`, `path#to#script#func` is valid.
                                #
                                #     v----v          v-----------------v
                                #     legacy function path#to#script#func()
                                #     endfunction
                                #
                                # We should not  highlight the function name as an  error then; hence this
                                # negative lookbehind.
                                .. '\%(\<leg\%[acy]\s\+fu\%[nction]\s\+\)\@16<!'
                                .. '\<' .. lang.legacy_autoload_invalid
                                .. '/'
    6              0.000105000     .. ' contained'
                            
                            # Ending the  signature at `enddef`  prevents a temporary unbalanced  paren from
                            # causing havoc beyond the end of the function.
    6              0.000271000 syntax region vi9FuncSignature
                                \ matchgroup=vi9ParenSep
                                \ start=/(/
                                \ end=/)/
                                \ matchgroup=NONE
                                \ end=/^\s*enddef\ze\s*\%(#.*\)\=$/
                                \ contained
                                \ contains=
                                \     @vi9DataTypeCluster,
                                \     @vi9ErrorSpaceArgs,
                                \     @vi9Expr,
                                \     vi9Comment,
                                \     vi9FuncArgs,
                                \     vi9OperAssign
                                \ skipwhite
                                \ nextgroup=vi9DataType
                            
    6              0.000087000     syntax match vi9LegacyFuncArgs /\%(:\s*\)\=\%(abort\|closure\|dict<\@!\|range\)/
                                    \ contained
                                    \ nextgroup=vi9LegacyFuncArgs
                                    \ skipwhite
                            
    6              0.000009000 execute 'syntax match vi9FuncArgs'
                                .. ' /'
                                # named argument followed by a type or an optional value
                                ..     '\.\@1<!\<\h[a-zA-Z0-9_]*\%(:\s\|\s\+=\s\)\@='
                                .. '\|'
                                # variable arguments
                                .. '\.\.\.\h[a-zA-Z0-9_]*\%(:\s\+list<\)\@='
                                .. '\|'
                                # ignored argument
                                ..     '\<_\%(,\|)\|$\)\@='
                                .. '\|'
                                # ignored variable arguments
                                ..     '\.\.\._\%()\|$\)\@='
                                .. '/'
    6              0.000088000     .. ' contained'
                            
    6              0.000044000 syntax match vi9FuncEnd /^\s*enddef\ze\s*\%(#.*\)\=$/
                            
    6              0.000131000 syntax region vi9GenericFunction
                                \ matchgroup=vi9ParenSep
                                \ start=/</
                                \ end=/>/
                                \ contained
                                \ contains=@vi9ErrorSpaceArgs,vi9GenericTypes
                                \ nextgroup=vi9FuncSignature
                                \ skipwhite
                            
    6              0.000026000 syntax match vi9GenericTypes /\u\w*/ contained
                            
                            # Legacy {{{3
                            
    6              0.000007000 execute 'syntax match vi9LegacyFunction'
                                .. ' /'
                                .. '\<fu\%[nction]!\='
                                .. '\s\+\%([gs]:\)\='
                                .. '\%(' .. '\u\%(\w\|[.]\)*' .. '\|' .. lang.legacy_autoload_invalid .. '\)'
                                .. '\ze\s*('
                                .. '/'
                                .. ' contains=vi9DefKey,vi9LegacyAutoloadInvalid'
    6              0.000211000     .. ' nextgroup=vi9LegacyFuncBody,vi9SpaceAfterLegacyFuncHeader'
    6              0.000064000     syntax match vi9SpaceAfterLegacyFuncHeader /\s\+\ze(/ contained nextgroup=vi9LegacyFuncBody
                            
    6              0.000347000 syntax cluster vi9LegacyCluster contains=
                                \ vi9LegacyComment,
                                \ vi9LegacyConcatInvalid,
                                \ vi9LegacyConcatValid,
                                \ vi9LegacyDictMember,
                                \ vi9LegacyFloat,
                                #\ to support the case of a nested legacy function
                                \ vi9LegacyFunction,
                                \ vi9LegacyString,
                                \ vi9LegacyVarArgsHeader
                            
                            # There might be a trailing comment after `:endfunction`.{{{
                            #
                            # Typically, it might be fold markers:
                            #
                            #     function Func()
                            #         some code
                            #     endfunction " } } }
                            #                 ^-----^
                            #
                            # We don't want those to be highlighted as errors (because they're unbalanced).
                            #}}}
    6              0.000113000 syntax region vi9LegacyFuncBody
                                \ start=/(/
                                \ matchgroup=vi9DefKey
                                \ end=/^\s*\<endf\%[unction]\ze\s*\%(".*\)\=$/
                                \ contained
                                \ contains=@vi9LegacyCluster
                                \ nextgroup=vi9LegacyComment
                                \ skipwhite
                            
                            # We've borrowed these regexes from the legacy plugin.
    6              0.000030000 syntax match vi9LegacyComment /^\s*".*$/ contained
                            # We also need to support inline comments.{{{
                            #
                            # If only  for a trailing comment  after `:endfunction`, so we  can't anchor the
                            # comment to the start of the line.
                            #}}}
    6              0.000037000 syntax match vi9LegacyComment /\s\@1<="[^\-:.%#=*].*$/ contained
                            
                            # We need to match strings because they can contain arbitrary text, which can break other rules.
    6              0.000038000 syntax region vi9LegacyString start=/"/ skip=/\\\\\|\\"/ end=/"/ oneline keepend
    6              0.000034000 syntax region vi9LegacyString start=/'/ skip=/''/ end=/'/ oneline keepend
                            
                            # In a Vim9 script, `.` cannot be used for a concatenation (nor `.=`).  Only `..` is valid.
                            # *Even* in a legacy function.{{{
                            #
                            # From `:help Vim9-script`:
                            #
                            #    > When using `:function` in a Vim9 script file the legacy syntax is used, with
                            #    > the highest |scriptversion|.
                            #
                            # From `:help scriptversion-2`:
                            #
                            #    > String concatenation with "." is not supported, use ".." instead.
                            #}}}
                            # The positive lookahead is necessary to avoid a spurious match when dot is used in a non-quoted regex.{{{
                            #
                            #     syn match Rule /aaa .* bbb/
                            #                         ^
                            #                         this is NOT a concatenation operator;
                            #                         this is a regex atom
                            #}}}
                            # TODO: Highlight these errors everywhere; not just in legacy functions.
    6              0.000044000 syntax match vi9LegacyConcatInvalid /\.\%(\s\|\w\|['"=]\)\@=/ contained
                                # A dot in the `..` concatenation operator is valid.
    6              0.000027000     syntax match vi9LegacyConcatValid /\.\./ contained
                                # A dot to access a dictionary member is valid.{{{
                                #
                                # Note that this regex is too broad, but we can't make it better.
                                # For example:
                                #
                                #     d.key
                                #     d['a'].key
                                #     {a: 0}.key
                                #     Func().key
                                #
                                # This is correct only if what precedes `.key` evaluates to a dictionary.
                                # Unfortunately, we can't know that with a  simple regex; so we accept it no
                                # matter what it is.
                                #}}}
    6              0.000037000     syntax match vi9LegacyDictMember /\%(\h\w*\|[)})\]]\)\zs\.\ze\h\w*/ contained
                                # A dot in `...` at the end of a legacy function's header is valid.{{{
                                #
                                # Same thing in a legacy lambda:
                                #
                                #     :legacy call timer_start(0, {... -> 0})
                                #                                  ^^^
                                #}}}
    6              0.000035000     syntax match vi9LegacyVarArgsHeader /\.\.\.\%(\s*\%()\|->\)\)\@=/ contained
                                # A dot in a float is valid.
    6              0.000027000     syntax match vi9LegacyFloat /\d\+\.\d\+/ contained
                            #}}}2
                            # User Call {{{2
                            
    6              0.000074000 syntax cluster vi9FuncCall contains=vi9FuncCallBuiltin,vi9FuncCallUser
                            
                            # call to user-defined function
    6              0.000006000 execute 'syntax match vi9FuncCallUser'
                                .. ' /\<'
                                .. '\%('
                                # function with global scope
                                ..     'g:\u\w*'
                                .. '\|'
                                # function with implicit scope: its name must start with an uppercase
                                ..     '\u\w*'
                                .. '\|'
                                # autoload function
                                # (even in a Vim9 script, we might need to call an autoload function with its legacy name)
                                ..     '\w\+#\w\%(\w\|#\)*'
                                .. '\|'
                                # dict function: its name must contain a `.`
                                # Why do you disallow `:`?{{{
                                #
                                # We don't want to highlight `dict` here:
                                #
                                #     b:dict.func()
                                #       ^--^
                                #
                                # If we did, to be consistent we would need to do the same here:
                                #
                                #     b:dict[expr].func()
                                #       ^--^
                                #
                                # But what about `[expr]`?
                                # If we leave it alone, the middle of our function would not be highlighted.
                                # So, we would need to highlight it as well.
                                # But that would be:
                                #
                                #    - weird if `expr` is a string (e.g. `'key'`)
                                #    - impossible to match since `expr` could be an arbitrarily complex expression
                                #
                                # In any case, the function is really `func()`, not whatever comes before.
                                #}}}
                                ..     ':\@1<!\w\+\.\%(\w\|\.\)\+'
                                .. '\|'
                                ..     'new\w*'
                                .. '\)'
                                # Do *not* allow whitespace between the function name and the open paren.{{{
                                #
                                #     .. '\ze\s*('
                                #            ^^^
                                #
                                # First, it's not allowed in Vim9 script.
                                # Second, it could cause a wrong highlighting:
                                #
                                #     eval (1 + 2)
                                #     ^--^
                                #     this should not be highlighted as a function, but as a command
                                #}}}
                                .. '[(<]\@='
                                .. '\|'
                                # Special Case:{{{
                                #
                                #     Foo().bar()
                                #           ^^^
                                #
                                #     b:dict.func()
                                #            ^--^
                                #
                                # A function might  be saved in a  dictionary which is assigned  to a public
                                # variable (e.g. `b:dict`), or given as the output of an arbitrarily complex
                                # expression (e.g. `Foo()`).
                                # The previous regex matching dict functions can't handle this, in part
                                # because of the `\<` assertion.
                                #}}}
                                ..     '\.\w\+(\@='
                                .. '/ display'
    6              0.000114000     .. ' nextgroup=vi9GenericFunctionCall'
                            
    6              0.000166000 syntax region vi9GenericFunctionCall
                                \ matchgroup=vi9ParenSep
                                \ start=/</
                                \ end=/>/
                                \ contained
                                \ contains=@vi9ErrorSpaceArgs,vi9DataTypeListDict,vi9GenericFunctionCallDataType,vi9GenericTypes
                                \ skipwhite
                            
    6              0.000050000 syntax match vi9GenericFunctionCallDataType
                                \ /\<\%(any\|blob\|bool\|channel\|float\|func\|job\|number\|string\)\>/
                                \ contained
                            
                            # Builtin Call {{{2
                            
                            # Don't try to merge `vi9FuncCallBuiltin` with `vi9FuncCallUser`.{{{
                            #
                            # It would be tricky to handle this case:
                            #
                            #     repeat.func()
                            #
                            # Where `repeat` comes from an imported `repeat.vim` script.
                            # `repeat` would probably be wrongly highlighted as a builtin function.
                            #}}}
    6              0.000073000 syntax match vi9FuncCallBuiltin /[:.]\@1<!\%(new\)\@!\<\l\w*(\@=/ contains=vi9FuncNameBuiltin display
                            #                                         ^---------^
                            #                                         :help vim9class /new(
                            
                            # Install a `:syntax keyword` rule to highlight *most* function names.{{{
                            #
                            # Except  the ones  which  are too  ambiguous,  and match  an  Ex command  (e.g.
                            # `eval()`, `execute()`, `function()`, ...).
                            #
                            # Rationale: We don't want to wrongly highlight `:eval` as a function.
                            # To remove any ambiguity, we need to assert the presence of an open paren after
                            # the function name.  That's only possible with a separate `:syntax match` rule.
                            #
                            # NOTE: We  don't  want to  assert  the  paren  for  *all* function  names;  the
                            # necessary regex would be too costly.
                            #}}}
    6              0.000009000 execute 'syntax keyword vi9FuncNameBuiltin'
                                .. ' ' .. lang.builtin_func
    6              0.000758000     .. ' contained'
                            
    6              0.000008000 execute 'syntax match vi9FuncNameBuiltin'
                                .. ' /\<\%(' .. lang.builtin_func_ambiguous .. '\)(\@=/'
    6              0.000091000     .. ' contained'
                            
                            # Lambda {{{2
                            
                            # This is necessary  to avoid the closing angle bracket  being highlighted as an
                            # error (with `vi9OperError`).
    6              0.000035000 syntax match vi9LambdaName /<lambda>\d\+/
                            #}}}1
                            # Operators {{{1
                            
                            # Warning: Don't include `vi9DictMayBeLiteralKey`.{{{
                            #
                            # It could break the highlighting of a dictionary containing a lambda:
                            #
                            #     eval {
                            #         key: (_, v): number => 0
                            #                  ^^
                            #                  ✘
                            #     }
                            #     ^
                            #     ✘
                            #}}}
                            # Don't include `vi9FuncArgs` either for similar reasons.
    6              0.000321000 syntax cluster vi9OperGroup contains=
                                \ @vi9Expr,
                                \ vi9BracketNotation,
                                \ vi9Comment,
                                \ vi9Continuation,
                                \ vi9Oper,
                                \ vi9OperAssign,
                                \ vi9OperParen,
                                \ vi9UserCmdRhsEscapeSeq
                            
                            # `nextgroup` is necessary to prevent a dictionary from being matched as a block.{{{
                            #
                            #     var n = 12 +
                            #         {
                            #             key: 34,
                            #         }
                            #         .key
                            #
                            # ---
                            #
                            # We could also write this:
                            #
                            #     nextgroup=vi9Dict
                            #
                            # But it would create an inconsistent highlighting:
                            #
                            #     # no indentation
                            #     var name =
                            #     yank
                            #     ^--^
                            #     not matched by anything
                            #     (because it could be a variable name used in the RHS of an assignment)
                            #
                            #     # the lines are indented
                            #         var name =
                            #         yank
                            #         ^--^
                            #         matched as an Ex command
                            #
                            # By  using `vi9SOLExpr`,  we prevent  the `yank`  token to  be matched  in the
                            # second case, which is more consistent.
                            #
                            # Also, it feeds more meaningful information to the syntax plugin.
                            # We're telling  the latter that the  next line is  not like the other  ones; it
                            # expects  an expression  at it  start; thus,  many constructs  are not  allowed
                            # there.
                            #}}}
                            # Don't write `display` here.{{{
                            #
                            # From `:help :syn-display`, this requirement must be satisfied:
                            #
                            #    - The item does not allow other items to match that didn't match otherwise
                            #
                            # Here, it's not satisfied, because of `vi9SOLExpr`.
                            #
                            # ---
                            #
                            # In practice, it would sometimes cause spurious highlights.
                            #
                            # MRE:
                            #
                            #     # test script
                            #     (x ==# 0)
                            #     def Func()
                            #     enddef
                            #
                            #     # command to execute:
                            #     syntax clear vi9Oper
                            #
                            # Notice that everything gets broken after `(x ==# 0)`.
                            # In practice, that could happen if:
                            #
                            #    - `Func()` is folded (hence, not displayed)
                            #    - `vi9Oper` is defined with `display`
                            #
                            # Here is another example:
                            #
                            #     var n = 12 +
                            #         {
                            #             key: 34,
                            #         }
                            #         .key
                            #
                            # Pressing `vio`  (visually select column) while  the cursor is on  a whitespace
                            # before `{` would  sometimes cause the latter  to be matched as the  start of a
                            # block.
                            #}}}
    6              0.000018000 execute 'syntax match vi9Oper'
                                .. ' ' .. lang.most_operators
                                .. ' nextgroup=vi9SOLExpr'
                                .. ' skipnl'
    6              0.000142000     .. ' skipwhite'
                            
                            #   =
                            #  -=
                            #  +=
                            #  *=
                            #  /=
                            #  %=
                            # ..=
    6              0.000093000 syntax match vi9OperAssign #\s\@1<=\%([-+*/%]\|\.\.\)\==\_s\@=#
                                \ nextgroup=vi9SOLExpr
                                \ skipnl
                                \ skipwhite
                            
                            # methods
    6              0.000033000 syntax match vi9Oper /->\%(\_s*\%(\h\|(\)\)\@=/ skipwhite
                            # logical not
    6              0.000016000 execute 'syntax match vi9Oper' .. ' ' .. lang.logical_not .. ' skipwhite display'
    6              0.000044000 
                            # support `:` when used inside conditional `?:` operator
    6              0.000081000 syntax match vi9Oper /\_s\@1<=:\_s\@=/
                                \ nextgroup=vi9SOLExpr
                                \ skipnl
                                \ skipwhite
                            
                            # But ignore `:` inside a slice, which is tricky.{{{
                            #
                            # Test your code against these lines:
                            #
                            #     eval [1 ? 2 : 3]
                            #                 ^
                            #
                            #     eval 1 ? 2 : 3
                            #                ^
                            #
                            #     eval list[1 : 2]
                            #                 ^
                            #
                            #     eval 1
                            #         ? 2
                            #         : 3
                            #         ^
                            #
                            #     eval col == 1 ? col([lnum, '$']) - 1 : col
                            #                                          ^
                            #}}}
    6              0.000010000 execute 'syntax match vi9ListSliceDelimiter'
                                .. ' /'
                                # try to ignore a colon part of a ternary operator (used in a slice)
                                .. '\%(?[^()?:]*\)\@<!'
                                # the colon must be surrounded with whitespace
                                .. '\s\@1<=:\s\@='
                                .. '/'
                                .. ' contained'
    6              0.000088000     .. ' containedin=vi9ListSlice'
                            
                            # contains `@vi9ErrorSpaceArgs` to handle errors in function calls
    6              0.000062000 syntax region vi9OperParen
                                \ matchgroup=vi9ParenSep
                                \ start=/(/
                                \ end=/)/
                                \ contains=
                                \     @vi9ErrorSpaceArgs,
                                \     @vi9OperGroup
                            
                            # Data Types {{{1
                            # `vi9Expr` {{{2
                            
    6              0.000671000 syntax cluster vi9Expr contains=
                                \ @vi9FuncCall,
                                \ vi9Bool,
                                \ vi9DataTypeCast,
                                \ vi9Dict,
                                \ vi9DeprecatedDictLiteralLegacy,
                                \ vi9DeprecatedScopes,
                                \ vi9Lambda,
                                \ vi9LambdaArrow,
                                \ vi9ListSlice,
                                \ vi9MayBeOptionScoped,
                                \ vi9None,
                                \ vi9Null,
                                \ vi9Number,
                                \ vi9Oper,
                                \ vi9OperParen,
                                \ vi9Registers,
                                \ vi9String,
                                \ vi9StringInterpolated
                            
                            # Booleans / null / v:none {{{2
                            
    6              0.000037000 syntax match vi9Bool /\%(v:\)\=\<\%(false\|true\)\>:\@!/ display
    6              0.000032000 syntax match vi9Null /\%(v:\)\=\<null\>:\@!/ display
    6              0.000055000 syntax match vi9Null /\<null_\%(blob\|channel\|dict\|function\|job\|list\|partial\|string\|tuple\|object\)\>/ display
                            
    6              0.000028000 syntax match vi9None /\<v:none\>:\@!/ display
                            
                            # Strings {{{2
                            
    6              0.000085000 syntax region vi9String
                                \ start=/"/
                                \ skip=/\\\\\|\\"/
                                \ end=/"/
                                \ contains=vi9EscapeSequence
                                \ keepend
                            
                            # `:help string`
    6              0.000042000 syntax match vi9EscapeSequence /\\\%(\o\{3}\|\o\{1,2}\O\@=\)/ contained
    6              0.000038000 syntax match vi9EscapeSequence /\\[xX]\%(\x\{2}\|\x\X\@=\)/ contained
    6              0.000030000 syntax match vi9EscapeSequence /\\u\x\{1,4}/ contained
    6              0.000032000 syntax match vi9EscapeSequence /\\U\x\{1,8}/ contained
    6              0.000029000 syntax match vi9EscapeSequence /\\[befnrt\\"]/ contained
                            # TODO: Should we match them in patterns too?
                            #
                            #     vi9GlobalPat
                            #     vi9RangePattern
                            #     vi9SubstPat
                            #     vi9SubstRep
                            #     vi9SynRegPat
                            #     vi9TryCatchPattern
                            #     vi9VimGrepPat
                            #
                            # Note that  in patterns, `\o`,  `\x`, `\X`, `\u`,  `\U` must include  a percent
                            # (`\%o`, `\%x`, ...). To avoid clashing with character classes.
                            
                            
                            # `:help interpolated-string`
    6              0.000222000 syntax region vi9StringInterpolated
                                \ start=/$"/
                                \ skip=/\\\\\|\\"/
                                \ end=/"/
                                \ contains=vi9EscapeSequence,vi9StringInterpolatedExpression,vi9SILB,vi9SIUB
                                \ keepend
                                \ oneline
                            
                            # `extend` is necessary in case the expression contains strings:{{{
                            #
                            #     echo $"{"foo"}" .. $'{'bar'}'
                            #              ^^^           ^^^
                            #              should be highlighted as strings
                            #
                            #     echo $"me{"\x7b"}\x7dme"
                            #                ^--^
                            #}}}
    6              0.000078000 syntax region vi9StringInterpolatedExpression
                                \ matchgroup=PreProc
                                \ start=/{{\@!/
                                \ end=/}/
                                \ contained
                                \ contains=@vi9Expr
                                \ extend
                                \ oneline
                            
                            # In a  syntax file, we  often build  syntax rules with  strings concatenations,
                            # which we then `:execute`.  Highlight the tokens inside the strings.
    6              0.000289000 if expand('%:p:h:t') == 'syntax'
                                syntax region vi9String
                                    \ start=/'/
                                    \ skip=/''/
                                    \ end=/'/
                                    \ contains=@vi9SynRegGroup,vi9SynExeCmd
                                    \ keepend
                                    \ oneline
                                syntax match vi9SynExeCmd /\<sy\%[ntax]\>/  contained nextgroup=vi9SynExeType skipwhite
                                syntax keyword vi9SynExeType keyword match region contained nextgroup=vi9SynExeGroupName skipwhite
                                syntax match vi9SynExeGroupName /[^'[:blank:]]\+/ contained
    6              0.000007000 else
                                # Order: Must come before `vi9Number`.
                                # We must not allow a digit to match after the ending quote.{{{
                                #
                                #     end=/'\d\@!/
                                #           ^---^
                                #
                                # Otherwise, it  would break  the highlighting  of a  big number  which contains
                                # quotes to be more readable:
                                #
                                #     const BIGNUMBER: number = 1'000'000
                                #                                ^---^
                                #                                this would be wrongly highlighted as a string,
                                #                                instead of a number
                                #}}}
                                # We must allow a newline before a quote to support a string at the start of a line:{{{
                                #
                                #     'some string'->setline(1)
                                #}}}
    6              0.000052000     syntax region vi9String
                                    \ start=/'/
                                    \ skip=/''/
                                    \ end=/'\d\@!/
                                    \ keepend
                                    \ oneline
    6              0.000182000     syntax region vi9StringInterpolated
                                    \ start=/$'/
                                    \ skip=/''/
                                    \ end=/'\d\@!/
                                    \ contains=vi9StringInterpolatedExpression,vi9SILB,vi9SIUB
                                    \ keepend
                                    \ oneline
    6              0.000009000 endif
                            
                            # The contents of a register is a string, and can be referred to via `@{regname}`.{{{
                            #
                            # It needs to be matched by our syntax plugin to avoid issues such as:
                            #
                            #     @" = text->join("\n")
                            #      ^
                            #      that's not the start of a string
                            #}}}
                            # Don't assert anything for the surroundings.{{{
                            #
                            # For example,  don't assume that  an `@r` expression is  necessarily surrounded
                            # with spaces:
                            #
                            #     Func(@r)
                            #         ^  ^
                            #
                            #     var l = [@r]
                            #             ^  ^
                            #
                            #     l->Func()
                            #      ^
                            #
                            # ...
                            #}}}
    6              0.000032000 syntax match vi9Registers /@[-"0-9a-z+.:%#/=]/
                            
                            # Numbers {{{2
                            
    6              0.000134000 syntax match vi9Number /\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=\>/
                                \ nextgroup=vi9Comment,vi9StrictWhitespace
                                \ skipwhite
                                \ display
                            
    6              0.000124000 syntax match vi9Number /-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=\>/
                                \ nextgroup=vi9Comment,vi9StrictWhitespace
                                \ skipwhite
                                \ display
                            
    6              0.000115000 syntax match vi9Number /\<0[xX]\x\+\>/ nextgroup=vi9Comment,vi9StrictWhitespace skipwhite display
    6              0.000119000 syntax match vi9Number /\_A\zs#\x\{6}\>/ nextgroup=vi9Comment,vi9StrictWhitespace skipwhite
    6              0.000121000 syntax match vi9Number /\<0[zZ][a-fA-F0-9.]\+\>/ nextgroup=vi9Comment,vi9StrictWhitespace skipwhite display
    6              0.000113000 syntax match vi9Number /\<0o[0-7]\+\>/ nextgroup=vi9Comment,vi9StrictWhitespace skipwhite display
    6              0.000114000 syntax match vi9Number /\<0b[01]\+\>/ nextgroup=vi9Comment,vi9StrictWhitespace skipwhite display
                            
                            # It is possible to use single quotes inside numbers to make them easier to read:{{{
                            #
                            #     echo 1'000'000
                            #
                            # Highlight them as part of a number.
                            #}}}
                            # Warning: Do *not* use `display` here.{{{
                            #
                            # It could break some subsequent highlighting.
                            #
                            # MRE:
                            #
                            #     # test script
                            #     def Foo()
                            #         (1'2) .. ''
                            #     enddef
                            #     def Bar()
                            #     enddef
                            #
                            #     # command to execute:
                            #     syntax clear vi9Number
                            #
                            # Notice that everything gets broken starting from the number.
                            #
                            # In practice, that could happen if:
                            #
                            #    - `Foo()` is folded (hence, not displayed)
                            #    - `vi9Number` is defined with `display`
                            #}}}
    6              0.000114000 syntax match vi9Number /\d\@1<='\d\@=/ nextgroup=vi9Comment,vi9StrictWhitespace skipwhite
                            
                            # Dictionaries {{{2
                            
                            # Order: Must come before `vi9Block`.
    6              0.000140000 syntax region vi9Dict
                                \ matchgroup=vi9Sep
                                \ start=/{/
                                \ end=/}/
                                \ contains=@vi9OperGroup,vi9DictExprKey,vi9DictMayBeLiteralKey
                            
                            # In literal dictionary, highlight unquoted key names as strings.
    6              0.000019000 execute 'syntax match vi9DictMayBeLiteralKey'
                                .. ' ' .. lang.maybe_dict_literal_key
                                .. ' contained'
                                .. ' contains=vi9DictIsLiteralKey'
                                .. ' keepend'
    6              0.000095000     .. ' display'
                            
                            # check the validity of the key
    6              0.000031000 syntax match vi9DictIsLiteralKey /\%(\w\|-\)\+/ contained
                            
                            # support expressions as keys (`[expr]`).
    6              0.000035000 syntax match vi9DictExprKey /\[.\{-}]\%(:\s\)\@=/
                                \ contained
                                \ contains=@vi9Expr
                                \ keepend
                            
                            # Lambdas {{{2
                            
                            # Warning: Don't add `keepend` here; it would break this:
                            #
                            #     return (F_: func(U): func(V): W) => (Y_: V) => (X_: U) => F_(X_)(Y_)
    6              0.000008000 execute 'syntax region vi9Lambda'
                                .. ' matchgroup=vi9ParenSep'
                                .. ' start=/' .. lang.lambda_start .. '/'
                                .. ' end=/' .. lang.lambda_end .. '/'
                                .. ' contains=@vi9DataTypeCluster,@vi9ErrorSpaceArgs,vi9LambdaArgs'
                                .. ' nextgroup=@vi9DataTypeCluster'
    6              0.000139000     .. ' oneline'
                            
    6              0.000029000 syntax match vi9LambdaArgs /\.\.\.\h[a-zA-Z0-9_]*/ contained
    6              0.000033000 syntax match vi9LambdaArgs /\%(:\s\)\@2<!\<\h[a-zA-Z0-9_]*/ contained
                            
    6              0.000115000 syntax match vi9LambdaArrow /\s\@1<==>\_s\@=/
                                \ nextgroup=vi9LambdaDictMissingParen,vi9Block
                                \ skipwhite
                            
                            # Type checking {{{2
                            
                            # Order: This section must come *after* the `vi9FuncCallUser` rule.{{{
                            #
                            # Otherwise, a funcref return type in a function's header would sometimes not be
                            # highlighted in its entirety:
                            #
                            #     def Func(): func(): number
                            #                 ^-----^
                            #                 not highlighted
                            #     enddef
                            #}}}
    6              0.000236000 syntax cluster vi9DataTypeCluster contains=
                                \ vi9DataType,
                                \ vi9DataTypeCast,
                                \ vi9DataTypeCastComposite,
                                \ vi9DataTypeCompositeLeadingColon,
                                \ vi9DataTypeFuncref,
                                \ vi9DataTypeListDict
                            
                            # Need to support *at least* these cases:{{{
                            #
                            #     var name: type
                            #     var name: type # comment
                            #     var name: type = value
                            #     var name: list<string> =<< trim END
                            #     def Func(arg: type)
                            #     def Func(): type
                            #
                            #     def Func(
                            #         arg: type,
                            #         ...
                            #
                            #     (arg: type) => expr
                            #     (): type => expr
                            #}}}
    6              0.000006000 execute 'syntax match vi9DataType'
                                .. ' /'
                                .. '\%(' .. '[:,]\s\+' .. '\)'
                                #     def new(this.from, this.to)
                                #                        ^-----^
                                # Source: https://github.com/vim/vim/wiki/Vim9-enumerations-with-a-dash-of-jam-and-pickles
                                # (example 6)
                                .. '\%(this\.\)\@!'
                                .. '\%('
                                           # match simple types
                                ..         'any\|blob\|bool\|channel\|float\|func\|job\|number\|string\|void'
                                           # match generic types
                                ..         '\|\u\w*'
                                #           export const NO_MONTH: common.Text = NoMonth.ONLY
                                #                                  ^---------^
                                #           Source: https://github.com/vim/vim/wiki/Vim9-enumerations-with-a-dash-of-jam-and-pickles
                                #           (example 4B)
                                ..         '\|\w\+\.\w\+'
                                .. '\)\>'
                                # positive lookahead
                                .. '\%('
                                # the type could be at the end of a line (e.g. variable declaration without assignment)
                                ..     '$'
                                # it could be followed by an inline comment
                                ..     '\|\s\+#'
                                # it could be followed by an assignment operator (`=`, `=<<`)
                                # or by an arrow (in a lambda, after its arguments)
                                ..     '\|\s\+=[ \n><]'
                                # it could be followed by a paren or a comma (in a function's header),
                                # or by a colon (in the case of `func`),
                                # or by a square bracket (`for [a: bool, b: number] in ...`)
                                #                                                ^
                                ..     '\|[),:\]]'
                                # it could be followed by the `in` keyword in a `:for` loop
                                ..     '\|\s\+in\s\+'
                                .. '\)\@='
                                .. '/hs=s+1'
                                #       ^^^
                                #       let's not highlight the colon
                                .. ' nextgroup=vi9RepeatForIn'
    6              0.000158000     .. ' skipwhite'
                            
                            # Composite data types need to be handled separately.
                            # First, let's deal with their leading colon.
    6              0.000115000 syntax match vi9DataTypeCompositeLeadingColon /:\s\+\%(\%(list\|dict\|tuple\|object\)<\|func(\)\@=/
                                \ nextgroup=vi9DataTypeListDict,vi9DataTypeFuncref
                            
                            # Now, we can deal with the rest.
                            # But a list/dict/funcref type can contain  itself; this is too tricky to handle
                            # with a  match and a  single regex.   It's much simpler  to let Vim  handle the
                            # possible recursion with a region which can contain itself.
    6              0.000234000 syntax region vi9DataTypeListDict
                                \ matchgroup=vi9ValidSubType
                                \ start=/\<\%(list\|dict\|tuple\|object\)</
                                \ end=/>/
                                \ contained
                                \ contains=vi9DataTypeFuncref,vi9DataTypeListDict,vi9ValidSubType
                                \ nextgroup=vi9RepeatForIn
                                \ oneline
                                \ skipwhite
                            
    6              0.000145000 syntax region vi9DataTypeFuncref
                                \ matchgroup=vi9ValidSubType
                                \ start=/\<func(/
                                \ end=/)/
                                \ contained
                                \ contains=vi9DataTypeFuncref,vi9DataTypeListDict,vi9ValidSubType
                                \ oneline
                            
                            # validate subtypes
    6              0.000006000 execute 'syntax match vi9ValidSubType'
                                # for the question mark: `func(?type)`
                                .. ' /?\=\<\%('
                                ..   'any'
                                .. '\|blob'
                                .. '\|bool'
                                .. '\|channel'
                                .. '\|float'
                                .. '\|func(\@!'
                                .. '\|job'
                                .. '\|number'
                                .. '\|string'
                                .. '\|void'
                                # generic type
                                .. '\|\u\w*'
                                #     export const RETROGRADE_FROM_WINTER_SOLSTICE: list<common.Text> = copy(Month.values)
                                #                                                        ^---------^
                                # Source: https://github.com/vim/vim/wiki/Vim9-enumerations-with-a-dash-of-jam-and-pickles
                                # (example 4B)
                                .. '\|\w\+\.\w\+'
                                .. '\)\>'
                                # the lookbehinds are  necessary to avoid breaking the nesting  of the outer
                                # region;  which would  prevent some  trailing `>`  or `)`  to be  correctly
                                # highlighted
                                .. '\|'
                                .. '?\=\<\%('
                                ..         'd\@1<=ict<'
                                .. '\|' .. 'l\@1<=ist<'
                                .. '\|' .. 't\@1<=uple<'
                                .. '\|' .. 'f\@1<=unc(\|)'
                                .. '\)'
                                .. '\|'
                                # support triple dot in `func(...list<type>)`
                                .. '\.\.\.\%(\%(list\|tuple\)<\)\@='
                                # support comma in `func(type1, type2)`
                                .. '\|' .. ','
                                .. '/'
                                .. ' contained'
    6              0.000104000     .. ' display'
                            
                            # support `:help type-casting` for simple types
    6              0.000008000 execute 'syntax match vi9DataTypeCast'
                                .. ' /<\%('
                                ..         'any\|blob\|bool\|channel\|float\|func\|job\|number\|string\|void'
                                .. '\)>'
                                # TODO: Type casts *might* be used for script/function local variables too.
                                # If so, you might need to remove this assertion.
                                # And also allow `vi9DataTypeCastComposite` to be matched in
                                # `vi9OperParen` (and other groups?), and link it to the `Type` HG.
                                .. '\%([bgtw]:\)\@='
    6              0.000058000     .. '/'
                            
                            # support `:help type-casting` for composite types
    6              0.000214000 syntax region vi9DataTypeCastComposite
                                \ matchgroup=vi9ValidSubType
                                \ start=/<\%(list\|dict\|tuple\|object\)</
                                \ end=/>>/
                                \ contains=vi9DataTypeFuncref,vi9DataTypeListDict,vi9ValidSubType
                                \ oneline
                            
    6              0.000142000 syntax region vi9DataTypeCastComposite
                                \ matchgroup=vi9ValidSubType
                                \ start=/<func(/
                                \ end=/)>/
                                \ contains=vi9DataTypeFuncref,vi9DataTypeListDict,vi9ValidSubType
                                \ oneline
                            #}}}1
                            # Options {{{1
                            # Assignment commands {{{2
                            
    6              0.000085000 syntax keyword vi9Set setl[ocal] setg[lobal] se[t]
                                \ contained
                                \ nextgroup=vi9MayBeOptionSet
                                \ skipwhite
                            
                            # Names {{{2
                            
    6              0.000008000 execute 'syntax match vi9MayBeOptionScoped'
                                .. ' /'
                                ..     lang.option_can_be_after
                                ..     lang.option_sigil
                                ..     lang.option_valid
                                .. '/'
                                .. ' contains=vi9IsOption,vi9OptionSigil'
                                # `vi9SetEqual` would be wrong here; we need spaces around `=`
                                .. ' nextgroup=vi9OperAssign'
    6              0.000178000     .. ' display'
                            
                            # Don't use `display` here.{{{
                            #
                            # It  could mess  up the  buffer  when you  set  a terminal  option whose  value
                            # contains an opening square bracket.  The latter could be wrongly parsed as the
                            # start a list.
                            #}}}
    6              0.000009000 execute 'syntax match vi9MayBeOptionSet'
                                .. ' /'
                                ..     lang.option_can_be_after
                                ..     lang.option_valid
                                .. '/'
                                .. ' contained'
                                .. ' contains=vi9IsOption'
                                .. ' nextgroup=vi9SetEqual,vi9SetEqualError,vi9MayBeOptionSet,vi9SetMod'
    6              0.000215000     .. ' skipwhite'
    6              0.000007000     execute 'syntax match vi9SetEqualError'
                                    .. ' /'
                                    ..    '\s\+'
                                    ..    '\%('
                                    # White space is disallowed around the assignment operator:{{{
                                    #
                                    #                        ✘
                                    #                        vv
                                    #     setlocal foldmethod = 'expr'
                                    #     setlocal foldmethod=expr
                                    #                        ^
                                    #                        ✔
                                    #}}}
                                    ..        '[-+^]\=='
                                    ..    '\|'
                                    # It's also disallowed before a modifier:{{{
                                    #
                                    #                 ✘
                                    #                 v
                                    #     set hlsearch &
                                    #     set hlsearch !
                                    #                 ^
                                    #                 ✘
                                    #}}}
                                    ..        lang.option_modifier
                                    ..    '\)\@='
                                    .. '/'
    6              0.000092000         .. ' contained'
                            
    6              0.000025000 syntax match vi9OptionSigil /&\%([gl]:\)\=/ contained
                            
    6              0.000008000 execute 'syntax keyword vi9IsOption'
                                .. ' ' .. lang.option
                                .. ' contained'
                                .. ' nextgroup=vi9MayBeOptionScoped,vi9SetEqual'
    6              0.001539000     .. ' skipwhite'
                            
    6              0.000007000 execute 'syntax keyword vi9IsOption'
                                .. ' ' .. lang.option_terminal
                                .. ' contained'
    6              0.000232000     .. ' nextgroup=vi9MayBeOptionScoped,vi9SetEqual'
                            
    6              0.000007000 execute 'syntax match vi9IsOption'
                                .. ' /\V'
                                .. lang.option_terminal_special
                                .. '/'
                                .. ' contained'
    6              0.000117000     .. ' nextgroup=vi9MayBeOptionScoped,vi9SetEqual'
                            
                            # Assignment operators {{{2
                            
    6              0.000084000 syntax match vi9SetEqual /[-+^]\==/
                                \ contained
                                \ nextgroup=vi9SetNumberValue,vi9SetStringValue
                            
                            # Values + separators (`[,:]`) {{{2
                            
    6              0.000006000 execute 'syntax match vi9SetStringValue'
                                .. ' /'
                                .. '\%('
                                           # match characters with no special meaning
                                ..         '[^\\[:blank:]]'
                                           # match whitespace escaped with an odd number of backslashes
                                .. '\|' .. '\%(\\\\\)*\\\s'
                                           # match backslash escaping sth else than a whitespace
                                .. '\|' .. '\\\S'
                                .. '\)*'
                                .. '/'
                                .. ' contained'
                                .. ' contains=vi9SetSep'
                                # necessary to support the case where a single `:set` command sets several options
                                .. ' nextgroup=vi9MayBeOptionScoped,vi9MayBeOptionSet'
                                .. ' oneline'
    6              0.000153000     .. ' skipwhite'
                            
    6              0.000023000 syntax match vi9SetSep /[,:]/ contained
                            
                            # Order: Must come after `vi9SetStringValue`.
    6              0.000106000 syntax match vi9SetNumberValue /\d\+\_s\@=/
                                \ contained
                                \ nextgroup=vi9MayBeOptionScoped,vi9MayBeOptionSet
                                \ skipwhite
                            
                            # Modifiers (e.g. `&vim`) {{{2
                            
                            # Modifiers which can be appended to an option name.{{{
                            #
                            # < = set local value to global one; or remove local value (for global-local options)
                            # ? = show value
                            # ! = invert value
                            #}}}
    6              0.000013000 execute 'syntax match vi9SetMod /' .. lang.option_modifier .. '/'
                                .. ' contained'
                                .. ' nextgroup=vi9MayBeOptionScoped,vi9MayBeOptionSet'
    6              0.000122000     .. ' skipwhite'
                            #}}}1
                            # Blocks {{{1
                            
                            # at start of line
    6              0.000064000 syntax region vi9Block
                                \ matchgroup=Statement
                                \ start=/^\s*{$/
                                \ end=/^\s*}/
                                \ contains=TOP
                            # `contains=TOP` is really necessary.{{{
                            #
                            # You can't get away with just:
                            #
                            #     \ contains=vi9StartOfLine
                            #
                            # That would not match things like strings, which are not contained in anything:
                            #
                            #     execute 'cmd ' .. name
                            #             ^----^
                            #}}}
                            
                            # possibly after a bar
    6              0.000062000 syntax region vi9Block
                                \ matchgroup=Statement
                                \ start=/\s*{$/
                                \ end=/^\s*}/
                                \ contains=TOP
                                \ contained
                            
                            # In a lambda, a dictionary must be surrounded by parens.{{{
                            #
                            #                     ✘
                            #                     v
                            #     var Ref = () => {}
                            #     var Ref = () => ({})
                            #                     ^
                            #                     ✔
                            #
                            # ---
                            #
                            # This can also warn us about of block which is not correctly broken after `{`:
                            #
                            #                     ✘
                            #                     v
                            #     var Ref = () => { command  }
                            #
                            #                     ✔
                            #                     v
                            #     var Ref = () => {
                            #         command
                            #     }
                            #
                            # From `:help inline-function`:
                            #
                            #    > Unfortunately this means using "() => {  command  }" does not work, line
                            #    > breaks are always required.
                            #}}}
                            # Order: must come before the next `vi9Block` rule.
    6              0.000027000 syntax match vi9LambdaDictMissingParen /{/ contained
                            
                            # in lambda
                            # Warning: Checking that there is no open paren before is not enough.{{{
                            #
                            # For example, it would fail to ignore  this dictionary passed as an argument to
                            # `Func()`:
                            #
                            #     Func(arg, {
                            #         key: 'value',
                            #     })
                            #}}}
    6              0.000063000 syntax region vi9Block
                                \ matchgroup=Statement
                                \ start=/\%(=>\s\+\)\@<={$/
                                \ end=/^\s*}/
                                \ contained
                                \ contains=TOP
                            
    6              0.000058000 syntax region vi9BlockUserCmd
                                \ matchgroup=Statement
                                \ start=/{$/
                                \ end=/^\s*}/
                                \ contained
                                \ contains=TOP
                            
                            # Highlight commonly used Groupnames {{{1
                            
    6              0.000005000 syntax case ignore
    6              0.000125000 syntax keyword vi9Group contained
                                \ Boolean
                                \ Character
                                \ Comment
                                \ Conditional
                                \ Constant
                                \ Debug
                                \ Define
                                \ Delimiter
                                \ Error
                                \ Exception
                                \ Float
                                \ Function
                                \ Identifier
                                \ Ignore
                                \ Include
                                \ Keyword
                                \ Label
                                \ Macro
                                \ Number
                                \ Operator
                                \ PreCondit
                                \ PreProc
                                \ Repeat
                                \ Special
                                \ SpecialChar
                                \ SpecialComment
                                \ Statement
                                \ StorageClass
                                \ String
                                \ Structure
                                \ Tag
                                \ Todo
                                \ Type
                                \ Typedef
                                \ Underlined
    6              0.000003000 syntax case match
                            
                            # Default highlighting groups {{{1
                            
    6              0.000004000 syntax case ignore
    6              0.000014000 execute 'syntax keyword vi9HLGroup contained' .. ' ' .. lang.default_highlighting_group
    6              0.000198000 
                            # Warning: Do *not* turn this `match` into  a `keyword` rule; `conceal` would be
                            # wrongly interpreted as an argument to `:syntax`.
    6              0.000031000 syntax match vi9HLGroup /\<conceal\>/ contained
    6              0.000003000 syntax case match
                            
                            # Special Filenames, Modifiers, Extension Removal {{{1
                            
    6              0.000061000 syntax match vi9SpecFile /<\%([acs]file\|abuf\)>/ nextgroup=vi9SpecFileMod
                            
                            # TODO: Update these rules so that they support the Vim9 filename modifiers:
                            #
                            #     edit %
                            #     edit %%
                            #     edit %%123
                            #     edit %%%
                            #     edit %%<123
                            #
                            # You'll probably need to refactor the rules, so that they're all contained.
                            # This assumes that you first recognize  all commands which accept a filename as
                            # argument.
                            #
                            # ---
                            #
                            # Make sure the file name modifiers  are accepted only after `%`, `%%`, `%%123`,
                            # `<cfile>`, `<sfile>`, `<afile>` and `<abuf>`.
                            #
                            # Edit: We currently match `<cfile>` (&friends) with `vi9ExSpecialCharacters`.
                            # Is that wrong?  Should we match them with `vi9SpecFile`?
                            #
                            # ---
                            #
                            # Re-read `:help cmdline-special` to make sure everything is correct.
                            
                            # Do *not* allow a space to match after `%`.{{{
                            #
                            #     \s%[: ]
                            #          ^
                            #          ✘
                            #
                            # Sometimes, it would break the highlighting of the arithmetic modulo operator:
                            #
                            #     eval (1) % 2
                            #              ^
                            #
                            # This does  mean that  in some  cases, `%`  might be  wrongly highlighted  as a
                            # modulo instead of a special filename.  Contrived example:
                            #
                            #     edit % | eval 0
                            #          ^
                            #          ✘
                            #
                            # For the moment, it looks like a  corner case which we won't encounter often in
                            # practice, so let's not try to fix it.
                            #}}}
    6              0.000057000 syntax match vi9SpecFile /\s%:/ms=s+1,me=e-1 nextgroup=vi9SpecFileMod
                            # `%` can be followed by a bar, or `<Bar>`:{{{
                            #
                            #     source % | eval 0
                            #              ^
                            #}}}
    6              0.000062000 syntax match vi9SpecFile /\s%\%($\|\s*[|<]\)\@=/ms=s+1 nextgroup=vi9SpecFileMod
    6              0.000062000 syntax match vi9SpecFile /\s%<\%([^[:blank:]<>]*>\)\@!/ms=s+1,me=e-1 nextgroup=vi9SpecFileMod
                            # TODO: The negative lookahead is necessary to prevent a match in a mapping:{{{
                            #
                            #     nnoremap x <ScriptCmd>argedit %<CR>
                            #                                    ^
                            # Pretty sure it's needed in other similar rules around here.
                            # Make tests.
                            # Try to avoid code repetition; import a regex if necessary.
                            #}}}
    6              0.000063000 syntax match vi9SpecFile /%%\d\+\|%<\%([^[:blank:]<>]*>\)\@!\|%%</ nextgroup=vi9SpecFileMod
    6              0.000031000 syntax match vi9SpecFileMod /\%(:[phtreS]\)\+/ contained
                            
                            # Lower Priority Comments: after some vim commands... {{{1
                            
                            # Warning: Do *not* use the `display` argument here.
                            
                            # We need  to assert  the presence  of whitespace before  the comment  leader to
                            # prevent matching some part of an autoload variable.
                            #     foo = script#autoload_variable
                            #                 ^----------------^
                            #                 that's not a comment
    6              0.000038000 syntax match vi9Comment /\_s\@1<=#.*$/ contains=@vi9CommentGroup
    6              0.000024000 syntax match vi9CommentContinuation /#\\ /hs=s+1 contained
                            # If you want to highlight a missing backslash in a line continuation comment, try this regex:{{{
                            #
                            #     #\%(\\ \)\@!\%(.*\n\s*\%(\\\|||\@!\|#\\ \)\)\@=
                            #
                            # Broken down:
                            #
                            #     #
                            #     a comment leader
                            #
                            #     \%(\\ \)\@!
                            #     not followed by a backslash
                            #
                            #     \%(.*\n\s*\%(\\\|||\@!\|#\\ \)\)\@=
                            #     but the next line is a continuation line
                            #
                            # Remember that a continuation line can start with:
                            #
                            #    - a backslash
                            #    - a bar (but not 2; that would be the logical operator OR)
                            #    - a commented backslash (followed by a space)
                            #
                            # It would  be useful to  highlight this  as an error,  but we don't  because it
                            # seems a little too costly for a syntax which is very rarely used.
                            #}}}
                            
                            # Control Characters {{{1
                            
    6              0.000037000 syntax match vi9CtrlChar /[\x01-\x08\x0b\x0f-\x1f]/
                            
                            # Patterns matching at start of line {{{1
                            
                            # We've tweaked the original rule.{{{
                            #
                            # A title in a Vim9 comment was not highlighted.
                            # https://github.com/vim/vim/issues/6599
                            #
                            # ---
                            #
                            # Also, we could not include a user name inside parens:
                            #
                            #     NOTE(user): some comment
                            #         ^----^
                            #}}}
                            # `hs=s+1` is necessary to not highlight the comment leader.{{{
                            #
                            #     hs=s+1
                            #     │  │
                            #     │  └ start of the matched pattern
                            #     └ offset for where the highlighting starts
                            #
                            # See `:help :syn-pattern-offset`:
                            #}}}
    6              0.000048000 syntax match vi9CommentTitle /#\s*\u\%(\w\|[()]\)*\%(\s\+\u\w*\)*:/hs=s+1
                                \ contained
                                \ contains=@vi9CommentGroup
                            
    6              0.000028000 syntax match vi9SynContinuePattern =\s\+/[^/]*/= contained
                            
                            # Backtick expansion {{{1
                            
                            #     `shell command`
    6              0.000054000 syntax region vi9BacktickExpansion
                                \ matchgroup=Special
                                \ start=/`\%([^`=]\)\@=/
                                \ end=/`/
                                \ oneline
                            
                            #     `=Vim expr`
    6              0.000054000 syntax region vi9BacktickExpansionVimExpr
                                \ matchgroup=Special
                                \ start=/`=/
                                \ end=/`/
                                \ contains=@vi9Expr
                                \ oneline
                            
                            # fixme/todo notices in comments {{{1
                            
    6              0.000023000 syntax keyword vi9Todo FIXME NOTE TODO contained
    6              0.000098000 syntax cluster vi9CommentGroup contains=
                                \ @Spell,
                                \ vi9CommentContinuation,
                                \ vi9CommentTitle,
                                \ vi9Todo
                            
                            # Fenced Languages  {{{1
                            
                            # NOTE: This block uses string interpolation which requires patch 8.2.4883
                            # Warning: Make sure not to use a variable name already used in an import.{{{
                            #
                            # For example, ATM, we already use `lang`:
                            #
                            #     import 'vi9Language.vim' as lang
                            #                                 ^--^
                            #
                            # So, don't write:
                            #
                            #     for lang: string in ...
                            #         ^--^
                            #          ✘
                            #}}}
    6              0.000038000 for language: string in get(g:, 'vim9_syntax', {})->get('fenced_languages', [])
                                var cmd_pat: string = {
                                    lua: 'lua',
                                    ruby: 'rub\%[y]',
                                    perl: 'pe\%[rl]',
                                    python: 'py\%[thon][3x]\=',
                                    tcl: 'tcl',
                                }->get(language, '')
                            
                                if cmd_pat == ''
                                    continue
                                endif
                            
                                var do_pat: string = {
                                    lua: 'luado\=',
                                    ruby: 'rubydo\=',
                                    perl: 'perldo\=',
                                    python: 'py[3x]\=do\=',
                                    tcl: 'tcldo\=',
                                }->get(language, '')
                            
                                var code: list<string> =<< trim eval END
                                    unlet! b:current_syntax
                            
                                    syntax include @vi9{language}Script syntax/{language}.vim
                            
                                    syntax match vi9{language}Cmd /\<{cmd_pat}\>/ contained nextgroup=vi9{language}CmdRegion skipwhite
                                    syntax region vi9{language}CmdRegion
                                        \ matchgroup=vi9ScriptDelim
                                        \ start=/<<\s*\z(\S\+\)$/
                                        \ end=/^\z1$/
                                        \ matchgroup=vi9Error
                                        \ end=/^\s\+\z1$/
                                        \ contained
                                        \ contains=@vi9{language}Script
                                        \ keepend
                                    syntax region vi9{language}CmdRegion
                                        \ matchgroup=vi9ScriptDelim
                                        \ start=/<<$/
                                        \ end=/\.$/
                                        \ contained
                                        \ contains=@vi9{language}Script
                                        \ keepend
                            
                                    syntax match vi9{language}Do /\<{do_pat}\>/ contained nextgroup=vi9{language}DoLine skipwhite
                                    syntax match vi9{language}DoLine /\S.*/ contained contains=@vi9{language}Script
                            
                                    syntax cluster vi9CanBeAtStartOfLine add=vi9{language}Cmd,vi9{language}Do
                            
                                    highlight default link vi9{language}Cmd vi9GenericCmd
                                    highlight default link vi9{language}Do vi9GenericCmd
                                END
                            
                                code->join("\n")
                                    ->substitute('\n\s*\\', ' ', 'g')
                                    ->split('\n')
                                    ->execute()
    6              0.000035000 endfor
                            #}}}1
                            # Errors {{{1
                            # Strict whitespace usage {{{2
                            
                            #                ✘
                            #                v
                            #     var l = [1  , 2]
                            #     var l = ['' , '']
                            #     var l = [[] , []]
                            #     var l = [{} , {}]
                            #                ^
                            #                ✘
                            #
                            #                   ✘
                            #                   v
                            #     var d = {a: 1  , b: 2}
                            #     var d = {a: '' , b: ''}
                            #     var d = {a: [] , b: []}
                            #     var d = {a: {} , b: {}}
                            #                   ^
                            #                   ✘
    6              0.000088000 syntax match vi9StrictWhitespace /\s\+\ze,/ contained containedin=vi9Dict,vi9ListSlice display
                            
                            #     [a, b ; c] = ...
                            #          ^
                            #          ✘
                            #
                            #     [a, b;c] = ...
                            #          ^
                            #          ✘
    6              0.000059000 syntax match vi9StrictWhitespace /\s\+\ze;\|;\ze\S/ contained containedin=vi9ListSlice display
                            
                            #     var l = [1,2]
                            #               ^
                            #               ✘
                            #
                            #     var d = {a: 1,b: 2}
                            #                  ^
                            #                  ✘
    6              0.000081000 syntax match vi9StrictWhitespace /,\ze[^[:blank:])]/ contained containedin=vi9Dict,vi9ListSlice display
                            
                            #     var d = {'a' :1, 'b' :2}
                            #                 ^       ^
                            #                 ✘       ✘
    6              0.000057000 syntax match vi9StrictWhitespace /\s\+\ze:[^[:blank:]\]]/ contained containedin=vi9Dict display
                            
                            #     var d = {a:1, b:2}
                            #               ^    ^
                            #               ✘    ✘
    6              0.000058000 syntax match vi9StrictWhitespace /\S\@1<=:\S\@=/ contained containedin=vi9Dict display
                                # `\S:\S` *might* be valid when it matches the start of a scoped variable.
                                # Don't highlight its colon as an error then.
                                # Why not just `\h`?{{{
                                #
                                # An explicit scope is not necessarily followed by an identifier:
                                #
                                #     var d = {key: g:}
                                #                     ^
                                #}}}
    6              0.000072000     syntax match vi9StrictWhitespaceScopedVar
                                    \ /\%(\<[bgstvw]\)\@1<=:\%(\h\|\_s\|[,;}\]]\)\@=/
                                    \ contained
                                    \ containedin=vi9Dict
                                    \ display
                            
                            # TODO: Try to highlight missing whitespace around most binary operators as an error.
                            # That's going to be tricky.
                            # For example, a filename could be `abc+def`; and `+` is not an operator.
                            
                            # TODO: Highlight these as errors:
                            #
                            #            ✘
                            #            v
                            #     &option=value
                            #     &option-=value
                            #     &option+=value
                            #            ^^
                            #            ✘
                            
                            # Deprecated syntaxes {{{2
                            
                            # Where can a legacy syntax be used in a Vim9 script?{{{
                            #
                            #    - inside a `:function`
                            #    - after `:legacy`
                            #    - in the RHS of a mapping (except if it uses `<expr>` or `<ScriptCmd>`)
                            #}}}
                            #   Can't the next rules sometimes highlight a valid legacy syntax as an error?{{{
                            #
                            # No, they can't.
                            # We install syntax rules to match the previous contexts, and we don't allow the
                            # next rules to nest inside.
                            #}}}
                            # `:let` is deprecated.
    6              0.000028000 syntax keyword vi9DeprecatedLet let contained
                            
                            # In legacy Vim script, a literal dictionary starts with `#{`.
                            # This syntax is no longer valid in Vim9.
    6              0.000061000 syntax match vi9DeprecatedDictLiteralLegacy /#{{\@!/ containedin=vi9ListSlice display
                            
                            # the scopes `a:`, `l:` and `s:` are no longer valid
                            # Don't use `contained` to limit these rules to `@vi9Expr`.{{{
                            #
                            # Because then, they would fail to match this:
                            #
                            #     let a:name = ...
                            #         ^^
                            #}}}
    6              0.000034000 syntax match vi9DeprecatedScopes /\<[as]:\w\@=/ display
    6              0.000036000 syntax match vi9DeprecatedScopes /&\@1<!\<l:\h\@=/ display
                            
                            # The `is#` operator worked in legacy, but didn't make sense.
                            # It's no longer supported in Vim9.
    6              0.000066000 syntax match vi9DeprecatedIsOperator /\C\<\%(is\|isnot\)[#?]/ contained containedin=vi9Oper display
                            
    6              0.000028000 syntax match vi9LegacyDotEqual /\s\.\%(=\s\)\@=/hs=s+1 display
                            
    6              0.000025000 syntax match vi9LegacyVarArgs /a:000/ display
                            
                            # TODO: Handle other legacy constructs like:
                            #
                            #    - `...)` in a function's header
                            #    - eval string
                            #    - lambda (tricky)
                            #    - single dot for concatenation (tricky)
                            
                            # TODO: Highlight legacy comment leaders as an error.  Optional.
                            
                            # TODO: Highlight missing types in function header as errors:
                            #
                            #     def Func(foo, bar)
                            #
                            # Exceptions: `_` and `..._`.
                            
                            # TODO: Highlight `:call` as useless.
                            #
                            # ---
                            #
                            # Same thing for `v:` in `v:true`, `v:false`, `v:null`.
                            #
                            # ---
                            #
                            # Same thing for `#` in `==#`, `!=#`, `=~#`, `!~#`.
                            
                            # TODO: Highlight this as an error:
                            #
                            #     def Func(...name: job)
                            
                            # Missing space / Extra space {{{2
                            
                            # We don't highlight a missing whitespace around an assignment operator:{{{
                            #
                            #     var name=123     # Error!
                            #     var name= 123    # Error!
                            #     var name =123    # Error!
                            #
                            # Because it's not syntax highlighted in those cases.
                            # The  absence of  highlighting should  serve as  a good  enough warning  to the
                            # user  (provided their  color scheme  highlights assignment  operators with  an
                            # easy-to-notice color).
                            #
                            # Besides, handling  all the cases  (after a variable name,  after a type,  in a
                            # heredoc, ...) would probably require many more rules.
                            # And, to  be consistent, we would  need to also handle  other binary operators,
                            # like the arithmetic ones.  But this  would require we first parse expressions,
                            # which would open a can of worms.
                            #}}}
                            # We could highlight missing or extra spaces in dictionaries:{{{
                            #
                            #         ✘
                            #         v
                            #     {key:'value'}
                            #     {key : 'value'}
                            #         ^
                            #         ✘
                            #
                            #     {key: 'value'}
                            #         ^^
                            #         ✔
                            #}}}
                            #   But we don't.{{{
                            #
                            # It's not necessary.  If you omit a space  after the colon, or add an extra one
                            # before, the key  won't be highlighted as  a string, which gives  a visual clue
                            # that something is wrong.
                            #
                            # There might still be an issue if  you use special characters in your keys, and
                            # you need to put quotes around them:
                            #
                            #           ✘
                            #           v
                            #     {'a+b':'value'}
                            #     {'c*d' : 'value'}
                            #           ^
                            #           ✘
                            #
                            # This code is wrong, but the highlighting  won't give any warning.  IMO, it's a
                            # corner case  which is  not worth  supporting.  You'll  rarely write  keys with
                            # special characters inside, *and* forget a space or add an extra space.
                            #}}}
                            
    6              0.000020000 if get(g:, 'vim9_syntax', {})
                             ->get('errors', {})
                             ->get('strict_whitespace', true)
                            
                                #         ✘
                                #         v
                                #     Func (arg)
    6              0.000079000     syntax region vi9SpaceExtraAfterFuncname
                                    \ matchgroup=vi9Error
                                    \ start=/\s\+(/
                                    \ matchgroup=vi9ParenSep
                                    \ end=/)/
                                    \ contains=@vi9OperGroup
                                    \ contained
                                    \ display
                            
                                #           ✘
                                #           v
                                #     Func(1,2)
                                #     Func(1, 2)
                                #            ^
                                #            ✔
    6              0.000029000     syntax match vi9SpaceMissingBetweenArgs /,[^[:blank:])]\@=/ contained display
                            
                                #           ✘
                                #           v
                                #     Func(1 , 2)
                                #     Func(1, 2)
                                #           ^
                                #           ✔
    6              0.000027000     syntax match vi9SpaceExtraBetweenArgs /\s\@1<=,/ contained display
                            
    6              0.000067000     syntax cluster vi9ErrorSpaceArgs contains=
                                    \ vi9SpaceExtraBetweenArgs,
                                    \ vi9SpaceMissingBetweenArgs
                            
                                #                   need a space before
                                #                   v
                                #     var name = 123# Error!
                                # We need to match a whitespace to avoid reporting spurious errors:{{{
                                #
                                #     start=/[^[:blank:]]\@1<=#\s/
                                #                              ^^
                                #
                                #     g:autoload#name = 123
                                #               ^
                                #               this is not the start of a comment,
                                #               thus there is no error
                                #
                                # Note that this is  not entirely correct; a comment might  be followed by a
                                # non-whitespace.  But in  practice, it seems like a simple  and good enough
                                # solution.
                                #}}}
                                # And we need to ignore an error if `#` is preceded by `@`.{{{
                                #
                                # Because `@#` might be a reference to a register.
                                #}}}
    6              0.000068000     syntax region vi9Comment
                                    \ matchgroup=vi9Error
                                    \ start=/[^[:blank:]@]\@1<=#\s\@=/
                                    \ end=/$/
                                    \ contains=@vi9CommentGroup
                                    \ excludenl
                                    \ oneline
                                    \ display
                            
                                # In a slice, the colon separating the 2 indexes must be surrounded with spaces:{{{
                                #
                                #             ✘
                                #             v
                                #     mylist[1:2]
                                #     mylist[1 : 2]
                                #             ^^^
                                #              ✔
                                #}}}
                                # To highlight a missing space, we must first recognize a list slice.{{{
                                #
                                # We don't try to  distinguish a slice of a list from a  simple list, because it
                                # seems too tricky.
                                #
                                #           mylist[1 : 2]
                                #     ReturnList()[1 : 2]
                                #        [1, 2, 3][1 : 2]
                                #     ...
                                #
                                # In particular, notice the variety of characters which can appear in front of a
                                # slice.
                                #}}}
    6              0.000177000     syntax region vi9ListSlice
                                    \ matchgroup=vi9Sep
                                    \ start=/\[/
                                    \ end=/\]/
                                    \ contains=
                                    \     @vi9OperGroup,
                                    \     vi9ColonForVariableScope,
                                    \     vi9ListSlice,
                                    \     vi9ListSliceDelimiter,
                                    \     vi9SpaceMissingListSlice
                                # If a colon is not prefixed with a space, it's an error.
    6              0.000038000     syntax match vi9SpaceMissingListSlice /[^[:blank:][]\@1<=:/ contained display
                                # If a colon is not followed with a space, it's an error.
    6              0.000024000     syntax match vi9SpaceMissingListSlice /:[^[:blank:]\]]\@=/ contained display
                                # Corner Case: A colon can be used in a variable name.  Ignore it.{{{
                                #
                                #     b:name
                                #      ^
                                #      ✔
                                #}}}
                                # Order: Out of these 3 rules, this one must come last.
    6              0.000007000     execute 'syntax match vi9ColonForVariableScope'
                                    .. ' /'
                                    .. '\<[bgtvw]:'
                                    .. '\%('
                                    ..    '\w'
                                    .. '\|'
                                           # `b:` is a dictionary expression, thus might be followed by `->`
                                    ..     '->'
                                    .. '\)\@='
                                    .. '/'
                                    .. ' contained'
    6              0.000035000         .. ' display'
    6              0.000006000 endif
                            
                            # Octal numbers {{{2
                            
                            # Warn about missing `o` in `0o` prefix in octal number.{{{
                            #
                            #    > Numbers starting with zero are not considered to be octal, only numbers
                            #    > starting with "0o" are octal: "0o744". |scriptversion-4|
                            #
                            #          ✘
                            #          v
                            #     echo 0765
                            #     echo 0o765
                            #          ^^
                            #          ✔
                            #}}}
    6              0.000012000 if get(g:, 'vim9_syntax', {})
                             ->get('errors', {})
                             ->get('octal_missing_o_prefix', false)
                            
                                # The  negative lookbehind  is necessary  to  ignore big  numbers which  are{{{
                                # written with quotes to be more readable:
                                #
                                #     1'076
                                #       ^^^
                                #
                                # Here, `076` is not a badly written octal number.
                                # There is no reason to stop the highlighting at `0`.
                                #
                                # ---
                                #
                                # Also, it's necessary to ignore a number used as a key in a dictionary:
                                #
                                #     d.0123
                                #       ^--^
                                #       this is not an octal number;
                                #       this is a key to retrieve some value from a dictionary
                                #}}}
                                syntax match vi9NumberOctalWarn /\%(\d'\|\.\)\@2<!\<0[0-7]\+\>/he=s+1
                                    \ nextgroup=vi9Comment
                                    \ skipwhite
                                    \ display
    6              0.000005000 endif
                            
                            # Range {{{2
                            
                            # Warn about omitting whitespace between line specifier and command.{{{
                            #
                            # In addition to making the code less readable, it might confuse the syntax plugin:
                            #
                            #     :123delete
                            #         ^----^
                            #           ✘
                            #         not recognized as an Ex command
                            #
                            #     :123 delete
                            #          ^----^
                            #            ✔
                            #          recognized as an Ex command
                            #
                            # Note that this issue also affects the legacy syntax plugin.
                            # We could try to fix it by removing all digits from the *syntax* option 'iskeyword':
                            #
                            #     :syntax iskeyword @,_
                            #
                            # But that would cause  other issues which would require too  much extra code to
                            # handle.   Indeed, it  would break  all the  `syntax keyword`  rules for  words
                            # containing digits.   It would also change  the semantics of the  `\<` and `\>`
                            # atoms in all regexes used for `syntax match` and `syntax region` rules.
                            #}}}
    6              0.000023000 if get(g:, 'vim9_syntax', {})
                             ->get('errors', {})
                             ->get('range_missing_space', false)
                            
                                syntax match vi9RangeMissingSpace /\S\@1<=\a/ contained display
    6              0.000002000 endif
                            
                            # Discourage usage  of an  implicit line  specifier, because  it makes  the code
                            # harder to read.
    6              0.000011000 if get(g:, 'vim9_syntax', {})
                             ->get('errors', {})
                             ->get('range_missing_specifier', false)
                                syntax match vi9RangeMissingSpecifier1 /[,;]/
                                    \ contained
                                    \ nextgroup=@vi9Range
                            
                                syntax match vi9RangeMissingSpecifier2 /[,;][a-zA-Z[:blank:]]\@=/
                                    \ contained
                                    \ nextgroup=@vi9CanBeAtStartOfLine
                                    \ skipwhite
    6              0.000003000 endif
                            
                            # Reserved names {{{2
                            
                            # Some names cannot be used for variables, because they're reserved:{{{
                            #
                            #     var true = 0
                            #     var null = ''
                            #     var this = []
                            #     ...
                            #}}}
    6              0.000034000 syntax keyword vi9ReservedNames true false null this super contained
                            #}}}1
                            # Synchronize (speed) {{{1
                            
                            # Need to define a pattern to sync on.{{{
                            #
                            # It doesn't need to match anything meaningful.
                            # It just needs to exist so that Vim searches back for something.
                            # This is useful – for example – when a heredoc is displayed from the middle
                            # (i.e. its first text line is above the first screen line).
                            #}}}
    6              0.000041000 syntax sync match vi9Sync grouphere NONE /^dummy pattern$/
                            # Don't look more than 60 lines back when looking for a pattern to sync on.
    6              0.000008000 syntax sync maxlines=60
                            #}}}1
                            # OOP {{{1
                            
                            # Let's keep this section at the very end so that `HighlightUserTypes()` works properly.
                            # The latter calls `synstack()` which needs the syntax to have been fully set.
                            
    6              0.000366000 syntax cluster vi9OOP contains=
                                \ vi9Abstract,
                                \ vi9Class,
                                \ vi9Enum,
                                \ vi9EnumName,
                                \ vi9Extends,
                                \ vi9Implements,
                                \ vi9Interface,
                                \ vi9Public,
                                \ vi9Static,
                                \ vi9This,
                                \ vi9UserType
                            
                            # :class
                            # :endclass
    6              0.000057000 syntax keyword vi9Class class endclass contained nextgroup=vi9ClassName skipwhite
                            
                            #           vvv
                            #     class Foo
                            #     endclass
    6              0.000101000 syntax match vi9ClassName /\u\w*/ contained nextgroup=vi9Extends,vi9Implements,vi9Specifies skipwhite
                            #                          v------v           vvv
                            #     class Foo implements Bar, Baz specifies Qux
    6              0.000139000 syntax match vi9InterfaceName /\u\w*\%(,\s\+\u\w*\)\=/
                                \ contained
                                \ nextgroup=vi9Extends,vi9Implements,vi9Specifies,vi9StrictWhitespace
                                \ skipwhite
                            
    6              0.000046000 syntax keyword vi9Extends extends contained nextgroup=vi9ClassName skipwhite
    6              0.000046000 syntax keyword vi9Implements implements contained nextgroup=vi9InterfaceName skipwhite
    6              0.000045000 syntax keyword vi9Specifies specifies contained nextgroup=vi9InterfaceName skipwhite
                            
                            # :interface
                            # :endinterface
    6              0.000051000 syntax keyword vi9Interface interface endinterface contained nextgroup=vi9InterfaceName skipwhite
                            
                            # this
    6              0.000092000 syntax match vi9This /\<this\>/ containedin=vi9FuncSignature,vi9OperParen
                            
                            # public
                            # static
                            # public static
    6              0.000088000 syntax keyword vi9Public public contained nextgroup=vi9Static,vi9Declare skipwhite
    6              0.000063000 syntax keyword vi9Static static contained nextgroup=vi9Declare skipwhite
                            
                            # abstract
    6              0.000063000 syntax keyword vi9Abstract abstract contained nextgroup=vi9Class skipwhite
                            
                            # :enum
                            # :endenum
    6              0.000498000 syntax region vi9Enum
                                \ matchgroup=Statement
                                \ start=/\<enum\>\s\+\%(\u\w*\)\@=/
                                \ end=/^\s*\<endenum\>/
                                \ contains=
                                \     @vi9Expr,
                                \     @vi9OOP,
                                \     vi9Comment,
                                \     vi9Continuation,
                                \     vi9DataTypeListDict,
                                \     vi9Declare,
                                \     vi9EnumValue,
                                \     vi9FuncEnd,
                                \     vi9FuncHeader,
                                \     vi9MayBeCmd,
                                \     vi9OperAssign,
                                \     vi9Return
                                \ nextgroup=vi9EnumName
                                \ skipwhite
                            
    6              0.000026000 syntax match vi9EnumName /\%(\<enum\s\)\@5<=\u\w*/ contained
    6              0.000039000 syntax match vi9EnumValue /\<\a\w*[(,]\@=\|\%(,\s\)\@2<=\<\a\w*$\|^\s*\u\w*$/ contained
                            
                            # :type
    6              0.000065000 syntax keyword vi9UserType type contained nextgroup=vi9UserTypeName skipwhite
    6              0.000049000 syntax match vi9UserTypeName /\u\w*/ contained nextgroup=vi9UserTypeAssignment skipwhite
    6              0.000034000 syntax match vi9UserTypeAssignment /=/ contained nextgroup=@vi9DataTypeCluster skipwhite
                            
    6              0.000010000 if get(g:, 'vim9_syntax', {})
                             ->get('user_types', false)
                                HighlightUserTypes()
                                autocmd_add([{
                                    cmd: 'HighlightUserTypes()',
                                    event: 'BufWritePost',
                                    group: 'vi9HighlightUserTypes',
                                    pattern: '<buffer>',
                                    replace: true,
                                }])
    6              0.000006000 endif
                            # }}}1
                            
                            # Highlight Groups {{{1
                            # All highlight groups need to be defined with the `default` argument.{{{
                            #
                            # So that they survive after we change/reload the colorscheme.
                            # Indeed,  a  colorscheme  always  executes  `:highlight  clear`  to  reset  all
                            # highlighting to the defaults.  By default,  the user-defined HGs do not exist,
                            # so for the latter, “reset all highlighting” means:
                            #
                            #    - removing all their attributes
                            #
                            #         $ vim --cmd 'highlight WillItSurvive ctermbg=green | highlight clear | highlight WillItSurvive | quit'
                            #         WillItSurvive  xxx cleared
                            #
                            #    - removing the links
                            #
                            #         $ vim --cmd 'highlight link WillItSurvive ErrorMsg | highlight clear | highlight WillItSurvive | quit'
                            #         WillItSurvive  xxx cleared
                            #}}}
                            
    6              0.000052000 highlight default link vi9GenericCmd Statement
                            # Make Vim highlight user commands in a similar way as for builtin Ex commands.{{{
                            #
                            # With a  twist: we  want them  to be  bold, so  that we  can't conflate  a user
                            # command with a builtin one.
                            #
                            # If you don't care about this distinction, you could get away with just:
                            #
                            #     highlight default link vi9UserCmdExe vi9GenericCmd
                            #}}}
                            # The guard makes sure the highlighting group is defined only if necessary.{{{
                            #
                            # Note that when the syntax item  for `vi9UserCmdExe` was defined earlier (with
                            # a `:syntax` command), Vim has automatically created a highlight group with the
                            # same name; but it's cleared:
                            #
                            #     vi9UserCmdExe      xxx cleared
                            #
                            # That's why we need the `->get('cleared')`.
                            #}}}
    6              0.000131000 if hlget('vi9UserCmdExe')->get(0, {})->get('cleared')
    1              0.000044000     Derive('vi9FuncCallUser', 'Function', {gui: {bold: true}, term: {bold: true}, cterm: {bold: true}})
    1              0.000018000     Derive('vi9UserCmdExe', 'vi9GenericCmd', {gui: {bold: true}, term: {bold: true}, cterm: {bold: true}})
    1              0.000015000     Derive('vi9FuncHeader', 'Function', {gui: {bold: true}, term: {bold: true}, cterm: {bold: true}})
    1              0.000017000     Derive('vi9CmdModifier', 'vi9GenericCmd', {gui: {italic: true}, term: {italic: true}, cterm: {italic: true}})
    6              0.000007000 endif
                            
    6              0.000033000 highlight default link vi9Error Error
                            
    6              0.000040000 highlight default link vi9Abstract Special
    6              0.000042000 highlight default link vi9AutocmdEventBadCase vi9Error
    6              0.000037000 highlight default link vi9Class Keyword
    6              0.000037000 highlight default link vi9CollationClassErr vi9Error
    6              0.000040000 highlight default link vi9DeclareError vi9Error
    6              0.000032000 highlight default link vi9DefBangError vi9Error
    6              0.000040000 highlight default link vi9DeprecatedDictLiteralLegacy vi9Error
    6              0.000042000 highlight default link vi9DeprecatedIsOperator vi9Error
    6              0.000039000 highlight default link vi9DeprecatedLet vi9Error
    6              0.000039000 highlight default link vi9DeprecatedScopes vi9Error
    6              0.000030000 highlight default link vi9DictMayBeLiteralKey vi9Error
    6              0.000037000 highlight default link vi9DigraphsCharsInvalid vi9Error
    6              0.000033000 highlight default link vi9EnumName Type
    6              0.000031000 highlight default link vi9EnumValue Constant
    6              0.000036000 highlight default link vi9EscapeSequence Special
    6              0.000031000 highlight default link vi9Extends Keyword
    6              0.000037000 highlight default link vi9FTError vi9Error
    6              0.000039000 highlight default link vi9Implements Keyword
    6              0.000043000 highlight default link vi9IncrementError vi9Error
    6              0.000038000 highlight default link vi9Interface Keyword
    6              0.000034000 highlight default link vi9LambdaDictMissingParen vi9Error
    6              0.000031000 highlight default link vi9LegacyAutoloadInvalid vi9Error
    6              0.000032000 highlight default link vi9LegacyConcatInvalid vi9Error
    6              0.000030000 highlight default link vi9LegacyDotEqual vi9Error
    6              0.000031000 highlight default link vi9LegacyFuncArgs vi9Error
    6              0.000029000 highlight default link vi9LegacyVarArgs vi9Error
    6              0.000035000 highlight default link vi9MapModErr vi9Error
    6              0.000036000 highlight default link vi9MarkCmdArgInvalid vi9Error
    6              0.000040000 highlight default link vi9NoWhitespaceBeforeInit vi9Error
    6              0.000030000 highlight default link vi9NumberOctalWarn vi9Error
    6              0.000039000 highlight default link vi9OperError vi9Error
    6              0.000034000 highlight default link vi9PatSepErr vi9Error
    6              0.000034000 highlight default link vi9ProfileSubCmdInvalid vi9Error
    6              0.000037000 highlight default link vi9Public vi9Declare
    6              0.000041000 highlight default link vi9RangeMissingSpace vi9Error
    6              0.000042000 highlight default link vi9RangeMissingSpecifier1 vi9Error
    6              0.000039000 highlight default link vi9RangeMissingSpecifier2 vi9Error
    6              0.000037000 highlight default link vi9ReservedNames vi9Error
    6              0.000040000 highlight default link vi9SIUB vi9Error
    6              0.000029000 highlight default link vi9SetEqualError vi9Error
    6              0.000032000 highlight default link vi9SpaceAfterFuncHeader vi9Error
    6              0.000033000 highlight default link vi9SpaceAfterLegacyFuncHeader vi9Error
    6              0.000030000 highlight default link vi9SpaceExtraBetweenArgs vi9Error
    6              0.000029000 highlight default link vi9SpaceMissingBetweenArgs vi9Error
    6              0.000029000 highlight default link vi9SpaceMissingListSlice vi9Error
    6              0.000030000 highlight default link vi9Specifies Keyword
    6              0.000037000 highlight default link vi9Static vi9Declare
    6              0.000033000 highlight default link vi9StrictWhitespace vi9Error
    6              0.000033000 highlight default link vi9SubstFlagErr vi9Error
    6              0.000033000 highlight default link vi9SynCaseError vi9Error
    6              0.000032000 highlight default link vi9SynCaseError vi9Error
    6              0.000034000 highlight default link vi9SynError vi9Error
    6              0.000033000 highlight default link vi9SyncError vi9Error
    6              0.000040000 highlight default link vi9This Structure
    6              0.000037000 highlight default link vi9UserCmdAttrError vi9Error
    6              0.000037000 highlight default link vi9UserType Identifier
    6              0.000032000 highlight default link vi9UserTypeAssignment Identifier
    6              0.000033000 highlight default link vi9WincmdArgInvalid vi9Error
                            
    6              0.000054000 highlight default link vi9AbbrevCmd vi9GenericCmd
    6              0.000049000 highlight default link vi9Augroup vi9GenericCmd
    6              0.000043000 highlight default link vi9AugroupNameEnd Title
    6              0.000049000 highlight default link vi9Autocmd vi9GenericCmd
    6              0.000047000 highlight default link vi9AutocmdAllEvents vi9AutocmdEventGoodCase
    6              0.000042000 highlight default link vi9AutocmdEventGoodCase Type
    6              0.000047000 highlight default link vi9AutocmdGroup vi9AugroupNameEnd
    6              0.000041000 highlight default link vi9AutocmdMod Special
    6              0.000045000 highlight default link vi9AutocmdPat vi9String
    6              0.000033000 highlight default link vi9BacktickExpansion vi9ShellCmd
    6              0.000045000 highlight default link vi9BangCmd vi9GenericCmd
    6              0.000037000 highlight default link vi9BangLastShellCmd Special
    6              0.000033000 highlight default link vi9BangShellCmd vi9ShellCmd
    6              0.000031000 highlight default link vi9Bool Boolean
    6              0.000043000 highlight default link vi9BracketKey Delimiter
    6              0.000043000 highlight default link vi9BracketNotation Special
    6              0.000046000 highlight default link vi9BreakContinue vi9Repeat
    6              0.000047000 highlight default link vi9Cd vi9GenericCmd
    6              0.000043000 highlight default link vi9Comment Comment
    6              0.000036000 highlight default link vi9CommentContinuation vi9Continuation
    6              0.000034000 highlight default link vi9CommentTitle PreProc
    6              0.000054000 highlight default link vi9Conditional Conditional
    6              0.000038000 highlight default link vi9Continuation Special
    6              0.000044000 highlight default link vi9ContinuationBeforeCmd vi9Continuation
    6              0.000044000 highlight default link vi9ContinuationBeforeUserCmd vi9Continuation
    6              0.000049000 highlight default link vi9CopyMove vi9GenericCmd
    6              0.000038000 highlight default link vi9CtrlChar SpecialChar
    6              0.000043000 highlight default link vi9Declare Identifier
    6              0.000047000 highlight default link vi9DeclareHereDoc vi9Declare
    6              0.000057000 highlight default link vi9DeclareHereDocStop vi9Declare
    6              0.000076000 highlight default link vi9DefKey Keyword
    6              0.000033000 highlight default link vi9DictIsLiteralKey String
    6              0.000044000 highlight default link vi9DigraphsChars vi9String
    6              0.000047000 highlight default link vi9DigraphsCmd vi9GenericCmd
    6              0.000044000 highlight default link vi9DigraphsNumber vi9Number
    6              0.000046000 highlight default link vi9DoCmds vi9Repeat
    6              0.000048000 highlight default link vi9Doautocmd vi9GenericCmd
    6              0.000048000 highlight default link vi9EchoHL vi9GenericCmd
    6              0.000042000 highlight default link vi9EchoHLNone vi9Group
    6              0.000079000 highlight default link vi9EvalExpr vi9OperAssign
    6              0.000055000 highlight default link vi9ExSpecialCharacters vi9BracketNotation
    6              0.000049000 highlight default link vi9Export vi9Import
    6              0.000045000 highlight default link vi9FTCmd vi9GenericCmd
    6              0.000042000 highlight default link vi9FTOption vi9SynType
    6              0.000044000 highlight default link vi9Finish vi9Return
    6              0.000034000 highlight default link vi9FuncArgs Identifier
    6              0.000040000 highlight default link vi9FuncEnd vi9DefKey
    6              0.000034000 highlight default link vi9GenericFunctionCallDataType Type
    6              0.000035000 highlight default link vi9GenericTypes Type
    6              0.000046000 highlight default link vi9Global vi9GenericCmd
    6              0.000042000 highlight default link vi9GlobalPat vi9String
    6              0.000039000 highlight default link vi9Group Type
    6              0.000038000 highlight default link vi9GroupAdd vi9SynOption
    6              0.000037000 highlight default link vi9GroupName vi9Group
    6              0.000034000 highlight default link vi9GroupRem vi9SynOption
    6              0.000036000 highlight default link vi9GroupSpecial Special
    6              0.000041000 highlight default link vi9HLGroup vi9Group
    6              0.000043000 highlight default link vi9HereDoc vi9String
    6              0.000043000 highlight default link vi9HiAttr PreProc
    6              0.000041000 highlight default link vi9HiCterm vi9HiTerm
    6              0.000043000 highlight default link vi9HiCtermFgBg vi9HiTerm
    6              0.000043000 highlight default link vi9HiCtermul vi9HiTerm
    6              0.000041000 highlight default link vi9HiEqual vi9OperAssign
    6              0.000041000 highlight default link vi9HiFgBgAttr vi9HiAttr
    6              0.000041000 highlight default link vi9HiGroup vi9GroupName
    6              0.000040000 highlight default link vi9HiGui vi9HiTerm
    6              0.000045000 highlight default link vi9HiGuiFgBg vi9HiTerm
    6              0.000041000 highlight default link vi9HiGuiFont vi9HiTerm
    6              0.000042000 highlight default link vi9HiGuiRgb vi9Number
    6              0.000039000 highlight default link vi9HiNumber Number
    6              0.000054000 highlight default link vi9HiStartStop vi9HiTerm
    6              0.000038000 highlight default link vi9HiTerm Type
    6              0.000046000 highlight default link vi9Highlight vi9GenericCmd
    6              0.000045000 highlight default link vi9Import Include
    6              0.000045000 highlight default link vi9ImportAs vi9Import
    6              0.000042000 highlight default link vi9ImportedScript vi9String
    6              0.000042000 highlight default link vi9Increment vi9Oper
    6              0.000035000 highlight default link vi9IsOption PreProc
    6              0.000037000 highlight default link vi9IskSep Delimiter
    6              0.000034000 highlight default link vi9LambdaArgs vi9FuncArgs
    6              0.000038000 highlight default link vi9LambdaArrow vi9Sep
    6              0.000039000 highlight default link vi9LegacyComment vi9Comment
    6              0.000039000 highlight default link vi9LegacyString vi9String
    6              0.000039000 highlight default link vi9Line12MissingColon vi9Error
    6              0.000046000 highlight default link vi9Map vi9GenericCmd
    6              0.000043000 highlight default link vi9MapMod vi9BracketKey
    6              0.000040000 highlight default link vi9MapModExpr vi9MapMod
    6              0.000037000 highlight default link vi9MapModKey Special
    6              0.000047000 highlight default link vi9MarkCmd vi9GenericCmd
    6              0.000038000 highlight default link vi9MarkCmdArg Special
    6              0.000042000 highlight default link vi9MatchComment vi9Comment
    6              0.000034000 highlight default link vi9None Constant
    6              0.000049000 highlight default link vi9Norm vi9GenericCmd
    6              0.000036000 highlight default link vi9NormCmds String
    6              0.000041000 highlight default link vi9NotPatSep vi9String
    6              0.000033000 highlight default link vi9Null Constant
    6              0.000040000 highlight default link vi9Number Number
    6              0.000033000 highlight default link vi9Oper Operator
    6              0.000038000 highlight default link vi9OperAssign Identifier
    6              0.000031000 highlight default link vi9OptionSigil vi9IsOption
    6              0.000035000 highlight default link vi9ParenSep Delimiter
    6              0.000036000 highlight default link vi9PatSep SpecialChar
    6              0.000040000 highlight default link vi9PatSepR vi9PatSep
    6              0.000035000 highlight default link vi9PatSepZ vi9PatSep
    6              0.000046000 highlight default link vi9ProfileCmd vi9GenericCmd
    6              0.000040000 highlight default link vi9ProfilePat vi9String
    6              0.000043000 highlight default link vi9RangeMark Special
    6              0.000042000 highlight default link vi9RangeNumber Number
    6              0.000044000 highlight default link vi9RangeOffset Number
    6              0.000041000 highlight default link vi9RangePattern String
    6              0.000044000 highlight default link vi9RangePatternBwdDelim Delimiter
    6              0.000041000 highlight default link vi9RangePatternFwdDelim Delimiter
    6              0.000043000 highlight default link vi9RangeSpecialSpecifier Special
    6              0.000049000 highlight default link vi9RegistersCmd vi9GenericCmd
    6              0.000042000 highlight default link vi9Repeat Repeat
    6              0.000047000 highlight default link vi9RepeatForDeclareName vi9Declare
    6              0.000046000 highlight default link vi9RepeatForIn vi9Repeat
    6              0.000040000 highlight default link vi9Return vi9DefKey
    6              0.000060000 highlight default link vi9SILB vi9String
    6              0.000038000 highlight default link vi9ScriptDelim vi9DeclareHereDoc
    6              0.000039000 highlight default link vi9Sep Delimiter
    6              0.000047000 highlight default link vi9Set vi9GenericCmd
    6              0.000045000 highlight default link vi9SetBracketEqual vi9OperAssign
    6              0.000047000 highlight default link vi9SetBracketKeycode vi9String
    6              0.000033000 highlight default link vi9SetEqual vi9OperAssign
    6              0.000032000 highlight default link vi9SetMod vi9IsOption
    6              0.000031000 highlight default link vi9SetNumberValue Number
    6              0.000032000 highlight default link vi9SetSep Delimiter
    6              0.000032000 highlight default link vi9SetStringValue String
    6              0.000033000 highlight default link vi9ShellCmd PreProc
    6              0.000038000 highlight default link vi9SpecFile Identifier
    6              0.000036000 highlight default link vi9SpecFileMod vi9SpecFile
    6              0.000039000 highlight default link vi9String String
    6              0.000043000 highlight default link vi9StringInterpolated vi9String
    6              0.000047000 highlight default link vi9Subst vi9GenericCmd
    6              0.000041000 highlight default link vi9SubstDelim Delimiter
    6              0.000036000 highlight default link vi9SubstFlags Special
    6              0.000041000 highlight default link vi9SubstPat vi9String
    6              0.000041000 highlight default link vi9SubstRep vi9String
    6              0.000039000 highlight default link vi9SubstSubstr SpecialChar
    6              0.000041000 highlight default link vi9SubstTwoBS vi9String
    6              0.000038000 highlight default link vi9SynCase Type
    6              0.000035000 highlight default link vi9SynContains vi9SynOption
    6              0.000033000 highlight default link vi9SynContinuePattern String
    6              0.000040000 highlight default link vi9SynEqual vi9OperAssign
    6              0.000038000 highlight default link vi9SynEqualMatchGroup vi9OperAssign
    6              0.000040000 highlight default link vi9SynEqualRegion vi9OperAssign
    6              0.000039000 highlight default link vi9SynExeCmd vi9GenericCmd
    6              0.000036000 highlight default link vi9SynExeGroupName vi9GroupName
    6              0.000036000 highlight default link vi9SynExeType vi9SynType
    6              0.000039000 highlight default link vi9SynKeyContainedin vi9SynContains
    6              0.000033000 highlight default link vi9SynKeyOpt vi9SynOption
    6              0.000034000 highlight default link vi9SynMatchOpt vi9SynOption
    6              0.000032000 highlight default link vi9SynMatchgroup vi9SynOption
    6              0.000034000 highlight default link vi9SynNextgroup vi9SynOption
    6              0.000035000 highlight default link vi9SynNotPatRange vi9SynRegPat
    6              0.000033000 highlight default link vi9SynOption Special
    6              0.000041000 highlight default link vi9SynPatRange vi9String
    6              0.000035000 highlight default link vi9SynRegOpt vi9SynOption
    6              0.000038000 highlight default link vi9SynRegPat vi9String
    6              0.000037000 highlight default link vi9SynRegStartSkipEnd Type
    6              0.000036000 highlight default link vi9SynType Type
    6              0.000037000 highlight default link vi9SyncC Type
    6              0.000038000 highlight default link vi9SyncGroup vi9GroupName
    6              0.000037000 highlight default link vi9SyncGroupName vi9GroupName
    6              0.000036000 highlight default link vi9SyncKey Type
    6              0.000037000 highlight default link vi9SyncNone Type
    6              0.000048000 highlight default link vi9Syntax vi9GenericCmd
    6              0.000032000 highlight default link vi9Todo Todo
    6              0.000042000 highlight default link vi9TryCatch Exception
    6              0.000043000 highlight default link vi9TryCatchPattern String
    6              0.000041000 highlight default link vi9TryCatchPatternDelim Delimiter
    6              0.000048000 highlight default link vi9Unmap vi9Map
    6              0.000047000 highlight default link vi9UserCmdAttrAddress vi9String
    6              0.000045000 highlight default link vi9UserCmdAttrAddress vi9String
    6              0.000045000 highlight default link vi9UserCmdAttrComma vi9Sep
    6              0.000045000 highlight default link vi9UserCmdAttrComplete vi9String
    6              0.000045000 highlight default link vi9UserCmdAttrEqual vi9OperAssign
    6              0.000037000 highlight default link vi9UserCmdAttrErrorValue vi9Error
    6              0.000041000 highlight default link vi9UserCmdAttrName Type
    6              0.000046000 highlight default link vi9UserCmdAttrNargs vi9String
    6              0.000044000 highlight default link vi9UserCmdAttrNargsNumber vi9Number
    6              0.000045000 highlight default link vi9UserCmdAttrRange vi9String
    6              0.000043000 highlight default link vi9UserCmdDef Statement
    6              0.000047000 highlight default link vi9UserCmdLhs vi9UserCmdExe
    6              0.000051000 highlight default link vi9UserCmdRhsEscapeSeq vi9BracketNotation
    6              0.000047000 highlight default link vi9VimGrep vi9GenericCmd
    6              0.000040000 highlight default link vi9VimGrepPat vi9String
    6              0.000047000 highlight default link vi9Wincmd vi9GenericCmd
    6              0.000039000 highlight default link vi9WincmdArg vi9String
                            
    6              0.000013000 if get(g:, 'vim9_syntax', {})
                             ->get('builtin_functions', true)
    6              0.000037000     highlight default link vi9FuncNameBuiltin Function
    6              0.000005000 endif
                            
    6              0.000011000 if get(g:, 'vim9_syntax', {})
                             ->get('data_types', true)
    6              0.000042000     highlight default link vi9DataType Type
    6              0.000041000     highlight default link vi9DataTypeCast vi9DataType
    6              0.000038000     highlight default link vi9ValidSubType vi9DataType
    6              0.000004000 endif
                            #}}}1
                            
    6              0.000041000 b:current_syntax = 'vim9'

SCRIPT  /Users/danbradbury/.vim/bundle/vim9-syntax/import/vim9Language.vim
Sourced 1 time
Total time:   0.000898000
 Self time:   0.000898000

count     total (s)      self (s)
    1              0.000001000 vim9script
                            
                            # DO NOT EDIT THIS FILE DIRECTLY.
                            # It is meant to be generated by ./tools/GenerateImport.vim
                            
                            # builtin_func {{{1
                            
    1              0.000001000 const builtin_func_list: list<string> =<< trim END
                                abs
                                acos
                                add
                                and
                                appendbufline
                                argc
                                argidx
                                arglistid
                                argv
                                asin
                                assert_beeps
                                assert_equal
                                assert_equalfile
                                assert_exception
                                assert_fails
                                assert_false
                                assert_inrange
                                assert_match
                                assert_nobeep
                                assert_notequal
                                assert_notmatch
                                assert_report
                                assert_true
                                atan
                                atan2
                                autocmd_add
                                autocmd_delete
                                autocmd_get
                                balloon_gettext
                                balloon_show
                                balloon_split
                                base64_decode
                                base64_encode
                                bindtextdomain
                                blob2list
                                blob2str
                                browsedir
                                bufadd
                                bufexists
                                buffer_exists
                                buffer_name
                                buffer_number
                                buflisted
                                bufload
                                bufloaded
                                bufname
                                bufnr
                                bufwinid
                                bufwinnr
                                byte2line
                                byteidx
                                byteidxcomp
                                ceil
                                ch_canread
                                ch_close
                                ch_close_in
                                ch_evalexpr
                                ch_evalraw
                                ch_getbufnr
                                ch_getjob
                                ch_info
                                ch_log
                                ch_logfile
                                ch_open
                                ch_read
                                ch_readblob
                                ch_readraw
                                ch_sendexpr
                                ch_sendraw
                                ch_setoptions
                                ch_status
                                changenr
                                char2nr
                                charclass
                                charcol
                                charidx
                                cindent
                                clearmatches
                                cmdcomplete_info
                                col
                                complete
                                complete_add
                                complete_check
                                complete_info
                                complete_match
                                cos
                                cosh
                                count
                                cscope_connection
                                cursor
                                deepcopy
                                deletebufline
                                did_filetype
                                diff
                                diff_filler
                                diff_hlID
                                digraph_get
                                digraph_getlist
                                digraph_set
                                digraph_setlist
                                echoraw
                                empty
                                environ
                                err_teapot
                                escape
                                eventhandler
                                executable
                                exepath
                                exists
                                exists_compiled
                                exp
                                expand
                                expandcmd
                                extend
                                extendnew
                                feedkeys
                                file_readable
                                filecopy
                                filereadable
                                filewritable
                                finddir
                                findfile
                                flatten
                                flattennew
                                float2nr
                                floor
                                fmod
                                fnameescape
                                fnamemodify
                                foldclosed
                                foldclosedend
                                foldlevel
                                foldtext
                                foldtextresult
                                foreach
                                foreground
                                fullcommand
                                funcref
                                garbagecollect
                                get
                                getbufinfo
                                getbufline
                                getbufoneline
                                getbufvar
                                getcellpixels
                                getcellwidths
                                getchangelist
                                getchar
                                getcharmod
                                getcharpos
                                getcharsearch
                                getcharstr
                                getcmdcomplpat
                                getcmdcompltype
                                getcmdline
                                getcmdpos
                                getcmdprompt
                                getcmdscreenpos
                                getcmdtype
                                getcmdwintype
                                getcompletion
                                getcompletiontype
                                getcurpos
                                getcursorcharpos
                                getcwd
                                getenv
                                getfontname
                                getfperm
                                getfsize
                                getftime
                                getftype
                                getimstatus
                                getjumplist
                                getline
                                getloclist
                                getmarklist
                                getmatches
                                getmousepos
                                getmouseshape
                                getpid
                                getpos
                                getqflist
                                getreg
                                getreginfo
                                getregion
                                getregionpos
                                getregtype
                                getscriptinfo
                                getstacktrace
                                gettabinfo
                                gettabvar
                                gettabwinvar
                                gettagstack
                                gettext
                                getwininfo
                                getwinpos
                                getwinposx
                                getwinposy
                                getwinvar
                                glob
                                glob2regpat
                                globpath
                                has
                                has_key
                                haslocaldir
                                hasmapto
                                highlightID
                                highlight_exists
                                histadd
                                histdel
                                histget
                                histnr
                                hlID
                                hlexists
                                hlget
                                hlset
                                hostname
                                iconv
                                id
                                indent
                                index
                                indexof
                                input
                                inputdialog
                                inputlist
                                inputrestore
                                inputsave
                                inputsecret
                                instanceof
                                interrupt
                                invert
                                isabsolutepath
                                isdirectory
                                isinf
                                islocked
                                isnan
                                items
                                job_getchannel
                                job_info
                                job_setoptions
                                job_start
                                job_status
                                job_stop
                                js_decode
                                js_encode
                                json_decode
                                json_encode
                                keys
                                keytrans
                                last_buffer_nr
                                len
                                libcall
                                libcallnr
                                line
                                line2byte
                                lispindent
                                list2blob
                                list2str
                                list2tuple
                                listener_add
                                listener_flush
                                listener_remove
                                localtime
                                log
                                log10
                                maparg
                                mapcheck
                                maplist
                                mapnew
                                mapset
                                matchadd
                                matchaddpos
                                matcharg
                                matchbufline
                                matchdelete
                                matchend
                                matchfuzzy
                                matchfuzzypos
                                matchlist
                                matchstr
                                matchstrlist
                                matchstrpos
                                max
                                menu_info
                                min
                                mkdir
                                nextnonblank
                                ngettext
                                nr2char
                                or
                                pathshorten
                                popup_atcursor
                                popup_beval
                                popup_clear
                                popup_close
                                popup_create
                                popup_dialog
                                popup_filter_menu
                                popup_filter_yesno
                                popup_findecho
                                popup_findinfo
                                popup_findpreview
                                popup_getoptions
                                popup_getpos
                                popup_hide
                                popup_list
                                popup_locate
                                popup_menu
                                popup_move
                                popup_notification
                                popup_setbuf
                                popup_setoptions
                                popup_settext
                                popup_show
                                pow
                                preinserted
                                prevnonblank
                                printf
                                prompt_getprompt
                                prompt_setcallback
                                prompt_setinterrupt
                                prompt_setprompt
                                prop_add
                                prop_add_list
                                prop_clear
                                prop_find
                                prop_list
                                prop_remove
                                prop_type_add
                                prop_type_change
                                prop_type_delete
                                prop_type_get
                                prop_type_list
                                pum_getpos
                                pumvisible
                                py3eval
                                pyxeval
                                rand
                                range
                                readblob
                                readdir
                                readdirex
                                readfile
                                reduce
                                reg_executing
                                reg_recording
                                reltime
                                reltimefloat
                                reltimestr
                                remote_expr
                                remote_foreground
                                remote_peek
                                remote_read
                                remote_send
                                remote_startserver
                                remove
                                rename
                                repeat
                                resolve
                                reverse
                                round
                                screenattr
                                screenchar
                                screenchars
                                screencol
                                screenpos
                                screenrow
                                screenstring
                                search
                                searchcount
                                searchdecl
                                searchpair
                                searchpairpos
                                searchpos
                                server2client
                                serverlist
                                setbufline
                                setbufvar
                                setcellwidths
                                setcharpos
                                setcharsearch
                                setcmdline
                                setcmdpos
                                setcursorcharpos
                                setenv
                                setfperm
                                setline
                                setloclist
                                setmatches
                                setpos
                                setqflist
                                setreg
                                settabvar
                                settabwinvar
                                settagstack
                                setwinvar
                                sha256
                                shellescape
                                shiftwidth
                                sign_define
                                sign_getdefined
                                sign_getplaced
                                sign_jump
                                sign_place
                                sign_placelist
                                sign_undefine
                                sign_unplace
                                sign_unplacelist
                                simplify
                                sin
                                sinh
                                slice
                                sound_clear
                                sound_playevent
                                sound_playfile
                                sound_stop
                                soundfold
                                spellbadword
                                spellsuggest
                                sqrt
                                srand
                                state
                                str2blob
                                str2float
                                str2list
                                str2nr
                                strcharlen
                                strcharpart
                                strchars
                                strdisplaywidth
                                strftime
                                strgetchar
                                stridx
                                string
                                strlen
                                strpart
                                strptime
                                strridx
                                strtrans
                                strutf16len
                                strwidth
                                submatch
                                swapfilelist
                                swapinfo
                                synID
                                synIDattr
                                synIDtrans
                                synconcealed
                                synstack
                                system
                                systemlist
                                tabpagebuflist
                                tabpagenr
                                tabpagewinnr
                                tagfiles
                                taglist
                                tan
                                tanh
                                tempname
                                term_dumpdiff
                                term_dumpload
                                term_dumpwrite
                                term_getaltscreen
                                term_getansicolors
                                term_getattr
                                term_getcursor
                                term_getjob
                                term_getline
                                term_getscrolled
                                term_getsize
                                term_getstatus
                                term_gettitle
                                term_gettty
                                term_list
                                term_scrape
                                term_sendkeys
                                term_setansicolors
                                term_setapi
                                term_setkill
                                term_setrestore
                                term_setsize
                                term_start
                                term_wait
                                terminalprops
                                test_alloc_fail
                                test_autochdir
                                test_feedinput
                                test_garbagecollect_now
                                test_garbagecollect_soon
                                test_getvalue
                                test_gui_event
                                test_ignore_error
                                test_mswin_event
                                test_null_blob
                                test_null_channel
                                test_null_dict
                                test_null_function
                                test_null_job
                                test_null_list
                                test_null_partial
                                test_null_string
                                test_null_tuple
                                test_option_not_set
                                test_override
                                test_refcount
                                test_setmouse
                                test_settime
                                test_srand_seed
                                test_unknown
                                test_void
                                timer_info
                                timer_pause
                                timer_start
                                timer_stop
                                timer_stopall
                                tolower
                                toupper
                                tr
                                trim
                                trunc
                                tuple2list
                                typename
                                undofile
                                undotree
                                uri_decode
                                uri_encode
                                utf16idx
                                values
                                virtcol
                                virtcol2col
                                visualmode
                                wildmenumode
                                wildtrigger
                                win_execute
                                win_findbuf
                                win_getid
                                win_gettype
                                win_gotoid
                                win_id2tabwin
                                win_id2win
                                win_move_separator
                                win_move_statusline
                                win_screenpos
                                win_splitmove
                                winbufnr
                                wincol
                                windowsversion
                                winheight
                                winlayout
                                winline
                                winnr
                                winrestcmd
                                winrestview
                                winsaveview
                                winwidth
                                wordcount
                                writefile
                                xor
                                debugbreak
                                luaeval
                                mzeval
                                perleval
                                pyeval
                                rubyeval
                            END
                            
    1              0.000020000 export const builtin_func: string = builtin_func_list->join()
                            
                            # builtin_func_ambiguous {{{1
                            
    1              0.000001000 const builtin_func_ambiguous_list: list<string> =<< trim END
                                append
                                browse
                                call
                                chdir
                                confirm
                                copy
                                delete
                                eval
                                execute
                                filter
                                function
                                insert
                                join
                                map
                                match
                                mode
                                sort
                                split
                                substitute
                                swapname
                                type
                                uniq
                            END
                            
    1              0.000003000 export const builtin_func_ambiguous: string = builtin_func_ambiguous_list->join("\\|")
                            
                            # collation_class {{{1
                            
    1              0.000001000 const collation_class_list: list<string> =<< trim END
                                alnum
                                alpha
                                backspace
                                blank
                                cntrl
                                digit
                                escape
                                fname
                                graph
                                ident
                                keyword
                                lower
                                print
                                punct
                                return
                                space
                                tab
                                upper
                                xdigit
                            END
                            
    1              0.000002000 export const collation_class: string = collation_class_list->join("\\|")
                            
                            # command_address_type {{{1
                            
    1              0.000001000 const command_address_type_list: list<string> =<< trim END
                                arguments
                                buffers
                                lines
                                loaded_buffers
                                other
                                quickfix
                                tabs
                                windows
                            END
                            
    1              0.000002000 export const command_address_type: string = command_address_type_list->join("\\|")
                            
                            # command_can_be_before {{{1
                            
    1              0.000002000 export const command_can_be_before: string = '\%([[:blank:]\n]\@=\|\c<\%(bar\|cr\)>\)\%(\s*\%([-+*/%]=\|=\s\|=<<\|\.\.=\)\|\_s*\%(->\|[-+*/%]\%(\s\+\)\@>[^|<]\)\)\@!'
                            
                            # command_complete_type {{{1
                            
    1              0.000001000 const command_complete_type_list: list<string> =<< trim END
                                arglist
                                augroup
                                behave
                                breakpoint
                                buffer
                                color
                                command
                                compiler
                                cscope
                                customlist
                                custom
                                diff_buffer
                                dir_in_path
                                dir
                                environment
                                event
                                expression
                                file_in_path
                                filetypecmd
                                filetype
                                file
                                function
                                help
                                highlight
                                history
                                keymap
                                locale
                                mapclear
                                mapping
                                menu
                                messages
                                option
                                packadd
                                retab
                                runtime
                                scriptnames
                                shellcmdline
                                shellcmd
                                sign
                                syntax
                                syntime
                                tag_listfiles
                                tag
                                user
                                var
                            END
                            
    1              0.000003000 export const command_complete_type: string = command_complete_type_list->join("\\|")
                            
                            # command_modifier {{{1
                            
    1              0.000000000 const command_modifier_list: list<string> =<< trim END
                                abo\%[veleft]
                                bel\%[owright]
                                bo\%[tright]
                                bro\%[wse]
                                conf\%[irm]
                                hid\%[e]
                                keepa\%[lt]
                                keepj\%[umps]
                                ke\%[epmarks]
                                keepp\%[atterns]
                                lefta\%[bove]
                                leg\%[acy]
                                loc\%[kmarks]
                                noa\%[utocmd]
                                nos\%[wapfile]
                                rightb\%[elow]
                                san\%[dbox]
                                sil\%[ent]
                                tab
                                to\%[pleft]
                                uns\%[ilent]
                                verb\%[ose]
                                vert\%[ical]
                                vim9\%[cmd]
                            END
                            
    1              0.000002000 export const command_modifier: string = command_modifier_list->join("\\|")
                            
                            # command_name {{{1
                            
    1              0.000001000 const command_name_list: list<string> =<< trim END
                                al[l]
                                am[enu]
                                an[oremenu]
                                arga[dd]
                                argded[upe]
                                argd[elete]
                                arge[dit]
                                argg[lobal]
                                argl[ocal]
                                ar[gs]
                                argu[ment]
                                as[cii]
                                aun[menu]
                                bN[ext]
                                bad[d]
                                ba[ll]
                                balt
                                bd[elete]
                                be[have]
                                bf[irst]
                                bl[ast]
                                bm[odified]
                                bn[ext]
                                bp[revious]
                                breaka[dd]
                                breakd[el]
                                breakl[ist]
                                br[ewind]
                                b[uffer]
                                buffers
                                bun[load]
                                bw[ipeout]
                                cN[ext]
                                cNf[ile]
                                cabo[ve]
                                cad[dbuffer]
                                cadde[xpr]
                                caddf[ile]
                                caf[ter]
                                cal[l]
                                cbe[fore]
                                cbel[ow]
                                cbo[ttom]
                                cb[uffer]
                                cc
                                ccl[ose]
                                ce[nter]
                                cex[pr]
                                cf[ile]
                                cfir[st]
                                cgetb[uffer]
                                cgete[xpr]
                                cg[etfile]
                                changes
                                che[ckpath]
                                checkt[ime]
                                chi[story]
                                cla[st]
                                cle[arjumps]
                                clip[reset]
                                cl[ist]
                                clo[se]
                                cme[nu]
                                cnew[er]
                                cn[ext]
                                cnf[ile]
                                cnoreme[nu]
                                col[der]
                                colo[rscheme]
                                comc[lear]
                                comp[iler]
                                cope[n]
                                cpf[ile]
                                cp[revious]
                                cq[uit]
                                cr[ewind]
                                cs[cope]
                                cst[ag]
                                cunme[nu]
                                cw[indow]
                                deb[ug]
                                debugg[reedy]
                                def
                                defc[ompile]
                                defe[r]
                                delc[ommand]
                                d[elete]
                                delf[unction]
                                delm[arks]
                                diffg[et]
                                diffo[ff]
                                diffp[atch]
                                diffpu[t]
                                diffs[plit]
                                difft[his]
                                dif[fupdate]
                                disa[ssemble]
                                di[splay]
                                dj[ump]
                                dl[ist]
                                dr[op]
                                ds[earch]
                                dsp[lit]
                                ea[rlier]
                                ec[ho]
                                echoc[onsole]
                                echoe[rr]
                                echom[sg]
                                echon
                                echow[indow]
                                e[dit]
                                em[enu]
                                enddef
                                endf[unction]
                                ene[w]
                                ev[al]
                                ex
                                exe[cute]
                                exi[t]
                                exu[sage]
                                f[ile]
                                files
                                filt[er]
                                fin[d]
                                fir[st]
                                fix[del]
                                fo[ld]
                                foldc[lose]
                                folddoc[losed]
                                foldd[oopen]
                                foldo[pen]
                                fu[nction]
                                go[to]
                                gr[ep]
                                grepa[dd]
                                gu[i]
                                gv[im]
                                ha[rdcopy]
                                h[elp]
                                helpc[lose]
                                helpf[ind]
                                helpg[rep]
                                helpt[ags]
                                his[tory]
                                ho[rizontal]
                                ij[ump]
                                il[ist]
                                ime[nu]
                                inoreme[nu]
                                int[ro]
                                ip[ut]
                                is[earch]
                                isp[lit]
                                iunme[nu]
                                j[oin]
                                ju[mps]
                                lN[ext]
                                lNf[ile]
                                lab[ove]
                                laddb[uffer]
                                lad[dexpr]
                                laddf[ile]
                                laf[ter]
                                lan[guage]
                                la[st]
                                lat[er]
                                lbe[fore]
                                lbel[ow]
                                lbo[ttom]
                                lb[uffer]
                                lcl[ose]
                                lcs[cope]
                                le[ft]
                                lex[pr]
                                lf[ile]
                                lfir[st]
                                lgetb[uffer]
                                lgete[xpr]
                                lg[etfile]
                                lgr[ep]
                                lgrepa[dd]
                                lh[elpgrep]
                                lhi[story]
                                l[ist]
                                ll
                                lla[st]
                                lli[st]
                                lmak[e]
                                lnew[er]
                                lne[xt]
                                lnf[ile]
                                loadk[eymap]
                                lo[adview]
                                lockv[ar]
                                lol[der]
                                lop[en]
                                lpf[ile]
                                lp[revious]
                                lr[ewind]
                                ls
                                lt[ag]
                                luaf[ile]
                                lw[indow]
                                mak[e]
                                marks
                                mat[ch]
                                me[nu]
                                menut[ranslate]
                                mes[sages]
                                mk[exrc]
                                mks[ession]
                                mksp[ell]
                                mkvie[w]
                                mkv[imrc]
                                mzf[ile]
                                mz[scheme]
                                nbc[lose]
                                nb[key]
                                nbs[tart]
                                new
                                n[ext]
                                nme[nu]
                                nnoreme[nu]
                                noh[lsearch]
                                noreme[nu]
                                nu[mber]
                                nunme[nu]
                                ol[dfiles]
                                ome[nu]
                                on[ly]
                                onoreme[nu]
                                opt[ions]
                                ounme[nu]
                                ow[nsyntax]
                                pa[ckadd]
                                packl[oadall]
                                pb[uffer]
                                pc[lose]
                                ped[it]
                                po[p]
                                popu[p]
                                pp[op]
                                pre[serve]
                                prev[ious]
                                p[rint]
                                profd[el]
                                prof[ile]
                                pro[mptfind]
                                promptr[epl]
                                ps[earch]
                                ptN[ext]
                                pt[ag]
                                ptf[irst]
                                ptj[ump]
                                ptl[ast]
                                ptn[ext]
                                ptp[revious]
                                ptr[ewind]
                                pts[elect]
                                pu[t]
                                pw[d]
                                py3
                                py3f[ile]
                                pyf[ile]
                                pyx
                                pyxf[ile]
                                qa[ll]
                                q[uit]
                                quita[ll]
                                r[ead]
                                rec[over]
                                redi[r]
                                red[o]
                                redr[aw]
                                redraws[tatus]
                                redrawt[abline]
                                redrawtabp[anel]
                                reg[isters]
                                res[ize]
                                ret[ab]
                                rew[ind]
                                ri[ght]
                                rubyf[ile]
                                rund[o]
                                ru[ntime]
                                rv[iminfo]
                                sN[ext]
                                sal[l]
                                sa[rgument]
                                sav[eas]
                                sbN[ext]
                                sba[ll]
                                sbf[irst]
                                sbl[ast]
                                sbm[odified]
                                sbn[ext]
                                sbp[revious]
                                sbr[ewind]
                                sb[uffer]
                                scripte[ncoding]
                                sc[riptnames]
                                scriptv[ersion]
                                scs[cope]
                                setf[iletype]
                                sf[ind]
                                sfir[st]
                                sh[ell]
                                sig[n]
                                si[malt]
                                sla[st]
                                sl[eep]
                                sm[agic]
                                sme[nu]
                                smi[le]
                                sn[ext]
                                sno[magic]
                                snoreme[nu]
                                sor[t]
                                so[urce]
                                spelld[ump]
                                spe[llgood]
                                spelli[nfo]
                                spellra[re]
                                spellr[epall]
                                spellu[ndo]
                                spellw[rong]
                                sp[lit]
                                spr[evious]
                                sr[ewind]
                                sta[g]
                                startg[replace]
                                star[tinsert]
                                startr[eplace]
                                stj[ump]
                                st[op]
                                stopi[nsert]
                                sts[elect]
                                sun[hide]
                                sunme[nu]
                                sus[pend]
                                sv[iew]
                                sw[apname]
                                sync[bind]
                                synti[me]
                                tN[ext]
                                tabN[ext]
                                tabc[lose]
                                tabe[dit]
                                tabf[ind]
                                tabfir[st]
                                tabl[ast]
                                tabm[ove]
                                tabnew
                                tabn[ext]
                                tabo[nly]
                                tabp[revious]
                                tabr[ewind]
                                tabs
                                ta[g]
                                tags
                                tclf[ile]
                                te[aroff]
                                ter[minal]
                                tf[irst]
                                this
                                tj[ump]
                                tl[ast]
                                tlm[enu]
                                tln[oremenu]
                                tlu[nmenu]
                                tm[enu]
                                tn[ext]
                                tp[revious]
                                tr[ewind]
                                ts[elect]
                                tu[nmenu]
                                u[ndo]
                                undoj[oin]
                                undol[ist]
                                unh[ide]
                                uni[q]
                                unlo[ckvar]
                                unme[nu]
                                up[date]
                                ve[rsion]
                                vie[w]
                                vim9s[cript]
                                vi[sual]
                                viu[sage]
                                vme[nu]
                                vne[w]
                                vnoreme[nu]
                                vs[plit]
                                vunme[nu]
                                wN[ext]
                                wa[ll]
                                winp[os]
                                wi[nsize]
                                wl[restore]
                                wn[ext]
                                wp[revious]
                                wq
                                wqa[ll]
                                w[rite]
                                wu[ndo]
                                wv[iminfo]
                                xa[ll]
                                xme[nu]
                                xnoreme[nu]
                                xr[estore]
                                xunme[nu]
                                y[ank]
                                addd
                            END
                            
    1              0.000015000 export const command_name: string = command_name_list->join()
                            
                            # default_highlighting_group {{{1
                            
    1              0.000001000 const default_highlighting_group_list: list<string> =<< trim END
                                ColorColumn
                                ComplMatchIns
                                CurSearch
                                Cursor
                                CursorColumn
                                CursorIM
                                CursorLine
                                CursorLineFold
                                CursorLineNr
                                CursorLineSign
                                DiffAdd
                                DiffChange
                                DiffDelete
                                DiffText
                                DiffTextAdd
                                Directory
                                EndOfBuffer
                                ErrorMsg
                                FoldColumn
                                Folded
                                IncSearch
                                LineNr
                                LineNrAbove
                                LineNrBelow
                                MatchParen
                                Menu
                                MessageWindow
                                ModeMsg
                                MoreMsg
                                MsgArea
                                NonText
                                Normal
                                Pmenu
                                PmenuBorder
                                PmenuExtra
                                PmenuExtraSel
                                PmenuKind
                                PmenuKindSel
                                PmenuMatch
                                PmenuMatchSel
                                PmenuSbar
                                PmenuSel
                                PmenuShadow
                                PmenuThumb
                                PopupNotification
                                PopupSelected
                                PreInsert
                                Question
                                QuickFixLine
                                Scrollbar
                                Search
                                SignColumn
                                SpecialKey
                                SpellBad
                                SpellCap
                                SpellLocal
                                SpellRare
                                StatusLine
                                StatusLineNC
                                StatusLineTerm
                                StatusLineTermNC
                                TOhtmlProgress
                                TabLine
                                TabLineFill
                                TabLineSel
                                TabPanel
                                TabPanelFill
                                TabPanelSel
                                Terminal
                                Title
                                TitleBar
                                TitleBarNC
                                ToolbarButton
                                ToolbarLine
                                Tooltip
                                User1
                                User2
                                User3
                                User4
                                User5
                                User6
                                User7
                                User8
                                User9
                                VertSplit
                                Visual
                                VisualNOS
                                WarningMsg
                                WildMenu
                                debugBreakpoint
                                debugPC
                                lCursor
                            END
                            
    1              0.000004000 export const default_highlighting_group: string = default_highlighting_group_list->join()
                            
                            # event {{{1
                            
    1              0.000001000 const event_list: list<string> =<< trim END
                                BufAdd
                                BufCreate
                                BufDelete
                                BufEnter
                                BufFilePost
                                BufFilePre
                                BufHidden
                                BufLeave
                                BufNew
                                BufNewFile
                                BufRead
                                BufReadCmd
                                BufReadPost
                                BufReadPre
                                BufUnload
                                BufWinEnter
                                BufWinLeave
                                BufWipeout
                                BufWrite
                                BufWriteCmd
                                BufWritePost
                                BufWritePre
                                CmdUndefined
                                CmdlineChanged
                                CmdlineEnter
                                CmdlineLeave
                                CmdlineLeavePre
                                CmdwinEnter
                                CmdwinLeave
                                ColorScheme
                                ColorSchemePre
                                CompleteChanged
                                CompleteDone
                                CompleteDonePre
                                CursorHold
                                CursorHoldI
                                CursorMoved
                                CursorMovedC
                                CursorMovedI
                                DiffUpdated
                                DirChanged
                                DirChangedPre
                                EncodingChanged
                                ExitPre
                                FileAppendCmd
                                FileAppendPost
                                FileAppendPre
                                FileChangedRO
                                FileChangedShell
                                FileChangedShellPost
                                FileEncoding
                                FileReadCmd
                                FileReadPost
                                FileReadPre
                                FileType
                                FileWriteCmd
                                FileWritePost
                                FileWritePre
                                FilterReadPost
                                FilterReadPre
                                FilterWritePost
                                FilterWritePre
                                FocusGained
                                FocusLost
                                FuncUndefined
                                GUIEnter
                                GUIFailed
                                InsertChange
                                InsertCharPre
                                InsertEnter
                                InsertLeave
                                InsertLeavePre
                                KeyInputPre
                                MenuPopup
                                ModeChanged
                                OptionSet
                                QuickFixCmdPost
                                QuickFixCmdPre
                                QuitPre
                                RemoteReply
                                SafeState
                                SafeStateAgain
                                SessionLoadPost
                                SessionWritePost
                                ShellCmdPost
                                ShellFilterPost
                                SigUSR1
                                SourceCmd
                                SourcePost
                                SourcePre
                                SpellFileMissing
                                StdinReadPost
                                StdinReadPre
                                SwapExists
                                Syntax
                                TabClosed
                                TabClosedPre
                                TabEnter
                                TabLeave
                                TabNew
                                TermChanged
                                TermResponse
                                TermResponseAll
                                TerminalOpen
                                TerminalWinOpen
                                TextChanged
                                TextChangedI
                                TextChangedP
                                TextChangedT
                                TextYankPost
                                User
                                VimEnter
                                VimLeave
                                VimLeavePre
                                VimResized
                                VimResume
                                VimSuspend
                                WinClosed
                                WinEnter
                                WinLeave
                                WinNew
                                WinNewPre
                                WinResized
                                WinScrolled
                            END
                            
    1              0.000004000 export const event: string = event_list->join()
                            
                            # ex_special_characters {{{1
                            
    1              0.000000000 const ex_special_characters_list: list<string> =<< trim END
                                abuf
                                afile
                                cWORD
                                cexpr
                                cfile
                                cword
                                sfile
                                slnum
                                stack
                                amatch
                                client
                                script
                                sflnum
                            END
                            
    1              0.000002000 export const ex_special_characters: string = ex_special_characters_list->join("\\|")
                            
                            # increment_invalid {{{1
                            
    1              0.000001000 export const increment_invalid: string = '\%(++\|--\)\%(\%(\%([bgstvw]:\)\=\h\w*\|&\%([lg]:\)\=[a-z]\{2,}\)\s*\_[[|.#]\)\@!'
                            
                            # key_name {{{1
                            
    1              0.000000000 const key_name_list: list<string> =<< trim END
                                BS
                                BackSpace
                                Bslash
                                CR
                                CSI
                                CursorHold
                                DecMouse
                                Del
                                Delete
                                Down
                                Drop
                                End
                                Enter
                                Esc
                                FocusGained
                                FocusLost
                                Help
                                Home
                                Ignore
                                Ins
                                Insert
                                JsbMouse
                                LF
                                Left
                                LeftDrag
                                LeftMouse
                                LeftMouseNM
                                LeftRelease
                                LeftReleaseNM
                                LineFeed
                                MiddleDrag
                                MiddleMouse
                                MiddleRelease
                                Mouse
                                MouseDown
                                MouseMove
                                MouseUp
                                NL
                                NetMouse
                                NewLine
                                Nop
                                Nul
                                PageDown
                                PageUp
                                PasteEnd
                                PasteStart
                                Plug
                                PtermMouse
                                Return
                                Right
                                RightDrag
                                RightMouse
                                RightRelease
                                SID
                                SNR
                                ScriptCmd
                                ScrollWheelDown
                                ScrollWheelLeft
                                ScrollWheelRight
                                ScrollWheelUp
                                SgrMouse
                                SgrMouseRelease
                                Space
                                Tab
                                Undo
                                Up
                                UrxvtMouse
                                X1Drag
                                X1Mouse
                                X1Release
                                X2Drag
                                X2Mouse
                                X2Release
                                k0
                                k1
                                k2
                                k3
                                k4
                                k5
                                k6
                                k7
                                k8
                                k9
                                kDel
                                kDivide
                                kEnd
                                kEnter
                                kHome
                                kInsert
                                kMinus
                                kMultiply
                                kPageDown
                                kPageUp
                                kPlus
                                kPoint
                                lt
                                xCSI
                                xDown
                                xEnd
                                xF1
                                xF2
                                xF3
                                xF4
                                xHome
                                xLeft
                                xRight
                                xUp
                                zEnd
                                zHome
                                F\d\{1,2}
                                .
                            END
                            
    1              0.000004000 export const key_name: string = key_name_list->join("\\|")
                            
                            # lambda_end {{{1
                            
    1              0.000000000 export const lambda_end: string = ')\ze\%(:.\{-}\)\=\s\+=>'
                            
                            # lambda_start {{{1
                            
    1              0.000001000 export const lambda_start: string = '(\ze\%(\s*\h\w*\%([^(]\|\%(\<func\)\@4<=(\)*\|\s*\.\.\._\)\=)\%(:.\{-}\)\=\s\+=>'
                            
                            # legacy_autoload_invalid {{{1
                            
    1              0.000000000 export const legacy_autoload_invalid: string = '\h\w*#\%(\w\|#\)*'
                            
                            # logical_not {{{1
                            
    1              0.000000000 export const logical_not: string = '/\w\@1<!![~=]\@!!*/'
                            
                            # mark_valid {{{1
                            
    1              0.000001000 export const mark_valid: string = '[a-zA-Z''`[\]<>0-9"^.(){}]'
                            
                            # maybe_dict_literal_key {{{1
                            
    1              0.000001000 export const maybe_dict_literal_key: string = '/\%([{\n]\|[^[:blank:]\n,{\\]\@1<!\s\)\@1<=[^[:blank:]{(''"]\+\ze\%(:\_s\)\@=/'
                            
                            # most_operators {{{1
                            
    1              0.000002000 export const most_operators: string = '"\%(\_s\)\@1<=\%([-+*/%]\|\.\.\|||\|&&\|??\=\|<<\|>>\|\%([=!]=\|[<>]=\=\|[=!]\~\|is\|isnot\)[?#]\=\)\_s\@=\%(\s*[|<]\)\@!"'
                            
                            # option {{{1
                            
    1              0.000001000 const option_list: list<string> =<< trim END
                                aleph
                                al
                                allowrevins
                                ari
                                noallowrevins
                                noari
                                altkeymap
                                akm
                                noaltkeymap
                                noakm
                                ambiwidth
                                ambw
                                antialias
                                anti
                                noantialias
                                noanti
                                arabic
                                arab
                                noarabic
                                noarab
                                arabicshape
                                arshape
                                noarabicshape
                                noarshape
                                autochdir
                                acd
                                noautochdir
                                noacd
                                autocomplete
                                ac
                                noautocomplete
                                noac
                                autocompletedelay
                                acl
                                autocompletetimeout
                                act
                                autoindent
                                ai
                                noautoindent
                                noai
                                autoread
                                ar
                                noautoread
                                noar
                                autoshelldir
                                asd
                                noautoshelldir
                                noasd
                                autowrite
                                aw
                                noautowrite
                                noaw
                                autowriteall
                                awa
                                noautowriteall
                                noawa
                                background
                                bg
                                backspace
                                bs
                                backup
                                bk
                                nobackup
                                nobk
                                backupcopy
                                bkc
                                backupdir
                                bdir
                                backupext
                                bex
                                backupskip
                                bsk
                                balloondelay
                                bdlay
                                ballooneval
                                beval
                                noballooneval
                                nobeval
                                balloonevalterm
                                bevalterm
                                noballoonevalterm
                                nobevalterm
                                balloonexpr
                                bexpr
                                belloff
                                bo
                                binary
                                bin
                                nobinary
                                nobin
                                bomb
                                nobomb
                                breakat
                                brk
                                breakindent
                                bri
                                nobreakindent
                                nobri
                                breakindentopt
                                briopt
                                browsedir
                                bsdir
                                bufhidden
                                bh
                                buflisted
                                bl
                                nobuflisted
                                nobl
                                buftype
                                bt
                                casemap
                                cmp
                                cdhome
                                cdh
                                nocdhome
                                nocdh
                                cdpath
                                cd
                                cedit
                                charconvert
                                ccv
                                chistory
                                chi
                                cindent
                                cin
                                nocindent
                                nocin
                                cinkeys
                                cink
                                cinoptions
                                cino
                                cinscopedecls
                                cinsd
                                cinwords
                                cinw
                                clipboard
                                cb
                                clipmethod
                                cpm
                                cmdheight
                                ch
                                cmdwinheight
                                cwh
                                colorcolumn
                                cc
                                columns
                                co
                                comments
                                com
                                commentstring
                                cms
                                compatible
                                cp
                                nocompatible
                                nocp
                                complete
                                cpt
                                completefunc
                                cfu
                                completefuzzycollect
                                cfc
                                completeitemalign
                                cia
                                completeopt
                                cot
                                completepopup
                                cpp
                                completeslash
                                csl
                                completetimeout
                                cto
                                concealcursor
                                cocu
                                conceallevel
                                cole
                                confirm
                                cf
                                noconfirm
                                nocf
                                copyindent
                                ci
                                nocopyindent
                                noci
                                cpoptions
                                cpo
                                cryptmethod
                                cm
                                cscopepathcomp
                                cspc
                                cscopeprg
                                csprg
                                cscopequickfix
                                csqf
                                cscoperelative
                                csre
                                nocscoperelative
                                nocsre
                                cscopetag
                                cst
                                nocscopetag
                                nocst
                                cscopetagorder
                                csto
                                cscopeverbose
                                csverb
                                nocscopeverbose
                                nocsverb
                                cursorbind
                                crb
                                nocursorbind
                                nocrb
                                cursorcolumn
                                cuc
                                nocursorcolumn
                                nocuc
                                cursorline
                                cul
                                nocursorline
                                nocul
                                cursorlineopt
                                culopt
                                debug
                                define
                                def
                                delcombine
                                deco
                                nodelcombine
                                nodeco
                                dictionary
                                dict
                                diff
                                nodiff
                                dia
                                diffanchors
                                dex
                                diffexpr
                                dip
                                diffopt
                                digraph
                                dg
                                nodigraph
                                nodg
                                directory
                                dir
                                display
                                dy
                                eadirection
                                ead
                                ed
                                edcompatible
                                noed
                                noedcompatible
                                emoji
                                emo
                                noemoji
                                noemo
                                encoding
                                enc
                                endoffile
                                eof
                                noendoffile
                                noeof
                                endofline
                                eol
                                noendofline
                                noeol
                                equalalways
                                ea
                                noequalalways
                                noea
                                equalprg
                                ep
                                errorbells
                                eb
                                noerrorbells
                                noeb
                                errorfile
                                ef
                                errorformat
                                efm
                                esckeys
                                ek
                                noesckeys
                                noek
                                eventignore
                                ei
                                eventignorewin
                                eiw
                                expandtab
                                et
                                noexpandtab
                                noet
                                exrc
                                ex
                                noexrc
                                noex
                                fileencoding
                                fenc
                                fileencodings
                                fencs
                                fileformat
                                ff
                                fileformats
                                ffs
                                fileignorecase
                                fic
                                nofileignorecase
                                nofic
                                filetype
                                ft
                                fillchars
                                fcs
                                findfunc
                                ffu
                                fixendofline
                                fixeol
                                nofixendofline
                                nofixeol
                                fkmap
                                fk
                                nofkmap
                                nofk
                                foldclose
                                fcl
                                foldcolumn
                                fdc
                                foldenable
                                fen
                                nofoldenable
                                nofen
                                foldexpr
                                fde
                                foldignore
                                fdi
                                foldlevel
                                fdl
                                foldlevelstart
                                fdls
                                foldmarker
                                fmr
                                foldmethod
                                fdm
                                foldminlines
                                fml
                                foldnestmax
                                fdn
                                foldopen
                                fdo
                                foldtext
                                fdt
                                formatexpr
                                fex
                                formatlistpat
                                flp
                                formatoptions
                                fo
                                formatprg
                                fp
                                fsync
                                fs
                                nofsync
                                nofs
                                gdefault
                                gd
                                nogdefault
                                nogd
                                grepformat
                                gfm
                                grepprg
                                gp
                                guicursor
                                gcr
                                guifont
                                gfn
                                guifontset
                                gfs
                                guifontwide
                                gfw
                                guiheadroom
                                ghr
                                guiligatures
                                gli
                                guioptions
                                go
                                guipty
                                noguipty
                                guitablabel
                                gtl
                                guitabtooltip
                                gtt
                                helpfile
                                hf
                                helpheight
                                hh
                                helplang
                                hlg
                                hidden
                                hid
                                nohidden
                                nohid
                                highlight
                                hl
                                history
                                hi
                                hkmap
                                hk
                                nohkmap
                                nohk
                                hkmapp
                                hkp
                                nohkmapp
                                nohkp
                                hlsearch
                                hls
                                nohlsearch
                                nohls
                                icon
                                noicon
                                iconstring
                                ignorecase
                                ic
                                noignorecase
                                noic
                                imactivatefunc
                                imaf
                                imactivatekey
                                imak
                                imcmdline
                                imc
                                noimcmdline
                                noimc
                                imdisable
                                imd
                                noimdisable
                                noimd
                                iminsert
                                imi
                                imsearch
                                ims
                                imstatusfunc
                                imsf
                                imstyle
                                imst
                                include
                                inc
                                includeexpr
                                inex
                                incsearch
                                is
                                noincsearch
                                nois
                                indentexpr
                                inde
                                indentkeys
                                indk
                                infercase
                                inf
                                noinfercase
                                noinf
                                isexpand
                                ise
                                insertmode
                                im
                                noinsertmode
                                noim
                                isfname
                                isf
                                isident
                                isi
                                iskeyword
                                isk
                                isprint
                                isp
                                joinspaces
                                js
                                nojoinspaces
                                nojs
                                jumpoptions
                                jop
                                key
                                keymap
                                kmp
                                keymodel
                                km
                                keyprotocol
                                kpc
                                keywordprg
                                kp
                                langmap
                                lmap
                                langmenu
                                lm
                                langnoremap
                                lnr
                                nolangnoremap
                                nolnr
                                langremap
                                lrm
                                nolangremap
                                nolrm
                                laststatus
                                ls
                                lazyredraw
                                lz
                                nolazyredraw
                                nolz
                                lhistory
                                lhi
                                linebreak
                                lbr
                                nolinebreak
                                nolbr
                                lines
                                linespace
                                lsp
                                lisp
                                nolisp
                                lispoptions
                                lop
                                lispwords
                                lw
                                list
                                nolist
                                listchars
                                lcs
                                lpl
                                nolpl
                                loadplugins
                                noloadplugins
                                luadll
                                macatsui
                                nomacatsui
                                magic
                                nomagic
                                makeef
                                mef
                                makeencoding
                                menc
                                makeprg
                                mp
                                matchpairs
                                mps
                                matchtime
                                mat
                                maxcombine
                                mco
                                maxfuncdepth
                                mfd
                                maxmapdepth
                                mmd
                                maxmem
                                mm
                                maxmempattern
                                mmp
                                maxmemtot
                                mmt
                                maxsearchcount
                                msc
                                menuitems
                                mis
                                messagesopt
                                mopt
                                mkspellmem
                                msm
                                modeline
                                ml
                                nomodeline
                                noml
                                modelineexpr
                                mle
                                nomodelineexpr
                                nomle
                                modelines
                                mls
                                modifiable
                                ma
                                nomodifiable
                                noma
                                modified
                                mod
                                nomodified
                                nomod
                                more
                                nomore
                                mouse
                                mousefocus
                                mousef
                                nomousefocus
                                nomousef
                                mousehide
                                mh
                                nomousehide
                                nomh
                                mousemodel
                                mousem
                                mousemoveevent
                                mousemev
                                nomousemoveevent
                                nomousemev
                                mouseshape
                                mouses
                                mousetime
                                mouset
                                mzquantum
                                mzq
                                mzschemedll
                                mzschemegcdll
                                nrformats
                                nf
                                number
                                nu
                                nonumber
                                nonu
                                numberwidth
                                nuw
                                omnifunc
                                ofu
                                opendevice
                                odev
                                noopendevice
                                noodev
                                operatorfunc
                                opfunc
                                osctimeoutlen
                                ost
                                osfiletype
                                oft
                                packpath
                                pp
                                paragraphs
                                para
                                paste
                                nopaste
                                pastetoggle
                                pt
                                pex
                                patchexpr
                                patchmode
                                pm
                                path
                                pa
                                perldll
                                preserveindent
                                pi
                                nopreserveindent
                                nopi
                                previewheight
                                pvh
                                previewpopup
                                pvp
                                previewwindow
                                nopreviewwindow
                                pvw
                                nopvw
                                printdevice
                                pdev
                                printencoding
                                penc
                                printexpr
                                pexpr
                                printfont
                                pfn
                                printheader
                                pheader
                                printmbcharset
                                pmbcs
                                printmbfont
                                pmbfn
                                printoptions
                                popt
                                prompt
                                noprompt
                                pumborder
                                pb
                                pumheight
                                ph
                                pummaxwidth
                                pmw
                                pumwidth
                                pw
                                pythondll
                                pythonhome
                                pythonthreedll
                                pythonthreehome
                                pyxversion
                                pyx
                                quickfixtextfunc
                                qftf
                                quoteescape
                                qe
                                readonly
                                ro
                                noreadonly
                                noro
                                redrawtime
                                rdt
                                regexpengine
                                re
                                relativenumber
                                rnu
                                norelativenumber
                                nornu
                                remap
                                noremap
                                renderoptions
                                rop
                                report
                                restorescreen
                                rs
                                norestorescreen
                                nors
                                revins
                                ri
                                norevins
                                nori
                                rightleft
                                rl
                                norightleft
                                norl
                                rightleftcmd
                                rlc
                                rubydll
                                ruler
                                ru
                                noruler
                                noru
                                rulerformat
                                ruf
                                runtimepath
                                rtp
                                scroll
                                scr
                                scrollbind
                                scb
                                noscrollbind
                                noscb
                                scrollfocus
                                scf
                                noscrollfocus
                                noscf
                                scrolljump
                                sj
                                scrolloff
                                so
                                scrollopt
                                sbo
                                sections
                                sect
                                secure
                                nosecure
                                selection
                                sel
                                selectmode
                                slm
                                sessionoptions
                                ssop
                                shell
                                sh
                                shellcmdflag
                                shcf
                                shellpipe
                                sp
                                shellquote
                                shq
                                shellredir
                                srr
                                shellslash
                                ssl
                                noshellslash
                                nossl
                                shelltemp
                                stmp
                                noshelltemp
                                nostmp
                                shelltype
                                st
                                shellxescape
                                sxe
                                shellxquote
                                sxq
                                shiftround
                                sr
                                noshiftround
                                nosr
                                shiftwidth
                                sw
                                shortmess
                                shm
                                shortname
                                sn
                                noshortname
                                nosn
                                showbreak
                                sbr
                                showcmd
                                sc
                                noshowcmd
                                nosc
                                showcmdloc
                                sloc
                                showfulltag
                                sft
                                noshowfulltag
                                nosft
                                showmatch
                                sm
                                noshowmatch
                                nosm
                                showmode
                                smd
                                noshowmode
                                nosmd
                                showtabline
                                stal
                                showtabpanel
                                stpl
                                sidescroll
                                ss
                                sidescrolloff
                                siso
                                signcolumn
                                scl
                                smartcase
                                scs
                                nosmartcase
                                noscs
                                smartindent
                                si
                                nosmartindent
                                nosi
                                smarttab
                                sta
                                nosmarttab
                                nosta
                                smoothscroll
                                sms
                                nosmoothscroll
                                nosms
                                softtabstop
                                sts
                                spell
                                nospell
                                spellcapcheck
                                spc
                                spellfile
                                spf
                                spelllang
                                spl
                                spelloptions
                                spo
                                spellsuggest
                                sps
                                splitbelow
                                sb
                                nosplitbelow
                                nosb
                                splitkeep
                                spk
                                splitright
                                spr
                                nosplitright
                                nospr
                                startofline
                                sol
                                nostartofline
                                nosol
                                statusline
                                stl
                                suffixes
                                su
                                suffixesadd
                                sua
                                swapfile
                                swf
                                noswapfile
                                noswf
                                swapsync
                                sws
                                switchbuf
                                swb
                                synmaxcol
                                smc
                                syntax
                                syn
                                tabclose
                                tcl
                                tabline
                                tal
                                tabpagemax
                                tpm
                                tabpanel
                                tpl
                                tabpanelopt
                                tplo
                                tabstop
                                ts
                                tagbsearch
                                tbs
                                notagbsearch
                                notbs
                                tagcase
                                tc
                                tagfunc
                                tfu
                                taglength
                                tl
                                tagrelative
                                tr
                                notagrelative
                                notr
                                tags
                                tag
                                tagstack
                                tgst
                                notagstack
                                notgst
                                tcldll
                                term
                                termbidi
                                tbidi
                                notermbidi
                                notbidi
                                termencoding
                                tenc
                                termguicolors
                                tgc
                                notermguicolors
                                notgc
                                termwinkey
                                twk
                                termwinscroll
                                twsl
                                termwinsize
                                tws
                                termwintype
                                twt
                                terse
                                noterse
                                textauto
                                ta
                                notextauto
                                nota
                                textmode
                                tx
                                notextmode
                                notx
                                textwidth
                                tw
                                thesaurus
                                tsr
                                thesaurusfunc
                                tsrfu
                                tildeop
                                top
                                notildeop
                                notop
                                timeout
                                to
                                notimeout
                                noto
                                ttimeout
                                nottimeout
                                timeoutlen
                                tm
                                ttimeoutlen
                                ttm
                                title
                                notitle
                                titlelen
                                titleold
                                titlestring
                                toolbar
                                tb
                                toolbariconsize
                                tbis
                                ttybuiltin
                                tbi
                                nottybuiltin
                                notbi
                                ttyfast
                                tf
                                nottyfast
                                notf
                                ttymouse
                                ttym
                                ttyscroll
                                tsl
                                ttytype
                                tty
                                undodir
                                udir
                                undofile
                                noundofile
                                udf
                                noudf
                                undolevels
                                ul
                                undoreload
                                ur
                                updatecount
                                uc
                                updatetime
                                ut
                                varsofttabstop
                                vsts
                                vartabstop
                                vts
                                verbose
                                vbs
                                verbosefile
                                vfile
                                viewdir
                                vdir
                                viewoptions
                                vop
                                viminfo
                                vi
                                viminfofile
                                vif
                                virtualedit
                                ve
                                visualbell
                                vb
                                novisualbell
                                novb
                                warn
                                nowarn
                                weirdinvert
                                wiv
                                noweirdinvert
                                nowiv
                                whichwrap
                                ww
                                wildchar
                                wc
                                wildcharm
                                wcm
                                wildignore
                                wig
                                wildignorecase
                                wic
                                nowildignorecase
                                nowic
                                wildmenu
                                wmnu
                                nowildmenu
                                nowmnu
                                wildmode
                                wim
                                wildoptions
                                wop
                                winaltkeys
                                wak
                                wincolor
                                wcr
                                window
                                wi
                                winfixbuf
                                wfb
                                winfixheight
                                wfh
                                nowinfixheight
                                nowfh
                                winfixwidth
                                wfw
                                nowinfixwidth
                                nowfw
                                winheight
                                wh
                                winminheight
                                wmh
                                winminwidth
                                wmw
                                winptydll
                                winwidth
                                wiw
                                wlseat
                                wse
                                wlsteal
                                wst
                                nowlsteal
                                nowst
                                wltimeoutlen
                                wtm
                                wrap
                                nowrap
                                wrapmargin
                                wm
                                wrapscan
                                ws
                                nowrapscan
                                nows
                                write
                                nowrite
                                writeany
                                wa
                                nowriteany
                                nowa
                                writebackup
                                wb
                                nowritebackup
                                nowb
                                writedelay
                                wd
                                xtermcodes
                                noxtermcodes
                            END
                            
    1              0.000033000 export const option: string = option_list->join()
                            
                            # option_can_be_after {{{1
                            
    1              0.000000000 export const option_can_be_after: string = '\%(\%(^\|[-+ \t!([>]\)\@1<=\|{\@1<=\)'
                            
                            # option_modifier {{{1
                            
    1              0.000000000 export const option_modifier: string = '\%(&\%(vim\)\=\|[<?!]\)\%(\_s\||\)\@='
                            
                            # option_sigil {{{1
                            
    1              0.000000000 export const option_sigil: string = '&\%([gl]:\)\='
                            
                            # option_terminal {{{1
                            
    1              0.000001000 const option_terminal_list: list<string> =<< trim END
                                t_8b
                                t_8f
                                t_8u
                                t_AB
                                t_AF
                                t_AL
                                t_AU
                                t_BD
                                t_BE
                                t_CF
                                t_CS
                                t_CV
                                t_Ce
                                t_Co
                                t_Cs
                                t_DL
                                t_Ds
                                t_EC
                                t_EI
                                t_F1
                                t_F2
                                t_F3
                                t_F4
                                t_F5
                                t_F6
                                t_F7
                                t_F8
                                t_F9
                                t_GP
                                t_IE
                                t_IS
                                t_K1
                                t_K3
                                t_K4
                                t_K5
                                t_K6
                                t_K7
                                t_K8
                                t_K9
                                t_KA
                                t_KB
                                t_KC
                                t_KD
                                t_KE
                                t_KF
                                t_KG
                                t_KH
                                t_KI
                                t_KJ
                                t_KK
                                t_KL
                                t_PE
                                t_PS
                                t_RB
                                t_RC
                                t_RF
                                t_RI
                                t_RK
                                t_RS
                                t_RT
                                t_RV
                                t_Ri
                                t_SC
                                t_SH
                                t_SI
                                t_SR
                                t_ST
                                t_Sb
                                t_Sf
                                t_Si
                                t_TE
                                t_TI
                                t_Te
                                t_Ts
                                t_Us
                                t_VS
                                t_WP
                                t_WS
                                t_XM
                                t_ZH
                                t_ZR
                                t_al
                                t_bc
                                t_cd
                                t_ce
                                t_ci
                                t_cl
                                t_cm
                                t_cs
                                t_cv
                                t_da
                                t_db
                                t_dl
                                t_ds
                                t_ed
                                t_el
                                t_f1
                                t_f2
                                t_f3
                                t_f4
                                t_f5
                                t_f6
                                t_f7
                                t_f8
                                t_f9
                                t_fd
                                t_fe
                                t_fs
                                t_il
                                t_k1
                                t_k2
                                t_k3
                                t_k4
                                t_k5
                                t_k6
                                t_k7
                                t_k8
                                t_k9
                                t_kB
                                t_kD
                                t_kI
                                t_kN
                                t_kP
                                t_kb
                                t_kd
                                t_ke
                                t_kh
                                t_kl
                                t_kr
                                t_ks
                                t_ku
                                t_le
                                t_mb
                                t_md
                                t_me
                                t_mr
                                t_ms
                                t_nd
                                t_op
                                t_se
                                t_so
                                t_sr
                                t_tb
                                t_te
                                t_ti
                                t_tp
                                t_ts
                                t_u7
                                t_ue
                                t_us
                                t_ut
                                t_vb
                                t_ve
                                t_vi
                                t_vs
                                t_xn
                                t_xo
                                t_xs
                            END
                            
    1              0.000004000 export const option_terminal: string = option_terminal_list->join()
                            
                            # option_terminal_special {{{1
                            
    1              0.000001000 const option_terminal_special_list: list<string> =<< trim END
                                t_#2
                                t_#4
                                t_%1
                                t_%i
                                t_&8
                                t_*7
                                t_@7
                                t_k;
                            END
                            
    1              0.000001000 export const option_terminal_special: string = option_terminal_special_list->join("\\|")
                            
                            # option_valid {{{1
                            
    1              0.000000000 export const option_valid: string = '\%([a-z]\{2,}\>\|t_[a-zA-Z0-9#%*:@_]\{2}\)'
                            
                            # pattern_delimiter {{{1
                            
    1              0.000001000 export const pattern_delimiter: string = '[^-+*/%.:# \t[:alnum:]\"|]\@=.\|->\@!\%(=\s\)\@!\|[+*/%]\%(=\s\)\@!'
                            
                            # wincmd_valid {{{1
                            
    1              0.000004000 export const wincmd_valid: string = '/\s\@1<=\%([-\]+:<=>FHJKLPRSTW^_bcdfhijklnopqrstvwxz}|]\|gF\|gT\|g]\|gf\|gt\|g}\)\_s\@=/'

SCRIPT  /Users/danbradbury/.vim/bundle/vim9-syntax/import/vim9SyntaxUtil.vim
Sourced 1 time
Total time:   0.000193000
 Self time:   0.000193000

count     total (s)      self (s)
    1              0.000001000 vim9script
                            
                            # Interface {{{1
    1              0.000001000 export def Derive( # {{{2
                                    new_group: string,
                                    from: string,
                                    new_attrs: dict<any>,
                                    )
                            # Purpose:{{{
                            #
                            # Derive  a  new syntax  group  (`new_group`)  from  an existing  one  (`from`),
                            # overriding some attributes (`new_attrs`).
                            #}}}
                            # Usage Examples:{{{
                            #
                            # To define `CommentUnderlined` with the same attributes as `Comment`, resetting
                            # the `term`, `cterm`, and `gui` attributes with the value `underline`:
                            #
                            #     Derive('CommentUnderlined', 'Comment', {gui: {bold: true}, term: {bold: true}, cterm: {bold: true}})
                            #
                            # To define `PopupSign` with the  same attributes as `WarningMsg`, resetting the
                            # `guibg` or `ctermbg` attributes with the colors of the `Normal` HG:
                            #
                            #     Derive('PopupSign', 'WarningMsg', {bg: 'Normal'})
                            #}}}
                            
                                var from_def: dict<any> = hlget(from, true)->get(0,  {})
                                if from_def->get('cleared')
                                    return
                                endif
                                highlights->add(from_def->extend({name: new_group, default: true})->extend(new_attrs))
                                highlights->hlset()
                            
                                # Make sure  the derived highlight groups  persist even if the  color scheme
                                # changes, and the Vim syntax plugin is not re-sourced.
                                autocmd_add([{
                                    cmd: 'highlights->hlset()',
                                    event: 'ColorScheme',
                                    group: 'DeriveHighlightGroups',
                                    once: true,
                                    pattern: '*',
                                    replace: true,
                                }])
                            enddef
                            
    1              0.000002000 var highlights: list<dict<any>>
                            
    1              0.000001000 export def HighlightUserTypes() # {{{2
                                var buf: number = bufnr('%')
                            
                                # remove existing text properties to start from a clean state
                                if prop_type_list({bufnr: buf})->index('vi9UserType') >= 0
                                    {type: 'vi9UserType', bufnr: buf, all: true}
                                        ->prop_remove(1, line('$'))
                                endif
                                # add property type
                                if prop_type_get('vi9UserType', {bufnr: buf}) == {}
                                    prop_type_add('vi9UserType', {highlight: 'Type', bufnr: buf})
                                endif
                            
                                var pat: string = '\%(^\|[^|]|\)\s*\%('
                                    #    `:help :type`
                                    .. 'type'
                                    #    `:help :enum`
                                    .. '\|' .. 'enum'
                                    #    `:help Vim9-using-interface`
                                    #    > The interface name can be used as a type:
                                    # A class can also be used as a type:
                                    # https://github.com/vim/vim/commit/eca2c5fff6f6ccad0df8824c4b4354d3f410d225
                                    .. '\|' .. '\%(export\s\+\)\=interface'
                                    .. '\|' .. '\%(\%(export\|abstract\|export\s\+abstract\)\s\+\)\=class'
                                    .. '\)\s\+\zs\u\w*'
                                var lines: list<string> = getline(1, '$')
                                var user_type: string = lines
                                    ->copy()
                                    ->map((_, line: string) => line->matchstr(pat))
                                    ->filter((_, type: string): bool => type != '')
                                    ->sort()
                                    ->uniq()
                                    ->join('\|')
                                if user_type == ''
                                    return
                                endif
                            
                                user_type = $'\zs\%({user_type}\)\ze'
                                #     def Func(obj1: UserType, obj2: UserType): UserType
                                #                    ^------^        ^------^   ^------^
                                #     var Lambda = (): UserType => ...
                                #                      ^------^
                                user_type = $':\s\+{user_type}\%([,)[:blank:]]\|$\)'
                                    #     var x: list<UserType>
                                    #                 ^------^
                                    .. $'\|<{user_type}>'
                                    #     var x: func(..., UserType, ...)
                                    #                      ^------^
                                    .. $'\|func(\%(\%(\.\.\.\|?\)\=\w*,\s*\)*{user_type}\%(,\s*\%(\.\.\.\|?\)\=\w*\)*)'
                            
                                # let's find out the positions of all the user types
                                var pos: list<list<number>>
                                # iterate over the lines of the buffer
                                for [lnum: number, line: string] in lines->items()
                                    var old_start: number = -1
                                    # iterate over user types on a given line
                                    while true
                                        # look for a user type name
                                        var [_, start: number, end: number] =
                                            matchstrpos(line, user_type, old_start + 1)
                            
                                        # bail out if there aren't (anymore)
                                        if start == -1
                                            break
                                        endif
                            
                                        # remember  where the  last user  type started  (useful in  the next
                                        # iteration to find the next user type on the same line)
                                        old_start = start
                            
                                        # ignore a user type inside a comment or a string
                                        if InCommentOrString(lnum + 1, start)
                                            continue
                                        endif
                            
                                        # save position of text property
                                        pos->add([lnum + 1, start, lnum + 1, end + 1])
                                    endwhile
                                endfor
                            
                                # finally, add text properties
                                prop_add_list({bufnr: buf, type: 'vi9UserType'}, pos)
                            enddef
                            # }}}1
                            # Util {{{1
    1              0.000001000 def InCommentOrString(lnum: number, col: number): bool # {{{2
                                return synstack(lnum, col)
                                    ->indexof((_, id: number): bool =>
                                        synIDattr(id, 'name') =~ '\ccomment\|string\|heredoc') >= 0
                            enddef

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/vim.vim
Sourced 14 times
Total time:   0.241210000
 Self time:   0.241210000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:	   Vim script
                            " Maintainer:	   Hirohito Higashi <h.east.727 ATMARK gmail.com>
                            "	   Doug Kearns <dougkearns@gmail.com>
                            " Last Change:	   2024 Aug 30
                            " Former Maintainer: Charles E. Campbell
                            
                            " DO NOT CHANGE DIRECTLY.
                            " THIS FILE PARTLY GENERATED BY gen_syntax_vim.vim.
                            " (Search string "GEN_SYN_VIM:" in this file)
                            
                            " Automatically generated keyword lists: {{{1
                            
                            " Quit when a syntax file was already loaded {{{2
   14              0.000109000 if exists("b:current_syntax")
    6              0.000007000   finish
    8              0.000009000 endif
    8              0.000051000 let s:keepcpo= &cpo
    8              0.000069000 set cpo&vim
                            
    8              0.000207000 let s:vim9script = "\n" .. getline(1, 32)->join("\n") =~# '\n\s*vim9\%[script]\>'
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    8              0.000272000 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    8              0.000090000 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " regular vim commands {{{2
                            " GEN_SYN_VIM: vimCommand normal, START_STR='syn keyword vimCommand contained', END_STR=''
    8              0.000476000 syn keyword vimCommand contained abo[veleft] abs[tract] al[l] ar[gs] arga[dd] argd[elete] argdo argded[upe] arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] b[uffer] bN[ext] ba[ll] bad[d] balt bd[elete] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] buffers bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfir[st] cg[etfile] cgetb[uffer] cgete[xpr] chd[ir] changes che[ckpath] checkt[ime] chi[story] cl[ist] cla[st] class clo[se] cle[arjumps] cn[ext] cnew[er] cnf[ile] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler]
    8              0.000452000 syn keyword vimCommand contained con[tinue] conf[irm] cons[t] cope[n] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] defc[ompile] defe[r] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] disa[ssemble] dj[ump] dli[st] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] el[se] elsei[f] em[enu] en[dif] endin[terface] endc[lass] ende[num] endfo[r] endt[ry] endw[hile] ene[w] enu[m] ev[al] ex exi[t] exp[ort] exu[sage] f[ile] files filet[ype] filt[er] fin[d] finall[y] fini[sh] fir[st] fix[del] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpf[ind] helpg[rep] helpt[ags] ha[rdcopy]
    8              0.000541000 syn keyword vimCommand contained hi[ghlight] hid[e] his[tory] ho[rizontal] if ij[ump] il[ist] imp[ort] int[ro] inte[rface] is[earch] isp[lit] j[oin] ju[mps] k kee[pmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] lex[pr] leg[acy] lf[ile] lfd[o] lfir[st] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lmak[e] lne[xt] lnew[er] lnf[ile] lo[adview] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] marks menut[ranslate]
    8              0.000418000 syn keyword vimCommand contained mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mod[e] mz[scheme] mzf[ile] n[ext] nb[key] nbc[lose] nbs[tart] noa[utocmd] noh[lsearch] nos[wapfile] nu[mber] o[pen] ol[dfiles] on[ly] opt[ions] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] ped[it] po[p] pp[op] pre[serve] prev[ious] pro[mptfind] promptr[epl] prof[ile] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pub[lic] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] python3 py3f[ile] pyx pyxd[o] pythonx pyxf[ile] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] ru[ntime]
    8              0.000380000 syn keyword vimCommand contained rub[y] rubyd[o] rubyf[ile] rund[o] rv[iminfo] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scriptv[ersion] scs[cope] setf[iletype] sf[ind] sfir[st] sh[ell] si[malt] sig[n] sil[ent] sla[st] sn[ext] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] stat[ic] stopi[nsert] stj[ump] sts[elect] sun[hide] sus[pend] sv[iew] sw[apname] synti[me] sync[bind] smi[le] t tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly]
    8              0.000298000 syn keyword vimCommand contained tabp[revious] tabN[ext] tabr[ewind] tabs tc[d] tch[dir] tcl tcld[o] tclf[ile] te[aroff] ter[minal] tf[irst] thi[s] tj[ump] tl[ast] tn[ext] to[pleft] tp[revious] tr[ewind] try ts[elect] ty[pe] u[ndo] undoj[oin] undol[ist] unh[ide] unlo[ckvar] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] vim9[cmd] viu[sage] vne[w] vs[plit] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] wu[ndo] wv[iminfo] x[it] xa[ll] xr[estore] y[ank] z dl dell delel deletl deletel dp dep delp delep deletp deletep a i
                            
                            " Lower priority for _new_ to distinguish constructors from the command.
    8              0.000082000 syn match   vimCommand contained	"\<new\>(\@!"
    8              0.000061000 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    8              0.000121000 syn keyword vimStdPlugin contained	Arguments Asm Break Cfilter Clear Continue DiffOrig Evaluate Finish Gdb Lfilter Man Over Program Run S Source Step Stop Termdebug TermdebugCommand TOhtml Until Winbar XMLent XMLns
                            
                            " vimOptions are caught only when contained in a vimSet {{{2
                            " GEN_SYN_VIM: vimOption normal, START_STR='syn keyword vimOption contained', END_STR='skipwhite nextgroup=vimSetEqual,vimSetMod'
    8              0.000417000 syn keyword vimOption contained al aleph ari allowrevins ambw ambiwidth arab arabic arshape arabicshape acd autochdir ai autoindent ar autoread asd autoshelldir aw autowrite awa autowriteall bg background bs backspace bk backup bkc backupcopy bdir backupdir bex backupext bsk backupskip bdlay balloondelay beval ballooneval bevalterm balloonevalterm bexpr balloonexpr bo belloff bin binary bomb brk breakat bri breakindent briopt breakindentopt bsdir browsedir bh bufhidden bl buflisted bt buftype cmp casemap cdh cdhome cd cdpath cedit ccv charconvert cin cindent cink cinkeys cino cinoptions cinsd cinscopedecls cinw cinwords cb clipboard ch cmdheight cwh cmdwinheight cc colorcolumn co columns com comments cms commentstring cp compatible cpt complete cfu completefunc skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000394000 syn keyword vimOption contained cot completeopt cpp completepopup csl completeslash cocu concealcursor cole conceallevel cf confirm ci copyindent cpo cpoptions cm cryptmethod cspc cscopepathcomp csprg cscopeprg csqf cscopequickfix csre cscoperelative cst cscopetag csto cscopetagorder csverb cscopeverbose crb cursorbind cuc cursorcolumn cul cursorline culopt cursorlineopt debug def define deco delcombine dict dictionary diff dex diffexpr dip diffopt dg digraph dir directory dy display ead eadirection ed edcompatible emo emoji enc encoding eof endoffile eol endofline ea equalalways ep equalprg eb errorbells ef errorfile efm errorformat ek esckeys ei eventignore et expandtab ex exrc fenc fileencoding fencs fileencodings ff fileformat ffs fileformats fic fileignorecase skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000362000 syn keyword vimOption contained ft filetype fcs fillchars fixeol fixendofline fcl foldclose fdc foldcolumn fen foldenable fde foldexpr fdi foldignore fdl foldlevel fdls foldlevelstart fmr foldmarker fdm foldmethod fml foldminlines fdn foldnestmax fdo foldopen fdt foldtext fex formatexpr flp formatlistpat fo formatoptions fp formatprg fs fsync gd gdefault gfm grepformat gp grepprg gcr guicursor gfn guifont gfs guifontset gfw guifontwide ghr guiheadroom gli guiligatures go guioptions guipty gtl guitablabel gtt guitabtooltip hf helpfile hh helpheight hlg helplang hid hidden hl highlight hi history hk hkmap hkp hkmapp hls hlsearch icon iconstring ic ignorecase imaf imactivatefunc imak imactivatekey imc imcmdline imd imdisable imi iminsert ims imsearch imsf imstatusfunc skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000353000 syn keyword vimOption contained imst imstyle inc include inex includeexpr is incsearch inde indentexpr indk indentkeys inf infercase im insertmode isf isfname isi isident isk iskeyword isp isprint js joinspaces jop jumpoptions key kmp keymap km keymodel kpc keyprotocol kp keywordprg lmap langmap lm langmenu lnr langnoremap lrm langremap ls laststatus lz lazyredraw lbr linebreak lines lsp linespace lisp lop lispoptions lw lispwords list lcs listchars lpl loadplugins luadll magic mef makeef menc makeencoding mp makeprg mps matchpairs mat matchtime mco maxcombine mfd maxfuncdepth mmd maxmapdepth mm maxmem mmp maxmempattern mmt maxmemtot mis menuitems msm mkspellmem ml modeline mle modelineexpr mls modelines ma modifiable mod modified more mouse mousef mousefocus skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000334000 syn keyword vimOption contained mh mousehide mousem mousemodel mousemev mousemoveevent mouses mouseshape mouset mousetime mzq mzquantum mzschemedll mzschemegcdll nf nrformats nu number nuw numberwidth ofu omnifunc odev opendevice opfunc operatorfunc pp packpath para paragraphs paste pt pastetoggle pex patchexpr pm patchmode pa path perldll pi preserveindent pvh previewheight pvp previewpopup pvw previewwindow pdev printdevice penc printencoding pexpr printexpr pfn printfont pheader printheader pmbcs printmbcharset pmbfn printmbfont popt printoptions prompt ph pumheight pw pumwidth pythondll pythonhome pythonthreedll pythonthreehome pyx pyxversion qftf quickfixtextfunc qe quoteescape ro readonly rdt redrawtime re regexpengine rnu relativenumber remap rop renderoptions skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000368000 syn keyword vimOption contained report rs restorescreen ri revins rl rightleft rlc rightleftcmd rubydll ru ruler ruf rulerformat rtp runtimepath scr scroll scb scrollbind scf scrollfocus sj scrolljump so scrolloff sbo scrollopt sect sections secure sel selection slm selectmode ssop sessionoptions sh shell shcf shellcmdflag sp shellpipe shq shellquote srr shellredir ssl shellslash stmp shelltemp st shelltype sxe shellxescape sxq shellxquote sr shiftround sw shiftwidth shm shortmess sn shortname sbr showbreak sc showcmd sloc showcmdloc sft showfulltag sm showmatch smd showmode stal showtabline ss sidescroll siso sidescrolloff scl signcolumn scs smartcase si smartindent sta smarttab sms smoothscroll sts softtabstop spell spc spellcapcheck spf spellfile spl spelllang skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000407000 syn keyword vimOption contained spo spelloptions sps spellsuggest sb splitbelow spk splitkeep spr splitright sol startofline stl statusline su suffixes sua suffixesadd swf swapfile sws swapsync swb switchbuf smc synmaxcol syn syntax tcl tabclose tal tabline tpm tabpagemax ts tabstop tbs tagbsearch tc tagcase tfu tagfunc tl taglength tr tagrelative tag tags tgst tagstack tcldll term tbidi termbidi tenc termencoding tgc termguicolors twk termwinkey twsl termwinscroll tws termwinsize twt termwintype terse ta textauto tx textmode tw textwidth tsr thesaurus tsrfu thesaurusfunc top tildeop to timeout tm timeoutlen title titlelen titleold titlestring tb toolbar tbis toolbariconsize ttimeout ttm ttimeoutlen tbi ttybuiltin tf ttyfast ttym ttymouse tsl ttyscroll tty ttytype skipwhite nextgroup=vimSetEqual,vimSetMod
    8              0.000324000 syn keyword vimOption contained udir undodir udf undofile ul undolevels ur undoreload uc updatecount ut updatetime vsts varsofttabstop vts vartabstop vbs verbose vfile verbosefile vdir viewdir vop viewoptions vi viminfo vif viminfofile ve virtualedit vb visualbell warn wiv weirdinvert ww whichwrap wc wildchar wcm wildcharm wig wildignore wic wildignorecase wmnu wildmenu wim wildmode wop wildoptions wak winaltkeys wcr wincolor wi window wfb winfixbuf wfh winfixheight wfw winfixwidth wh winheight wmh winminheight wmw winminwidth winptydll wiw winwidth wrap wm wrapmargin ws wrapscan write wa writeany wb writebackup wd writedelay xtermcodes skipwhite nextgroup=vimSetEqual,vimSetMod
                            
                            " vimOptions: These are the turn-off setting variants {{{2
                            " GEN_SYN_VIM: vimOption turn-off, START_STR='syn keyword vimOption contained', END_STR=''
    8              0.000610000 syn keyword vimOption contained noari noallowrevins noarab noarabic noarshape noarabicshape noacd noautochdir noai noautoindent noar noautoread noasd noautoshelldir noaw noautowrite noawa noautowriteall nobk nobackup nobeval noballooneval nobevalterm noballoonevalterm nobin nobinary nobomb nobri nobreakindent nobl nobuflisted nocdh nocdhome nocin nocindent nocp nocompatible nocf noconfirm noci nocopyindent nocsre nocscoperelative nocst nocscopetag nocsverb nocscopeverbose nocrb nocursorbind nocuc nocursorcolumn nocul nocursorline nodeco nodelcombine nodiff nodg nodigraph noed noedcompatible noemo noemoji noeof noendoffile noeol noendofline noea noequalalways noeb noerrorbells noek noesckeys noet noexpandtab noex noexrc nofic nofileignorecase nofixeol nofixendofline
    8              0.000193000 syn keyword vimOption contained nofen nofoldenable nofs nofsync nogd nogdefault noguipty nohid nohidden nohk nohkmap nohkp nohkmapp nohls nohlsearch noicon noic noignorecase noimc noimcmdline noimd noimdisable nois noincsearch noinf noinfercase noim noinsertmode nojs nojoinspaces nolnr nolangnoremap nolrm nolangremap nolz nolazyredraw nolbr nolinebreak nolisp nolist nolpl noloadplugins nomagic noml nomodeline nomle nomodelineexpr noma nomodifiable nomod nomodified nomore nomousef nomousefocus nomh nomousehide nomousemev nomousemoveevent nonu nonumber noodev noopendevice nopaste nopi nopreserveindent nopvw nopreviewwindow noprompt noro noreadonly nornu norelativenumber noremap nors norestorescreen nori norevins norl norightleft noru noruler noscb noscrollbind noscf noscrollfocus
    8              0.000184000 syn keyword vimOption contained nosecure nossl noshellslash nostmp noshelltemp nosr noshiftround nosn noshortname nosc noshowcmd nosft noshowfulltag nosm noshowmatch nosmd noshowmode noscs nosmartcase nosi nosmartindent nosta nosmarttab nosms nosmoothscroll nospell nosb nosplitbelow nospr nosplitright nosol nostartofline noswf noswapfile notbs notagbsearch notr notagrelative notgst notagstack notbidi notermbidi notgc notermguicolors noterse nota notextauto notx notextmode notop notildeop noto notimeout notitle nottimeout notbi nottybuiltin notf nottyfast noudf noundofile novb novisualbell nowarn nowiv noweirdinvert nowic nowildignorecase nowmnu nowildmenu nowfb nowinfixbuf nowfh nowinfixheight nowfw nowinfixwidth nowrap nows nowrapscan nowrite nowa nowriteany
    8              0.000041000 syn keyword vimOption contained nowb nowritebackup noxtermcodes
                            
                            " vimOptions: These are the invertible variants {{{2
                            " GEN_SYN_VIM: vimOption invertible, START_STR='syn keyword vimOption contained', END_STR=''
    8              0.002167000 syn keyword vimOption contained invari invallowrevins invarab invarabic invarshape invarabicshape invacd invautochdir invai invautoindent invar invautoread invasd invautoshelldir invaw invautowrite invawa invautowriteall invbk invbackup invbeval invballooneval invbevalterm invballoonevalterm invbin invbinary invbomb invbri invbreakindent invbl invbuflisted invcdh invcdhome invcin invcindent invcp invcompatible invcf invconfirm invci invcopyindent invcsre invcscoperelative invcst invcscopetag invcsverb invcscopeverbose invcrb invcursorbind invcuc invcursorcolumn invcul invcursorline invdeco invdelcombine invdiff invdg invdigraph inved invedcompatible invemo invemoji inveof invendoffile inveol invendofline invea invequalalways inveb inverrorbells invek invesckeys
    8              0.000191000 syn keyword vimOption contained invet invexpandtab invex invexrc invfic invfileignorecase invfixeol invfixendofline invfen invfoldenable invfs invfsync invgd invgdefault invguipty invhid invhidden invhk invhkmap invhkp invhkmapp invhls invhlsearch invicon invic invignorecase invimc invimcmdline invimd invimdisable invis invincsearch invinf invinfercase invim invinsertmode invjs invjoinspaces invlnr invlangnoremap invlrm invlangremap invlz invlazyredraw invlbr invlinebreak invlisp invlist invlpl invloadplugins invmagic invml invmodeline invmle invmodelineexpr invma invmodifiable invmod invmodified invmore invmousef invmousefocus invmh invmousehide invmousemev invmousemoveevent invnu invnumber invodev invopendevice invpaste invpi invpreserveindent invpvw invpreviewwindow
    8              0.000171000 syn keyword vimOption contained invprompt invro invreadonly invrnu invrelativenumber invremap invrs invrestorescreen invri invrevins invrl invrightleft invru invruler invscb invscrollbind invscf invscrollfocus invsecure invssl invshellslash invstmp invshelltemp invsr invshiftround invsn invshortname invsc invshowcmd invsft invshowfulltag invsm invshowmatch invsmd invshowmode invscs invsmartcase invsi invsmartindent invsta invsmarttab invsms invsmoothscroll invspell invsb invsplitbelow invspr invsplitright invsol invstartofline invswf invswapfile invtbs invtagbsearch invtr invtagrelative invtgst invtagstack invtbidi invtermbidi invtgc invtermguicolors invterse invta invtextauto invtx invtextmode invtop invtildeop invto invtimeout invtitle invttimeout invtbi invttybuiltin
    8              0.000084000 syn keyword vimOption contained invtf invttyfast invudf invundofile invvb invvisualbell invwarn invwiv invweirdinvert invwic invwildignorecase invwmnu invwildmenu invwfb invwinfixbuf invwfh invwinfixheight invwfw invwinfixwidth invwrap invws invwrapscan invwrite invwa invwriteany invwb invwritebackup invxtermcodes
                            
                            " termcap codes (which can also be set) {{{2
                            " GEN_SYN_VIM: vimOption term output code, START_STR='syn keyword vimOption contained', END_STR='skipwhite nextgroup=vimSetEqual,vimSetMod'
    8              0.000308000 syn keyword vimOption contained t_AB t_AF t_AU t_AL t_al t_bc t_BE t_BD t_cd t_ce t_Ce t_CF t_cl t_cm t_Co t_CS t_Cs t_cs t_CV t_da t_db t_DL t_dl t_ds t_Ds t_EC t_EI t_fs t_fd t_fe t_GP t_IE t_IS t_ke t_ks t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RF t_RB t_RC t_RI t_Ri t_RK t_RS t_RT t_RV t_Sb t_SC t_se t_Sf t_SH t_SI t_Si t_so t_SR t_sr t_ST t_Te t_te t_TE t_ti t_TI t_Ts t_ts t_u7 t_ue t_us t_Us t_ut t_vb t_ve t_vi t_VS t_vs t_WP t_WS t_XM t_xn t_xs t_ZH t_ZR t_8f t_8b t_8u t_xo skipwhite nextgroup=vimSetEqual,vimSetMod
                            " term key codes
    8              0.000100000 syn keyword vimOption contained	t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ku
    8              0.000059000 syn match   vimOption contained	"t_%1"
    8              0.000045000 syn match   vimOption contained	"t_#2"
    8              0.000039000 syn match   vimOption contained	"t_#4"
    8              0.000042000 syn match   vimOption contained	"t_@7"
    8              0.000040000 syn match   vimOption contained	"t_*7"
    8              0.000038000 syn match   vimOption contained	"t_&8"
    8              0.000040000 syn match   vimOption contained	"t_%i"
    8              0.000039000 syn match   vimOption contained	"t_k;"
                            
                            " unsupported settings: some were supported by vi but don't do anything in vim {{{2
                            " GEN_SYN_VIM: Missing vimOption, START_STR='syn keyword vimErrSetting contained', END_STR=''
    8              0.000133000 syn keyword vimErrSetting contained akm altkeymap anti antialias ap autoprint bf beautify biosk bioskey consk conskey fk fkmap fl flash gr graphic ht hardtabs macatsui mesg novice open opt optimize oft osfiletype redraw slow slowopen sourceany w1200 w300 w9600
    8              0.000098000 syn keyword vimErrSetting contained noakm noaltkeymap noanti noantialias noap noautoprint nobf nobeautify nobiosk nobioskey noconsk noconskey nofk nofkmap nofl noflash nogr nographic nomacatsui nomesg nonovice noopen noopt nooptimize noredraw noslow noslowopen nosourceany
    8              0.000092000 syn keyword vimErrSetting contained invakm invaltkeymap invanti invantialias invap invautoprint invbf invbeautify invbiosk invbioskey invconsk invconskey invfk invfkmap invfl invflash invgr invgraphic invmacatsui invmesg invnovice invopen invopt invoptimize invredraw invslow invslowopen invsourceany
                            
                            " AutoCmd Events {{{2
    8              0.000009000 syn case ignore
                            " GEN_SYN_VIM: vimAutoEvent, START_STR='syn keyword vimAutoEvent contained', END_STR=''
    8              0.000290000 syn keyword vimAutoEvent contained BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre CmdlineChanged CmdlineEnter CmdlineLeave CmdUndefined CmdwinEnter CmdwinLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedC CursorMovedI DiffUpdated DirChanged DirChangedPre EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost
    8              0.000243000 syn keyword vimAutoEvent contained FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre KeyInputPre MenuPopup ModeChanged OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SafeState SafeStateAgain SessionLoadPost SessionWritePost ShellCmdPost ShellFilterPost SigUSR1 SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabClosed TabEnter TabLeave TabNew TermChanged TerminalOpen TerminalWinOpen TermResponse TermResponseAll TextChanged TextChangedI TextChangedP TextChangedT TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinClosed WinEnter WinLeave WinNew WinNewPre WinResized WinScrolled
                            
                            " Highlight commonly used Groupnames {{{2
    8              0.000152000 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo
                            
                            " Default highlighting groups {{{2
                            " GEN_SYN_VIM: vimHLGroup, START_STR='syn keyword vimHLGroup contained', END_STR=''
    8              0.000272000 syn keyword vimHLGroup contained ErrorMsg IncSearch ModeMsg NonText StatusLine StatusLineNC EndOfBuffer VertSplit VisualNOS DiffText PmenuSbar TabLineSel TabLineFill Cursor lCursor QuickFixLine CursorLineSign CursorLineFold CurSearch PmenuKind PmenuKindSel PmenuMatch PmenuMatchSel PmenuExtra PmenuExtraSel Normal Directory LineNr CursorLineNr MoreMsg Question Search SpellBad SpellCap SpellRare SpellLocal PmenuThumb Pmenu PmenuSel SpecialKey Title WarningMsg WildMenu Folded FoldColumn SignColumn Visual DiffAdd DiffChange DiffDelete TabLine CursorColumn CursorLine ColorColumn MatchParen StatusLineTerm StatusLineTermNC ToolbarLine ToolbarButton Menu Tooltip Scrollbar CursorIM LineNrAbove LineNrBelow
    8              0.000063000 syn match vimHLGroup contained "\<Conceal\>"
    8              0.000009000 syn case match
                            
                            " Function Names {{{2
                            " GEN_SYN_VIM: vimFuncName, START_STR='syn keyword vimFuncName contained', END_STR=''
    8              0.000207000 syn keyword vimFuncName contained abs acos add and append appendbufline argc argidx arglistid argv asin assert_beeps assert_equal assert_equalfile assert_exception assert_fails assert_false assert_inrange assert_match assert_nobeep assert_notequal assert_notmatch assert_report assert_true atan atan2 autocmd_add autocmd_delete autocmd_get balloon_gettext balloon_show balloon_split bindtextdomain blob2list browse browsedir bufadd bufexists buflisted bufload bufloaded bufname bufnr bufwinid bufwinnr byte2line byteidx byteidxcomp call ceil ch_canread ch_close ch_close_in ch_evalexpr ch_evalraw ch_getbufnr ch_getjob ch_info ch_log ch_logfile ch_open ch_read ch_readblob ch_readraw ch_sendexpr ch_sendraw ch_setoptions ch_status changenr char2nr charclass charcol charidx
    8              0.000235000 syn keyword vimFuncName contained chdir cindent clearmatches col complete complete_add complete_check complete_info confirm copy cos cosh count cscope_connection cursor debugbreak deepcopy delete deletebufline did_filetype diff diff_filler diff_hlID digraph_get digraph_getlist digraph_set digraph_setlist echoraw empty environ err_teapot escape eval eventhandler executable execute exepath exists exists_compiled exp expand expandcmd extend extendnew feedkeys filecopy filereadable filewritable filter finddir findfile flatten flattennew float2nr floor fmod fnameescape fnamemodify foldclosed foldclosedend foldlevel foldtext foldtextresult foreach foreground fullcommand funcref function garbagecollect get getbufinfo getbufline getbufoneline getbufvar getcellwidths getchangelist
    8              0.000186000 syn keyword vimFuncName contained getchar getcharmod getcharpos getcharsearch getcharstr getcmdcompltype getcmdline getcmdpos getcmdscreenpos getcmdtype getcmdwintype getcompletion getcurpos getcursorcharpos getcwd getenv getfontname getfperm getfsize getftime getftype getimstatus getjumplist getline getloclist getmarklist getmatches getmousepos getmouseshape getpid getpos getqflist getreg getreginfo getregion getregionpos getregtype getscriptinfo gettabinfo gettabvar gettabwinvar gettagstack gettext getwininfo getwinpos getwinposx getwinposy getwinvar glob glob2regpat globpath has has_key haslocaldir hasmapto histadd histdel histget histnr hlID hlexists hlget hlset hostname iconv id indent index indexof input inputdialog inputlist inputrestore inputsave inputsecret
    8              0.000179000 syn keyword vimFuncName contained insert instanceof interrupt invert isabsolutepath isdirectory isinf islocked isnan items job_getchannel job_info job_setoptions job_start job_status job_stop join js_decode js_encode json_decode json_encode keys keytrans len libcall libcallnr line line2byte lispindent list2blob list2str listener_add listener_flush listener_remove localtime log log10 luaeval map maparg mapcheck maplist mapnew mapset match matchadd matchaddpos matcharg matchbufline matchdelete matchend matchfuzzy matchfuzzypos matchlist matchstr matchstrlist matchstrpos max menu_info min mkdir mode mzeval nextnonblank nr2char or pathshorten perleval popup_atcursor popup_beval popup_clear popup_close popup_create popup_dialog popup_filter_menu popup_filter_yesno
    8              0.000153000 syn keyword vimFuncName contained popup_findecho popup_findinfo popup_findpreview popup_getoptions popup_getpos popup_hide popup_list popup_locate popup_menu popup_move popup_notification popup_setbuf popup_setoptions popup_settext popup_show pow prevnonblank printf prompt_getprompt prompt_setcallback prompt_setinterrupt prompt_setprompt prop_add prop_add_list prop_clear prop_find prop_list prop_remove prop_type_add prop_type_change prop_type_delete prop_type_get prop_type_list pum_getpos pumvisible py3eval pyeval pyxeval rand range readblob readdir readdirex readfile reduce reg_executing reg_recording reltime reltimefloat reltimestr remote_expr remote_foreground remote_peek remote_read remote_send remote_startserver remove rename repeat resolve reverse round
    8              0.000182000 syn keyword vimFuncName contained rubyeval screenattr screenchar screenchars screencol screenpos screenrow screenstring search searchcount searchdecl searchpair searchpairpos searchpos server2client serverlist setbufline setbufvar setcellwidths setcharpos setcharsearch setcmdline setcmdpos setcursorcharpos setenv setfperm setline setloclist setmatches setpos setqflist setreg settabvar settabwinvar settagstack setwinvar sha256 shellescape shiftwidth sign_define sign_getdefined sign_getplaced sign_jump sign_place sign_placelist sign_undefine sign_unplace sign_unplacelist simplify sin sinh slice sort sound_clear sound_playevent sound_playfile sound_stop soundfold spellbadword spellsuggest split sqrt srand state str2float str2list str2nr strcharlen strcharpart strchars
    8              0.000316000 syn keyword vimFuncName contained strdisplaywidth strftime strgetchar stridx string strlen strpart strptime strridx strtrans strutf16len strwidth submatch substitute swapfilelist swapinfo swapname synID synIDattr synIDtrans synconcealed synstack system systemlist tabpagebuflist tabpagenr tabpagewinnr tagfiles taglist tan tanh tempname term_dumpdiff term_dumpload term_dumpwrite term_getaltscreen term_getansicolors term_getattr term_getcursor term_getjob term_getline term_getscrolled term_getsize term_getstatus term_gettitle term_gettty term_list term_scrape term_sendkeys term_setansicolors term_setapi term_setkill term_setrestore term_setsize term_start term_wait terminalprops test_alloc_fail test_autochdir test_feedinput test_garbagecollect_now test_garbagecollect_soon
    8              0.000153000 syn keyword vimFuncName contained test_getvalue test_gui_event test_ignore_error test_mswin_event test_null_blob test_null_channel test_null_dict test_null_function test_null_job test_null_list test_null_partial test_null_string test_option_not_set test_override test_refcount test_setmouse test_settime test_srand_seed test_unknown test_void timer_info timer_pause timer_start timer_stop timer_stopall tolower toupper tr trim trunc type typename undofile undotree uniq utf16idx values virtcol virtcol2col visualmode wildmenumode win_execute win_findbuf win_getid win_gettype win_gotoid win_id2tabwin win_id2win win_move_separator win_move_statusline win_screenpos win_splitmove winbufnr wincol windowsversion winheight winlayout winline winnr winrestcmd winrestview winsaveview
    8              0.000041000 syn keyword vimFuncName contained winwidth wordcount writefile xor
                            
                            "--- syntax here and above generated by mkvimvim ---
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up commands for this syntax highlighting file {{{2
                            
    8              0.000140000 com! -nargs=* Vim9 execute <q-args> s:vim9script ? "" : "contained"
    8              0.000040000 com! -nargs=* VimL execute <q-args> s:vim9script ? "contained" : ""
                            
    8              0.000046000 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[afhHlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'H'
                              com! -nargs=* VimFoldH <args> fold
                             else
                              com! -nargs=* VimFoldH <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p'
                              com! -nargs=* VimFoldp <args> fold
                             else
                              com! -nargs=* VimFoldp <args>
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    8              0.000010000 else
    8              0.000042000  com! -nargs=*	VimFolda	<args>
    8              0.000027000  com! -nargs=*	VimFoldf	<args>
    8              0.000024000  com! -nargs=*	VimFoldh	<args>
    8              0.000022000  com! -nargs=*	VimFoldH	<args>
    8              0.000025000  com! -nargs=*	VimFoldl	<args>
    8              0.000024000  com! -nargs=*	VimFoldm	<args>
    8              0.000027000  com! -nargs=*	VimFoldp	<args>
    8              0.000025000  com! -nargs=*	VimFoldP	<args>
    8              0.000024000  com! -nargs=*	VimFoldr	<args>
    8              0.000023000  com! -nargs=*	VimFoldt	<args>
    8              0.000008000 endif
                            
                            " Deprecated variable options {{{2
    8              0.000021000 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    8              0.000008000 endif
    8              0.000019000 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    8              0.000006000 endif
    8              0.000052000 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    8              0.000007000 endif
                            
                            " Variable options {{{2
    8              0.000016000 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    8              0.000007000 else
    8              0.000019000  let s:vimsyn_maxlines= 60
    8              0.000007000 endif
                            
                            " Nulls {{{2
                            " =====
    8              0.000183000 Vim9 syn keyword  vim9Null	null null_blob null_channel null_class null_dict null_function null_job null_list null_object null_partial null_string
                            
                            " Booleans {{{2
                            " ========
    8              0.000092000 Vim9 syn keyword vim9Boolean	true false
                            
                            " Numbers {{{2
                            " =======
    8              0.000007000 syn case ignore
    8              0.000242000 syn match	vimNumber	'\<\d\+\%(\.\d\+\%(e[+-]\=\d\+\)\=\)\='	skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000195000 syn match	vimNumber	'\<0b[01]\+'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000193000 syn match	vimNumber	'\<0o\=\o\+'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000185000 syn match	vimNumber	'\<0x\x\+'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000183000 syn match	vimNumber	'\<0z\>'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000207000 syn match	vimNumber	'\<0z\%(\x\x\)\+\%(\.\%(\x\x\)\+\)*'	skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000219000 syn match	vimNumber	'\%(^\|\A\)\zs#\x\{6}'		skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    8              0.000008000 syn case match
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    8              0.001801000 syn cluster vimCmdList	contains=vimAbb,vimAddress,vimAutoCmd,vimAugroup,vimBehave,vimCall,vimCatch,vimConst,vimDef,vimDelcommand,@vimEcho,vimEnddef,vimEndfunction,vimExecute,vimIsCommand,vimExtCmd,vimFor,vimFunction,vimGlobal,vimHighlight,vimLet,vimLoadkeymap,vimMap,vimMark,vimMatch,vimNotFunc,vimNorm,vimSet,vimSleep,vimSyntax,vimThrow,vimUnlet,vimUnmap,vimUserCmd,vimMenu,vimMenutranslate,@vim9CmdList
    8              0.000204000 syn cluster vim9CmdList	contains=vim9Const,vim9Final,vim9For,vim9Var
    8              0.000104000 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=@vimCmdList,vimSubst1
    8              0.000119000 syn match vimIsCommand	"\<\%(\h\w*\|[23]mat\%[ch]\)\>"	contains=vimCommand
    8              0.000100000 syn match vimBang	      contained	"!"
    8              0.000096000 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    8              0.000059000 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    8              0.000058000 syn match vimVar	      	"\s\zs&\%([lg]:\)\=\a\+\>"
    8              0.000052000 syn match vimVar		"\s\zs&t_\S[a-zA-Z0-9]\>"
    8              0.000044000 syn match vimVar        	"\s\zs&t_k;"
    8              0.000066000 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    8              0.000035000 syn keyword vimCommand  contained	in
                            
    8              0.000395000 syn cluster vimExprList	contains=vimEnvvar,vimFunc,vimNumber,vimOper,vimOperParen,vimLetRegister,vimString,vimVar,@vim9ExprList
    8              0.000104000 syn cluster vim9ExprList	contains=vim9Boolean,vim9Null
                            
                            " Insertions And Appends: insert append {{{2
                            "   (buftype != nofile test avoids having append, change, insert show up in the command window)
                            " =======================
    8              0.000032000 if &buftype != 'nofile'
    7              0.000134000  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$" extend
    7              0.000112000  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$" extend
    7              0.000110000  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$" extend
    8              0.000007000 endif
                            
                            " Behave! {{{2
                            " =======
    8              0.000042000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    8              0.000055000  syn match   vimBehaveError contained	"[^ ]\+"
    8              0.000006000 endif
    8              0.000190000 syn match   vimBehave	"\<be\%[have]\>"	nextgroup=vimBehaveBang,vimBehaveModel,vimBehaveError skipwhite
    8              0.000088000 syn match   vimBehaveBang	contained	"\a\@1<=!" nextgroup=vimBehaveModel skipwhite
    8              0.000031000 syn keyword vimBehaveModel	contained	mswin	xterm
                            
                            " Call {{{2
                            " ====
    8              0.000089000 syn match vimCall	"\<call\=\>"	skipwhite nextgroup=vimFunc
                            
                            " Exception Handling {{{2
    8              0.000046000 syn keyword	vimThrow	th[row]	skipwhite nextgroup=@vimExprList
    8              0.000095000 syn keyword	vimCatch	cat[ch]	skipwhite nextgroup=vimCatchPattern
    8              0.000211000 syn region	vimCatchPattern	contained	matchgroup=Delimiter start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)" skip="\\\\\|\\\z1" end="\z1" contains=@vimSubstList oneline
                            
                            " Filetypes {{{2
                            " =========
    8              0.000218000 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    8              0.000038000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    8              0.000044000  syn match   vimFTError  contained	"\I\i*"
    8              0.000006000 endif
    8              0.000037000 syn keyword vimFTCmd    contained	filet[ype]
    8              0.000041000 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    8              0.000700000 syn cluster vimAugroupList	contains=@vimCmdList,vimFilter,vimFunc,vimLineComment,vimSpecFile,vimOper,vimNumber,vimOperParen,@vimComment,vimString,vimSubst,vimRegister,vimCmplxRepeat,vimNotation,vimCtrlChar,vimFuncVar,vimContinue
    8              0.000236000 syn match   vimAugroup	"\<aug\%[roup]\>" contains=vimAugroupKey,vimAugroupBang skipwhite nextgroup=vimAugroupBang,vimAutoCmdGroup
    8              0.000024000 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                              syn region  vimAugroup  fold	start="\<aug\%[roup]\>\ze\s\+\%([eE][nN][dD]\)\@!\S\+" matchgroup=vimAugroupKey end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>" contains=vimAutoCmd,@vimAugroupList,vimAugroupkey skipwhite nextgroup=vimAugroupEnd
    8              0.000008000 else
    8              0.000251000   syn region  vimAugroup	start="\<aug\%[roup]\>\ze\s\+\%([eE][nN][dD]\)\@!\S\+" matchgroup=vimAugroupKey end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>" contains=vimAutoCmd,@vimAugroupList,vimAugroupkey skipwhite nextgroup=vimAugroupEnd
    8              0.000006000 endif
    8              0.000030000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    8              0.000060000   syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    8              0.000006000 endif
                            
    8              0.000040000 syn match   vimAutoCmdGroup	contained "\S\+"
    8              0.000041000 syn match   vimAugroupEnd	contained "\c\<END\>"
    8              0.000082000 syn match   vimAugroupBang	contained "\a\@1<=!" skipwhite nextgroup=vimAutoCmdGroup
    8              0.000170000 syn keyword vimAugroupKey	contained aug[roup]  skipwhite nextgroup=vimAugroupBang,vimAutoCmdGroup,vimAugroupEnd
                            
                            " Operators: {{{2
                            " =========
    8              0.000535000 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,@vimContinue,vim9Comment,vimVar,vimBoolean,vimNull
    8              0.000142000 syn match	vimOper	"||\|&&\|[-+*/%.!]"			skipwhite nextgroup=vimString,vimSpecFile
    8              0.000243000 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\|!\~#\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    8              0.000143000 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    8              0.000085000 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    8              0.000159000 syn region	vimOperParen	matchgroup=vimSep		start="#\={" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    8              0.000033000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    8              0.000040000  syn match	vimOperError	")"
    8              0.000005000 endif
                            
                            " Functions: Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    8              0.000273000 syn cluster	vimFuncList	contains=vimFuncBang,vimFunctionError,vimFuncKey,vimFuncSID,Tag
    8              0.000247000 syn cluster	vimDefList	contains=vimFuncBang,vimFunctionError,vimDefKey,vimFuncSID,Tag
                            
    8              0.000893000 syn cluster	vimFuncBodyCommon	contains=@vimCmdList,vimCmplxRepeat,vimContinue,vimCtrlChar,vimDef,vimEnvvar,vimFBVar,vimFunc,vimFunction,vimLetHereDoc,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegister,vimSearch,vimSpecFile,vimString,vimSubst,vimFuncFold
    8              0.000318000 syn cluster	vimFuncBodyList	contains=@vimFuncBodyCommon,vimComment,vimLineComment,vimFuncVar,vimInsert,vimConst,vimLet
    8              0.000369000 syn cluster	vimDefBodyList	contains=@vimFuncBodyCommon,vim9Comment,vim9LineComment,vim9Const,vim9Final,vim9Var,vim9Null,vim9Boolean,vim9For
                            
    8              0.000111000 syn region	vimFuncPattern	contained		matchgroup=vimOper start="/" end="$" contains=@vimSubstList
    8              0.000222000 syn match	vimFunction	"\<fu\%[nction]\>"	skipwhite nextgroup=vimCmdSep,vimComment,vimFuncPattern contains=vimFuncKey
    8              0.000203000 syn match	vimDef	"\<def\>"		skipwhite nextgroup=vimCmdSep,vimComment,vimFuncPattern contains=vimDefKey
                            
    8              0.000151000 syn match	vimFunction	"\<fu\%[nction]\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+"	contains=@vimFuncList skipwhite nextgroup=vimFuncParams
    8              0.000117000 syn match	vimDef	"\<def\s\+new\%(\i\|{.\{-1,}}\)\+"				contains=@vimDefList            nextgroup=vimDefParams
    8              0.000162000 syn match	vimDef	"\<def\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+"		contains=@vimDefList,vimMethodName            nextgroup=vimDefParams
                            
    8              0.000165000 syn match	vimFuncComment	contained	+".*+ skipwhite skipnl nextgroup=vimFuncBody,vimEndfunction
    8              0.000134000 syn match	vimDefComment	contained	"#.*" skipwhite skipnl nextgroup=vimDefBody,vimEnddef
                            
    8              0.000033000 syn match	vimFuncBang	contained	"!"
    8              0.000040000 syn match	vimFuncSID	contained	"\c<sid>"
    8              0.000037000 syn match	vimFuncSID	contained	"\<[sg]:"
    8              0.000039000 syn keyword	vimFuncKey	contained	fu[nction]
    8              0.000031000 syn keyword	vimDefKey	contained	def
    8              0.000032000 syn keyword	vimMethodName	contained	empty len string
                            
    8              0.000365000 syn region	vimFuncParams	contained	matchgroup=Delimiter start="(" skip=+\n\s*\\\|\n\s*"\\ + end=")" skipwhite skipnl nextgroup=vimFuncBody,vimFuncComment,vimEndfunction,vimFuncMod,vim9CommentError	contains=vimFuncParam,@vimContinue
    8              0.000429000 syn region	vimDefParams	contained	matchgroup=Delimiter start="("		   end=")" skipwhite skipnl nextgroup=vimDefBody,vimDefComment,vimEnddef,vimReturnType,vimCommentError	contains=vimDefParam,vim9Comment,vimFuncParamEquals
    8              0.000084000 syn match	vimFuncParam	contained	"\<\h\w*\>\|\.\.\."	skipwhite nextgroup=vimFuncParamEquals
    8              0.000121000 syn match	vimDefParam	contained	"\<\h\w*\>"		skipwhite nextgroup=vimParamType,vimFuncParamEquals
                            
    8              0.000040000 syn match	vimFuncParamEquals contained	"="			skipwhite        nextgroup=@vimExprList
    8              0.000257000 syn match	vimFuncMod	 contained	"\<\%(abort\|closure\|dict\|range\)\>"	skipwhite skipnl nextgroup=vimFuncBody,vimFuncComment,vimEndfunction,vimFuncMod,vim9CommentError
                            
    8              0.000217000 syn region	vimFuncBody	contained	start="^.\="	matchgroup=vimCommand end="\<endfu\%[nction]\>"	contains=@vimFuncBodyList skipwhite nextgroup=vimCmdSep,vimComment,vim9CommentError
    8              0.000207000 syn region	vimDefBody	contained	start="^.\="	matchgroup=vimCommand end="\<enddef\>"	contains=@vimDefBodyList  skipwhite nextgroup=vimCmdSep,vim9Comment,vimCommentError
                            
    8              0.000184000 syn match	vimEndfunction	"\<endf\%[unction]\>" skipwhite nextgroup=vimCmdSep,vimComment,vim9CommentError
    8              0.000170000 syn match	vimEnddef	"\<enddef\>"	    skipwhite nextgroup=vimCmdSep,vim9Comment,vimCommentError
                            
    8              0.000025000 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncFold	start="^\s*:\=\s*fu\%[nction]\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+\s*("	end="^\s*:\=\s*endf\%[unction]\>" contains=vimFunction fold keepend extend transparent
                             syn region	vimFuncFold	start="^\s*:\=\s*def\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\)\+("		end="^\s*:\=\s*enddef\>"          contains=vimDef      fold keepend extend transparent
                             syn region	vimFuncFold	start="^\s*:\=\s*def\s\+new\i\+("					end="^\s*:\=\s*enddef\>"          contains=vimDef      fold keepend extend transparent
    8              0.000008000 endif
                            
    8              0.000050000 syn match	vimFuncVar   contained	"a:\%(\K\k*\|\d\+\)\>"
    8              0.000042000 syn match	vimFuncBlank contained	"\s\+"
                            
                            " Types: {{{2
                            " =====
                            
    8              0.000284000 syn region	vimReturnType	contained	start=":\s" end="$" matchgroup=vim9Comment end="\ze[#"]" skipwhite skipnl nextgroup=vimDefBody,vimDefComment,vimEnddef,vimCommentError contains=vimTypeSep transparent
    8              0.000079000 syn match	vimParamType	contained	":\s"	skipwhite skipnl nextgroup=@vimType contains=vimTypeSep
                            
    8              0.000051000 syn match	vimTypeSep	contained	":\s\@=" skipwhite nextgroup=@vimType
    8              0.000060000 syn keyword	vimType	contained	any blob bool channel float job number string void
    8              0.000035000 syn match	vimType	contained	"\<func\>"
    8              0.000116000 syn region	vimCompoundType	contained	matchgroup=vimType start="\<func("            end=")" nextgroup=vimTypeSep contains=@vimType oneline transparent
    8              0.000080000 syn region	vimCompoundType   contained         matchgroup=vimType start="\<\%(list\|dict\)<" end=">"                      contains=@vimType oneline transparent
    8              0.000058000 syn match	vimUserType	contained	"\<\u\w*\>"
                            
    8              0.000122000 syn cluster vimType contains=vimType,vimCompoundType,vimUserType
                            
                            " Keymaps: {{{2
                            " =======
                            
    8              0.000093000 syn match  vimKeymapStart	"^"	contained skipwhite nextgroup=vimKeymapLhs,@vimKeymapLineComment
    8              0.000124000 syn match  vimKeymapLhs	"\S\+"	contained skipwhite nextgroup=vimKeymapRhs contains=vimNotation
    8              0.000123000 syn match  vimKeymapRhs	"\S\+"	contained skipwhite nextgroup=vimKeymapTailComment contains=vimNotation
    8              0.000038000 syn match  vimKeymapTailComment	"\S.*"	contained
                            
                            " TODO: remove when :" comment is matched in parts as "ex-colon comment" --djk
    8              0.000012000 if s:vim9script
                              syn match  vim9KeymapLineComment	"#.*"	contained contains=@vimCommentGroup,vimCommentString,vim9CommentTitle
    8              0.000007000 else
    8              0.000130000   syn match  vimKeymapLineComment	+".*+	contained contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    8              0.000006000 endif
    8              0.006772000 syn cluster vimKeymapLineComment contains=vim9\=KeymapLineComment
                            
    8              0.000136000 syn region vimLoadkeymap matchgroup=vimCommand start="\<loadk\%[eymap]\>" end="\%$" contains=vimKeymapStart
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    8              0.000154000 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst1
    8              0.000131000 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst1
    8              0.000120000 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst1
    8              0.000117000 syn match	vimSpecFile	"\s%$"ms=s+1		nextgroup=vimSpecFileMod,vimSubst1
    8              0.000114000 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst1
    8              0.000147000 syn match	vimSpecFile	"#\d\+\|[#%]<\>"		nextgroup=vimSpecFileMod,vimSubst1
    8              0.000044000 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    8              0.000542000 syn cluster	vimUserCmdList	contains=@vimCmdList,vimCmplxRepeat,@vimComment,vimCtrlChar,vimEscapeBrace,vimFunc,vimNotation,vimNumber,vimOper,vimRegister,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange
    8              0.000035000 syn keyword	vimUserCmdKey	contained	com[mand]
    8              0.000159000 syn match	vimUserCmdName	contained	"\<\u[[:alnum:]]*\>"	skipwhite nextgroup=vimUserCmdBlock
    8              0.000466000 syn match	vimUserCmd		"\<com\%[mand]\>!\=.*$"	contains=vimUserCmdKey,vimBang,vimUserCmdAttr,vimUserCmdAttrError,vimUserCmdName,@vimUserCmdList,vimComFilter
    8              0.000048000 syn match	vimUserCmdAttrError	contained	"-\a\+\ze\%(\s\|=\)"
    8              0.000128000 syn match	vimUserCmdAttr	contained	"-addr="		contains=vimUserCmdAttrKey nextgroup=vimUserCmdAttrAddr
    8              0.000069000 syn match	vimUserCmdAttr	contained	"-bang\>"		contains=vimUserCmdAttrKey
    8              0.000067000 syn match	vimUserCmdAttr	contained	"-bar\>"		contains=vimUserCmdAttrKey
    8              0.000066000 syn match	vimUserCmdAttr	contained	"-buffer\>"		contains=vimUserCmdAttrKey
    8              0.000156000 syn match	vimUserCmdAttr	contained	"-complete="		contains=vimUserCmdAttrKey nextgroup=vimUserCmdAttrCmplt,vimUserCmdError
    8              0.000066000 syn match	vimUserCmdAttr	contained	"-count\>"		contains=vimUserCmdAttrKey
    8              0.000112000 syn match	vimUserCmdAttr	contained	"-count="		contains=vimUserCmdAttrKey nextgroup=vimNumber
    8              0.000070000 syn match	vimUserCmdAttr	contained	"-keepscript\>"		contains=vimUserCmdAttrKey
    8              0.000111000 syn match	vimUserCmdAttr	contained	"-nargs="		contains=vimUserCmdAttrKey nextgroup=vimUserCmdAttrNargs
    8              0.000070000 syn match	vimUserCmdAttr	contained	"-range\>"		contains=vimUserCmdAttrKey
    8              0.000164000 syn match	vimUserCmdAttr	contained	"-range="		contains=vimUserCmdAttrKey nextgroup=vimNumber,vimUserCmdAttrRange
    8              0.000070000 syn match	vimUserCmdAttr	contained	"-register\>"		contains=vimUserCmdAttrKey
                            
    8              0.000040000 syn match	vimUserCmdAttrNargs	contained	"[01*?+]"
    8              0.000030000 syn match	vimUserCmdAttrRange	contained	"%"
                            
    8              0.000047000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    8              0.000036000  syn match	vimUserCmdError	contained	"\S\+\>"
    8              0.000009000 endif
                            
    8              0.000008000 syn case ignore
    8              0.000115000 syn keyword	vimUserCmdAttrKey   contained	a[ddr] ban[g] bar bu[ffer] com[plete] cou[nt] k[eepscript] n[args] ra[nge] re[gister]
                            " GEN_SYN_VIM: vimUserCmdAttrCmplt, START_STR='syn keyword vimUserCmdAttrCmplt contained', END_STR=''
    8              0.000159000 syn keyword vimUserCmdAttrCmplt contained arglist augroup behave breakpoint buffer color command compiler cscope diff_buffer dir dir_in_path environment event expression file file_in_path filetype function help highlight history keymap locale mapclear mapping menu messages option packadd runtime scriptnames shellcmd sign syntax syntime tag tag_listfiles user var
    8              0.000120000 syn keyword	vimUserCmdAttrCmplt     contained	custom customlist nextgroup=vimUserCmdAttrCmpltFunc,vimUserCmdError
    8              0.000124000 syn match	vimUserCmdAttrCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%([.#]\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            " GEN_SYN_VIM: vimUserCmdAttrAddr, START_STR='syn keyword vimUserCmdAttrAddr contained', END_STR=''
    8              0.000059000 syn keyword vimUserCmdAttrAddr contained arguments arg buffers buf lines line loaded_buffers load other quickfix qf tabs tab windows win
    8              0.000030000 syn match	vimUserCmdAttrAddr	contained	"?"
    8              0.000007000 syn case match
                            
    8              0.000071000 syn region	vimUserCmdBlock	contained	matchgroup=vimSep start="{" end="}" contains=@vimDefBodyList
                            
    8              0.000093000 syn match	vimDelcommand		"\<delc\%[ommand]\>" skipwhite nextgroup=vimDelcommandAttr
    8              0.000035000 syn match	vimDelcommandAttr	contained	"-buffer\>"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    8              0.000039000 if get(g:, "vimsyn_comment_strings", 1)
    8              0.000050000   syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e end='"'
    8              0.000006000 endif
                            
    8              0.000016000 if s:vim9script
                              syn cluster vimComment contains=vim9Comment
    8              0.000006000 else
    8              0.000053000   syn cluster vimComment contains=vimComment
    8              0.000005000 endif
                            
    8              0.000181000 VimL syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    8              0.000154000 VimL syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    8              0.000134000 VimL syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
                            " Vim9 comments - TODO: might be highlighted while they don't work
    8              0.000145000 Vim9 syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    8              0.000149000 Vim9 syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString
    8              0.000154000 Vim9 syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString
                            " Vim9 comment inside expression
    8              0.000140000 Vim9 syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString contained
    8              0.000155000 Vim9 syn match	vim9Comment	+^\s*#[^{].*$+		contains=@vimCommentGroup,vimCommentString contained
    8              0.000131000 Vim9 syn match	vim9Comment	+^\s*#$+		contains=@vimCommentGroup,vimCommentString contained
                            
    8              0.000048000 syn match	vim9CommentError	contained	"#.*"
    8              0.000032000 syn match	vimCommentError	contained	+".*+
                            
                            " Environment Variables: {{{2
                            " =====================
    8              0.000043000 syn match	vimEnvvar	"\$\I\i*"
    8              0.000043000 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    8              0.000088000 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    8              0.000038000 syn match	vimPatSepErr	contained	"\\)"
    8              0.000036000 syn match	vimPatSep	contained	"\\|"
    8              0.000104000 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    8              0.000084000 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    8              0.000044000 syn match	vimNotPatSep	contained	"\\\\"
    8              0.000223000 syn cluster	vimStringGroup	contains=vimEscape,vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    8              0.000108000 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    8              0.000062000 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
    8              0.000084000 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    8              0.000055000 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
    8              0.000030000 syn match	vimEscape	contained	"\\."
                            " syn match	vimEscape	contained	+\\[befnrt\"]+
    8              0.000081000 syn match	vimEscape	contained	"\\\o\{1,3}\|\\[xX]\x\{1,2}\|\\u\x\{1,4}\|\\U\x\{1,8}"
    8              0.000075000 syn match	vimEscape	contained	"\\<" contains=vimNotation
    8              0.000037000 syn match	vimEscape	contained	"\\<\*[^>]*>\=>"
                            
    8              0.000093000 syn region	vimString	oneline start=+$'+ skip=+''+ end=+'+ contains=@vimStringInterpolation
    8              0.000055000 syn region	vimString	oneline start=+$"+ end=+"+ contains=@vimStringGroup,@vimStringInterpolation
    8              0.000071000 syn region	vimStringInterpolationExpr  oneline contained matchgroup=vimSep start=+{+ end=+}+ contains=@vimExprList
    8              0.000039000 syn match	vimStringInterpolationBrace contained "{{"
    8              0.000028000 syn match	vimStringInterpolationBrace contained "}}"
    8              0.000084000 syn cluster	vimStringInterpolation contains=vimStringInterpolationExpr,vimStringInterpolationBrace
                            
                            " Substitutions: {{{2
                            " =============
    8              0.000225000 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    8              0.000123000 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    8              0.000075000 syn cluster	vimSubstList	add=vimCollection
    8              0.000108000 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)\>"			skipwhite nextgroup=vimSubstPat
    8              0.000099000 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)[_#]\@="		skipwhite nextgroup=vimSubstPat
    8              0.000094000 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)\>"		skipwhite nextgroup=vimSubstPat
    8              0.000091000 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)[_#]\@="	skipwhite nextgroup=vimSubstPat
                            " TODO: Vim9 illegal separators for abbreviated :s form are [-.:], :su\%[...] required
                            "     : # is allowed but "not recommended" (see :h pattern-delimiter)
    8              0.000153000 syn region	vimSubstPat	contained	matchgroup=vimSubstDelim start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    8              0.000160000 syn region	vimSubstRep4	contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>"	contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    8              0.000097000 syn region	vimCollection	contained 	transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    8              0.000043000 syn match	vimCollClassErr	contained	"\[:.\{-\}:\]"
    8              0.000148000 syn match	vimCollClass	contained 	transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|retu\%[rn]\|tab\|escape\|backspace\):\]"
    8              0.000034000 syn match	vimSubstSubstr	contained	"\\z\=\d"
    8              0.000027000 syn match	vimSubstTwoBS	contained	"\\\\"
    8              0.000082000 syn match	vimSubstFlagErr	contained	"[^< \t\r|]\+" contains=vimSubstFlags
    8              0.000042000 syn match	vimSubstFlags	contained	"[&cegiIlnpr#]\+"
                            
                            " Vi compatibility
    8              0.000051000 syn match	vimSubstDelim	contained	"\\"
    8              0.000100000 syn match	vimSubstPat	contained	"\\\ze[/?&]" contains=vimSubstDelim nextgroup=vimSubstRep4
                            
                            " 'String': {{{2
    8              0.000050000 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    8              0.000287000 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    8              0.000204000 syn match	vimMark	"'[[\]{}()<>]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    8              0.000165000 syn match	vimMark	",\zs'[[\]{}()<>]\ze"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    8              0.000163000 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    8              0.000448000 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    8              0.000158000 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst1
    8              0.000046000 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    8              0.000156000 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    8              0.000086000 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    8              0.000052000 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    8              0.000056000 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    8              0.000041000 syn match	vimRegister	'@"'
    8              0.000073000 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
    8              0.000057000 syn match	vimLetRegister	contained	'@["0-9\-a-zA-Z#=*+_/]'
                            
    8              0.000089000 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    8              0.000128000 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    8              0.000138000 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    8              0.000173000 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    8              0.000124000 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
                            " ===============
    8              0.000065000 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    8              0.000059000 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    8              0.000156000 syn match	vimSet		"\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skipwhite nextgroup=vimSetBang,vimSetRegion
    8              0.000343000 syn region	vimSetRegion	contained	start="\S" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*["#]\\ + matchgroup=vimCmdSep end="|" end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend contains=@vimComment,@vimContinue,vimErrSetting,vimOption,vimSetAll,vimSetTermcap
    8              0.000351000 syn region	vimSetEqual	contained	matchgroup=vimOper start="[=:]\|[-+^]=" skip=+\\\\\|\\|\|\\\s\|\n\s*\\\|\n\s*["#]\\ \|^\s*\\\|^\s*["#]\\ + matchgroup=vimCmdSep end="|" end="\ze\s" end="$" contains=@vimContinue,vimCtrlChar,vimEnvvar,vimNotation,vimSetSep
    8              0.000100000 syn match	vimSetBang	contained	"\a\@1<=!" skipwhite nextgroup=vimSetAll,vimSetTermcap
    8              0.000075000 syn keyword	vimSetAll	contained	all nextgroup=vimSetMod
    8              0.000024000 syn keyword	vimSetTermcap	contained	termcap
    8              0.000167000 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    8              0.000035000 syn match	vimSetSep	contained	"[,:]"
    8              0.000072000 syn match	vimSetMod	contained	"\a\@1<=\%(&vim\=\|[!&?<]\)"
                            
                            " Variable Declarations: {{{2
                            " =====================
    8              0.000298000 VimL syn keyword	vimLet	let		skipwhite nextgroup=vimVar,vimFuncVar,vimLetRegister,vimVarList
    8              0.000158000 VimL syn keyword	vimConst	cons[t]		skipwhite nextgroup=vimVar,vimVarList
    8              0.000096000 syn region	vimVarList	contained	start="\[" end="]" contains=vimVar,@vimContinue
                            
    8              0.000156000 VimL syn keyword	vimUnlet	unl[et]		skipwhite nextgroup=vimUnletBang,vimUnletVars
    8              0.000071000 syn match	vimUnletBang	contained	"!"	skipwhite nextgroup=vimUnletVars
    8              0.000346000 syn region	vimUnletVars	contained	start="$\I\|\h" skip="\n\s*\\" end="$" end="|" contains=vimVar,vimEnvvar,vimContinue,vimString,vimNumber
                            
    8              0.000281000 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='\%(^\z(\s*\)\S.*\)\@<==<<\s*trim\%(\s\+\)\@>\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\z1\=\z2$' extend
    8              0.000159000 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\%(\s*\)\@>\z(\L\S*\)'			matchgroup=vimLetHereDocStop end='^\z1$' extend
    8              0.000172000 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='\%(^\z(\s*\)\S.*\)\@<==<<\s*\%(trim\s\+eval\|eval\s\+trim\)\%(\s\+\)\@>\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\z1\=\z2$' contains=@vimStringInterpolation extend
    8              0.000112000 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\s*eval\%(\s\+\)\@>\z(\L\S*\)'			matchgroup=vimLetHereDocStop end='^\z1$' contains=@vimStringInterpolation extend
                            
    8              0.000154000 Vim9 syn keyword	vim9Const	const	skipwhite nextgroup=vim9Variable,vim9VariableList
    8              0.000133000 Vim9 syn keyword	vim9Final	final	skipwhite nextgroup=vim9Variable,vim9VariableList
    8              0.000134000 Vim9 syn keyword	vim9Var	var	skipwhite nextgroup=vim9Variable,vim9VariableList
                            
    8              0.000106000 syn match	vim9Variable	contained	"\<\h\w*\>"	skipwhite nextgroup=vimTypeSep,vimLetHereDoc
    8              0.000069000 syn region	vim9VariableList	contained	start="\[" end="]" contains=vim9Variable,@vimContinue
                            
                            " For: {{{2
                            " ===
    8              0.000010000 if s:vim9script
                              syn keyword	vim9For	for	skipwhite nextgroup=vim9Variable,vim9VariableList
    8              0.000007000 else
    8              0.000104000   syn keyword	vimFor	for	skipwhite nextgroup=vimVar,vimVarList
    8              0.000006000 endif
                            
                            " Abbreviations: {{{2
                            " =============
                            " GEN_SYN_VIM: vimCommand abbrev, START_STR='syn keyword vimAbb', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    8              0.000201000 syn keyword vimAbb ab[breviate] ca[bbrev] cnorea[bbrev] cuna[bbrev] ia[bbrev] inorea[bbrev] iuna[bbrev] norea[bbrev] una[bbreviate] skipwhite nextgroup=vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand abclear, START_STR='syn keyword vimAbb', END_STR='skipwhite nextgroup=vimMapMod'
    8              0.000084000 syn keyword vimAbb abc[lear] cabc[lear] iabc[lear] skipwhite nextgroup=vimMapMod
                            
                            " Autocmd: {{{2
                            " =======
    8              0.000140000 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent nextgroup=vimAutoCmdSpace
    8              0.000067000 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    8              0.000098000 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod,vimAutoCmdBlock
    8              0.000093000 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    8              0.000072000 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"	skipwhite nextgroup=vimAutoCmdBlock
    8              0.000061000 syn region	vimAutoCmdBlock	contained	matchgroup=vimSep start="{" end="}" contains=@vimDefBodyList
                            
                            " Echo And Execute: -- prefer strings! {{{2
                            " ================
                            " NOTE: No trailing comments
                            
    8              0.000252000 syn region	vimEcho
                                  \ matchgroup=vimCommand
                                  \ start="\<ec\%[ho]\>"
                                  \ start="\<echoe\%[rr]\>"
                                  \ start="\<echom\%[sg]\>"
                                  \ start="\<echoc\%[onsole]\>"
                                  \ start="\<echon\>"
                                  \ start="\<echow\%[indow]\>"
                                  \ skip=+\\|\|\n\s*\\\|\n\s*"\\ +
                                  \ matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimExprList transparent
                            
    8              0.000168000 syn match	vimEchohl	"\<echohl\=\>"	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchohlNone
    8              0.000008000 syn case ignore
    8              0.000024000 syn keyword	vimEchohlNone	contained none
    8              0.000007000 syn case match
                            
    8              0.000065000 syn cluster	vimEcho	contains=vimEcho,vimEchohl
                            
    8              0.000135000 syn region	vimExecute	matchgroup=vimCommand start="\<exe\%[cute]\>" skip=+\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimExprList transparent
                            
                            " Maps: {{{2
                            " ====
                            " GEN_SYN_VIM: vimCommand map, START_STR='syn keyword vimMap', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    8              0.000208000 syn keyword vimMap cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] om[ap] ono[remap] smap snor[emap] tma[p] tno[remap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapMod,vimMapLhs
    8              0.000131000 syn match	vimMap	"\<map\>"	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    8              0.000123000 syn keyword	vimMap	no[remap]	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand mapclear, START_STR='syn keyword vimMap', END_STR='skipwhite nextgroup=vimMapMod'
    8              0.000121000 syn keyword vimMap cmapc[lear] imapc[lear] lmapc[lear] nmapc[lear] omapc[lear] smapc[lear] tmapc[lear] vmapc[lear] xmapc[lear] skipwhite nextgroup=vimMapMod
    8              0.000092000 syn keyword	vimMap	mapc[lear]	skipwhite nextgroup=vimMapBang,vimMapMod
                            " GEN_SYN_VIM: vimCommand unmap, START_STR='syn keyword vimUnmap', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    8              0.000146000 syn keyword vimUnmap cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] tunma[p] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapMod,vimMapLhs
    8              0.000118000 syn keyword	vimUnmap	unm[ap]	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            
    8              0.000259000 syn match	vimMapLhs	contained	"\%(.\|\S\)\+"		contains=vimCtrlChar,vimNotation skipwhite        nextgroup=vimMapRhs
    8              0.000169000 syn match	vimMapLhs	contained	"\%(.\|\S\)\+\ze\s*$"	contains=vimCtrlChar,vimNotation skipwhite skipnl nextgroup=vimMapRhsContinue
    8              0.000090000 syn match	vimMapBang	contained	"\a\@1<=!"		skipwhite nextgroup=vimMapMod,vimMapLhs
    8              0.000222000 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    8              0.000185000 syn region	vimMapRhs	contained	start="\S" 	        skip=+\\|\|\@1<=|\|\n\s*\\\|\n\s*"\\ + end="|" end="$" contains=@vimContinue,vimCtrlChar,vimNotation skipnl nextgroup=vimMapRhsContinue
                            " assume a continuation comment introduces the RHS
    8              0.000153000 syn region	vimMapRhsContinue	contained	start=+^\s*\%(\\\|"\\ \)+ skip=+\\|\|\@1<=|\|\n\s*\\\|\n\s*"\\ + end="|" end="$" contains=@vimContinue,vimCtrlChar,vimNotation
    8              0.000006000 syn case ignore
    8              0.000050000 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    8              0.000007000 syn case match
                            
                            " Menus: {{{2
                            " =====
                            " NOTE: tail comments disallowed
                            " GEN_SYN_VIM: vimCommand menu, START_STR='syn keyword vimMenu', END_STR='skipwhite nextgroup=vimMenuBang,vimMenuMod,vimMenuName,vimMenuPriority,vimMenuStatus'
    8              0.000399000 syn keyword vimMenu am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] sme[nu] snoreme[nu] sunme[nu] tlm[enu] tln[oremenu] tlu[nmenu] tm[enu] tu[nmenu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] xme[nu] xnoreme[nu] xunme[nu] skipwhite nextgroup=vimMenuBang,vimMenuMod,vimMenuName,vimMenuPriority,vimMenuStatus
    8              0.000101000 syn keyword vimMenu popu[p] skipwhite nextgroup=vimMenuBang,vimMenuName
    8              0.000141000 syn region	vimMenuRhs	 contained contains=@vimContinue,vimNotation start="|\@!\S"            skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + end="$" matchgroup=vimSep end="|"
    8              0.000140000 syn region	vimMenuRhsContinue contained contains=@vimContinue,vimNotation start=+^\s*\%(\\\|"\\ \)+ skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + end="$" matchgroup=vimSep end="|"
    8              0.000189000 syn match	vimMenuName	"\.\@!\%(\\\s\|\S\)\+"        contained contains=vimMenuNotation,vimNotation skipwhite        nextgroup=vimCmdSep,vimMenuRhs
    8              0.000183000 syn match	vimMenuName	"\.\@!\%(\\\s\|\S\)\+\ze\s*$" contained contains=vimMenuNotation,vimNotation skipwhite skipnl nextgroup=vimCmdSep,vimMenuRhsContinue
    8              0.000036000 syn match	vimMenuNotation	"&\a\|&&\|\\\s\|\\\." contained
    8              0.000081000 syn match	vimMenuPriority	"\<\d\+\%(\.\d\+\)*\>" contained skipwhite nextgroup=vimMenuName
    8              0.000186000 syn match	vimMenuMod	"\c<\%(script\|silent\|special\)>" contained skipwhite nextgroup=vimMenuName,vimMenuPriority,vimMenuMod contains=vimMapModKey,vimMapModErr
    8              0.000061000 syn keyword	vimMenuStatus	enable disable nextgroup=vimMenuName skipwhite
    8              0.000084000 syn match	vimMenuBang	"\a\@1<=!" contained skipwhite nextgroup=vimMenuName,vimMenuMod
                            
    8              0.000233000 syn region	vimMenutranslate
                                  \ matchgroup=vimCommand start="\<menut\%[ranslate]\>"
                                  \ skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ +
                                  \ end="$" matchgroup=vimCmdSep end="|" matchgroup=vimMenuClear end="\<clear\ze\s*\%(["#|]\|$\)"
                                  \ contains=@vimContinue,vimMenutranslateName keepend transparent
                            " oneline is sufficient to match the current formatting in runtime/lang/*.vim
    8              0.000106000 syn match	vimMenutranslateName "\%(\\\s\|\S\)\+" contained contains=vimMenuNotation,vimNotation
    8              0.000078000 syn match	vimMenutranslateComment +".*+ contained containedin=vimMenutranslate
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    8              0.000007000 syn case ignore
    8              0.000382000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd]-\)\{0,4}x\=\%(f\d\{1,2}\|[^ \t:]\|space\|bar\|bslash\|nl\|newline\|lf\|linefeed\|cr\|retu\%[rn]\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|csi\|right\|paste\%(start\|end\)\|left\|help\|undo\|k\=insert\|ins\|mouse\|[kz]\=home\|[kz]\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\%(page\)\=\%(\|down\|up\|k\d\>\)\)>" contains=vimBracket
                            
    8              0.000125000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}\%(net\|dec\|jsb\|pterm\|urxvt\|sgr\)mouse>"		contains=vimBracket
    8              0.000138000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}\%(left\|middle\|right\)\%(mouse\|drag\|release\)>"	contains=vimBracket
    8              0.000097000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}left\%(mouse\|release\)nm>"			contains=vimBracket
    8              0.000098000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}x[12]\%(mouse\|drag\|release\)>"		contains=vimBracket
    8              0.000092000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}sgrmouserelease>"			contains=vimBracket
    8              0.000091000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}mouse\%(up\|down\|move\)>"			contains=vimBracket
    8              0.000102000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}scrollwheel\%(up\|down\|right\|left\)>"		contains=vimBracket
                            
    8              0.000091000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%(sid\|nop\|nul\|lt\|drop\)>"				contains=vimBracket
    8              0.000126000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%(snr\|plug\|cursorhold\|ignore\|cmd\|scriptcmd\|focus\%(gained\|lost\)\)>"	contains=vimBracket
    8              0.000155000 syn match	vimNotation	'\%(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    8              0.000124000 syn match	vimNotation	'\%#=1\%(\\\|<lt>\)\=<\%(q-\)\=\%(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    8              0.000126000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([cas]file\|abuf\|amatch\|cexpr\|cword\|cWORD\|client\|stack\|script\|sf\=lnum\)>"	contains=vimBracket
    8              0.000105000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd]-\)\{0,4}char-\%(\d\+\|0\o\+\|0x\x\+\)>"		contains=vimBracket
                            
    8              0.000033000 syn match	vimBracket contained	"[\\<>]"
    8              0.000006000 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    8              0.000261000 syn match	vimFunc              	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("                	contains=vimFuncEcho,vimFuncName,vimUserFunc,vimExecute
    8              0.000154000 syn match	vimUserFunc	contained        	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation,vimMethodName
    8              0.000032000 syn keyword	vimFuncEcho	contained      	ec ech echo
                            
    8              0.000132000 syn match	vimMap	"\<map\%(\s\+(\)\@="	skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            
                            " User Command Highlighting: {{{2
    8              0.000075000 syn match vimUsrCmd	'^\s*\zs\u\%(\w*\)\@>\%([(#[]\|\s\+\%([-+*/%]\=\|\.\.\)=\)\@!'
                            
                            " Errors And Warnings: {{{2
                            " ====================
    8              0.000060000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
                             " TODO: The new-prefix exception should only apply to constructor definitions.
                             " TODO: The |builtin-object-methods| exception should only apply to method
                             " definitions.
    8              0.000151000  syn match	vimFunctionError	"\s\zs\%(empty\|len\|new\|string\)\@![a-z0-9]\i\{-}\ze\s*("		contained contains=vimFuncKey,vimFuncBlank
    8              0.000137000  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    8              0.000060000  syn match	vimElseIfErr	"\<else\s\+if\>"
    8              0.000063000  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    8              0.000007000 endif
                            
    8              0.000261000 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<retu\%[rn]\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Match: {{{2
                            " =====
    8              0.000113000 syn match	vimMatch		"\<[23]\=mat\%[ch]\>" skipwhite nextgroup=vimMatchGroup,vimMatchNone
    8              0.000074000 syn match	vimMatchGroup	contained	"[[:alnum:]._-]\+"    skipwhite nextgroup=vimMatchPattern
    8              0.000006000 syn case ignore
    8              0.000025000 syn keyword	vimMatchNone	contained	none
    8              0.000004000 syn case match
    8              0.000137000 syn region	vimMatchPattern	contained	matchgroup=Delimiter start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)" skip="\\\\\|\\\z1" end="\z1" contains=@vimSubstList oneline
                            
                            " Norm: {{{2
                            " ====
    8              0.000078000 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    8              0.000030000 syn match	vimNormCmds contained	".*$"
                            
                            " Sleep: {{{2
                            " =====
    8              0.000107000 syn keyword	vimSleep		sl[eep]		skipwhite nextgroup=vimSleepBang,vimSleepArg
    8              0.000058000 syn match	vimSleepBang	contained	"\a\@1<=!"		skipwhite nextgroup=vimSleepArg
    8              0.000035000 syn match	vimSleepArg	contained	"\<\%(\d\+\)\=m\=\>"
                            
                            " Syntax: {{{2
                            "=======
    8              0.000098000 syn match	vimGroupList	contained	"[^[:space:],]\+\%(\s*,\s*[^[:space:],]\+\)*" contains=vimGroupSpecial
    8              0.000152000 syn region	vimGroupList	contained	start=/^\s*["#]\\ \|^\s*\\\|[^[:space:],]\+\s*,/ skip=/\s*\n\s*\\\|\s*\n\s*["#]\\ \|^\s*\\\|^\s*["#]\\ / end=/[^[:space:],]\s*$\|[^[:space:],]\ze\s\+\w/ contains=@vimContinue,vimGroupSpecial
    8              0.000033000 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
                            
    8              0.000056000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    8              0.000036000  syn match	vimSynError	contained	"\i\+"
    8              0.000053000  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    8              0.000004000 endif
    8              0.000075000 syn match	vimSynContains	contained	"\<contain\%(s\|edin\)="	skipwhite skipnl nextgroup=vimGroupList
    8              0.000071000 syn match	vimSynKeyContainedin	contained	"\<containedin="	skipwhite skipnl nextgroup=vimGroupList
    8              0.000064000 syn match	vimSynNextgroup	contained	"\<nextgroup="		skipwhite skipnl nextgroup=vimGroupList
    8              0.000042000 if has("conceal")
                             " no whitespace allowed after '='
    8              0.000070000  syn match	vimSynCchar	contained	"\<cchar="	nextgroup=vimSynCcharValue
    8              0.000025000  syn match	vimSynCcharValue	contained	"\S"
    8              0.000005000 endif
                            
    8              0.000130000 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,@vimComment
    8              0.000056000 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    8              0.000088000 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    8              0.000033000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    8              0.000026000  syn match	vimSynCaseError	contained	"\i\+"
    8              0.000007000 endif
    8              0.000023000 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    8              0.000050000 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    8              0.000054000 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    8              0.000234000 syn region	vimClusterName	contained keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="$\||" contains=@vimContinue,vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    8              0.000054000 syn match	vimGroupAdd	contained keepend	"\<add="	skipwhite skipnl nextgroup=vimGroupList
    8              0.000052000 syn match	vimGroupRem	contained keepend	"\<remove="	skipwhite skipnl nextgroup=vimGroupList
                            
                            " Syntax: foldlevel {{{2
    8              0.000091000 syn keyword	vimSynType	contained	foldlevel	skipwhite nextgroup=vimSynFoldMethod,vimSynFoldMethodError
    8              0.000028000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynfoldmethoderror")
    8              0.000027000  syn match	vimSynFoldMethodError	contained	"\i\+"
    8              0.000005000 endif
    8              0.000022000 syn keyword	vimSynFoldMethod	contained	start	minimum
                            
                            " Syntax: iskeyword {{{2
    8              0.000067000 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    8              0.000059000 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    8              0.000022000 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    8              0.000048000 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: keyword {{{2
    8              0.000135000 syn cluster	vimSynKeyGroup	contains=@vimContinue,vimSynCchar,vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    8              0.000052000 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    8              0.000104000 syn region	vimSynKeyRegion	contained         keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|\|$" contains=@vimSynKeyGroup
    8              0.000069000 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
                            
                            " Syntax: match {{{2
    8              0.000251000 syn cluster	vimSynMtchGroup	contains=@vimContinue,vimSynCchar,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vimMtchComment
    8              0.000053000 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    8              0.000101000 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|\|$" contains=@vimSynMtchGroup
    8              0.000087000 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
                            
                            " Syntax: off and on {{{2
    8              0.000035000 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    8              0.000273000 syn cluster	vimSynRegPatGroup	contains=@vimContinue,vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    8              0.000181000 syn cluster	vimSynRegGroup	contains=@vimContinue,vimSynCchar,vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    8              0.000051000 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    8              0.000073000 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip=+\\\\\|\\\|\n\s*\\\|\n\s*"\\ + end="|\|$" contains=@vimSynRegGroup
    8              0.000152000 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    8              0.000062000 syn match	vimSynReg	contained	"\<\%(start\|skip\|end\)="	nextgroup=vimSynRegPat
    8              0.000126000 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup
    8              0.000156000 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip=/\\\\\|\\\z1\|\n\s*\\\|\n\s*"\\ /  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    8              0.000060000 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    8              0.000076000 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    8              0.000029000 syn match	vimSynPatMod	contained	"lc=\d\+"
    8              0.000050000 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    8              0.000044000 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    8              0.000029000 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    8              0.000042000 syn match	vimMtchComment	contained	'"[^"]\+$'
                            
                            " Syntax: sync {{{2
                            " ============
    8              0.000254000 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    8              0.000032000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    8              0.000023000  syn match	vimSyncError	contained	"\i\+"
    8              0.000005000 endif
    8              0.000026000 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    8              0.000050000 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    8              0.000044000 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    8              0.000082000 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    8              0.000053000 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    8              0.000084000 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    8              0.000070000 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    8              0.000066000 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    8              0.000077000 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    8              0.000021000 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    8              0.000133000 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    8              0.000105000 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,@vimComment
    8              0.000033000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    8              0.000033000  syn match	vimHiCtermError	contained	"\D\i*"
    8              0.000004000 endif
    8              0.000078000 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    8              0.000033000 syn match	vimHiBang	contained	"\a\@1<=!"	skipwhite nextgroup=@vimHighlightCluster
                            
    8              0.000029000 syn match	vimHiGroup	contained	"\i\+"
    8              0.000006000 syn case ignore
    8              0.000077000 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl underdashed underdotted underdouble
    8              0.000037000 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    8              0.000007000 syn case match
    8              0.000054000 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    8              0.000069000 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    8              0.000008000 syn case ignore
    8              0.000109000 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey grey40 grey50 grey90 lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred lightyellow magenta red seagreen white yellow
    8              0.000044000 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    8              0.000005000 syn case match
    8              0.000042000 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    8              0.000043000 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    8              0.000042000 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    8              0.000468000 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiCtermfont,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation,vimComment,vim9comment
    8              0.000104000 syn region	vimHiKeyList	contained 	start="\i\+" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimHiCluster
    8              0.000042000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    8              0.000025000  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    8              0.000005000 endif
    8              0.000079000 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    8              0.000106000 syn match	vimHiStartStop	contained	"\c\%(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    8              0.000051000 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    8              0.000123000 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    8              0.000113000 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    8              0.000113000 syn match	vimHiCtermfont	contained	"\cctermfont="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    8              0.000047000 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    8              0.000047000 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    8              0.000123000 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    8              0.000062000 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    8              0.000021000 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    8              0.000089000 syn keyword	vimHiClear	contained	clear	skipwhite nextgroup=vimGroup,vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
                            " TODO: simplify and allow line continuations --djk
    8              0.000176000 syn region	vimHiLink	contained matchgroup=Type start="\%(\<hi\%[ghlight]!\=\s\+\)\@<=\%(\%(def\%[ault]\s\+\)\=link\>\|\<def\%[ault]\>\)" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimHiCluster
                            
                            " Control Characters: {{{2
                            " ==================
    8              0.000038000 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    8              0.000224000 Vim9 syn region	vim9LineComment	start=+^[ \t:]*\zs#.*$+ skip=+\n\s*\\\|\n\s*#\\ + end="$" contains=@vimCommentGroup,vimCommentString,vim9CommentTitle
    8              0.000202000 VimL syn region	vimLineComment	start=+^[ \t:]*\zs".*$+ skip=+\n\s*\\\|\n\s*"\\ + end="$" contains=@vimCommentGroup,vimCommentString,vimCommentTitle
                            
    8              0.000143000 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    8              0.000130000 syn match	vim9CommentTitle	'#\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vim9CommentTitleLeader,vimTodo,@vimCommentGroup
                            
                            " allowed anywhere in the file
    8              0.000011000 if !s:vim9script
    8              0.000038000   syn match	vimShebangError	"^\s*\zs#!.*" display
    8              0.000005000 endif
    8              0.000035000 syn match	vimShebang	"\%^#!.*" display
                            
    8              0.000037000 syn match	vimContinue		"^\s*\zs\\"
    8              0.000042000 syn match         vimContinueComment	'^\s*\zs["#]\\ .*'
    8              0.000071000 syn cluster	vimContinue contains=vimContinue,vimContinueComment
    8              0.000107000 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    8              0.000030000 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
    8              0.000024000 syn match	vim9CommentTitleLeader	'#\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    8              0.000066000 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    8              0.000035000 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    8              0.000233000 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst1
    8              0.000144000 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst1
                            
                            " Vim9 Script Regions: {{{2
                            " ==================
                            
    8              0.000010000 if s:vim9script
                              syn cluster vimLegacyTop	contains=TOP,vim9LegacyHeader,vim9Comment,vim9LineComment
                              VimFoldH syn region vim9LegacyHeader start="\%^" end="^\ze\s*vim9s\%[cript]\>" contains=@vimLegacyTop,vimComment,vimLineComment
                            
                              syn keyword vim9Vim9ScriptArg	noclear contained
                              syn keyword vim9Vim9Script	vim9s[cript] nextgroup=vim9Vim9ScriptArg skipwhite
    8              0.000007000 endif
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed Lua      (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'm' : embed MzScheme (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'p' : embed Perl     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'P' : embed Python   (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'r' : embed Ruby     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 't' : embed Tcl      (but only if vim supports it)
    8              0.000023000 if !exists("g:vimsyn_embed")
    1              0.000005000  let g:vimsyn_embed= "lmpPr"
    8              0.000005000 endif
                            
                            " [-- lua --] {{{3
    8              0.000211000 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    8              0.000734000 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    8              0.000007000 endif
    8              0.000206000 if (g:vimsyn_embed =~# 'l' && has("lua")) && filereadable(s:luapath)
    8              0.000022000  unlet! b:current_syntax
    8              0.000059000  syn cluster vimFuncBodyList	add=vimLuaRegion
    8              0.011458000  exe "syn include @vimLuaScript ".s:luapath
    8              0.000118000  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+^\z(\s*\)lua\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimLuaScript
    8              0.000079000  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimLuaScript
    8              0.000080000  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+^\z(\s*\)lua\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimLuaScript
    8              0.000073000  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+^\.$+		contains=@vimLuaScript
    8              0.000035000  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+^\z(\s*\)lua\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+lua\s*<<\s*\z(\S*\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)lua\s*<<\s*trim\s\*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+^\.$+
    8              0.000007000 endif
    8              0.000011000 unlet s:luapath
                            
                            " [-- perl --] {{{3
    8              0.000177000 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    8              0.000877000 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    8              0.000004000 endif
    8              0.000177000 if (g:vimsyn_embed =~# 'p' && has("perl")) && filereadable(s:perlpath)
    8              0.000012000  unlet! b:current_syntax
    8              0.000043000  syn cluster vimFuncBodyList	add=vimPerlRegion
    8              0.035716000  exe "syn include @vimPerlScript ".s:perlpath
    8              0.000096000  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimPerlScript
    8              0.000071000  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimPerlScript
    8              0.000069000  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimPerlScript
    8              0.000061000  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+		contains=@vimPerlScript
    8              0.000030000  syn cluster vimFuncBodyList	add=vimPerlRegion
                            else
                             syn region vimEmbedError start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(\S*\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)pe\%[rl]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+^\.$+
    8              0.000005000 endif
    8              0.000008000 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    8              0.000159000 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    8              0.000556000 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    8              0.000007000 endif
    8              0.000165000 if (g:vimsyn_embed =~# 'r' && has("ruby")) && filereadable(s:rubypath)
    8              0.000035000  syn cluster vimFuncBodyList	add=vimRubyRegion
    8              0.000011000  unlet! b:current_syntax
    8              0.093166000  exe "syn include @vimRubyScript ".s:rubypath
    8              0.000083000  VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimRubyScript
    8              0.000065000  VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub\%[y]\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimRubyScript
    8              0.000076000  VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimRubyScript
    8              0.000052000  VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub\%[y]\s*<<\s*$+ end=+\.$+		contains=@vimRubyScript
    8              0.000025000  syn cluster vimFuncBodyList	add=vimRubyRegion
                            else
                             syn region vimEmbedError start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+rub\%[y]\s*<<\s*\z(\S.*\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)rub\%[y]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+rub\%[y]\s*<<\s*$+ end=+^\.$+
    8              0.000004000 endif
    8              0.000008000 unlet s:rubypath
                            
                            " [-- python --] {{{3
    8              0.000145000 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    8              0.000506000 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    8              0.000005000 endif
    8              0.000144000 if g:vimsyn_embed =~# 'P' && has("pythonx") && filereadable(s:pythonpath)
    8              0.000014000  unlet! b:current_syntax
    8              0.000025000  syn cluster vimFuncBodyList	add=vimPythonRegion
    8              0.005585000  exe "syn include @vimPythonScript ".s:pythonpath
    8              0.000079000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimPythonScript
    8              0.000058000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\z(\S\+\)+ end=+^\z1$+		contains=@vimPythonScript
    8              0.000058000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimPythonScript
    8              0.000052000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*$+ end=+^\.$+			contains=@vimPythonScript
    8              0.000060000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=\z(\S\+\)+ end=+^\z1$+	contains=@vimPythonScript
    8              0.000056000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=$+ end=+^\.$+		contains=@vimPythonScript
    8              0.000021000  syn cluster vimFuncBodyList	add=vimPythonRegion
                            else
                             syn region vimEmbedError start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+py\%[thon][3x]\=\s*<<\s*\z(\S\+\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)py\%[thon][3x]\=\s*<<\s*trim\s*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+py\%[thon][3x]\=\s*<<\s*$+ end=+^\.$+
    8              0.000005000 endif
    8              0.000007000 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    8              0.000050000 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    8              0.000004000 else
    8              0.000014000  let s:trytcl= 1
    8              0.000004000 endif
    8              0.000007000 if s:trytcl
    8              0.000126000  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    8              0.000377000  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    8              0.000005000  endif
    8              0.000027000  if (g:vimsyn_embed =~# 't' && has("tcl")) && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc\%[l]\=\s*<<\s*\z(\S*\)+ end=+^\z1$+		contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc\%[l]\=\s*<<\s*$+ end=+^\.$+		contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    8              0.000004000  else
    8              0.000046000   syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    8              0.000033000   syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*\z(\S*\)+ end=+^\z1$+
    8              0.000033000   syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
    8              0.000027000   syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*$+ end=+^\.$+
    8              0.000005000  endif
    8              0.000008000  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
                             syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*\z(\S*\)+ end=+^\z1$+
                             syn region vimEmbedError start=+^\z(\s*\)tc\%[l]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
                             syn region vimEmbedError start=+tc\%[l]\=\s*<<\s*$+ end=+^\.$+
    8              0.000005000 endif
    8              0.000006000 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    8              0.000123000 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    8              0.000444000 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    8              0.000002000 endif
    8              0.000037000 if (g:vimsyn_embed =~# 'm' && has("mzscheme")) && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(\S*\)+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s*$+ end=+^\z1\.$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+^\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    8              0.000003000 else
    8              0.000040000  syn region vimEmbedError start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s\+\z(\S\+\)+ end=+^\z1\z2$+
    8              0.000031000  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(\S*\)+ end=+^\z1$+
    8              0.000031000  syn region vimEmbedError start=+^\z(\s*\)mz\%[scheme]\s*<<\s*trim\s\*$+ end=+^\z1\.$+
    8              0.000027000  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+^\.$+
    8              0.000002000 endif
    8              0.000008000 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    8              0.000013000 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    8              0.000005000 endif
    8              0.000028000 exe "syn sync maxlines=".s:vimsyn_maxlines
    8              0.000014000 syn sync linecont	"^\s\+\\"
    8              0.000006000 syn sync linebreaks=1
    8              0.000034000 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    8              0.000015000 if !exists("skip_vim_syntax_inits")
    8              0.000010000  if !exists("g:vimsyn_noerror")
    8              0.000036000   hi def link vimBehaveError	vimError
    8              0.000022000   hi def link vimCollClassErr	vimError
    8              0.000026000   hi def link vimErrSetting	vimError
    8              0.000010000   hi def link vimEmbedError	vimError
    8              0.000023000   hi def link vimFTError	vimError
    8              0.000022000   hi def link vimFunctionError	vimError
    8              0.000025000   hi def link vimFunc         	vimError
    8              0.000015000   hi def link vimHiAttribList	vimError
    8              0.000017000   hi def link vimHiCtermError	vimError
    8              0.000016000   hi def link vimHiKeyError	vimError
    8              0.000016000   hi def link vimMapModErr	vimError
    8              0.000017000   hi def link vimShebangError	vimError
    8              0.000018000   hi def link vimSubstFlagErr	vimError
    8              0.000019000   hi def link vimSynCaseError	vimError
    8              0.000016000   hi def link vimSynFoldMethodError	vimError
    8              0.000022000   hi def link vimBufnrWarn	vimWarn
    8              0.000005000  endif
                            
    8              0.000040000  hi def link vimAbb	vimCommand
    8              0.000041000  hi def link vimAddress	vimMark
    8              0.000038000  hi def link vimAugroupBang	vimBang
    8              0.000020000  hi def link vimAugroupError	vimError
    8              0.000038000  hi def link vimAugroupKey	vimCommand
    8              0.000042000  hi def link vimAutoCmd	vimCommand
    8              0.000047000  hi def link vimAutoEvent	Type
    8              0.000044000  hi def link vimAutoCmdMod	Special
    8              0.000041000  hi def link vimBang	vimOper
    8              0.000037000  hi def link vimBehaveBang	vimBang
    8              0.000038000  hi def link vimBehaveModel	vimBehave
    8              0.000042000  hi def link vimBehave	vimCommand
    8              0.000037000  hi def link vimBracket	Delimiter
    8              0.000043000  hi def link vimCall	vimCommand
    8              0.000040000  hi def link vimCatch	vimCommand
    8              0.000041000  hi def link vimCmplxRepeat	SpecialChar
    8              0.000048000  hi def link vimCommand	Statement
    8              0.000046000  hi def link vimComment	Comment
    8              0.000025000  hi def link vimCommentError	vimError
    8              0.000034000  hi def link vimCommentString	vimString
    8              0.000044000  hi def link vimCommentTitle	PreProc
    8              0.000035000  hi def link vimCondHL	vimCommand
    8              0.000039000  hi def link vimConst	vimCommand
    8              0.000045000  hi def link vimContinue	Special
    8              0.000031000  hi def link vimContinueComment	vimComment
    8              0.000044000  hi def link vimCtrlChar	SpecialChar
    8              0.000038000  hi def link vimDefComment	vim9Comment
    8              0.000037000  hi def link vimDefKey	vimCommand
    8              0.000035000  hi def link vimDefParam vimVar
    8              0.000040000  hi def link vimDelcommand	vimCommand
    8              0.000031000  hi def link vimDelcommandAttr	vimUserCmdAttr
    8              0.000034000  hi def link vimEcho	vimCommand
    8              0.000033000  hi def link vimEchohlNone	vimGroup
    8              0.000061000  hi def link vimEchohl	vimCommand
    8              0.000037000  hi def link vimElseIfErr	Error
    8              0.000043000  hi def link vimEndfunction	vimCommand
    8              0.000041000  hi def link vimEnddef	vimCommand
    8              0.000047000  hi def link vimEnvvar	PreProc
    8              0.000032000  hi def link vimError	Error
    8              0.000044000  hi def link vimEscape	Special
    8              0.000041000  hi def link vimFBVar	vimVar
    8              0.000023000  hi def link vimFgBgAttrib	vimHiAttrib
    8              0.000031000  hi def link vimFuncEcho	vimCommand
    8              0.000041000  hi def link vimFor	vimCommand
    8              0.000038000  hi def link vimFTCmd	vimCommand
    8              0.000028000  hi def link vimFTOption	vimSynType
    8              0.000037000  hi def link vimFuncBang	vimBang
    8              0.000033000  hi def link vimFuncComment	vimComment
    8              0.000037000  hi def link vimFuncKey	vimCommand
    8              0.000043000  hi def link vimFuncName	Function
    8              0.000045000  hi def link vimFuncMod	Special
    8              0.000039000  hi def link vimFuncParam	vimVar
    8              0.000036000  hi def link vimFuncParamEquals	vimOper
    8              0.000039000  hi def link vimFuncSID	Special
    8              0.000045000  hi def link vimFuncVar	Identifier
    8              0.000027000  hi def link vimGroupAdd	vimSynOption
    8              0.000032000  hi def link vimGroupName	vimGroup
    8              0.000017000  hi def link vimGroupRem	vimSynOption
    8              0.000039000  hi def link vimGroupSpecial	Special
    8              0.000048000  hi def link vimGroup	Type
    8              0.000042000  hi def link vimHiAttrib	PreProc
    8              0.000033000  hi def link vimHiBang	vimBang
    8              0.000037000  hi def link vimHiClear	Type
    8              0.000043000  hi def link vimHiCtermColor	Constant
    8              0.000024000  hi def link vimHiCtermFgBg	vimHiTerm
    8              0.000022000  hi def link vimHiCtermfont	vimHiTerm
    8              0.000023000  hi def link vimHiCtermul	vimHiTerm
    8              0.000022000  hi def link vimHiCTerm	vimHiTerm
    8              0.000038000  hi def link vimHighlight	vimCommand
    8              0.000023000  hi def link vimHiGroup	vimGroupName
    8              0.000022000  hi def link vimHiGuiFgBg	vimHiTerm
    8              0.000024000  hi def link vimHiGuiFont	vimHiTerm
    8              0.000028000  hi def link vimHiGuiRgb	vimNumber
    8              0.000023000  hi def link vimHiGui	vimHiTerm
    8              0.000034000  hi def link vimHiNmbr	Number
    8              0.000024000  hi def link vimHiStartStop	vimHiTerm
    8              0.000034000  hi def link vimHiTerm	Type
    8              0.000044000  hi def link vimHLGroup	vimGroup
    8              0.000036000  hi def link vimInsert	vimString
    8              0.000036000  hi def link vimIskSep	Delimiter
    8              0.000032000  hi def link vim9KeymapLineComment	vimKeymapLineComment
    8              0.000033000  hi def link vimKeymapLineComment	vimComment
    8              0.000035000  hi def link vimKeymapTailComment	vimComment
    8              0.000040000  hi def link vimLet	vimCommand
    8              0.000037000  hi def link vimLetHereDoc	vimString
    8              0.000039000  hi def link vimLetHereDocStart	Special
    8              0.000040000  hi def link vimLetHereDocStop	Special
    8              0.000048000  hi def link vimLetRegister	Special
    8              0.000039000  hi def link vimLineComment	vimComment
    8              0.000031000  hi def link vimMapBang	vimBang
    8              0.000032000  hi def link vimMapModKey	vimFuncSID
    8              0.000029000  hi def link vimMapMod	vimBracket
    8              0.000037000  hi def link vimMap	vimCommand
    8              0.000044000  hi def link vimMark	Number
    8              0.000038000  hi def link vimMarkNumber	vimNumber
    8              0.000038000  hi def link vimMatch	vimCommand
    8              0.000034000  hi def link vimMatchGroup	vimGroup
    8              0.000032000  hi def link vimMatchNone	vimGroup
    8              0.000032000  hi def link vimMenuBang	vimBang
    8              0.000037000  hi def link vimMenuClear	Special
    8              0.000030000  hi def link vimMenuMod	vimMapMod
    8              0.000042000  hi def link vimMenuName	PreProc
    8              0.000043000  hi def link vimMenu	vimCommand
    8              0.000031000  hi def link vimMenuNotation	vimNotation
    8              0.000038000  hi def link vimMenuPriority	Number
    8              0.000041000  hi def link vimMenuStatus	Special
    8              0.000037000  hi def link vimMenutranslateComment	vimComment
    8              0.000036000  hi def link vimMethodName	vimFuncName
    8              0.000030000  hi def link vimMtchComment	vimComment
    8              0.000038000  hi def link vimNorm	vimCommand
    8              0.000040000  hi def link vimNotation	Special
    8              0.000044000  hi def link vimNotFunc	vimCommand
    8              0.000034000  hi def link vimNotPatSep	vimString
    8              0.000043000  hi def link vimNumber	Number
    8              0.000044000  hi def link vimOperError	Error
    8              0.000046000  hi def link vimOper	Operator
    8              0.000052000  hi def link vimOption	PreProc
    8              0.000044000  hi def link vimParenSep	Delimiter
    8              0.000023000  hi def link vimPatSepErr	vimError
    8              0.000030000  hi def link vimPatSepR	vimPatSep
    8              0.000040000  hi def link vimPatSep	SpecialChar
    8              0.000037000  hi def link vimPatSepZone	vimString
    8              0.000030000  hi def link vimPatSepZ	vimPatSep
    8              0.000035000  hi def link vimPattern	Type
    8              0.000038000  hi def link vimPlainMark	vimMark
    8              0.000032000  hi def link vimPlainRegister	vimRegister
    8              0.000042000  hi def link vimRegister	SpecialChar
    8              0.000038000  hi def link vimScriptDelim	Comment
    8              0.000040000  hi def link vimSearchDelim	Statement
    8              0.000038000  hi def link vimSearch	vimString
    8              0.000041000  hi def link vimSep	Delimiter
    8              0.000043000  hi def link vimSet	vimCommand
    8              0.000035000  hi def link vimSetAll	vimOption
    8              0.000032000  hi def link vimSetBang	vimBang
    8              0.000040000  hi def link vimSetMod	vimOption
    8              0.000033000  hi def link vimSetSep	vimSep
    8              0.000032000  hi def link vimSetString	vimString
    8              0.000034000  hi def link vimSetTermcap	vimOption
    8              0.000040000  hi def link vimShebang	PreProc
    8              0.000043000  hi def link vimSleep	vimCommand
    8              0.000035000  hi def link vimSleepArg	Constant
    8              0.000036000  hi def link vimSleepBang	vimBang
    8              0.000041000  hi def link vimSpecFile	Identifier
    8              0.000037000  hi def link vimSpecFileMod	vimSpecFile
    8              0.000033000  hi def link vimSpecial	Type
    8              0.000036000  hi def link vimStringCont	vimString
    8              0.000041000  hi def link vimString	String
    8              0.000035000  hi def link vimStringEnd	vimString
    8              0.000033000  hi def link vimStringInterpolationBrace	vimEscape
    8              0.000038000  hi def link vimSubst1	vimSubst
    8              0.000038000  hi def link vimSubstDelim	Delimiter
    8              0.000057000  hi def link vimSubstFlags	Special
    8              0.000042000  hi def link vimSubstSubstr	SpecialChar
    8              0.000037000  hi def link vimSubstTwoBS	vimString
    8              0.000039000  hi def link vimSubst	vimCommand
    8              0.000038000  hi def link vimSynCaseError	Error
    8              0.000042000  hi def link vimSynCase	Type
    8              0.000039000  hi def link vimSyncC	Type
    8              0.000039000  hi def link vimSyncError	Error
    8              0.000030000  hi def link vimSyncGroupName	vimGroupName
    8              0.000021000  hi def link vimSyncGroup	vimGroupName
    8              0.000038000  hi def link vimSyncKey	Type
    8              0.000039000  hi def link vimSyncNone	Type
    8              0.000022000  hi def link vimSynContains	vimSynOption
    8              0.000038000  hi def link vimSynError	Error
    8              0.000043000  hi def link vimSynFoldMethodError	Error
    8              0.000041000  hi def link vimSynFoldMethod	Type
    8              0.000031000  hi def link vimSynKeyContainedin	vimSynContains
    8              0.000017000  hi def link vimSynKeyOpt	vimSynOption
    8              0.000018000  hi def link vimSynCchar	vimSynOption
    8              0.000037000  hi def link vimSynCcharValue	Character
    8              0.000018000  hi def link vimSynMtchGrp	vimSynOption
    8              0.000018000  hi def link vimSynMtchOpt	vimSynOption
    8              0.000017000  hi def link vimSynNextgroup	vimSynOption
    8              0.000024000  hi def link vimSynNotPatRange	vimSynRegPat
    8              0.000029000  hi def link vimSynOption	Special
    8              0.000036000  hi def link vimSynPatRange	vimString
    8              0.000015000  hi def link vimSynRegOpt	vimSynOption
    8              0.000032000  hi def link vimSynRegPat	vimString
    8              0.000036000  hi def link vimSynReg	Type
    8              0.000043000  hi def link vimSyntax	vimCommand
    8              0.000017000  hi def link vimSynType	vimSpecial
    8              0.000040000  hi def link vimThrow	vimCommand
    8              0.000042000  hi def link vimTodo	Todo
    8              0.000045000  hi def link vimType	Type
    8              0.000042000  hi def link vimUnlet	vimCommand
    8              0.000034000  hi def link vimUnletBang	vimBang
    8              0.000038000  hi def link vimUnmap	vimMap
    8              0.000021000  hi def link vimUserCmdAttrAddr	vimSpecial
    8              0.000021000  hi def link vimUserCmdAttrCmplt	vimSpecial
    8              0.000020000  hi def link vimUserCmdAttrNargs	vimSpecial
    8              0.000022000  hi def link vimUserCmdAttrRange	vimSpecial
    8              0.000030000  hi def link vimUserCmdAttrKey	vimUserCmdAttr
    8              0.000039000  hi def link vimUserCmdAttr	Special
    8              0.000043000  hi def link vimUserCmdAttrError	Error
    8              0.000044000  hi def link vimUserCmdError	Error
    8              0.000041000  hi def link vimUserCmdKey	vimCommand
    8              0.000038000  hi def link vimUserFunc	Normal
    8              0.000046000  hi def link vimVar	Identifier
    8              0.000033000  hi def link vimWarn	WarningMsg
                            
    8              0.000047000  hi def link vim9Boolean	Boolean
    8              0.000046000  hi def link vim9Comment	Comment
    8              0.000024000  hi def link vim9CommentError	vimError
    8              0.000046000  hi def link vim9CommentTitle	PreProc
    8              0.000041000  hi def link vim9Const	vimCommand
    8              0.000040000  hi def link vim9Final	vimCommand
    8              0.000039000  hi def link vim9For	vimCommand
    8              0.000037000  hi def link vim9LineComment	vimComment
    8              0.000044000  hi def link vim9Null	Constant
    8              0.000042000  hi def link vim9Var	vimCommand
    8              0.000033000  hi def link vim9Variable	vimVar
    8              0.000030000  hi def link vim9Vim9Script	vimCommand
    8              0.000036000  hi def link vim9Vim9ScriptArg	Special
    8              0.000003000 endif
                            
                            " Current Syntax Variable: {{{2
    8              0.000011000 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    8              0.000021000 delc Vim9
    8              0.000009000 delc VimL
    8              0.000008000 delc VimFolda
    8              0.000008000 delc VimFoldf
    8              0.000008000 delc VimFoldh
    8              0.000008000 delc VimFoldH
    8              0.000008000 delc VimFoldl
    8              0.000006000 delc VimFoldm
    8              0.000006000 delc VimFoldp
    8              0.000008000 delc VimFoldP
    8              0.000007000 delc VimFoldr
    8              0.000007000 delc VimFoldt
    8              0.000025000 let &cpo = s:keepcpo
    8              0.000010000 unlet s:keepcpo s:vim9script
                            " vim:ts=18 fdm=marker ft=vim

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale.vim
Sourced 1 time
Total time:   0.000113000
 Self time:   0.000113000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>
                            " Description: Primary code path for the plugin
                            "   Manages execution of linters when requested by autocommands
                            
                            " Strings used for severity in the echoed message
    1              0.000003000 let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')
    1              0.000001000 let g:ale_echo_msg_info_str = get(g:, 'ale_echo_msg_info_str', 'Info')
    1              0.000002000 let g:ale_echo_msg_log_str = get(g:, 'ale_echo_msg_log_str', 'Log')
    1              0.000001000 let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')
                            
                            " LSP window/showMessage format
    1              0.000002000 let g:ale_lsp_show_message_format = get(g:, 'ale_lsp_show_message_format', '%severity%:%linter%: %s')
                            " Valid values mimic LSP definitions (error, warning and information; log is
                            " never shown)
    1              0.000002000 let g:ale_lsp_show_message_severity = get(g:, 'ale_lsp_show_message_severity', 'error')
                            
    1              0.000001000 let s:lint_timer = -1
    1              0.000002000 let s:getcmdwintype_exists = exists('*getcmdwintype')
                            
                            " Return 1 if a file is too large for ALE to handle.
    1              0.000002000 function! ale#FileTooLarge(buffer) abort
                                let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
                                return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0
                            endfunction
                            
                            " A function for checking various conditions whereby ALE just shouldn't
                            " attempt to do anything, say if particular buffer types are open in Vim.
    1              0.000001000 function! ale#ShouldDoNothing(buffer) abort
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
                                if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
                                if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for diff buffers.
                                if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
                                if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
                                if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
                                if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
                                if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
                                if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
                                if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
                                if exists(':CtrlPFunky') is 2
                                \&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000001000 function! s:Lint(buffer, should_lint_file, timer_id) abort
                                " Use the filetype from the buffer
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:linters = ale#linter#Get(l:filetype)
                            
                                let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
                                let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
                                " Load code to ignore linters only if we need to.
                                if (
                                \   !empty(l:ignore_config)
                                \   || l:disable_lsp is 1
                                \   || l:disable_lsp is v:true
                                \   || (l:disable_lsp is# 'auto' && get(g:, 'lspconfig', 0))
                                \)
                                    let l:linters = ale#engine#ignore#Exclude(
                                    \   l:filetype,
                                    \   l:linters,
                                    \   l:ignore_config,
                                    \   l:disable_lsp,
                                    \)
                                endif
                            
                                " Tell other sources that they can start checking the buffer now.
                                let g:ale_want_results_buffer = a:buffer
                                silent doautocmd <nomodeline> User ALEWantResults
                                unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
                                if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
                                let l:lint_file = empty(l:linters)
                                \   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
                                call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)
                            endfunction
                            
                            " (delay, [linting_flag, buffer_number])
    1              0.000001000 function! ale#Queue(delay, ...) abort
                                if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                let l:buffer = get(a:000, 1, v:null)
                            
                                if l:buffer is v:null
                                    let l:buffer = bufnr('')
                                endif
                            
                                if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Default linting_flag to ''
                                let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
                                if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
                                if a:delay > 0
                                    let s:lint_timer = timer_start(
                                    \   a:delay,
                                    \   function('s:Lint', [l:buffer, l:should_lint_file])
                                    \)
                                else
                                    call s:Lint(l:buffer, l:should_lint_file, 0)
                                endif
                            endfunction
                            
    1              0.000002000 let s:current_ale_version = [4, 0, 0]
                            
                            " A function used to check for ALE features in files outside of the project.
    1              0.000001000 function! ale#Has(feature) abort
                                let l:match = matchlist(a:feature, '\c\v^ale-(\d+)\.(\d+)(\.(\d+))?$')
                            
                                if !empty(l:match)
                                    let l:version = [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
                            
                                    return ale#semver#GTE(s:current_ale_version, l:version)
                                endif
                            
                                return 0
                            endfunction
                            
                            " Given a buffer number and a variable name, look for that variable in the
                            " buffer scope, then in global scope. If the name does not exist in the global
                            " scope, an exception will be thrown.
                            "
                            " Every variable name will be prefixed with 'ale_'.
    1              0.000000000 function! ale#Var(buffer, variable_name) abort
                                let l:full_name = 'ale_' . a:variable_name
                                let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
                                return get(l:vars, l:full_name, g:[l:full_name])
                            endfunction
                            
                            " Initialize a variable with a default value, if it isn't already set.
                            "
                            " Every variable name will be prefixed with 'ale_'.
    1              0.000001000 function! ale#Set(variable_name, default) abort
                                let l:full_name = 'ale_' . a:variable_name
                            
                                if !has_key(g:, l:full_name)
                                    let g:[l:full_name] = a:default
                                endif
                            endfunction
                            
                            " Given a string for adding to a command, return the string padded with a
                            " space on the left if it is not empty. Otherwise return an empty string.
                            "
                            " This can be used for making command strings cleaner and easier to test.
    1              0.000001000 function! ale#Pad(string) abort
                                return !empty(a:string) ? ' ' . a:string : ''
                            endfunction
                            
                            " Given a environment variable name and a value, produce part of a command for
                            " setting an environment variable before running a command. The syntax will be
                            " valid for cmd on Windows, or most shells on Unix.
    1              0.000000000 function! ale#Env(variable_name, value) abort
                                if has('win32')
                                    return 'set ' . ale#Escape(a:variable_name . '=' . a:value) . ' && '
                                endif
                            
                                return a:variable_name . '=' . ale#Escape(a:value) . ' '
                            endfunction
                            
                            " Escape a string suitably for each platform.
                            " shellescape does not work on Windows.
    1              0.000001000 function! ale#Escape(str) abort
                                if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(
                                    \   a:str =~# ' '
                                    \       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'
                                    \       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),
                                    \   '%',
                                    \   '%%',
                                    \   'g',
                                    \)
                                endif
                            
                                return shellescape (a:str)
                            endfunction
                            
                            " Get the loclist item message according to a given format string.
                            "
                            " See `:help g:ale_loclist_msg_format` and `:help g:ale_echo_msg_format`
    1              0.000001000 function! ale#GetLocItemMessage(item, format_string) abort
                                let l:msg = a:format_string
                                let l:severity = g:ale_echo_msg_warning_str
                                let l:code = get(a:item, 'code', '')
                                let l:type = get(a:item, 'type', 'E')
                                let l:linter_name = get(a:item, 'linter_name', '')
                                let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
                                if l:type is# 'E'
                                    let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
                                let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
                                let l:msg = substitute(l:msg, '\V%type%', '\=l:type', 'g')
                                let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
                                let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
                                let l:msg = substitute(l:msg, '\r', '', 'g')
                            
                                return l:msg
                            endfunction
                            
                            " Given a buffer and a linter or fixer name, return an Array of two-item
                            " Arrays describing how to map filenames to and from the local to foreign file
                            " systems.
    1              0.000001000 function! ale#GetFilenameMappings(buffer, name) abort
                                let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
                                if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
                                endif
                            
                                let l:name = a:name
                            
                                if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
                                    let l:name = '*'
                                endif
                            
                                return get(l:linter_mappings, l:name, [])
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/util.vim
Sourced 1 time
Total time:   0.000411000
 Self time:   0.000411000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Contains miscellaneous functions
                            
                            " A wrapper function for mode() so we can test calls for it.
    1              0.000002000 function! ale#util#Mode(...) abort
                                return call('mode', a:000)
                            endfunction
                            
                            " A wrapper function for feedkeys so we can test calls for it.
    1              0.000001000 function! ale#util#FeedKeys(...) abort
                                return call('feedkeys', a:000)
                            endfunction
                            
                            " Show a message in as small a window as possible.
                            "
                            " Vim 8 does not support echoing long messages from asynchronous callbacks,
                            " but NeoVim does. Small messages can be echoed in Vim 8, and larger messages
                            " have to be shown in preview windows.
    1              0.000000000 function! ale#util#ShowMessage(string, ...) abort
                                let l:options = get(a:000, 0, {})
                            
                                if !has('nvim')
                                    call ale#preview#CloseIfTypeMatches('ale-preview.message')
                                endif
                            
                                " We have to assume the user is using a monospace font.
                                if has('nvim') || (a:string !~? "\n" && len(a:string) < &columns)
                                    " no-custom-checks
                                    echo a:string
                                else
                                    call ale#preview#Show(split(a:string, "\n"), extend(
                                    \   {
                                    \       'filetype': 'ale-preview.message',
                                    \       'stay_here': 1,
                                    \   },
                                    \   l:options,
                                    \))
                                endif
                            endfunction
                            
                            " A wrapper function for execute, so we can test executing some commands.
    1              0.000001000 function! ale#util#Execute(expr) abort
                                execute a:expr
                            endfunction
                            
    1              0.000002000 if !exists('g:ale#util#nul_file')
                                " A null file for sending output to nothing.
    1              0.000001000     let g:ale#util#nul_file = '/dev/null'
                            
    1              0.000002000     if has('win32')
                                    let g:ale#util#nul_file = 'nul'
    1              0.000001000     endif
    1              0.000000000 endif
                            
                            " Given a job, a buffered line of data, a list of parts of lines, a mode data
                            " is being read in, and a callback, join the lines of output for a NeoVim job
                            " or socket together, and call the callback with the joined output.
                            "
                            " Note that jobs and IDs are the same thing on NeoVim.
    1              0.000001000 function! ale#util#JoinNeovimOutput(job, last_line, data, mode, callback) abort
                                if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
                                endif
                            
                                let l:lines = a:data[:-2]
                            
                                if len(a:data) > 1
                                    let l:lines[0] = a:last_line . l:lines[0]
                                    let l:new_last_line = a:data[-1]
                                else
                                    let l:new_last_line = a:last_line . get(a:data, 0, '')
                                endif
                            
                                for l:line in l:lines
                                    call a:callback(a:job, l:line)
                                endfor
                            
                                return l:new_last_line
                            endfunction
                            
                            " Return the number of lines for a given buffer.
    1              0.000001000 function! ale#util#GetLineCount(buffer) abort
                                return len(getbufline(a:buffer, 1, '$'))
                            endfunction
                            
    1              0.000001000 function! ale#util#GetFunction(string_or_ref) abort
                                if type(a:string_or_ref) is v:t_string
                                    return function(a:string_or_ref)
                                endif
                            
                                return a:string_or_ref
                            endfunction
                            
                            " Open the file (at the given line).
                            " options['open_in'] can be:
                            "   current-buffer (default)
                            "   tab
                            "   split
                            "   vsplit
    1              0.000001000 function! ale#util#Open(filename, line, column, options) abort
                                let l:open_in = get(a:options, 'open_in', 'current-buffer')
                                let l:args_to_open = '+' . a:line . ' ' . fnameescape(a:filename)
                            
                                if l:open_in is# 'tab'
                                    call ale#util#Execute('tabedit ' . l:args_to_open)
                                elseif l:open_in is# 'split'
                                    call ale#util#Execute('split ' . l:args_to_open)
                                elseif l:open_in is# 'vsplit'
                                    call ale#util#Execute('vsplit ' . l:args_to_open)
                                elseif bufnr(a:filename) isnot bufnr('')
                                    " Open another file only if we need to.
                                    call ale#util#Execute('edit ' . l:args_to_open)
                                else
                                    normal! m`
                                endif
                            
                                call cursor(a:line, a:column)
                                normal! zz
                            endfunction
                            
    1              0.000001000 let g:ale#util#error_priority = 5
    1              0.000001000 let g:ale#util#warning_priority = 4
    1              0.000001000 let g:ale#util#info_priority = 3
    1              0.000001000 let g:ale#util#style_error_priority = 2
    1              0.000001000 let g:ale#util#style_warning_priority = 1
                            
    1              0.000001000 function! ale#util#GetItemPriority(item) abort
                                if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
                                if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority
                            endfunction
                            
                            " Compare two loclist items for ALE, sorted by their buffers, filenames, and
                            " line numbers and column numbers.
    1              0.000001000 function! ale#util#LocItemCompare(left, right) abort
                                if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
                                if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
                                if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
                                if a:left.lnum < a:right.lnum
                                    return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Compare two loclist items, including the text for the items.
                            "
                            " This function can be used for de-duplicating lists.
    1              0.000001000 function! ale#util#LocItemCompareWithText(left, right) abort
                                let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                            
                                if l:cmp_value
                                    return l:cmp_value
                                endif
                            
                                if a:left.text < a:right.text
                                    return -1
                                endif
                            
                                if a:left.text > a:right.text
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function will perform a binary search and a small sequential search
                            " on the list to find the last problem in the buffer and line which is
                            " on or before the column. The index of the problem will be returned.
                            "
                            " -1 will be returned if nothing can be found.
    1              0.000001000 function! ale#util#BinarySearch(loclist, buffer, line, column) abort
                                let l:min = 0
                                let l:max = len(a:loclist) - 1
                            
                                while 1
                                    if l:max < l:min
                                        return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0
                                        \&& a:loclist[l:index - 1].bufnr == a:buffer
                                        \&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile
                            endfunction
                            
                            " A function for testing if a function is running inside a sandbox.
                            " See :help sandbox
    1              0.000001000 function! ale#util#InSandbox() abort
                                try
                                    let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
                                return 0
                            endfunction
                            
    1              0.000001000 function! ale#util#Tempname() abort
                                let l:clear_tempdir = 0
                            
                                if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
                                try
                                    let l:name = tempname() " no-custom-checks
                                finally
                                    if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
                                endtry
                            
                                return l:name
                            endfunction
                            
                            " Given a single line, or a List of lines, and a single pattern, or a List
                            " of patterns, return all of the matches for the lines(s) from the given
                            " patterns, using matchlist().
                            "
                            " Only the first pattern which matches a line will be returned.
    1              0.000000000 function! ale#util#GetMatches(lines, patterns) abort
                                let l:matches = []
                                let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
                                let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
                                for l:line in l:lines
                                    for l:pattern in l:patterns
                                        let l:match = matchlist(l:line, l:pattern)
                            
                                        if !empty(l:match)
                                            call add(l:matches, l:match)
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:matches
                            endfunction
                            
                            " Given a single line, or a List of lines, and a single pattern, or a List of
                            " patterns, and a callback function for mapping the items matches, return the
                            " result of mapping all of the matches for the lines from the given patterns,
                            " using matchlist()
                            "
                            " Only the first pattern which matches a line will be returned.
    1              0.000001000 function! ale#util#MapMatches(lines, patterns, Callback) abort
                                return map(ale#util#GetMatches(a:lines, a:patterns), 'a:Callback(v:val)')
                            endfunction
                            
    1              0.000001000 function! s:LoadArgCount(function) abort
                                try
                                    let l:output = execute('function a:function')
                                catch /E123/
                                    return 0
                                endtry
                            
                                let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
                                let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
                                return len(l:arg_list)
                            endfunction
                            
                            " Given the name of a function, a Funcref, or a lambda, return the number
                            " of named arguments for a function.
    1              0.000000000 function! ale#util#FunctionArgCount(function) abort
                                let l:Function = ale#util#GetFunction(a:function)
                                let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
                                if l:count == 0
                                    let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
                                    if l:function_name =~# '#'
                                        execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
                                        let l:count = s:LoadArgCount(l:Function)
                                    endif
                                endif
                            
                                return l:count
                            endfunction
                            
                            " Escape a string so the characters in it will be safe for use inside of PCRE
                            " or RE2 regular expressions without characters having special meanings.
    1              0.000001000 function! ale#util#EscapePCRE(unsafe_string) abort
                                return substitute(a:unsafe_string, '\([\-\[\]{}()*+?.^$|]\)', '\\\1', 'g')
                            endfunction
                            
                            " Escape a string so that it can be used as a literal string inside an evaled
                            " vim command.
    1              0.000001000 function! ale#util#EscapeVim(unsafe_string) abort
                                return "'" . substitute(a:unsafe_string, "'", "''", 'g') . "'"
                            endfunction
                            
                            
                            " Given a String or a List of String values, try and decode the string(s)
                            " as a JSON value which can be decoded with json_decode. If the JSON string
                            " is invalid, the default argument value will be returned instead.
                            "
                            " This function is useful in code where the data can't be trusted to be valid
                            " JSON, and where throwing exceptions is mostly just irritating.
    1              0.000001000 function! ale#util#FuzzyJSONDecode(data, default) abort
                                if empty(a:data)
                                    return a:default
                                endif
                            
                                let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
                            
                                try
                                    let l:result = json_decode(l:str)
                            
                                    " Vim 8 only uses the value v:none for decoding blank strings.
                                    if !has('nvim') && l:result is v:none
                                        return a:default
                                    endif
                            
                                    return l:result
                                catch /E474\|E491/
                                    return a:default
                                endtry
                            endfunction
                            
                            " Write a file, including carriage return characters for DOS files.
                            "
                            " The buffer number is required for determining the fileformat setting for
                            " the buffer.
    1              0.000001000 function! ale#util#Writefile(buffer, lines, filename) abort
                                let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                \   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')
                                \   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
                                let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
                                call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks
                            endfunction
                            
    1              0.000002000 if !exists('s:patial_timers')
    1              0.000001000     let s:partial_timers = {}
    1              0.000000000 endif
                            
    1              0.000001000 function! s:ApplyPartialTimer(timer_id) abort
                                if has_key(s:partial_timers, a:timer_id)
                                    let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
                                    call call(l:Callback, [a:timer_id] + l:args)
                                endif
                            endfunction
                            
                            " Given a delay, a callback, a List of arguments, start a timer with
                            " timer_start() and call the callback provided with [timer_id] + args.
                            "
                            " The timer must not be stopped with timer_stop().
                            " Use ale#util#StopPartialTimer() instead, which can stop any timer, and will
                            " clear any arguments saved for executing callbacks later.
    1              0.000001000 function! ale#util#StartPartialTimer(delay, callback, args) abort
                                let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
                                let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
                                return l:timer_id
                            endfunction
                            
    1              0.000001000 function! ale#util#StopPartialTimer(timer_id) abort
                                call timer_stop(a:timer_id)
                            
                                if has_key(s:partial_timers, a:timer_id)
                                    call remove(s:partial_timers, a:timer_id)
                                endif
                            endfunction
                            
                            " Given a possibly multi-byte string and a 1-based character position on a
                            " line, return the 1-based byte position on that line.
    1              0.000001000 function! ale#util#Col(str, chr) abort
                                if a:chr < 2
                                    return a:chr
                                endif
                            
                                return strlen(join(split(a:str, '\zs')[0:a:chr - 2], '')) + 1
                            endfunction
                            
    1              0.000000000 function! ale#util#FindItemAtCursor(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                let l:loclist = get(l:info, 'loclist', [])
                                let l:pos = getpos('.')
                                let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
                                let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
                                return [l:info, l:loc]
                            endfunction
                            
    1              0.000001000 function! ale#util#Input(message, value, ...) abort
                                if a:0 > 0
                                    return input(a:message, a:value, a:1)
                                else
                                    return input(a:message, a:value)
                                endif
                            endfunction
                            
    1              0.000000000 function! ale#util#HasBuflineApi() abort
                                return exists('*deletebufline') && exists('*setbufline')
                            endfunction
                            
                            " Sets buffer contents to lines
    1              0.000001000 function! ale#util#SetBufferContents(buffer, lines) abort
                                let l:has_bufline_api = ale#util#HasBuflineApi()
                            
                                if !l:has_bufline_api && a:buffer isnot bufnr('')
                                    return
                                endif
                            
                                " If the file is in DOS mode, we have to remove carriage returns from
                                " the ends of lines before calling setline(), or we will see them
                                " twice.
                                let l:new_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                \   ? map(copy(a:lines), 'substitute(v:val, ''\r\+$'', '''', '''')')
                                \   : a:lines
                                let l:first_line_to_remove = len(l:new_lines) + 1
                            
                                " Use a Vim API for setting lines in other buffers, if available.
                                if l:has_bufline_api
                                    if has('nvim')
                                        " save and restore signs to avoid flickering
                                        let signs = sign_getplaced(a:buffer, {'group': 'ale'})[0].signs
                            
                                        call nvim_buf_set_lines(a:buffer, 0, l:first_line_to_remove, 0, l:new_lines)
                            
                                        " restore signs (invalid line numbers will be skipped)
                                        call sign_placelist(map(signs, {_, v -> extend(v, {'buffer': a:buffer})}))
                                    else
                                        call setbufline(a:buffer, 1, l:new_lines)
                                    endif
                            
                                    call deletebufline(a:buffer, l:first_line_to_remove, '$')
                                " Fall back on setting lines the old way, for the current buffer.
                                else
                                    let l:old_line_length = line('$')
                            
                                    if l:old_line_length >= l:first_line_to_remove
                                        let l:save = winsaveview()
                                        silent execute
                                        \   l:first_line_to_remove . ',' . l:old_line_length . 'd_'
                                        call winrestview(l:save)
                                    endif
                            
                                    call setline(1, l:new_lines)
                                endif
                            
                                return l:new_lines
                            endfunction
                            
    1              0.000001000 function! ale#util#GetBufferContents(buffer) abort
                                return join(getbufline(a:buffer, 1, '$'), "\n") . "\n"
                            endfunction
                            
    1              0.000001000 function! ale#util#ToURI(resource) abort
                                let l:uri_handler = ale#uri#GetURIHandler(a:resource)
                            
                                if l:uri_handler is# v:null
                                    " resource is a filesystem path
                                    let l:uri = ale#path#ToFileURI(a:resource)
                                else
                                    " resource is a URI
                                    let l:uri = a:resource
                                endif
                            
                                return l:uri
                            endfunction
                            
    1              0.000001000 function! ale#util#ToResource(uri) abort
                                let l:uri_handler = ale#uri#GetURIHandler(a:uri)
                            
                                if l:uri_handler is# v:null
                                    " resource is a filesystem path
                                    let l:resource = ale#path#FromFileURI(a:uri)
                                else
                                    " resource is a URI
                                    let l:resource = a:uri
                                endif
                            
                                return l:resource
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/linter.vim
Sourced 1 time
Total time:   0.000266000
 Self time:   0.000266000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Linter registration and lazy-loading
                            "   Retrieves linters as requested by the engine, loading them if needed.
                            
    1              0.000002000 let s:runtime_loaded_map = {}
    1              0.000001000 let s:linters = {}
                            
                            " Default filetype aliases.
                            " The user defined aliases will be merged with this Dictionary.
                            "
                            " NOTE: Update the g:ale_linter_aliases documentation when modifying this.
    1              0.000015000 let s:default_ale_linter_aliases = {
                            \   'Dockerfile': 'dockerfile',
                            \   'bash': 'sh',
                            \   'csh': 'sh',
                            \   'javascriptreact': ['javascript', 'jsx'],
                            \   'plaintex': 'tex',
                            \   'ps1': 'powershell',
                            \   'rmarkdown': 'r',
                            \   'rmd': 'r',
                            \   'systemverilog': 'verilog',
                            \   'typescriptreact': ['typescript', 'tsx'],
                            \   'vader': ['vim', 'vader'],
                            \   'verilog_systemverilog': ['verilog_systemverilog', 'verilog'],
                            \   'vimwiki': 'markdown',
                            \   'vue': ['vue', 'javascript'],
                            \   'xsd': ['xsd', 'xml'],
                            \   'xslt': ['xslt', 'xml'],
                            \   'zsh': 'sh',
                            \}
                            
                            " Default linters to run for particular filetypes.
                            " The user defined linter selections will be merged with this Dictionary.
                            "
                            " No linters are used for plaintext files by default.
                            "
                            " Only cargo and rls are enabled for Rust by default.
                            " rpmlint is disabled by default because it can result in code execution.
                            " hhast is disabled by default because it executes code in the project root.
                            "
                            " NOTE: Update the g:ale_linters documentation when modifying this.
    1              0.000015000 let s:default_ale_linters = {
                            \   'apkbuild': ['apkbuild_lint', 'secfixes_check'],
                            \   'astro': ['eslint'],
                            \   'csh': ['shell'],
                            \   'elixir': ['credo', 'dialyxir', 'dogma'],
                            \   'go': ['gofmt', 'golangci-lint', 'gopls', 'govet'],
                            \   'groovy': ['npm-groovy-lint'],
                            \   'hack': ['hack'],
                            \   'help': [],
                            \   'inko': ['inko'],
                            \   'json': ['biome', 'jsonlint', 'spectral', 'vscodejson'],
                            \   'json5': [],
                            \   'jsonc': ['biome'],
                            \   'perl': ['perlcritic'],
                            \   'perl6': [],
                            \   'python': ['flake8', 'mypy', 'pylint', 'pyright', 'ruff'],
                            \   'rust': ['analyzer', 'cargo'],
                            \   'spec': [],
                            \   'text': [],
                            \   'vader': ['vimls'],
                            \   'vue': ['eslint', 'vls'],
                            \   'zsh': ['shell'],
                            \   'v': ['v'],
                            \   'yaml': ['actionlint', 'spectral', 'yaml-language-server', 'yamllint'],
                            \}
                            
                            " Testing/debugging helper to unload all linters.
    1              0.000001000 function! ale#linter#Reset() abort
                                let s:runtime_loaded_map = {}
                                let s:linters = {}
                            endfunction
                            
                            " Return a reference to the linters loaded.
                            " This is only for tests.
                            " Do not call this function.
    1              0.000001000 function! ale#linter#GetLintersLoaded() abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                return s:linters
                            endfunction
                            
    1              0.000001000 function! s:IsCallback(value) abort
                                return type(a:value) is v:t_string || type(a:value) is v:t_func
                            endfunction
                            
    1              0.000001000 function! s:IsBoolean(value) abort
                                return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)
                            endfunction
                            
    1              0.000001000 function! ale#linter#PreProcess(filetype, linter) abort
                                if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
                                endif
                            
                                let l:obj = {
                                \   'name': get(a:linter, 'name'),
                                \   'lsp': get(a:linter, 'lsp', ''),
                                \}
                            
                                if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
                                endif
                            
                                let l:needs_address = l:obj.lsp is# 'socket'
                                let l:needs_executable = l:obj.lsp isnot# 'socket'
                                let l:needs_command = l:obj.lsp isnot# 'socket'
                                let l:needs_lsp_details = !empty(l:obj.lsp)
                            
                                if empty(l:obj.lsp)
                                    let l:obj.callback = get(a:linter, 'callback')
                            
                                    if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
                                    endif
                                endif
                            
                                if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
                                endif
                            
                                if !l:needs_executable
                                    if has_key(a:linter, 'executable')
                                        throw '`executable` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'executable')
                                    let l:obj.executable = a:linter.executable
                            
                                    if type(l:obj.executable) isnot v:t_string
                                    \&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
                                    endif
                                else
                                    throw '`executable` must be defined'
                                endif
                            
                                if !l:needs_command
                                    if has_key(a:linter, 'command')
                                        throw '`command` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'command')
                                    let l:obj.command = a:linter.command
                            
                                    if type(l:obj.command) isnot v:t_string
                                    \&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
                                    endif
                                else
                                    throw '`command` must be defined'
                                endif
                            
                                if !l:needs_address
                                    if has_key(a:linter, 'address')
                                        throw '`address` cannot be used when lsp != ''socket'''
                                    endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string
                                    \&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                            
                                    if has_key(a:linter, 'cwd')
                                        throw '`cwd` makes no sense for socket LSP connections'
                                    endif
                                else
                                    throw '`address` must be defined for getting the LSP address'
                                endif
                            
                                if has_key(a:linter, 'cwd')
                                    let l:obj.cwd = a:linter.cwd
                            
                                    if type(l:obj.cwd) isnot v:t_string
                                    \&& type(l:obj.cwd) isnot v:t_func
                                        throw '`cwd` must be a String or Function if defined'
                                    endif
                                endif
                            
                                if l:needs_lsp_details
                                    " Default to using the filetype as the language.
                                    let l:obj.language = get(a:linter, 'language', a:filetype)
                            
                                    if type(l:obj.language) isnot v:t_string
                                    \&& type(l:obj.language) isnot v:t_func
                                        throw '`language` must be a String or Function if defined'
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string
                                        \&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function'
                                        endif
                                    else
                                        throw '`project_root` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict
                                        \&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a Dictionary or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict
                                        \&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
                                endif
                            
                                let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
                                if type(l:obj.output_stream) isnot v:t_string
                                \|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
                                endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
                                let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
                                if !s:IsBoolean(l:obj.lint_file) && type(l:obj.lint_file) isnot v:t_func
                                    throw '`lint_file` must be `0`, `1`, or a Function'
                                endif
                            
                                " An option indicating that the buffer should be read.
                                let l:obj.read_buffer = get(a:linter, 'read_buffer', 1)
                            
                                if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
                                endif
                            
                                let l:obj.aliases = get(a:linter, 'aliases', [])
                            
                                if type(l:obj.aliases) isnot v:t_list
                                \|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
                                endif
                            
                                return l:obj
                            endfunction
                            
    1              0.000001000 function! ale#linter#Define(filetype, linter) abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
                                if !has_key(s:linters, a:filetype)
                                    let s:linters[a:filetype] = []
                                endif
                            
                                " Remove previously defined linters with the same name.
                                call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
                                call add(s:linters[a:filetype], l:new_linter)
                            endfunction
                            
                            " Prevent any linters from being loaded for a given filetype.
    1              0.000001000 function! ale#linter#PreventLoading(filetype) abort
                                let s:runtime_loaded_map[a:filetype] = 1
                            endfunction
                            
    1              0.000001000 function! ale#linter#GetAll(filetypes) abort
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
                                if ale#util#InSandbox()
                                    return []
                                endif
                            
                                let l:combined_linters = []
                            
                                for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
                                    if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
                                    call extend(l:combined_linters, get(s:linters, l:filetype, []))
                                endfor
                            
                                return l:combined_linters
                            endfunction
                            
    1              0.000001000 function! s:GetAliasedFiletype(original_filetype) abort
                                let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
                                if type(l:buffer_aliases) is v:t_list
                                \|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
                                for l:dict in [
                                \   l:buffer_aliases,
                                \   g:ale_linter_aliases,
                                \   s:default_ale_linter_aliases,
                                \]
                                    if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
                                endfor
                            
                                return a:original_filetype
                            endfunction
                            
    1              0.000000000 function! ale#linter#ResolveFiletype(original_filetype) abort
                                let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
                                if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
                                endif
                            
                                return l:filetype
                            endfunction
                            
    1              0.000001000 function! s:GetLinterNames(original_filetype) abort
                                let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
                                if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
                                if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'
                            endfunction
                            
    1              0.000001000 function! ale#linter#Get(original_filetypes) abort
                                let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
                                for l:original_filetype in split(a:original_filetypes, '\.')
                                    let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                                    let l:linter_names = s:GetLinterNames(l:original_filetype)
                                    let l:all_linters = ale#linter#GetAll(l:filetype)
                                    let l:filetype_linters = []
                            
                                    if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
                                    call extend(l:possibly_duplicated_linters, l:filetype_linters)
                                endfor
                            
                                let l:name_list = []
                                let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
                                for l:linter in reverse(l:possibly_duplicated_linters)
                                    if index(l:name_list, l:linter.name) < 0
                                        call add(l:name_list, l:linter.name)
                                        call add(l:combined_linters, l:linter)
                                    endif
                                endfor
                            
                                return reverse(l:combined_linters)
                            endfunction
                            
                            " Given a buffer and linter, get the executable String for the linter.
    1              0.000000000 function! ale#linter#GetExecutable(buffer, linter) abort
                                let l:Executable = a:linter.executable
                            
                                return type(l:Executable) is v:t_func
                                \   ? l:Executable(a:buffer)
                                \   : l:Executable
                            endfunction
                            
    1              0.000000000 function! ale#linter#GetCwd(buffer, linter) abort
                                let l:Cwd = get(a:linter, 'cwd', v:null)
                            
                                return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd
                            endfunction
                            
                            " Given a buffer and linter, get the command String for the linter.
    1              0.000001000 function! ale#linter#GetCommand(buffer, linter) abort
                                let l:Command = a:linter.command
                            
                                return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command
                            endfunction
                            
                            " Given a buffer and linter, get the address for connecting to the server.
    1              0.000001000 function! ale#linter#GetAddress(buffer, linter) abort
                                let l:Address = a:linter.address
                            
                                return type(l:Address) is v:t_func ? l:Address(a:buffer) : l:Address
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/vim/ale_custom_linting_rules.vim
Sourced 1 time
Total time:   0.000254000
 Self time:   0.000131000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: A linter for checking ALE project code itself.
                            
    1              0.000002000 function! ale_linters#vim#ale_custom_linting_rules#GetExecutable(buffer) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:dir_list = []
                            
                                for l:dir in split(&runtimepath, ',')
                                    if l:filename[:len(l:dir) - 1] is# l:dir
                                        call add(l:dir_list, l:dir)
                                    endif
                                endfor
                            
                                return !empty(l:dir_list)
                                \   ? findfile('test/script/custom-linting-rules', join(l:dir_list, ','))
                                \   : ''
                            endfunction
                            
    1              0.000001000 function! s:GetALEProjectDir(buffer) abort
                                let l:executable = ale_linters#vim#ale_custom_linting_rules#GetExecutable(a:buffer)
                            
                                return ale#path#Dirname(ale#path#Dirname(ale#path#Dirname(l:executable)))
                            endfunction
                            
    1              0.000001000 function! ale_linters#vim#ale_custom_linting_rules#GetCwd(buffer) abort
                                let l:executable = ale_linters#vim#ale_custom_linting_rules#GetExecutable(a:buffer)
                            
                                return ale#path#Dirname(ale#path#Dirname(ale#path#Dirname(l:executable)))
                            endfunction
                            
    1              0.000001000 function! ale_linters#vim#ale_custom_linting_rules#GetCommand(buffer) abort
                                let l:temp_dir = ale#command#CreateDirectory(a:buffer)
                                let l:temp_file = l:temp_dir . '/example.vim'
                            
                                let l:lines = getbufline(a:buffer, 1, '$')
                                call ale#util#Writefile(a:buffer, l:lines, l:temp_file)
                            
                                return '%e ' . ale#Escape(l:temp_dir)
                            endfunction
                            
    1              0.000001000 function! ale_linters#vim#ale_custom_linting_rules#Handle(buffer, lines) abort
                                let l:dir = s:GetALEProjectDir(a:buffer)
                                let l:output = []
                                let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+) (.+)$'
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " Ignore trailing whitespace errors if we've turned them off.
                                    if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    \&& l:match[3] is# 'Trailing whitespace'
                                        continue
                                    endif
                            
                                    call add(l:output, {
                                    \   'lnum': l:match[2],
                                    \   'text': l:match[3],
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000135000   0.000012000 call ale#linter#Define('vim', {
                            \   'name': 'ale_custom_linting_rules',
                            \   'executable': function('ale_linters#vim#ale_custom_linting_rules#GetExecutable'),
                            \   'cwd': function('ale_linters#vim#ale_custom_linting_rules#GetCwd'),
                            \   'command': function('ale_linters#vim#ale_custom_linting_rules#GetCommand'),
                            \   'callback': 'ale_linters#vim#ale_custom_linting_rules#Handle',
                            \   'read_buffer': 0,
                            \})

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/vim/vimls.vim
Sourced 1 time
Total time:   0.000263000
 Self time:   0.000142000

count     total (s)      self (s)
                            " Author: Jeffrey Lau - https://github.com/zoonfafer
                            " Description: Vim Language Server integration for ALE
                            
    1   0.000009000   0.000004000 call ale#Set('vim_vimls_executable', 'vim-language-server')
    1   0.000006000   0.000002000 call ale#Set('vim_vimls_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000006000   0.000002000 call ale#Set('vim_vimls_config', {})
                            
    1              0.000001000 function! ale_linters#vim#vimls#GetProjectRoot(buffer) abort
                                let l:trigger_file_candidates = [
                                \   '.vimrc',
                                \   'init.vim',
                                \]
                            
                                for l:candidate in l:trigger_file_candidates
                                    let l:trigger_file = fnamemodify(bufname(a:buffer), ':t')
                            
                                    if l:trigger_file is# l:candidate
                                        return fnamemodify(
                                        \   bufname(a:buffer),
                                        \   ':h',
                                        \)
                                    endif
                                endfor
                            
                                let l:trigger_dir_candidates = [
                                \   'autoload',
                                \   'plugin',
                                \   '.git',
                                \]
                            
                                let l:path_upwards = ale#path#Upwards(fnamemodify(bufname(a:buffer), ':p:h'))
                            
                                for l:path in l:path_upwards
                                    for l:candidate in l:trigger_dir_candidates
                                        let l:trigger_dir = ale#path#Simplify(
                                        \   l:path . '/' . l:candidate,
                                        \)
                            
                                        if isdirectory(l:trigger_dir)
                                            return fnamemodify(
                                            \   l:trigger_dir,
                                            \   ':p:h:h',
                                            \)
                                        endif
                                    endfor
                                endfor
                            
                                return ''
                            endfunction
                            
    1   0.000120000   0.000012000 call ale#linter#Define('vim', {
                            \   'name': 'vimls',
                            \   'lsp': 'stdio',
                            \   'lsp_config': {b -> ale#Var(b, 'vim_vimls_config')},
                            \   'executable': {b -> ale#path#FindExecutable(b, 'vim_vimls', [
                            \       'node_modules/.bin/vim-language-server',
                            \   ])},
                            \   'command': '%e --stdio',
                            \   'language': 'vim',
                            \   'project_root': function('ale_linters#vim#vimls#GetProjectRoot'),
                            \})

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/vim/vint.vim
Sourced 1 time
Total time:   0.000754000
 Self time:   0.000621000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>, KabbAmine <amine.kabb@gmail.com>
                            " Description: This file adds support for checking Vim code with Vint.
                            
                            " This flag can be used to change enable/disable style issues.
    1   0.000016000   0.000006000 call ale#Set('vim_vint_show_style_issues', 1)
    1   0.000008000   0.000003000 call ale#Set('vim_vint_executable', 'vint')
    1              0.000004000 let s:enable_neovim = has('nvim') ? ' --enable-neovim' : ''
    1              0.000002000 let s:format = '-f "{file_path}:{line_number}:{column_number}: {severity}: {policy_name} - {description} (see {reference})"'
                            
    1              0.000002000 function! ale_linters#vim#vint#GetCommand(buffer, version) abort
                                let l:can_use_no_color_flag = empty(a:version)
                                \   || ale#semver#GTE(a:version, [0, 3, 7])
                            
                                let l:warning_flag = ale#Var(a:buffer, 'vim_vint_show_style_issues') ? '-s' : '-w'
                            
                                " Use the --stdin-display-name argument if supported, temp file otherwise.
                                let l:stdin_or_temp = ale#semver#GTE(a:version, [0, 4, 0])
                                \   ? ' --stdin-display-name %s -'
                                \   : ' %t'
                            
                                return '%e'
                                \   . ' ' . l:warning_flag
                                \   . (l:can_use_no_color_flag ? ' --no-color' : '')
                                \   . s:enable_neovim
                                \   . ' ' . s:format
                                \   . l:stdin_or_temp
                            endfunction
                            
    1              0.000003000 let s:word_regex_list = [
                            \   '\v^Undefined variable: ([^ ]+)',
                            \   '\v^Make the scope explicit like ...([^ ]+). ',
                            \   '\v^.*start with a capital or contain a colon: ([^ ]+)',
                            \   '\v.*instead of .(\=[=~]).',
                            \]
                            
    1              0.000001000 function! ale_linters#vim#vint#Handle(buffer, lines) abort
                                let l:loclist = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
                            
                                for l:item in l:loclist
                                    let l:match = []
                            
                                    for l:regex in s:word_regex_list
                                        let l:match = matchlist(l:item.text, l:regex)
                            
                                        if !empty(l:match)
                                            let l:item.end_col = l:item.col + len(l:match[1]) - 1
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:loclist
                            endfunction
                            
    1   0.000131000   0.000013000 call ale#linter#Define('vim', {
                            \   'name': 'vint',
                            \   'executable': {buffer -> ale#Var(buffer, 'vim_vint_executable')},
                            \   'command': {buffer -> ale#semver#RunWithVersionCheck(
                            \       buffer,
                            \       ale#Var(buffer, 'vim_vint_executable'),
                            \       '%e --version',
                            \       function('ale_linters#vim#vint#GetCommand'),
                            \   )},
                            \   'callback': 'ale_linters#vim#vint#Handle',
                            \})

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/vim/vinter.vim
Sourced 1 time
Total time:   0.000165000
 Self time:   0.000052000

count     total (s)      self (s)
                            " Author: Dan Bradbury - https://github.com/DanBradbury
                            " Description: Vinter, a code style analyzer for vim9script files
                            
    1   0.000007000   0.000003000 call ale#Set('vim_vinter_executable', 'vinter')
    1   0.000005000   0.000001000 call ale#Set('vim_vinter_options', '')
                            
    1              0.000001000 function! ale_linters#vim#vinter#GetCommand(buffer) abort
                                let l:executable = ale#Var(a:buffer, 'vim_vinter_executable')
                            
                                return ale#vim#EscapeExecutable(l:executable, 'vinter') . ' --format json .'
                            endfunction
                            
    1              0.000001000 function! ale_linters#vim#vinter#GetType(severity) abort
                                if a:severity is? 'convention'
                                \|| a:severity is? 'warning'
                                \|| a:severity is? 'refactor'
                                    return 'W'
                                endif
                            
                                return 'E'
                            endfunction
                            
                            " Handle output from rubocop and linters that depend on it (e.b. standardrb)
    1              0.000001000 function! ale_linters#vim#vinter#HandleOutput(buffer, lines) abort
                                try
                                    let l:errors = json_decode(a:lines[0])
                                catch
                                    return []
                                endtry
                            
                                if !has_key(l:errors, 'summary')
                                \|| l:errors['summary']['offense_count'] == 0
                                \|| empty(l:errors['files'])
                                    return []
                                endif
                            
                                let l:output = []
                            
                                for l:error in l:errors['files'][0]['offenses']
                                    let l:start_col = l:error['location']['column'] + 0
                                    call add(l:output, {
                                    \   'lnum': l:error['location']['line'] + 0,
                                    \   'col': l:start_col,
                                    \   'end_col': l:start_col + l:error['location']['length'] - 1,
                                    \   'code': l:error['cop_name'],
                                    \   'text': l:error['message'],
                                    \   'type': 'E'
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000111000   0.000006000 call ale#linter#Define('vim', {
                            \   'name': 'vinter',
                            \   'executable': 'vinter',
                            \   'command': '%e %t --format=json',
                            \   'callback': 'ale_linters#vim#vinter#HandleOutput',
                            \   'read_buffer': 0,
                            \})

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/engine.vim
Sourced 1 time
Total time:   0.000298000
 Self time:   0.000298000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Backend execution and job management
                            "   Executes linters in the background, using NeoVim or Vim 8 jobs
                            
                            " Remapping of linter problems.
    1              0.000003000 let g:ale_type_map = get(g:, 'ale_type_map', {})
    1              0.000002000 let g:ale_filename_mappings = get(g:, 'ale_filename_mappings', {})
                            
    1              0.000001000 if !has_key(s:, 'executable_cache_map')
    1              0.000001000     let s:executable_cache_map = {}
    1              0.000001000 endif
                            
    1              0.000001000 function! ale#engine#CleanupEveryBuffer() abort
                                for l:key in keys(g:ale_buffer_info)
                                    " The key could be a filename or a buffer number, so try and
                                    " convert it to a number. We need a number for the other
                                    " functions.
                                    let l:buffer = str2nr(l:key)
                            
                                    if l:buffer > 0
                                        " Stop all jobs and clear the results for everything, and delete
                                        " all of the data we stored for the buffer.
                                        call ale#engine#Cleanup(l:buffer)
                                    endif
                                endfor
                            endfunction
                            
    1              0.000000000 function! ale#engine#MarkLinterActive(info, linter) abort
                                let l:found = 0
                            
                                for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
                                endfor
                            
                                if !l:found
                                    call add(a:info.active_linter_list, a:linter)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#engine#MarkLinterInactive(info, linter_name) abort
                                call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')
                            endfunction
                            
    1              0.000001000 function! ale#engine#ResetExecutableCache() abort
                                let s:executable_cache_map = {}
                            endfunction
                            
                            " Check if files are executable, and if they are, remember that they are
                            " for subsequent calls. We'll keep checking until programs can be executed.
    1              0.000001000 function! ale#engine#IsExecutable(buffer, executable) abort
                                if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
                                let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
                                if l:result isnot v:null
                                    return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures')
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000001000 function! ale#engine#InitBufferInfo(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {
                                    \   'active_linter_list': [],
                                    \   'active_other_sources_list': [],
                                    \   'loclist': [],
                                    \}
                            
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function is documented and part of the public API.
                            "
                            " Return 1 if ALE is busy checking a given buffer
    1              0.000000000 function! ale#engine#IsCheckingBuffer(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                return !empty(get(l:info, 'active_linter_list', []))
                                \   || !empty(get(l:info, 'active_other_sources_list', []))
                            endfunction
                            
    1              0.000001000 function! ale#engine#HandleLoclist(linter_name, buffer, loclist, from_other_source) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
                                    call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
                                endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
                                let l:linter_loclist = ale#engine#FixLocList(
                                \   a:buffer,
                                \   a:linter_name,
                                \   a:from_other_source,
                                \   a:loclist,
                                \)
                            
                                " Remove previous items for this linter.
                                call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
                                if !empty(l:linter_loclist)
                                    " Add the new items.
                                    call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
                                    call sort(l:info.loclist, 'ale#util#LocItemCompare')
                                endif
                            
                                if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                call ale#engine#SetResults(a:buffer, l:info.loclist)
                            endfunction
                            
    1              0.000001000 function! s:HandleExit(job_info, buffer, output, data) abort
                                let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
                                if empty(l:buffer_info)
                                    return
                                endif
                            
                                let l:linter = a:job_info.linter
                                let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
                                call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
                                if ale#util#InSandbox()
                                    return
                                endif
                            
                                if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
                                endif
                            
                                try
                                    let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
                                endtry
                            
                                if type(l:loclist) isnot# v:t_list
                                    " we only expect the list type; don't pass anything else down to
                                    " `ale#engine#HandleLoclist` since it won't understand it
                                    let l:loclist = []
                                endif
                            
                                call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)
                            endfunction
                            
    1              0.000001000 function! ale#engine#SetResults(buffer, loclist) abort
                                let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                if g:ale_use_neovim_diagnostics_api
                                    call ale#engine#SendResultsToNeovimDiagnostics(a:buffer, a:loclist)
                                endif
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
                                if !g:ale_use_neovim_diagnostics_api && g:ale_set_signs
                                    call ale#sign#SetSigns(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_quickfix || g:ale_set_loclist
                                    call ale#list#SetLists(a:buffer, a:loclist)
                                endif
                            
                                if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
                                if !g:ale_use_neovim_diagnostics_api && g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
                                endif
                            
                                if !g:ale_use_neovim_diagnostics_api
                                \&& (g:ale_virtualtext_cursor is# 'all' || g:ale_virtualtext_cursor == 2)
                                    call ale#virtualtext#SetTexts(a:buffer, a:loclist)
                                endif
                            
                                if l:linting_is_done
                                    if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#cursor#EchoCursorWarning()
                                    endif
                            
                                    if !g:ale_use_neovim_diagnostics_api
                                    \&& (g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor == 1)
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
                                    call setbufvar(
                                    \   a:buffer,
                                    \   'ale_linted',
                                    \   getbufvar(a:buffer, 'ale_linted', 0) + 1
                                    \)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
                                    call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
                                    silent doautocmd <nomodeline> User ALELintPost
                                endif
                            endfunction
                            
    1              0.000002000 function! ale#engine#SendResultsToNeovimDiagnostics(buffer, loclist) abort
                                if !has('nvim-0.6')
                                    " We will warn the user on startup as well if they try to set
                                    " g:ale_use_neovim_diagnostics_api outside of a Neovim context.
                                    return
                                endif
                            
                                " Keep the Lua surface area really small in the VimL part of ALE,
                                " and just require the diagnostics.lua module on demand.
                                let l:SendDiagnostics = luaeval('require("ale.diagnostics").send')
                                call l:SendDiagnostics(a:buffer, a:loclist)
                            endfunction
                            
    1              0.000001000 function! s:RemapItemTypes(type_map, loclist) abort
                                for l:item in a:loclist
                                    let l:key = l:item.type
                                    \   . (get(l:item, 'sub_type', '') is# 'style' ? 'S' : '')
                                    let l:new_key = get(a:type_map, l:key, '')
                            
                                    if l:new_key is# 'E'
                                    \|| l:new_key is# 'ES'
                                    \|| l:new_key is# 'W'
                                    \|| l:new_key is# 'WS'
                                    \|| l:new_key is# 'I'
                                        let l:item.type = l:new_key[0]
                            
                                        if l:new_key is# 'ES' || l:new_key is# 'WS'
                                            let l:item.sub_type = 'style'
                                        elseif has_key(l:item, 'sub_type')
                                            call remove(l:item, 'sub_type')
                                        endif
                                    endif
                                endfor
                            endfunction
                            
    1              0.000001000 function! ale#engine#FixLocList(buffer, linter_name, from_other_source, loclist) abort
                                let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
                                if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
                                endif
                            
                                let l:bufnr_map = {}
                                let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
                                let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
                                for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {
                                    \   'bufnr': a:buffer,
                                    \   'text': l:old_item.text,
                                    \   'lnum': str2nr(l:old_item.lnum),
                                    \   'col': str2nr(get(l:old_item, 'col', 0)),
                                    \   'vcol': 0,
                                    \   'type': get(l:old_item, 'type', 'E'),
                                    \   'nr': get(l:old_item, 'nr', -1),
                                    \   'linter_name': a:linter_name,
                                    \}
                            
                                    if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
                                    if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
                                    let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
                                    if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
                                    endif
                            
                                    if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                            
                                        " When the error ends after the end of the file, put it at the
                                        " end. This is only done for the current buffer.
                                        if l:item.bufnr == a:buffer && l:item.end_lnum > l:last_line_number
                                            let l:item.end_lnum = l:last_line_number
                                        endif
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line
                                            \   ? getbufline(a:buffer, l:item.end_lnum)[0]
                                            \   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
                                    call add(l:new_loclist, l:item)
                                endfor
                            
                                let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
                                if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
                                return l:new_loclist
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000001000 function! ale#engine#EscapeCommandPart(command_part) abort
                                " TODO: Emit deprecation warning here later.
                                return ale#command#EscapeCommandPart(a:command_part)
                            endfunction
                            
                            " Run a job.
                            "
                            " Returns 1 when a job was started successfully.
    1              0.000001000 function! s:RunJob(command, options) abort
                                if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {
                                    \   command -> s:RunJob(command, a:options)
                                    \}
                            
                                    return 1
                                endif
                            
                                let l:command = a:command
                            
                                if empty(l:command)
                                    return 0
                                endif
                            
                                let l:cwd = a:options.cwd
                                let l:executable = a:options.executable
                                let l:buffer = a:options.buffer
                                let l:linter = a:options.linter
                                let l:output_stream = a:options.output_stream
                                let l:read_buffer = a:options.read_buffer && !a:options.lint_file
                                let l:info = g:ale_buffer_info[l:buffer]
                            
                                let l:Callback = function('s:HandleExit', [{
                                \   'linter': l:linter,
                                \   'executable': l:executable,
                                \}])
                                let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {
                                \   'cwd': l:cwd,
                                \   'output_stream': l:output_stream,
                                \   'executable': l:executable,
                                \   'read_buffer': l:read_buffer,
                                \   'log_output': 1,
                                \   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),
                                \})
                            
                                " Only proceed if the job is being run.
                                if empty(l:result)
                                    return 0
                                endif
                            
                                call ale#engine#MarkLinterActive(l:info, l:linter)
                            
                                silent doautocmd <nomodeline> User ALEJobStarted
                            
                                return 1
                            endfunction
                            
    1              0.000029000 function! s:StopCurrentJobs(buffer, clear_lint_file_jobs, linter_slots) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
                                if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
                                else
                                    let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
                                    for [l:lint_file, l:linter] in a:linter_slots
                                        if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
                                        endif
                                    endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
                                    call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#engine#Stop(buffer) abort
                                call s:StopCurrentJobs(a:buffer, 1, [])
                            endfunction
                            
    1              0.000001000 function! s:RemoveProblemsForDisabledLinters(buffer, linters) abort
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
                                let l:name_map = {}
                            
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                call filter(
                                \   get(g:ale_buffer_info[a:buffer], 'loclist', []),
                                \   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',
                                \)
                            endfunction
                            
    1              0.000001000 function! s:AddProblemsFromOtherBuffers(buffer, linters) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:loclist = []
                                let l:name_map = {}
                            
                                " Build a map of the active linters.
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
                                for l:info in values(g:ale_buffer_info)
                                    for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')
                                        \&& l:item.filename is# l:filename
                                        \&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
                                    endfor
                                endfor
                            
                                if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:RunIfExecutable(buffer, linter, lint_file, executable) abort
                                if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {
                                    \   executable -> s:RunIfExecutable(
                                    \       a:buffer,
                                    \       a:linter,
                                    \       a:lint_file,
                                    \       executable
                                    \   )
                                    \}
                            
                                    return 1
                                endif
                            
                                if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
                                    let l:job_type = a:lint_file ? 'file_linter' : 'linter'
                                    call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
                                    let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
                                    if l:cwd isnot v:null
                                        call ale#command#SetCwd(a:buffer, l:cwd)
                                    endif
                            
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
                                    if l:cwd isnot v:null
                                        call ale#command#ResetCwd(a:buffer)
                                    endif
                            
                                    let l:options = {
                                    \   'cwd': l:cwd,
                                    \   'executable': a:executable,
                                    \   'buffer': a:buffer,
                                    \   'linter': a:linter,
                                    \   'output_stream': get(a:linter, 'output_stream', 'stdout'),
                                    \   'read_buffer': a:linter.read_buffer,
                                    \   'lint_file': a:lint_file,
                                    \}
                            
                                    return s:RunJob(l:command, l:options)
                                endif
                            
                                return 0
                            endfunction
                            
                            " Run a linter for a buffer.
                            "
                            " Returns 1 if the linter was successfully run.
    1              0.000001000 function! s:RunLinter(buffer, linter, lint_file) abort
                                if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
                                    let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
                                    return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000001000 function! s:GetLintFileSlots(buffer, linters) abort
                                let l:linter_slots = []
                            
                                for l:linter in a:linters
                                    let l:LintFile = l:linter.lint_file
                            
                                    if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
                                    endif
                            
                                    call add(l:linter_slots, [l:LintFile, l:linter])
                                endfor
                            
                                return l:linter_slots
                            endfunction
                            
    1              0.000001000 function! s:GetLintFileValues(slots, Callback) abort
                                let l:deferred_list = []
                                let l:new_slots = []
                            
                                for [l:lint_file, l:linter] in a:slots
                                    while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
                                    endwhile
                            
                                    if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
                                    else
                                        " If we have the value now, coerce it to 0 or 1.
                                        let l:lint_file = l:lint_file is 1
                                    endif
                            
                                    call add(l:new_slots, [l:lint_file, l:linter])
                                endfor
                            
                                if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =
                                        \   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
                                else
                                    call a:Callback(l:new_slots)
                                endif
                            endfunction
                            
    1              0.000002000 function! s:RunLinters(
                            \   buffer,
                            \   linters,
                            \   slots,
                            \   should_lint_file,
                            \   new_buffer,
                            \) abort
                                call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
                                call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
                                let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                silent doautocmd <nomodeline> User ALELintPre
                            
                                for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
                                    if !l:lint_file || a:should_lint_file
                                        if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
                                        endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
                                endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
                                if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(
                                    \   a:buffer,
                                    \   map(copy(a:slots), 'v:val[1]')
                                    \)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#engine#RunLinters(buffer, linters, should_lint_file) abort
                                " Initialise the buffer information if needed.
                                let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
                                call s:GetLintFileValues(
                                \   s:GetLintFileSlots(a:buffer, a:linters),
                                \   {
                                \       slots -> s:RunLinters(
                                \           a:buffer,
                                \           a:linters,
                                \           slots,
                                \           a:should_lint_file,
                                \           l:new_buffer,
                                \       )
                                \   }
                                \)
                            endfunction
                            
                            " Clean up a buffer.
                            "
                            " This function will stop all current jobs for the buffer,
                            " clear the state of everything, and remove the Dictionary for managing
                            " the buffer.
    1              0.000001000 function! ale#engine#Cleanup(buffer) abort
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
                                if exists('*ale#lsp#CloseDocument')
                                    call ale#lsp#CloseDocument(a:buffer)
                                endif
                            
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)
                            endfunction
                            
                            " Given a buffer number, return the warnings and errors for a given buffer.
    1              0.000001000 function! ale#engine#GetLoclist(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
                                return g:ale_buffer_info[a:buffer].loclist
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/command.vim
Sourced 1 time
Total time:   0.000261000
 Self time:   0.000261000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for formatting command strings, running commands, and
                            "   managing files during linting and fixing cycles.
                            
                            " This dictionary holds lists of files and directories to remove later.
    1              0.000002000 if !exists('s:buffer_data')
    1              0.000001000     let s:buffer_data = {}
    1              0.000000000 endif
                            
                            " The regular expression used for formatting filenames with modifiers.
    1              0.000001000 let s:path_format_regex = '\v\%s(%(:h|:t|:r|:e)*)'
                            
                            " Used to get the data in tests.
    1              0.000001000 function! ale#command#GetData() abort
                                return deepcopy(s:buffer_data)
                            endfunction
                            
    1              0.000001000 function! ale#command#ClearData() abort
                                let s:buffer_data = {}
                            endfunction
                            
    1              0.000000000 function! ale#command#InitData(buffer) abort
                                if !has_key(s:buffer_data, a:buffer)
                                    let s:buffer_data[a:buffer] = {
                                    \   'jobs': {},
                                    \   'file_list': [],
                                    \   'directory_list': [],
                                    \}
                                endif
                            endfunction
                            
                            " Set the cwd for commands that are about to run.
                            " Used internally.
    1              0.000001000 function! ale#command#SetCwd(buffer, cwd) abort
                                call ale#command#InitData(a:buffer)
                                let s:buffer_data[a:buffer].cwd = a:cwd
                            endfunction
                            
    1              0.000000000 function! ale#command#ResetCwd(buffer) abort
                                if has_key(s:buffer_data, a:buffer)
                                    let s:buffer_data[a:buffer].cwd = v:null
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#command#ManageFile(buffer, file) abort
                                call ale#command#InitData(a:buffer)
                                call add(s:buffer_data[a:buffer].file_list, a:file)
                            endfunction
                            
    1              0.000001000 function! ale#command#ManageDirectory(buffer, directory) abort
                                call ale#command#InitData(a:buffer)
                                call add(s:buffer_data[a:buffer].directory_list, a:directory)
                            endfunction
                            
    1              0.000001000 function! ale#command#CreateFile(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP'
                                endif
                            
                                let l:temporary_file = ale#util#Tempname()
                                call ale#command#ManageFile(a:buffer, l:temporary_file)
                            
                                return l:temporary_file
                            endfunction
                            
                            " Create a new temporary directory and manage it in one go.
    1              0.000001000 function! ale#command#CreateDirectory(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP_DIR'
                                endif
                            
                                let l:temporary_directory = ale#util#Tempname()
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                            
                                return l:temporary_directory
                            endfunction
                            
    1              0.000001000 function! ale#command#RemoveManagedFiles(buffer) abort
                                let l:info = get(s:buffer_data, a:buffer, {})
                            
                                if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
                                    if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
                                    for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
                                    for l:directory in l:info.directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    call remove(s:buffer_data, a:buffer)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#command#CreateTempFile(buffer, temporary_file, input) abort
                                if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
                                let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
                                let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
                                call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
                                call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
                                return 1
                            endfunction
                            
    1              0.000001000 function! s:TemporaryFilename(buffer) abort
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
                                return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000001000 function! ale#command#EscapeCommandPart(command_part) abort
                                return substitute(a:command_part, '%', '%%', 'g')
                            endfunction
                            
                            " Format a filename, converting it with filename mappings, if non-empty,
                            " and escaping it for putting into a command string.
                            "
                            " The filename can be modified.
    1              0.000001000 function! s:FormatFilename(filename, mappings, modifiers) abort
                                let l:filename = a:filename
                            
                                if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
                                endif
                            
                                if !empty(a:modifiers)
                                    let l:filename = fnamemodify(l:filename, a:modifiers)
                                endif
                            
                                return ale#Escape(l:filename)
                            endfunction
                            
                            " Produce a command prefix to check to a particular directory for a command.
                            " %s format markers with filename-modifiers can be used as the directory, and
                            " will be returned verbatim for formatting in paths relative to files.
    1              0.000001000 function! ale#command#CdString(directory) abort
                                let l:match = matchstrpos(a:directory, s:path_format_regex)
                                " Do not escape the directory here if it's a valid format string.
                                " This allows us to use sequences like %s:h, %s:h:h, etc.
                                let l:directory = l:match[1:] == [0, len(a:directory)]
                                \   ? a:directory
                                \   : ale#Escape(a:directory)
                            
                                if has('win32')
                                    return 'cd /d ' . l:directory . ' && '
                                endif
                            
                                return 'cd ' . l:directory . ' && '
                            endfunction
                            
                            " Given a command string, replace every...
                            " %s -> with the current filename
                            " %t -> with the name of an unused file in a temporary directory
                            " %% -> with a literal %
    1              0.000002000 function! ale#command#FormatCommand(
                            \   buffer,
                            \   executable,
                            \   command,
                            \   pipe_file_if_needed,
                            \   input,
                            \   cwd,
                            \   mappings,
                            \) abort
                                let l:temporary_file = ''
                                let l:command = a:command
                            
                                if !empty(a:cwd)
                                    let l:command = ale#command#CdString(a:cwd) . l:command
                                endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
                                let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
                                if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
                                endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
                                if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(
                                    \   l:command,
                                    \   s:path_format_regex,
                                    \   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',
                                    \   'g'
                                    \)
                                endif
                            
                                if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(
                                    \   l:command,
                                    \   '\v\%t(%(:h|:t|:r|:e)*)',
                                    \   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',
                                    \   'g'
                                    \)
                                endif
                            
                                " Finish formatting so %% becomes %.
                                let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
                                if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
                                let l:file_created = ale#command#CreateTempFile(
                                \   a:buffer,
                                \   l:temporary_file,
                                \   a:input,
                                \)
                            
                                return [l:temporary_file, l:command, l:file_created]
                            endfunction
                            
    1              0.000001000 function! ale#command#StopJobs(buffer, job_type) abort
                                let l:info = get(s:buffer_data, a:buffer, {})
                            
                                if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
                                endif
                            endfunction
                            
    1              0.000001000 function! s:GatherOutput(line_list, job_id, line) abort
                                call add(a:line_list, a:line)
                            endfunction
                            
    1              0.000001000 function! s:ExitCallback(buffer, line_list, Callback, data) abort
                                if !has_key(s:buffer_data, a:buffer)
                                    return
                                endif
                            
                                let l:jobs = s:buffer_data[a:buffer].jobs
                            
                                if !has_key(l:jobs, a:data.job_id)
                                    return
                                endif
                            
                                let l:job_type = remove(l:jobs, a:data.job_id)
                            
                                if g:ale_history_enabled
                                    call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
                                    if g:ale_history_log_output && a:data.log_output is 1
                                        call ale#history#RememberOutput(
                                        \   a:buffer,
                                        \   a:data.job_id,
                                        \   a:line_list[:]
                                        \)
                                    endif
                                endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
                                call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                                let l:value = a:Callback(a:buffer, a:line_list, {
                                \   'exit_code': a:data.exit_code,
                                \   'temporary_file': a:data.temporary_file,
                                \})
                            
                                let l:result = a:data.result
                                let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
                                call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
                                try
                                    if get(l:result, 'result_callback', v:null) isnot v:null
                                        call call(l:result.result_callback, [l:value])
                                    endif
                                finally
                                    call ale#command#ResetCwd(a:buffer)
                                endtry
                            endfunction
                            
    1              0.000001000 function! ale#command#Run(buffer, command, Callback, ...) abort
                                let l:options = get(a:000, 0, {})
                            
                                if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
                                let l:output_stream = get(l:options, 'output_stream', 'stdout')
                                let l:line_list = []
                                let l:cwd = get(l:options, 'cwd', v:null)
                            
                                if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
                                    let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
                                endif
                            
                                let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(
                                \   a:buffer,
                                \   get(l:options, 'executable', ''),
                                \   a:command,
                                \   get(l:options, 'read_buffer', 0),
                                \   get(l:options, 'input', v:null),
                                \   l:cwd,
                                \   get(l:options, 'filename_mappings', []),
                                \)
                                let l:command = ale#job#PrepareCommand(a:buffer, l:command)
                                let l:job_options = {
                                \   'exit_cb': {job_id, exit_code -> s:ExitCallback(
                                \       a:buffer,
                                \       l:line_list,
                                \       a:Callback,
                                \       {
                                \           'job_id': job_id,
                                \           'exit_code': exit_code,
                                \           'temporary_file': l:temporary_file,
                                \           'log_output': get(l:options, 'log_output', 1),
                                \           'result': l:result,
                                \       }
                                \   )},
                                \   'mode': 'nl',
                                \}
                            
                                if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                endif
                            
                                let l:status = 'failed'
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
                                    let l:job_id = ale#job#Start(l:command, l:job_options)
                                endif
                            
                                if l:job_id
                                    let l:status = 'started'
                                    let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
                                    call ale#command#InitData(a:buffer)
                                    let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
                                endif
                            
                                if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
                                let l:result = {
                                \   '_deferred_job_id': l:job_id,
                                \   'executable': get(l:options, 'executable', ''),
                                \   'cwd': l:cwd,
                                \   'command': a:command,
                                \}
                            
                                if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(
                                        \   g:ale_run_synchronously_callbacks,
                                        \   {exit_code, output -> [
                                        \       extend(l:line_list, output),
                                        \       l:job_options.exit_cb(l:job_id, exit_code),
                                        \   ]}
                                        \)
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(
                                        \   type(l:command) is v:t_list
                                        \       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])
                                        \       : l:command
                                        \))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')
                                        \&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(
                                        \   g:ale_run_synchronously_callbacks,
                                        \   {-> l:job_options.exit_cb(l:job_id, v:shell_error)}
                                        \)
                                    endif
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000001000 function! ale#command#IsDeferred(value) abort
                                return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/history.vim
Sourced 1 time
Total time:   0.000121000
 Self time:   0.000121000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Tools for managing command history
                            
                            " A flag for controlling the maximum size of the command history to store.
    1              0.000002000 let g:ale_max_buffer_history_size = get(g:, 'ale_max_buffer_history_size', 20)
                            
                            " Return a shallow copy of the command history for a given buffer number.
    1              0.000001000 function! ale#history#Get(buffer) abort
                                return copy(getbufvar(a:buffer, 'ale_history', []))
                            endfunction
                            
    1              0.000001000 function! ale#history#Add(buffer, status, job_id, command) abort
                                if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
                                let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
                                if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
                                call add(l:history, {
                                \   'status': a:status,
                                \   'job_id': a:job_id,
                                \   'command': a:command,
                                \})
                            
                                call setbufvar(a:buffer, 'ale_history', l:history)
                            endfunction
                            
    1              0.000001000 function! s:FindHistoryItem(buffer, job_id) abort
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
                                for l:obj in reverse(ale#history#Get(a:buffer))
                                    if l:obj.job_id == a:job_id
                                        return l:obj
                                    endif
                                endfor
                            
                                return {}
                            endfunction
                            
                            " Set an exit code for a command which finished.
    1              0.000001000 function! ale#history#SetExitCode(buffer, job_id, exit_code) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
                                let l:obj.exit_code = a:exit_code
                                let l:obj.status = 'finished'
                            endfunction
                            
                            " Set the output for a command which finished.
    1              0.000001000 function! ale#history#RememberOutput(buffer, job_id, output) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                let l:obj.output = a:output
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/job.vim
Sourced 1 time
Total time:   0.000228000
 Self time:   0.000228000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: APIs for working with Asynchronous jobs, with an API normalised
                            " between Vim 8 and NeoVim.
                            "
                            " Important functions are described below. They are:
                            "
                            "   ale#job#Start(command, options) -> job_id
                            "   ale#job#IsRunning(job_id) -> 1 if running, 0 otherwise.
                            "   ale#job#Stop(job_id)
                            
                            " A setting for wrapping commands.
    1              0.000002000 let g:ale_command_wrapper = get(g:, 'ale_command_wrapper', '')
                            
    1              0.000002000 if !has_key(s:, 'job_map')
    1              0.000001000     let s:job_map = {}
    1              0.000001000 endif
                            
                            " A map from timer IDs to jobs, for tracking jobs that need to be killed
                            " with SIGKILL if they don't terminate right away.
    1              0.000001000 if !has_key(s:, 'job_kill_timers')
    1              0.000001000     let s:job_kill_timers = {}
    1              0.000000000 endif
                            
    1              0.000001000 function! s:KillHandler(timer) abort
                                let l:job = remove(s:job_kill_timers, a:timer)
                                call job_stop(l:job, 'kill')
                            endfunction
                            
    1              0.000001000 function! s:NeoVimCallback(job, data, event) abort
                                let l:info = s:job_map[a:job]
                            
                                if a:event is# 'stdout'
                                    let l:info.out_cb_line = ale#util#JoinNeovimOutput(
                                    \   a:job,
                                    \   l:info.out_cb_line,
                                    \   a:data,
                                    \   l:info.mode,
                                    \   ale#util#GetFunction(l:info.out_cb),
                                    \)
                                elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(
                                    \   a:job,
                                    \   l:info.err_cb_line,
                                    \   a:data,
                                    \   l:info.mode,
                                    \   ale#util#GetFunction(l:info.err_cb),
                                    \)
                                else
                                    if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
                                    if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
                                    try
                                        call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, a:job)
                                            call remove(s:job_map, a:job)
                                        endif
                                    endtry
                                endif
                            endfunction
                            
    1              0.000001000 function! s:VimOutputCallback(channel, data) abort
                                let l:job = ch_getjob(a:channel)
                                let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
                                if l:job_id > 0 && has_key(s:job_map, l:job_id)
                                    call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:VimErrorCallback(channel, data) abort
                                let l:job = ch_getjob(a:channel)
                                let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
                                if l:job_id > 0 && has_key(s:job_map, l:job_id)
                                    call ale#util#GetFunction(s:job_map[l:job_id].err_cb)(l:job_id, a:data)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:VimCloseCallback(channel) abort
                                let l:job = ch_getjob(a:channel)
                                let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                                let l:info = get(s:job_map, l:job_id, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
                                if job_status(l:job) is# 'dead'
                                    try
                                        if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
                                        endif
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
                                        endif
                                    endtry
                                endif
                            endfunction
                            
    1              0.000000000 function! s:VimExitCallback(job, exit_code) abort
                                let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
                                let l:info = get(s:job_map, l:job_id, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
                                if ch_status(job_getchannel(a:job)) is# 'closed'
                                    try
                                        if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
                                        endif
                                    finally
                                        " Automatically forget about the job after it's done.
                                        if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
                                        endif
                                    endtry
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#job#ParseVim8ProcessID(job_string) abort
                                return matchstr(a:job_string, '\d\+') + 0
                            endfunction
                            
    1              0.000001000 function! ale#job#ValidateArguments(command, options) abort
                                if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif
                            endfunction
                            
    1              0.000001000 function! s:PrepareWrappedCommand(original_wrapper, command) abort
                                let l:match = matchlist(a:command, '\v^(.*(\&\&|;)) *(.*)$')
                                let l:prefix = ''
                                let l:command = a:command
                            
                                if !empty(l:match)
                                    let l:prefix = l:match[1] . ' '
                                    let l:command = l:match[3]
                                endif
                            
                                let l:format = a:original_wrapper
                            
                                if l:format =~# '%@'
                                    let l:wrapped = substitute(l:format, '%@', ale#Escape(l:command), '')
                                else
                                    if l:format !~# '%\*'
                                        let l:format .= ' %*'
                                    endif
                            
                                    let l:wrapped = substitute(l:format, '%\*', l:command, '')
                                endif
                            
                                return l:prefix . l:wrapped
                            endfunction
                            
    1              0.000001000 function! ale#job#PrepareCommand(buffer, command) abort
                                let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
                                let l:command = !empty(l:wrapper)
                                \ ? s:PrepareWrappedCommand(l:wrapper, a:command)
                                \ : a:command
                            
                                " If a custom shell is specified, use that.
                                if exists('b:ale_shell')
                                    let l:ale_shell = b:ale_shell
                                elseif exists('g:ale_shell')
                                    let l:ale_shell = g:ale_shell
                                endif
                            
                                if exists('l:ale_shell')
                                    let l:shell_arguments = get(b:, 'ale_shell_arguments', get(g:, 'ale_shell_arguments', &shellcmdflag))
                            
                                    return split(l:ale_shell) + split(l:shell_arguments) + [l:command]
                                endif
                            
                                if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
                                if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]
                            endfunction
                            
                            " Start a job with options which are agnostic to Vim and NeoVim.
                            "
                            " The following options are accepted:
                            "
                            " out_cb  - A callback for receiving stdin.  Arguments: (job_id, data)
                            " err_cb  - A callback for receiving stderr. Arguments: (job_id, data)
                            " exit_cb - A callback for program exit.     Arguments: (job_id, status_code)
                            " mode    - A mode for I/O. Can be 'nl' for split lines or 'raw'.
    1              0.000001000 function! ale#job#Start(command, options) abort
                                call ale#job#ValidateArguments(a:command, a:options)
                            
                                let l:job_info = copy(a:options)
                                let l:job_options = {}
                            
                                if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {
                                    \   'in_mode': l:job_info.mode,
                                    \   'out_mode': l:job_info.mode,
                                    \   'err_mode': l:job_info.mode,
                                    \}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    else
                                        " prevent buffering of output and excessive polling in case close_cb is set
                                        let l:job_options.out_cb = {->0}
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    else
                                        " prevent buffering of output and excessive polling in case close_cb is set
                                        let l:job_options.err_cb = {->0}
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
                                if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
                                    let s:job_map[l:job_id] = l:job_info
                                endif
                            
                                return l:job_id
                            endfunction
                            
                            " Force running commands in a Windows CMD command line.
                            " This means the same command syntax works everywhere.
    1              0.000001000 function! ale#job#StartWithCmd(command, options) abort
                                let l:shell = &l:shell
                                let l:shellcmdflag = &l:shellcmdflag
                                let &l:shell = 'cmd'
                                let &l:shellcmdflag = '/c'
                            
                                try
                                    let l:job_id = ale#job#Start(a:command, a:options)
                                finally
                                    let &l:shell = l:shell
                                    let &l:shellcmdflag = l:shellcmdflag
                                endtry
                            
                                return l:job_id
                            endfunction
                            
                            " Send raw data to the job.
    1              0.000001000 function! ale#job#SendRaw(job_id, string) abort
                                if has('nvim')
                                    call jobsend(a:job_id, a:string)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    if ch_status(l:job) is# 'open'
                                        call ch_sendraw(job_getchannel(l:job), a:string)
                                    endif
                                endif
                            endfunction
                            
                            " Given a job ID, return 1 if the job is currently running.
                            " Invalid job IDs will be ignored.
    1              0.000001000 function! ale#job#IsRunning(job_id) abort
                                if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                            
                                        return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                            
                                    return job_status(l:job) is# 'run'
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000001000 function! ale#job#HasOpenChannel(job_id) abort
                                if ale#job#IsRunning(a:job_id)
                                    if has('nvim')
                                        " TODO: Implement a check for NeoVim.
                                        return 1
                                    endif
                            
                                    " Check if the Job's channel can be written to.
                                    return ch_status(s:job_map[a:job_id].job) is# 'open'
                                endif
                            
                                return 0
                            endfunction
                            
                            " Given a Job ID, stop that job.
                            " Invalid job IDs will be ignored.
    1              0.000001000 function! ale#job#Stop(job_id) abort
                                if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
                                if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    silent! call jobstop(a:job_id)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim
Sourced 1 time
Total time:   0.000095000
 Self time:   0.000057000

count     total (s)      self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/utils.vim
                            " Description:   Utilities
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000001000 fu! ctrlp#utils#lash()
                            	retu &ssl || !exists('+ssl') ? '/' : '\'
                            endf
                            
    1              0.000001000 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#opts()
                            	let s:lash = ctrlp#utils#lash()
                            	let usrhome = $HOME . s:lash( $HOME )
                            	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
                            	let cadir = isdirectory(usrhome.'.ctrlp_cache')
                            		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
                            	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
                            	let s:cache_dir = cadir
                            endf
    1   0.000042000   0.000004000 cal ctrlp#utils#opts()
                            
    1              0.000003000 let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
                            " Files and Directories {{{1
    1              0.000001000 fu! ctrlp#utils#cachedir()
                            	retu s:cache_dir
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#cachefile(...)
                            	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
                            	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
                            	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
                            endf
                            
    1              0.000000000 fu! ctrlp#utils#readfile(file)
                            	if filereadable(a:file)
                            		let data = readfile(a:file)
                            		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
                            		retu data
                            	en
                            	retu []
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#mkdir(dir)
                            	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
                            	retu a:dir
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#writecache(lines, ...)
                            	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
                            		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
                            	en
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#glob(...)
                            	let path = ctrlp#utils#fnesc(a:1, 'g')
                            	retu s:wig_cond ? glob(path, a:2) : glob(path)
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#globpath(...)
                            	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
                            endf
                            
    1              0.000001000 fu! ctrlp#utils#fnesc(path, type, ...)
                            	if exists('*fnameescape')
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = fnameescape(a:path)
                            		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
                            	retu a:0 ? escape(path, a:1) : path
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim
Sourced 1 time
Total time:   0.000101000
 Self time:   0.000101000

count     total (s)      self (s)
                            " Primary functions {{{
                            
    1              0.000002000 function! gitgutter#all(force) abort
                              let visible = tabpagebuflist()
                            
                              for bufnr in range(1, bufnr('$') + 1)
                                if buflisted(bufnr)
                                  let file = expand('#'.bufnr.':p')
                                  if !empty(file)
                                    if index(visible, bufnr) != -1
                                      call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
                                    endif
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#process_buffer(bufnr, force) abort
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
                              if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
                                call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
                              endif
                            
                              if gitgutter#utility#is_active(a:bufnr)
                            
                                if has('patch-7.4.1559')
                                  let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
                                endif
                                let how = s:setup_path(a:bufnr, l:Callback)
                                if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter assume unchanged/
                                    call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#disable() abort
                              call s:toggle_each_buffer(0)
                              let g:gitgutter_enabled = 0
                            endfunction
                            
    1              0.000001000 function! gitgutter#enable() abort
                              call s:toggle_each_buffer(1)
                              let g:gitgutter_enabled = 1
                            endfunction
                            
    1              0.000001000 function s:toggle_each_buffer(enable)
                              for bufnr in range(1, bufnr('$') + 1)
                                if buflisted(bufnr)
                                  let file = expand('#'.bufnr.':p')
                                  if !empty(file)
                                    if a:enable
                                      call gitgutter#buffer_enable(bufnr)
                                    else
                                      call gitgutter#buffer_disable(bufnr)
                                    end
                                  endif
                                endif
                              endfor
                            endfunction
                            
    1              0.000001000 function! gitgutter#toggle() abort
                              if g:gitgutter_enabled
                                call gitgutter#disable()
                              else
                                call gitgutter#enable()
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#buffer_disable(...) abort
                              let bufnr = a:0 ? a:1 : bufnr('')
                              call gitgutter#utility#setbufvar(bufnr, 'enabled', 0)
                              call s:clear(bufnr)
                            endfunction
                            
    1              0.000001000 function! gitgutter#buffer_enable(...) abort
                              let bufnr = a:0 ? a:1 : bufnr('')
                              call gitgutter#utility#setbufvar(bufnr, 'enabled', 1)
                              call gitgutter#process_buffer(bufnr, 1)
                            endfunction
                            
    1              0.000000000 function! gitgutter#buffer_toggle(...) abort
                              let bufnr = a:0 ? a:1 : bufnr('')
                              if gitgutter#utility#getbufvar(bufnr, 'enabled', 1)
                                call gitgutter#buffer_disable(bufnr)
                              else
                                call gitgutter#buffer_enable(bufnr)
                              endif
                            endfunction
                            
                            " }}}
                            
    1              0.000000000 function! gitgutter#setup_maps()
                              if !g:gitgutter_map_keys
                                return
                              endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
                              let bufnr = bufnr('')
                            
                              if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
                                return
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
                              endif
                            
                              call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)
                            endfunction
                            
    1              0.000001000 function! s:setup_path(bufnr, continuation)
                              if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)
                            endfunction
                            
    1              0.000000000 function! s:has_fresh_changes(bufnr) abort
                              return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')
                            endfunction
                            
    1              0.000000000 function! s:reset_tick(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)
                            endfunction
                            
    1              0.000000000 function! s:clear(bufnr)
                              call gitgutter#sign#clear_signs(a:bufnr)
                              call gitgutter#hunk#reset(a:bufnr)
                              call s:reset_tick(a:bufnr)
                              call gitgutter#utility#setbufvar(a:bufnr, 'path', '')
                            endfunction
                            
                            
                            " Note:
                            " - this runs synchronously
                            " - it ignores unsaved changes in buffers
                            " - it does not change to the repo root
    1              0.000001000 function! gitgutter#quickfix(current_file)
                              let cmd = g:gitgutter_git_executable.' '.g:gitgutter_git_args.' rev-parse --show-cdup'
                              let path_to_repo = get(systemlist(cmd), 0, '')
                              if !empty(path_to_repo) && path_to_repo[-1:] != '/'
                                let path_to_repo .= '/'
                              endif
                            
                              let locations = []
                              let cmd = g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'.
                                    \ ' diff --no-ext-diff --no-color -U0'.
                                    \ ' --src-prefix=a/'.path_to_repo.' --dst-prefix=b/'.path_to_repo.' '.
                                    \ g:gitgutter_diff_args. ' '. g:gitgutter_diff_base
                              if a:current_file
                                let cmd = cmd.' -- '.expand('%:p')
                              endif
                              let diff = systemlist(cmd)
                              let lnum = 0
                              for line in diff
                                if line =~ '^diff --git [^"]'
                                  let paths = line[11:]
                                  let mid = (len(paths) - 1) / 2
                                  let [fnamel, fnamer] = [paths[:mid-1], paths[mid+1:]]
                                  let fname = fnamel ==# fnamer ? fnamel : fnamel[2:]
                                elseif line =~ '^diff --git "'
                                  let [_, fnamel, _, fnamer] = split(line, '"')
                                  let fname = fnamel ==# fnamer ? fnamel : fnamel[2:]
                                elseif line =~ '^diff --cc [^"]'
                                  let fname = line[10:]
                                elseif line =~ '^diff --cc "'
                                  let [_, fname] = split(line, '"')
                                elseif line =~ '^@@'
                                  let lnum = matchlist(line, '+\(\d\+\)')[1]
                                elseif lnum > 0
                                  call add(locations, {'filename': fname, 'lnum': lnum, 'text': line})
                                  let lnum = 0
                                endif
                              endfor
                              if !g:gitgutter_use_location_list
                                call setqflist(locations)
                              else
                                call setloclist(0, locations)
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#difforig()
                              let bufnr = bufnr('')
                              let path = gitgutter#utility#repo_path(bufnr, 1)
                              let filetype = &filetype
                            
                              vertical new
                              set buftype=nofile
                              let &filetype = filetype
                            
                              if g:gitgutter_diff_relative_to ==# 'index'
                                let index_name = gitgutter#utility#get_diff_base(bufnr).':'.path
                                let cmd = gitgutter#utility#cd_cmd(bufnr,
                                      \ g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name
                                      \ )
                                " NOTE: this uses &shell to execute cmd.  Perhaps we should use instead
                                " gitgutter#utility's use_known_shell() / restore_shell() functions.
                                silent! execute "read ++edit !" cmd
                              else
                                silent! execute "read ++edit" path
                              endif
                            
                              0d_
                              diffthis
                              wincmd p
                              diffthis
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/cursor.vim
Sourced 1 time
Total time:   0.000200000
 Self time:   0.000200000

count     total (s)      self (s)
    1              0.000002000 scriptencoding utf-8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Author: João Paulo S. de Souza <joao.paulo.silvasouza@hotmail.com>
                            " Description: Echoes lint message for the current line, if any
                            
                            " Controls the milliseconds delay before echoing a message.
    1              0.000004000 let g:ale_echo_delay = get(g:, 'ale_echo_delay', 10)
                            " A string format for the echoed message.
    1              0.000002000 let g:ale_echo_msg_format = get(g:, 'ale_echo_msg_format', '%code: %%s')
                            
    1              0.000001000 let s:cursor_timer = -1
                            
                            " A wrapper for echon so we can test messages we echo in Vader tests.
    1              0.000001000 function! ale#cursor#Echom(message) abort
                                if mode() is# 'n'
                                    " no-custom-checks
                                    exec "norm! :echom a:message\n"
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#cursor#TruncatedEcho(original_message) abort
                                let l:message = a:original_message
                                " Change tabs to spaces.
                                let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
                                let l:message = substitute(l:message, "\n", ' ', 'g')
                                " Convert indentation groups into single spaces for better legibility when
                                " put on a single line
                                let l:message = substitute(l:message, ' \+', ' ', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
                                let l:shortmess_options = &l:shortmess
                            
                                try
                                    let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
                                    silent! setlocal shortmess+=T
                            
                                    try
                                        call ale#cursor#Echom(l:message)
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
                                    if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
                                    endif
                                finally
                                    let &l:shortmess = l:shortmess_options
                                endtry
                            endfunction
                            
    1              0.000001000 function! s:StopCursorTimer() abort
                                if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#cursor#EchoCursorWarning(...) abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if g:ale_echo_cursor
                                    if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                            
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        "
                                        " no-custom-checks
                                        echo
                                        let l:info.echoed = 0
                                    endif
                                endif
                            
                                if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#cursor#EchoCursorWarningWithDelay() abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let l:pos = getpos('.')[0:2]
                            
                                if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
                                endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
                                if l:pos != w:last_pos
                                    let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
                                    let w:last_pos = l:pos
                                    let s:cursor_timer = timer_start(
                                    \   l:delay,
                                    \   function('ale#cursor#EchoCursorWarning')
                                    \)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:ShowCursorDetailForItem(loc, options) abort
                                let l:stay_here = get(a:options, 'stay_here', 0)
                            
                                let s:last_detailed_line = line('.')
                                let l:message = get(a:loc, 'detail', a:loc.text)
                                let l:lines = split(l:message, "\n")
                            
                                if g:ale_floating_preview || g:ale_detail_to_floating_preview
                                    call ale#floating_preview#Show(l:lines)
                                else
                                    call ale#preview#Show(l:lines, {'stay_here': l:stay_here})
                            
                                    " Clear the echo message if we manually displayed details.
                                    if !l:stay_here
                                        " no-custom-checks
                                        echo
                                    endif
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#cursor#ShowCursorDetail() abort
                                let l:buffer = bufnr('')
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode() isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if !empty(l:loc)
                                    call s:ShowCursorDetailForItem(l:loc, {'stay_here': 0})
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000260000
 Self time:   0.000260000

count     total (s)      self (s)
    1              0.000023000 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7.4.1826') && !has('gui_running')) ||
                                  \     (has('patch-7.4.1850') &&  has('gui_running')) ||
                                  \     (has('patch-7.4.1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000002000 let s:jobs = {}
                            
    1              0.000001000 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000002000 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                let job = job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                                let s:jobs[s:job_id(job)] = 1
                              endif
                            endfunction
                            
                            
    1              0.000002000 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000002000 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000001000 function! s:on_stderr_nvim(_job_id, data, _event) dict abort
                              if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif
                            endfunction
                            
    1              0.000001000 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000001000 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000001000 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              let jobid = s:job_id(job)
                              if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile
                            
                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
    1              0.000001000 function! s:job_id(job)
                              " Vim
                              return job_info(a:job).process
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000094000
 Self time:   0.000094000

count     total (s)      self (s)
    1              0.000006000 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000002000 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000002000 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000001000 let s:new_log_session = 1
                            
                            
    1              0.000001000 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                            endfunction
                            
                            
    1              0.000001000 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000001000 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000001000 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000001000 function! s:grep_version()
                              let v = system(g:gitgutter_grep.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system(g:gitgutter_grep.' --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000001000 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000000000 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000001000 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000001000 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.064452000
 Self time:   0.000409000

count     total (s)      self (s)
    1              0.000003000 scriptencoding utf8
                            
    1              0.000005000 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000001000 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
                            " True for git v1.7.2+.
    1              0.000002000 function! s:git_supports_command_line_config_override() abort
                              call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
                              return !v:shell_error
                            endfunction
                            
    1   0.064055000   0.000012000 let s:c_flag = s:git_supports_command_line_config_override()
                            
    1              0.000005000 let s:temp_from = tempname()
    1              0.000002000 let s:temp_buffer = tempname()
    1              0.000002000 let s:counter = 0
                            
                            " Returns a diff of the buffer against the index or the working tree.
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
                            "
                            " When diffing against the index:
                            "
                            " The buffer contents is not the same as the file on disk so we need to pass
                            " two instances of the file to git-diff:
                            "
                            "     git diff myfileA myfileB
                            "
                            " where myfileA comes from
                            "
                            "     git show :myfile > myfileA
                            "
                            " and myfileB is the buffer contents.
                            "
                            " Regarding line endings:
                            "
                            " git-show does not convert line endings.
                            " git-diff FILE FILE does convert line endings for the given files.
                            "
                            " If a file has CRLF line endings and git's core.autocrlf is true,
                            " the file in git's object store will have LF line endings.  Writing
                            " it out via git-show will produce a file with LF line endings.
                            "
                            " If this last file is one of the files passed to git-diff, git-diff will
                            " convert its line endings to CRLF before diffing -- which is what we want --
                            " but also by default output a warning on stderr.
                            "
                            "   warning: LF will be replace by CRLF in <temp file>.
                            "   The file will have its original line endings in your working directory.
                            "
                            " When running the diff asynchronously, the warning message triggers the stderr
                            " callbacks which assume the overall command has failed and reset all the
                            " signs.  As this is not what we want, and we can safely ignore the warning,
                            " we turn it off by passing the '-c "core.safecrlf=false"' argument to
                            " git-diff.
                            "
                            " When writing the temporary files we preserve the original file's extension
                            " so that repos using .gitattributes to control EOL conversion continue to
                            " convert correctly.
                            "
                            " Arguments:
                            "
                            " bufnr              - the number of the buffer to be diffed
                            " from               - 'index' or 'working_tree'; what the buffer is diffed against
                            " preserve_full_diff - truthy to return the full diff or falsey to return only
                            "                      the hunk headers (@@ -x,y +m,n @@); only possible if
                            "                      grep is available.
    1              0.000002000 function! gitgutter#diff#run_diff(bufnr, from, preserve_full_diff) abort
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
                              endif
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -3
                                throw 'gitgutter assume unchanged'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
                              let s:counter = (s:counter + 1) % 20
                              let buff_file .= '.'.s:counter
                            
                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)
                            
                              if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
                                let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                let from_file .= '.'.s:counter
                            
                                if !empty(extension)
                                  let from_file .= '.'.extension
                                endif
                            
                                " Write file from index to temporary file.
                                let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
                                let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
                              let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'
                            
                              let cmd .= ')'
                            
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {
                                      \   'out': function('gitgutter#diff#handler'),
                                      \   'err': function('gitgutter#hunk#reset'),
                                      \ })
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#diff#handler(bufnr, diff) abort
                              call gitgutter#debug#log(a:diff)
                            
                              if !bufexists(a:bufnr)
                                return
                              endif
                            
                              call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
                              let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
                              let signs_count = len(modified_lines)
                              if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf(
                                      \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
                                      \ signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
                                if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
                                  call gitgutter#sign#update_signs(a:bufnr, modified_lines)
                                endif
                              endif
                            
                              call s:save_last_seen_change(a:bufnr)
                              if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000001000 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
                            " This function is public so it may be used by other plugins
                            " e.g. vim-signature.
    1              0.000001000 function! gitgutter#diff#process_hunks(bufnr, hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000001000 function! s:process_hunk(bufnr, hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000001000 function! s:is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000001000 function! s:is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000001000 function! s:is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000001000 function! s:is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000001000 function! s:is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000002000 function! s:process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000002000 function! s:process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000001000 function! s:process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000002000 function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000002000 function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            
                            " Returns a diff for the current hunk.
                            " Assumes there is only 1 current hunk unless the optional argument is given,
                            " in which case the cursor is in two hunks and the argument specifies the one
                            " to choose.
                            "
                            " Optional argument: 0 (to use the first hunk) or 1 (to use the second).
    1              0.000001000 function! gitgutter#diff#hunk_diff(bufnr, full_diff, ...)
                              let modified_diff = []
                              let hunk_index = 0
                              let keep_line = 1
                              " Don't keepempty when splitting because the diff we want may not be the
                              " final one.  Instead add trailing NL at end of function.
                              for line in split(a:full_diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                            
                                  if a:0 && hunk_index != a:1
                                    let keep_line = 0
                                  endif
                            
                                  let hunk_index += 1
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                              return join(modified_diff, "\n")."\n"
                            endfunction
                            
                            
    1              0.000001000 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
                              if getbufvar(a:bufnr, '&endofline')
                                call add(bufcontents, '')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
                              try
                                call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
                              endtry
                            endfunction
                            
                            
    1              0.000001000 function! s:save_last_seen_change(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim
Sourced 1 time
Total time:   0.000529000
 Self time:   0.000529000

count     total (s)      self (s)
    1              0.000007000 let s:winid = 0
    1              0.000001000 let s:preview_bufnr = 0
    1              0.000006000 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000002000 function! gitgutter#hunk#set_hunks(bufnr, hunks) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
    1              0.000002000 function! gitgutter#hunk#hunks(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])
                            endfunction
                            
    1              0.000001000 function! gitgutter#hunk#reset(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#hunk#summary(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000001000 function! s:reset_summary(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000001000 function! gitgutter#hunk#increment_lines_added(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[0] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000002000 function! gitgutter#hunk#increment_lines_modified(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[1] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000001000 function! gitgutter#hunk#increment_lines_removed(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[2] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#hunk#next_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in hunks
                                if hunk[2] > current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    execute 'normal!' hunk[2] . 'Gzv'
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    if gitgutter#hunk#is_preview_window_open()
                                      call gitgutter#hunk#preview()
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No more hunks')
                            endfunction
                            
    1              0.000001000 function! gitgutter#hunk#prev_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in reverse(copy(hunks))
                                if hunk[2] < current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    let target = hunk[2] == 0 ? 1 : hunk[2]
                                    execute 'normal!' target . 'Gzv'
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    if gitgutter#hunk#is_preview_window_open()
                                      call gitgutter#hunk#preview()
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No previous hunks')
                            endfunction
                            
                            " Returns the hunk the cursor is currently in or an empty list if the cursor
                            " isn't in a hunk.
    1              0.000001000 function! s:current_hunk() abort
                              let bufnr = bufnr('')
                              let current_hunk = []
                            
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  let current_hunk = hunk
                                  break
                                endif
                              endfor
                            
                              return current_hunk
                            endfunction
                            
                            " Returns truthy if the cursor is in two hunks (which can only happen if the
                            " cursor is on the first line and lines above have been deleted and lines
                            " immediately below have been deleted) or falsey otherwise.
    1              0.000001000 function! s:cursor_in_two_hunks()
                              let hunks = gitgutter#hunk#hunks(bufnr(''))
                            
                              if line('.') == 1 && len(hunks) > 1 && hunks[0][2:3] == [0, 0] && hunks[1][2:3] == [1, 0]
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " A line can be in 0 or 1 hunks, with the following exception: when the first
                            " line(s) of a file has been deleted, and the new second line (and
                            " optionally below) has been deleted, the new first line is in two hunks.
    1              0.000001000 function! gitgutter#hunk#cursor_in_hunk(hunk) abort
                              let current_line = line('.')
                            
                              if current_line == 1 && a:hunk[2] == 0
                                return 1
                              endif
                            
                              if current_line >= a:hunk[2] && current_line < a:hunk[2] + (a:hunk[3] == 0 ? 1 : a:hunk[3])
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#hunk#in_hunk(lnum)
                              " Hunks are sorted in the order they appear in the buffer.
                              for hunk in gitgutter#hunk#hunks(bufnr(''))
                                " if in a hunk on first line of buffer
                                if a:lnum == 1 && hunk[2] == 0
                                  return 1
                                endif
                            
                                " if in a hunk generally
                                if a:lnum >= hunk[2] && a:lnum < hunk[2] + (hunk[3] == 0 ? 1 : hunk[3])
                                  return 1
                                endif
                            
                                " if hunk starts after the given line
                                if a:lnum < hunk[2]
                                  return 0
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#hunk#text_object(inner) abort
                              let hunk = s:current_hunk()
                            
                              if empty(hunk)
                                return
                              endif
                            
                              let [first_line, last_line] = [hunk[2], hunk[2] + hunk[3] - 1]
                            
                              if ! a:inner
                                let lnum = last_line
                                let eof = line('$')
                                while lnum < eof && empty(getline(lnum + 1))
                                  let lnum +=1
                                endwhile
                                let last_line = lnum
                              endif
                            
                              execute 'normal! 'first_line.'GV'.last_line.'G'
                            endfunction
                            
                            
    1              0.000000000 function! gitgutter#hunk#stage(...) abort
                              if !s:in_hunk_preview_window() && !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              if a:0 && (a:1 != 1 || a:2 != line('$'))
                                call s:hunk_op(function('s:stage'), a:1, a:2)
                              else
                                call s:hunk_op(function('s:stage'))
                              endif
                              silent! call repeat#set("\<Plug>(GitGutterStageHunk)", -1)
                            endfunction
                            
    1              0.000000000 function! gitgutter#hunk#undo() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:undo'))
                              silent! call repeat#set("\<Plug>(GitGutterUndoHunk)", -1)
                            endfunction
                            
    1              0.000001000 function! gitgutter#hunk#preview() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:preview'))
                              silent! call repeat#set("\<Plug>(GitGutterPreviewHunk)", -1)
                            endfunction
                            
                            
    1              0.000001000 function! s:hunk_op(op, ...)
                              let bufnr = bufnr('')
                            
                              if s:in_hunk_preview_window()
                                if string(a:op) =~ '_stage'
                                  " combine hunk-body in preview window with updated hunk-header
                                  let hunk_body = getline(1, '$')
                            
                                  let [removed, added] = [0, 0]
                                  for line in hunk_body
                                    if line[0] == '-'
                                      let removed += 1
                                    elseif line[0] == '+'
                                      let added += 1
                                    endif
                                  endfor
                            
                                  let hunk_header = b:hunk_header
                                  " from count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(-\d\+\)\(,\d\+\)\?', '\=submatch(1).",".removed', '')
                                  " to count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".added', '')
                            
                                  let hunk_diff = join(hunk_header + hunk_body, "\n")."\n"
                            
                                  call s:goto_original_window()
                                  call gitgutter#hunk#close_hunk_preview_window()
                                  call s:stage(hunk_diff)
                                endif
                            
                                return
                              endif
                            
                              if gitgutter#utility#is_active(bufnr)
                                " Get a (synchronous) diff.
                                let [async, g:gitgutter_async] = [g:gitgutter_async, 0]
                                let diff = gitgutter#diff#run_diff(bufnr, g:gitgutter_diff_relative_to, 1)
                                let g:gitgutter_async = async
                            
                                call gitgutter#hunk#set_hunks(bufnr, gitgutter#diff#parse_diff(diff))
                                call gitgutter#diff#process_hunks(bufnr, gitgutter#hunk#hunks(bufnr))  " so the hunk summary is updated
                            
                                if empty(s:current_hunk())
                                  call gitgutter#utility#warn('Cursor is not in a hunk')
                                elseif s:cursor_in_two_hunks()
                                  let choice = input('Choose hunk: upper or lower (u/l)? ')
                                  " Clear input
                                  normal! :<ESC>
                                  if choice =~ 'u'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 0))
                                  elseif choice =~ 'l'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 1))
                                  else
                                    call gitgutter#utility#warn('Did not recognise your choice')
                                  endif
                                else
                                  let hunk_diff = gitgutter#diff#hunk_diff(bufnr, diff)
                            
                                  if a:0
                                    let hunk_first_line = s:current_hunk()[2]
                                    let hunk_diff = s:part_of_diff(hunk_diff, a:1-hunk_first_line, a:2-hunk_first_line)
                                  endif
                            
                                  call a:op(hunk_diff)
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! s:stage(hunk_diff)
                              let bufnr = bufnr('')
                              let diff = s:adjust_header(bufnr, a:hunk_diff)
                              " Apply patch to index.
                              call gitgutter#utility#system(
                                    \ gitgutter#utility#cd_cmd(bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' apply --cached --unidiff-zero - '),
                                    \ diff)
                              if v:shell_error
                                call gitgutter#utility#warn('Patch does not apply')
                              else
                                if exists('#User#GitGutterStage')
                                  execute 'doautocmd' s:nomodeline 'User GitGutterStage'
                                endif
                              endif
                            
                              " Refresh gitgutter's view of buffer.
                              call gitgutter#process_buffer(bufnr, 1)
                            endfunction
                            
                            
    1              0.000000000 function! s:undo(hunk_diff)
                              " Apply reverse patch to buffer.
                              let hunk  = gitgutter#diff#parse_hunk(split(a:hunk_diff, '\n')[4])
                              let lines = map(split(a:hunk_diff, '\r\?\n')[5:], 'v:val[1:]')
                              let lnum  = hunk[2]
                              let added_only   = hunk[1] == 0 && hunk[3]  > 0
                              let removed_only = hunk[1]  > 0 && hunk[3] == 0
                            
                              if removed_only
                                call append(lnum, lines)
                              elseif added_only
                                execute lnum .','. (lnum+len(lines)-1) .'d _'
                              else
                                call append(lnum-1, lines[0:hunk[1]])
                                execute (lnum+hunk[1]) .','. (lnum+hunk[1]+hunk[3]) .'d _'
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! s:preview(hunk_diff)
                              let lines = split(a:hunk_diff, '\r\?\n')
                              let header = lines[0:4]
                              let body = lines[5:]
                            
                              call s:open_hunk_preview_window()
                              call s:populate_hunk_preview_window(header, body)
                              call s:enable_staging_from_hunk_preview_window()
                              if &previewwindow
                                call s:goto_original_window()
                              endif
                            endfunction
                            
                            
                            " Returns a new hunk diff using the specified lines from the given one.
                            " Assumes all lines are additions.
                            " a:first, a:last - 0-based indexes into the body of the hunk.
    1              0.000001000 function! s:part_of_diff(hunk_diff, first, last)
                              let diff_lines = split(a:hunk_diff, '\n', 1)
                            
                              " adjust 'to' line count in header
                              let diff_lines[4] = substitute(diff_lines[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".(a:last-a:first+1)', '')
                            
                              return join(diff_lines[0:4] + diff_lines[5+a:first:5+a:last], "\n")."\n"
                            endfunction
                            
                            
    1              0.000001000 function! s:adjust_header(bufnr, hunk_diff)
                              let filepath = gitgutter#utility#repo_path(a:bufnr, 0)
                              return s:adjust_hunk_summary(s:fix_file_references(filepath, a:hunk_diff))
                            endfunction
                            
                            
                            " Replaces references to temp files with the actual file.
    1              0.000001000 function! s:fix_file_references(filepath, hunk_diff)
                              let lines = split(a:hunk_diff, '\n')
                            
                              let left_prefix  = matchstr(lines[2], '[abciow12]').'/'
                              let right_prefix = matchstr(lines[3], '[abciow12]').'/'
                              let quote        = lines[0][11] == '"' ? '"' : ''
                            
                              let left_file  = quote.left_prefix.a:filepath.quote
                              let right_file = quote.right_prefix.a:filepath.quote
                            
                              let lines[0] = 'diff --git '.left_file.' '.right_file
                              let lines[2] = '--- '.left_file
                              let lines[3] = '+++ '.right_file
                            
                              return join(lines, "\n")."\n"
                            endfunction
                            
                            
    1              0.000001000 function! s:adjust_hunk_summary(hunk_diff) abort
                              let line_adjustment = s:line_adjustment_for_current_hunk()
                              let diff = split(a:hunk_diff, '\n', 1)
                              let diff[4] = substitute(diff[4], '+\zs\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                              return join(diff, "\n")
                            endfunction
                            
                            
                            " Returns the number of lines the current hunk is offset from where it would
                            " be if any changes above it in the file didn't exist.
    1              0.000001000 function! s:line_adjustment_for_current_hunk() abort
                              let bufnr = bufnr('')
                              let adj = 0
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  break
                                else
                                  let adj += hunk[1] - hunk[3]
                                endif
                              endfor
                              return adj
                            endfunction
                            
                            
    1              0.000001000 function! s:in_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                return win_id2win(s:winid) == winnr()
                              else
                                return &previewwindow
                              endif
                            endfunction
                            
                            
                            " Floating window: does not move cursor to floating window.
                            " Preview window: moves cursor to preview window.
    1              0.000001000 function! s:open_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  call gitgutter#hunk#close_hunk_preview_window()
                            
                                  let buf = nvim_create_buf(v:false, v:false)
                                  " Set default width and height for now.
                                  let s:winid = nvim_open_win(buf, v:false, g:gitgutter_floating_window_options)
                                  call nvim_buf_set_option(buf, 'filetype',  'diff')
                                  call nvim_buf_set_option(buf, 'buftype',   'acwrite')
                                  call nvim_buf_set_option(buf, 'bufhidden', 'delete')
                                  call nvim_buf_set_option(buf, 'swapfile',  v:false)
                                  call nvim_buf_set_name(buf, 'gitgutter://hunk-preview')
                            
                                  " Assumes cursor is in original window.
                                  autocmd CursorMoved <buffer> ++once call gitgutter#hunk#close_hunk_preview_window()
                            
                                  if g:gitgutter_close_preview_on_escape
                                    " Map <Esc> to close the floating preview.
                                    nnoremap <buffer> <silent> <Esc> :<C-U>call gitgutter#hunk#close_hunk_preview_window()<CR>
                                    " Ensure that when the preview window is closed, the map is removed.
                                    autocmd User GitGutterPreviewClosed silent! nunmap <buffer> <Esc>
                                    autocmd CursorMoved <buffer> ++once silent! nunmap <buffer> <Esc>
                                    execute "autocmd WinClosed <buffer=".winbufnr(s:winid)."> doautocmd" s:nomodeline "User GitGutterPreviewClosed"
                                  endif
                            
                                  return
                                endif
                            
                                if exists('*popup_create')
                                  if g:gitgutter_close_preview_on_escape
                                    let g:gitgutter_floating_window_options.filter = function('s:close_popup_on_escape')
                                  endif
                            
                                  let s:winid = popup_create('', g:gitgutter_floating_window_options)
                            
                                  call setbufvar(winbufnr(s:winid), '&filetype', 'diff')
                            
                                  return
                                endif
                              endif
                            
                              if exists('&previewpopup')
                                let [previewpopup, &previewpopup] = [&previewpopup, '']
                              endif
                            
                              " Specifying where to open the preview window can lead to the cursor going
                              " to an unexpected window when the preview window is closed (#769).
                              silent! noautocmd execute g:gitgutter_preview_win_location 'pedit gitgutter://hunk-preview'
                              silent! wincmd P
                              setlocal statusline=%{''}
                              doautocmd WinEnter
                              if exists('*win_getid')
                                let s:winid = win_getid()
                              else
                                let s:preview_bufnr = bufnr('')
                              endif
                              setlocal filetype=diff buftype=acwrite bufhidden=delete
                              " Reset some defaults in case someone else has changed them.
                              setlocal noreadonly modifiable noswapfile
                              if g:gitgutter_close_preview_on_escape
                                " Ensure cursor goes to the expected window.
                                nnoremap <buffer> <silent> <Esc> :<C-U>wincmd p<Bar>pclose<CR>
                              endif
                            
                              if exists('&previewpopup')
                                let &previewpopup=previewpopup
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! s:close_popup_on_escape(winid, key)
                              if a:key == "\<Esc>"
                                call popup_close(a:winid)
                                return 1
                              endif
                              return 0
                            endfunction
                            
                            
                            " Floating window: does not care where cursor is.
                            " Preview window: assumes cursor is in preview window.
    1              0.000001000 function! s:populate_hunk_preview_window(header, body)
                              let body_length = len(a:body)
                            
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  let height = min([body_length, g:gitgutter_floating_window_options.height])
                            
                                  " Assumes cursor is not in previewing window.
                                  call nvim_buf_set_var(winbufnr(s:winid), 'hunk_header', a:header)
                            
                                  let [_scrolloff, &scrolloff] = [&scrolloff, 0]
                            
                                  let width = max(map(copy(a:body), 'strdisplaywidth(v:val)'))
                                  call nvim_win_set_width(s:winid, width)
                                  call nvim_win_set_height(s:winid, height)
                            
                                  let &scrolloff=_scrolloff
                            
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, [])
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, a:body)
                                  call nvim_buf_set_option(winbufnr(s:winid), 'modified', v:false)
                            
                                  let ns_id = nvim_create_namespace('GitGutter')
                                  call nvim_buf_clear_namespace(winbufnr(s:winid), ns_id, 0, -1)
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call nvim_buf_add_highlight(winbufnr(s:winid), ns_id, group, region[0]-1, region[2]-1, region[3])
                                  endfor
                            
                                  call nvim_win_set_cursor(s:winid, [1,0])
                                endif
                            
                                if exists('*popup_create')
                                  call popup_settext(s:winid, a:body)
                            
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call win_execute(s:winid, "call matchaddpos('".group."', [[".region[0].", ".region[2].", ".(region[3]-region[2]+1)."]])")
                                  endfor
                                endif
                            
                              else
                                let b:hunk_header = a:header
                            
                                %delete _
                                call setline(1, a:body)
                                setlocal nomodified
                            
                                normal! G$
                                let hunk_height = max([body_length, winline()])
                                let height = min([hunk_height, &previewheight])
                                execute 'resize' height
                                1
                            
                                call clearmatches()
                                for region in gitgutter#diff_highlight#process(a:body)
                                  let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                  call matchaddpos(group, [[region[0], region[2], region[3]-region[2]+1]])
                                endfor
                            
                                1
                              endif
                            endfunction
                            
                            
    1              0.000002000 function! s:enable_staging_from_hunk_preview_window()
                              augroup gitgutter_hunk_preview
                                autocmd!
                                let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                                execute 'autocmd BufWriteCmd <buffer='.bufnr.'> GitGutterStageHunk'
                              augroup END
                            endfunction
                            
                            
    1              0.000001000 function! s:goto_original_window()
                              noautocmd wincmd p
                              doautocmd WinEnter
                            endfunction
                            
                            
    1              0.000001000 function! gitgutter#hunk#close_hunk_preview_window()
                              let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                              call setbufvar(bufnr, '&modified', 0)
                            
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                pclose
                              endif
                            
                              let s:winid = 0
                              let s:preview_bufnr = 0
                            endfunction
                            
                            
    1              0.000001000 function gitgutter#hunk#is_preview_window_open()
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                for i in range(1, winnr('$'))
                                  if getwinvar(i, '&previewwindow')
                                    return 1
                                  endif
                                endfor
                              endif
                              return 0
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000223000
 Self time:   0.000223000

count     total (s)      self (s)
                            " For older Vims without sign_place() the plugin has to manaage the sign ids.
    1              0.000002000 let s:first_sign_id = 3000
    1              0.000002000 let s:next_sign_id  = s:first_sign_id
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000003000 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
    1              0.000001000 function! gitgutter#sign#enable() abort
                              let old_signs = g:gitgutter_signs
                            
                              let g:gitgutter_signs = 1
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !old_signs && !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#all(1)
                              endif
                            endfunction
                            
    1              0.000000000 function! gitgutter#sign#disable() abort
                              let g:gitgutter_signs = 0
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#sign#clear_signs(bufnr(''))
                              endif
                            endfunction
                            
    1              0.000001000 function! gitgutter#sign#toggle() abort
                              if g:gitgutter_signs
                                call gitgutter#sign#disable()
                              else
                                call gitgutter#sign#enable()
                              endif
                            endfunction
                            
                            
                            " Removes gitgutter's signs from the buffer being processed.
    1              0.000000000 function! gitgutter#sign#clear_signs(bufnr) abort
                              if exists('*sign_unplace')
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                                return
                              endif
                            
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000001000 function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
                              if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
                                let modified_lines = s:handle_double_hunk(a:modified_lines)
                                let signs = map(copy(modified_lines), '{'.
                                      \ '"buffer":   a:bufnr,'.
                                      \ '"group":    "gitgutter",'.
                                      \ '"name":     s:highlight_name_for_change(v:val[1]),'.
                                      \ '"lnum":     v:val[0],'.
                                      \ '"priority": g:gitgutter_sign_priority'.
                                      \ '}')
                            
                                if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000001000 function! s:find_current_signs(bufnr) abort
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = []      " [<line_number (number),...]
                              endif
                            
                              if exists('*getbufinfo')
                                let bufinfo = getbufinfo(a:bufnr)[0]
                                let signs = has_key(bufinfo, 'signs') ? bufinfo.signs : []
                              else
                                let signs = []
                            
                                redir => signlines
                                  silent execute "sign place buffer=" . a:bufnr
                                redir END
                            
                                for signline in filter(split(signlines, '\n')[2:], 'v:val =~# "="')
                                  " Typical sign line before v8.1.0614:  line=88 id=1234 name=GitGutterLineAdded
                                  " We assume splitting is faster than a regexp.
                                  let components = split(signline)
                                  call add(signs, {
                                        \ 'lnum': str2nr(split(components[0], '=')[1]),
                                        \ 'id':   str2nr(split(components[1], '=')[1]),
                                        \ 'name':        split(components[2], '=')[1]
                                        \ })
                                endfor
                              endif
                            
                              for sign in signs
                                if sign.name =~# 'GitGutter'
                                  " Remove orphaned signs (signs placed on lines which have been deleted).
                                  " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                  " line numbers are decremented appropriately.)
                                  if has_key(gitgutter_signs, sign.lnum)
                                    execute "sign unplace" gitgutter_signs[sign.lnum].id
                                  endif
                                  let gitgutter_signs[sign.lnum] = {'id': sign.id, 'name': sign.name}
                                else
                                  if !g:gitgutter_sign_allow_clobber
                                    call add(other_signs, sign.lnum)
                                  endif
                                endif
                              endfor
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
                              if !g:gitgutter_sign_allow_clobber
                                call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
                              endif
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000001000 function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000001000 function! s:remove_signs(bufnr, sign_ids, all_signs) abort
                              if a:all_signs && s:supports_star && (g:gitgutter_sign_allow_clobber || empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs')))
                                execute "sign unplace * buffer=" . a:bufnr
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000001000 function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
                              endif
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              let modified_lines = s:handle_double_hunk(a:modified_lines)
                            
                              for line in modified_lines
                                let line_number = line[0]  " <number>
                                if g:gitgutter_sign_allow_clobber || index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
                            " Handle special case where the first line is the site of two hunks:
                            " lines deleted above at the start of the file, and lines deleted
                            " immediately below.
    1              0.000001000 function! s:handle_double_hunk(modified_lines)
                              if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              endif
                            
                              return a:modified_lines
                            endfunction
                            
                            
    1              0.000000000 function! s:next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000001000 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction
                            
                            
    1              0.000001000 function! s:highlight_name_for_change(text) abort
                              if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif
                            endfunction
                            
                            

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/sign.vim
Sourced 1 time
Total time:   0.000463000
 Self time:   0.000379000

count     total (s)      self (s)
    1              0.000002000 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Draws error and warning signs into signcolumn
                            
                            " This flag can be set to some integer to control the maximum number of signs
                            " that ALE will set.
    1              0.000005000 let g:ale_max_signs = get(g:, 'ale_max_signs', -1)
                            " This flag can be set to 1 to enable changing the sign column colors when
                            " there are errors.
    1              0.000002000 let g:ale_change_sign_column_color = get(g:, 'ale_change_sign_column_color', v:false)
                            " These variables dictate what signs are used to indicate errors and warnings.
    1              0.000002000 let g:ale_sign_error = get(g:, 'ale_sign_error', 'E')
    1              0.000002000 let g:ale_sign_style_error = get(g:, 'ale_sign_style_error', g:ale_sign_error)
    1              0.000002000 let g:ale_sign_warning = get(g:, 'ale_sign_warning', 'W')
    1              0.000001000 let g:ale_sign_style_warning = get(g:, 'ale_sign_style_warning', g:ale_sign_warning)
    1              0.000002000 let g:ale_sign_info = get(g:, 'ale_sign_info', 'I')
    1              0.000002000 let g:ale_sign_priority = get(g:, 'ale_sign_priority', 30)
                            " This variable sets an offset which can be set for sign IDs.
                            " This ID can be changed depending on what IDs are set for other plugins.
                            " The dummy sign will use the ID exactly equal to the offset.
    1              0.000002000 let g:ale_sign_offset = get(g:, 'ale_sign_offset', 1000000)
                            " This flag can be set to 1 to keep sign gutter always open
    1              0.000002000 let g:ale_sign_column_always = get(g:, 'ale_sign_column_always', v:false)
    1              0.000002000 let g:ale_sign_highlight_linenrs = get(g:, 'ale_sign_highlight_linenrs', v:false)
                            
    1              0.000005000 let s:supports_sign_groups = has('nvim-0.4.2') || has('patch-8.1.614')
                            
    1              0.000009000 if !hlexists('ALEErrorSign')
    1              0.000006000     highlight link ALEErrorSign error
    1              0.000000000 endif
                            
    1              0.000002000 if !hlexists('ALEStyleErrorSign')
    1              0.000001000     highlight link ALEStyleErrorSign ALEErrorSign
    1              0.000001000 endif
                            
    1              0.000001000 if !hlexists('ALEWarningSign')
    1              0.000001000     highlight link ALEWarningSign todo
    1              0.000001000 endif
                            
    1              0.000002000 if !hlexists('ALEStyleWarningSign')
    1              0.000001000     highlight link ALEStyleWarningSign ALEWarningSign
    1              0.000001000 endif
                            
    1              0.000001000 if !hlexists('ALEInfoSign')
    1              0.000002000     highlight link ALEInfoSign ALEWarningSign
    1              0.000000000 endif
                            
    1              0.000002000 if !hlexists('ALESignColumnWithErrors')
    1              0.000002000     highlight link ALESignColumnWithErrors error
    1              0.000000000 endif
                            
    1              0.000002000 function! ale#sign#SetUpDefaultColumnWithoutErrorsHighlight() abort
                                let l:verbose = &verbose
                                set verbose=0
                                let l:output = execute('highlight SignColumn', 'silent')
                                let &verbose = l:verbose
                            
                                let l:highlight_syntax = join(split(l:output)[2:])
                                let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                            
                                if !empty(l:match)
                                    execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
                                elseif l:highlight_syntax isnot# 'cleared'
                                    execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
                                endif
                            endfunction
                            
    1              0.000002000 if !hlexists('ALESignColumnWithoutErrors')
    1   0.000071000   0.000007000     call ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    1              0.000001000 endif
                            
                            " Spaces and backslashes need to be escaped for signs.
    1              0.000002000 function! s:EscapeSignText(sign_text) abort
                                return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')
                            endfunction
                            
                            " Signs show up on the left for error markers.
    1   0.000017000   0.000010000 execute 'sign define ALEErrorSign text=' . s:EscapeSignText(g:ale_sign_error)
                            \   . ' texthl=ALEErrorSign linehl=ALEErrorLine'
    1   0.000009000   0.000005000 execute 'sign define ALEStyleErrorSign text=' .  s:EscapeSignText(g:ale_sign_style_error)
                            \   . ' texthl=ALEStyleErrorSign linehl=ALEErrorLine'
    1   0.000008000   0.000005000 execute 'sign define ALEWarningSign text=' . s:EscapeSignText(g:ale_sign_warning)
                            \   . ' texthl=ALEWarningSign linehl=ALEWarningLine'
    1   0.000007000   0.000004000 execute 'sign define ALEStyleWarningSign text=' . s:EscapeSignText(g:ale_sign_style_warning)
                            \   . ' texthl=ALEStyleWarningSign linehl=ALEWarningLine'
    1   0.000007000   0.000004000 execute 'sign define ALEInfoSign text=' . s:EscapeSignText(g:ale_sign_info)
                            \   . ' texthl=ALEInfoSign linehl=ALEInfoLine'
    1              0.000002000 sign define ALEDummySign text=\  texthl=SignColumn
                            
    1              0.000002000 if g:ale_sign_highlight_linenrs && (has('nvim-0.3.2') || has('patch-8.2.3874'))
                                if !hlexists('ALEErrorSignLineNr')
                                    highlight link ALEErrorSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEStyleErrorSignLineNr')
                                    highlight link ALEStyleErrorSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEWarningSignLineNr')
                                    highlight link ALEWarningSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEStyleWarningSignLineNr')
                                    highlight link ALEStyleWarningSignLineNr CursorLineNr
                                endif
                            
                                if !hlexists('ALEInfoSignLineNr')
                                    highlight link ALEInfoSignLineNr CursorLineNr
                                endif
                            
                                sign define ALEErrorSign numhl=ALEErrorSignLineNr
                                sign define ALEStyleErrorSign numhl=ALEStyleErrorSignLineNr
                                sign define ALEWarningSign numhl=ALEWarningSignLineNr
                                sign define ALEStyleWarningSign numhl=ALEStyleWarningSignLineNr
                                sign define ALEInfoSign numhl=ALEInfoSignLineNr
    1              0.000001000 endif
                            
    1              0.000001000 function! ale#sign#GetSignName(sublist) abort
                                let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
                                for l:item in a:sublist
                                    let l:item_priority = ale#util#GetItemPriority(l:item)
                            
                                    if l:item_priority > l:priority
                                        let l:priority = l:item_priority
                                    endif
                                endfor
                            
                                if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'
                            endfunction
                            
    1              0.000001000 function! s:PriorityCmd() abort
                                if s:supports_sign_groups
                                    return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif
                            endfunction
                            
    1              0.000001000 function! s:GroupCmd() abort
                                if s:supports_sign_groups
                                    return ' group=ale_signs '
                                else
                                    return ' '
                                endif
                            endfunction
                            
                            " Read sign data for a buffer to a list of lines.
    1              0.000001000 function! ale#sign#ReadSigns(buffer) abort
                                let l:output = execute(
                                \   'sign place ' . s:GroupCmd() . s:PriorityCmd()
                                \   . ' buffer=' . a:buffer
                                \ )
                            
                                return split(l:output, "\n")
                            endfunction
                            
    1              0.000001000 function! ale#sign#ParsePattern() abort
                                if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale_signs  name=ALEErrorSign
                                    " строка=1  id=1000001  группа=ale_signs  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  グループ=ale_signs  名前=ALEWarningSign
                                    " línea=12 id=1000001 grupo=ale_signs  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale_signs   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale_signs  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale_signs>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " строка=1  id=1000001  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  名前=ALEWarningSign
                                    " línea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
                                endif
                            
                                return l:pattern
                            endfunction
                            
                            " Given a buffer number, return a List of placed signs [line, id, group]
    1              0.000001000 function! ale#sign#ParseSignsWithGetPlaced(buffer) abort
                                let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale_signs' : '' })[0].signs
                                let l:result = []
                                let l:is_dummy_sign_set = 0
                            
                                for l:sign in l:signs
                                    if l:sign['name'] is# 'ALEDummySign'
                                        let l:is_dummy_sign_set = 1
                                    else
                                        call add(l:result, [
                                        \   str2nr(l:sign['lnum']),
                                        \   str2nr(l:sign['id']),
                                        \   l:sign['name'],
                                        \])
                                    endif
                                endfor
                            
                                return [l:is_dummy_sign_set, l:result]
                            endfunction
                            
                            " Given a list of lines for sign output, return a List of [line, id, group]
    1              0.000001000 function! ale#sign#ParseSigns(line_list) abort
                                let l:pattern =ale#sign#ParsePattern()
                                let l:result = []
                                let l:is_dummy_sign_set = 0
                            
                                for l:line in a:line_list
                                    let l:match = matchlist(l:line, l:pattern)
                            
                                    if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [
                                            \   str2nr(l:match[1]),
                                            \   str2nr(l:match[2]),
                                            \   l:match[3],
                                            \])
                                        endif
                                    endif
                                endfor
                            
                                return [l:is_dummy_sign_set, l:result]
                            endfunction
                            
    1              0.000001000 function! ale#sign#FindCurrentSigns(buffer) abort
                                if exists('*sign_getplaced')
                                    return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                else
                                    let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                    return ale#sign#ParseSigns(l:line_list)
                                endif
                            endfunction
                            
                            " Given a loclist, group the List into with one List per line.
    1              0.000001000 function! s:GroupLoclistItems(buffer, loclist) abort
                                let l:grouped_items = []
                                let l:last_lnum = -1
                            
                                for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
                                return l:grouped_items
                            endfunction
                            
    1              0.000001000 function! s:UpdateLineNumbers(buffer, current_sign_list, loclist) abort
                                let l:line_map = {}
                                let l:line_numbers_changed = 0
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
                                for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
                                if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif
                            endfunction
                            
    1              0.000000000 function! s:BuildSignMap(buffer, current_sign_list, grouped_items) abort
                                let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
                                if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
                                    let l:selected_grouped_items = a:grouped_items
                                endif
                            
                                let l:sign_map = {}
                                let l:sign_offset = g:ale_sign_offset
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(
                                    \   l:sign_info.current_name_list,
                                    \   l:sign_info.new_name
                                    \)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                return l:sign_map
                            endfunction
                            
    1              0.000001000 function! ale#sign#GetSignCommands(buffer, was_sign_set, sign_map) abort
                                let l:command_list = []
                                let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
                                if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '
                                    \   .  g:ale_sign_offset
                                    \   . s:GroupCmd()
                                    \   . s:PriorityCmd()
                                    \   . ' line=1 name=ALEDummySign '
                                    \   . ' buffer=' . a:buffer
                                    \)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
                                for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '
                                            \   . (l:info.new_id)
                                            \   . s:GroupCmd()
                                            \   . s:PriorityCmd()
                                            \   . ' line=' . l:line_str
                                            \   . ' name=' . (l:info.new_name)
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
                                for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '
                                            \   . l:current_id
                                            \   . s:GroupCmd()
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endfor
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
                                if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '
                                    \   . g:ale_sign_offset
                                    \   . s:GroupCmd()
                                    \   . ' buffer=' . a:buffer
                                    \)
                                endif
                            
                                return l:command_list
                            endfunction
                            
                            " This function will set the signs which show up on the left.
    1              0.000000000 function! ale#sign#SetSigns(buffer, loclist) abort
                                if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
                                let [l:is_dummy_sign_set, l:current_sign_list] =
                                \   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
                                call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
                                let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
                                let l:sign_map = s:BuildSignMap(
                                \   a:buffer,
                                \   l:current_sign_list,
                                \   l:grouped_items,
                                \)
                            
                                let l:command_list = ale#sign#GetSignCommands(
                                \   a:buffer,
                                \   l:is_dummy_sign_set,
                                \   l:sign_map,
                                \)
                            
                                " Change the sign column color if the option is on.
                                if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
                                for l:command in l:command_list
                                    silent! execute l:command
                                endfor
                            
                                " Reset the sign column color when there are no more errors.
                                if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif
                            endfunction
                            
                            " Remove all signs.
    1              0.000001000 function! ale#sign#Clear() abort
                                if s:supports_sign_groups
                                    sign unplace group=ale_signs *
                                else
                                    sign unplace *
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/list.vim
Sourced 1 time
Total time:   0.000234000
 Self time:   0.000234000

count     total (s)      self (s)
                            " Author: Bjorn Neergaard <bjorn@neersighted.com>, modified by Yann fery <yann@fery.me>
                            " Description: Manages the loclist and quickfix lists
                            
                            " This flag dictates if ale open the configured loclist
    1              0.000004000 let g:ale_open_list = get(g:, 'ale_open_list', v:false)
                            " This flag dictates if ale keeps open loclist even if there is no error in loclist
    1              0.000003000 let g:ale_keep_list_window_open = get(g:, 'ale_keep_list_window_open', 0)
                            " This flag dictates that quickfix windows should be opened vertically
    1              0.000002000 let g:ale_list_vertical = get(g:, 'ale_list_vertical', v:false)
                            " The window size to set for the quickfix and loclist windows
    1              0.000001000 let g:ale_list_window_size = get(g:, 'ale_list_window_size', 10)
                            " A string format for the loclist messages.
    1              0.000004000 let g:ale_loclist_msg_format = get(g:, 'ale_loclist_msg_format',
                            \   get(g:, 'ale_echo_msg_format', '%code: %%s')
                            \)
                            
    1              0.000001000 if !exists('s:timer_args')
    1              0.000002000     let s:timer_args = {}
    1              0.000000000 endif
                            
                            " Return 1 if there is a buffer with buftype == 'quickfix' in buffer list
    1              0.000001000 function! ale#list#IsQuickfixOpen() abort
                                let l:res = getqflist({ 'winid' : winnr() })
                            
                                if has_key(l:res, 'winid') && l:res.winid > 0
                                    return 1
                                endif
                            
                                let l:res = getloclist(0, { 'winid' : winnr() })
                            
                                if has_key(l:res, 'winid') && l:res.winid > 0
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Check if we should open the list, based on the save event being fired, and
                            " that setting being on, or that the error count is at least as high as the
                            " setting when set to an integer value.
    1              0.000002000 function! s:ShouldOpen(buffer, loclist_len) abort
                                let l:val = ale#Var(a:buffer, 'open_list')
                                let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved
                            endfunction
                            
                            " Check if we should close the list, based on the save event being fired, and
                            " that setting being on, or the setting just being set to an integer value.
    1              0.000001000 function! s:ShouldClose(buffer) abort
                                let l:val = ale#Var(a:buffer, 'open_list')
                                let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))
                            endfunction
                            
    1              0.000001000 function! s:Deduplicate(list) abort
                                let l:list = a:list
                            
                                call sort(l:list, function('ale#util#LocItemCompareWithText'))
                                call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
                                return l:list
                            endfunction
                            
    1              0.000001000 function! ale#list#GetCombinedList() abort
                                let l:list = []
                            
                                for l:info in values(g:ale_buffer_info)
                                    call extend(l:list, l:info.loclist)
                                endfor
                            
                                return s:Deduplicate(l:list)
                            endfunction
                            
    1              0.000001000 function! s:FixList(buffer, list) abort
                                let l:format = ale#Var(a:buffer, 'loclist_msg_format')
                                let l:new_list = []
                            
                                for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
                                return l:new_list
                            endfunction
                            
    1              0.000001000 function! s:WinFindBuf(buffer) abort
                                return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]
                            endfunction
                            
    1              0.000001000 function! s:SetListsImpl(timer_id, buffer, loclist) abort
                                let l:title = expand('#' . a:buffer . ':p')
                            
                                if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
                                    let l:ids = s:WinFindBuf(a:buffer)
                            
                                    let l:loclist = s:Deduplicate(a:loclist)
                            
                                    for l:id in l:ids
                                        if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, l:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
                                    endfor
                                endif
                            
                                " Save the current view before opening/closing any window
                                call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " ShouldOpen() checks if the current buffer has enough problems to be
                                " opened.
                                if s:ShouldOpen(a:buffer, len(a:loclist))
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
                                if !ale#engine#IsCheckingBuffer(a:buffer)
                                    call s:CloseWindowIfNeeded(a:buffer)
                                endif
                            endfunction
                            
                            " Try to restore the window view after closing any of the lists to avoid making
                            " the it moving around, especially useful when on insert mode
    1              0.000001000 function! s:RestoreViewIfNeeded(buffer) abort
                                let l:saved_view = getbufvar(a:buffer, 'ale_winview', {})
                            
                                " Saved view is empty, can't do anything
                                if empty(l:saved_view)
                                    return
                                endif
                            
                                " Check whether the cursor has moved since linting was actually requested. If
                                " the user has indeed moved lines, do nothing
                                let l:current_view = winsaveview()
                            
                                if l:current_view['lnum'] != l:saved_view['lnum']
                                    return
                                endif
                            
                                " Anchor view by topline if the list is set to open horizontally
                                if ale#Var(a:buffer, 'list_vertical') == 0
                                    call winrestview({'topline': l:saved_view['topline']})
                                endif
                            endfunction
                            
    1              0.000000000 function! ale#list#SetLists(buffer, loclist) abort
                                if get(g:, 'ale_set_lists_synchronously') == 1
                                \|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(
                                    \   0,
                                    \   function('s:SetListsImpl'),
                                    \   [a:buffer, a:loclist],
                                    \)
                                endif
                            endfunction
                            
    1              0.000000000 function! ale#list#ForcePopulateErrorList(populate_quickfix) abort
                                let l:quickfix_bak = g:ale_set_quickfix
                                let g:ale_set_quickfix = a:populate_quickfix
                                let l:loclist_bak = g:ale_set_loclist
                                let g:ale_set_loclist = !a:populate_quickfix
                                let l:open_list_bak = g:ale_open_list
                                let g:ale_open_list = 1
                            
                                let l:buffer = bufnr('')
                                let l:loclist = get(g:ale_buffer_info, l:buffer, {'loclist': []}).loclist
                                call s:SetListsImpl(-1, l:buffer, l:loclist)
                            
                                let g:ale_open_list = l:open_list_bak
                                let g:ale_set_loclist = l:loclist_bak
                                let g:ale_set_quickfix = l:quickfix_bak
                            endfunction
                            
    1              0.000001000 function! s:CloseWindowIfNeeded(buffer) abort
                                if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
                                    return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/highlight.vim
Sourced 1 time
Total time:   0.000246000
 Self time:   0.000246000

count     total (s)      self (s)
    1              0.000002000 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: This module implements error/warning highlighting.
                            
    1              0.000004000 if !hlexists('ALEError')
    1              0.000003000     highlight link ALEError SpellBad
    1              0.000000000 endif
                            
    1              0.000002000 if !hlexists('ALEStyleError')
    1              0.000002000     highlight link ALEStyleError ALEError
    1              0.000000000 endif
                            
    1              0.000002000 if !hlexists('ALEWarning')
    1              0.000002000     highlight link ALEWarning SpellCap
    1              0.000000000 endif
                            
    1              0.000001000 if !hlexists('ALEStyleWarning')
    1              0.000002000     highlight link ALEStyleWarning ALEWarning
    1              0.000000000 endif
                            
    1              0.000002000 if !hlexists('ALEInfo')
    1              0.000001000     highlight link ALEInfo ALEWarning
    1              0.000000000 endif
                            
                            " The maximum number of items for the second argument of matchaddpos()
    1              0.000001000 let s:MAX_POS_VALUES = 8
    1              0.000001000 let s:MAX_COL_SIZE = 1073741824 " pow(2, 30)
                            
    1              0.000002000 let s:has_nvim_highlight = exists('*nvim_buf_add_highlight') && exists('*nvim_buf_clear_namespace')
                            
    1              0.000001000 if s:has_nvim_highlight
                                let s:ns_id = nvim_create_namespace('ale_highlight')
    1              0.000001000 endif
                            
                            " Wrappers are necessary to test this functionality by faking the calls in tests.
    1              0.000002000 function! ale#highlight#nvim_buf_add_highlight(buffer, ns_id, hl_group, line, col_start, col_end) abort
                                " Ignore all errors for adding highlights.
                                try
                                    call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
                                endtry
                            endfunction
                            
    1              0.000001000 function! ale#highlight#nvim_buf_clear_namespace(buffer, ns_id, line_start, line_end) abort
                                call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)
                            endfunction
                            
    1              0.000002000 function! ale#highlight#CreatePositions(line, col, end_line, end_col) abort
                                if a:line >= a:end_line
                                    " For single lines, just return the one position.
                                    return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =
                                \   [[a:line, a:col, s:MAX_COL_SIZE]]
                                \   + range(a:line + 1, a:end_line - 1)
                                \   + [[a:end_line, 1, a:end_col]]
                            
                                return map(
                                \   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),
                                \   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',
                                \)
                            endfunction
                            
                            " Given a loclist for current items to highlight, remove all highlights
                            " except these which have matching loclist item entries.
                            
    1              0.000001000 function! ale#highlight#RemoveHighlights() abort
                                if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
                            " Same semantics of matchaddpos but will use nvim_buf_add_highlight if
                            " available. This involves iterating over the position list, switching from
                            " 1-based indexing to 0-based indexing, and translating the multiple ways
                            " that position can be specified for matchaddpos into line + col_start +
                            " col_end.
    1              0.000001000 function! s:matchaddpos(group, pos_list) abort
                                if s:has_nvim_highlight
                                    for l:pos in a:pos_list
                                        let l:line = type(l:pos) == v:t_number
                                        \   ? l:pos - 1
                                        \   : l:pos[0] - 1
                            
                                        if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
                                        else
                                            let l:col_start = l:pos[1] - 1
                                            let l:col_end = l:col_start + get(l:pos, 2, 1)
                                        endif
                            
                                        call ale#highlight#nvim_buf_add_highlight(
                                        \   bufnr(''),
                                        \   s:ns_id,
                                        \   a:group,
                                        \   l:line,
                                        \   l:col_start,
                                        \   l:col_end,
                                        \)
                                    endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:highlight_line(bufnr, lnum, group) abort
                                call s:matchaddpos(a:group, [a:lnum])
                            endfunction
                            
    1              0.000001000 function! s:highlight_range(bufnr, range, group) abort
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
                                call map(
                                \   ale#highlight#CreatePositions(
                                \       a:range.lnum,
                                \       a:range.col,
                                \       a:range.end_lnum,
                                \       a:range.end_col
                                \   ),
                                \   's:matchaddpos(a:group, v:val)'
                                \)
                            endfunction
                            
    1              0.000001000 function! ale#highlight#UpdateHighlights() abort
                                let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled
                                \   ? get(b:, 'ale_highlight_items', [])
                                \   : []
                            
                                call ale#highlight#RemoveHighlights()
                            
                                for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {
                                    \   'lnum': l:item.lnum,
                                    \   'col': l:item.col,
                                    \   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),
                                    \   'end_col': get(l:item, 'end_col', l:item.col)
                                    \}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
                                endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
                                if !g:ale_set_signs
                                    let l:available_groups = {
                                    \   'ALEWarningLine': hlexists('ALEWarningLine'),
                                    \   'ALEInfoLine': hlexists('ALEInfoLine'),
                                    \   'ALEErrorLine': hlexists('ALEErrorLine'),
                                    \}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#highlight#BufferHidden(buffer) abort
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
                                call ale#highlight#RemoveHighlights()
                            endfunction
                            
    1              0.000002000 augroup ALEHighlightBufferGroup
    1              0.000032000     autocmd!
    1              0.000005000     autocmd BufEnter * call ale#highlight#UpdateHighlights()
    1              0.000001000     autocmd BufHidden * call ale#highlight#BufferHidden(expand('<abuf>'))
    1              0.000001000 augroup END
                            
    1              0.000001000 function! ale#highlight#SetHighlights(buffer, loclist) abort
                                let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled
                                \   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')
                                \   : []
                            
                                " Set the list in the buffer variable.
                                call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
                                if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
                                endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
                                call ale#highlight#UpdateHighlights()
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/virtualtext.vim
Sourced 1 time
Total time:   0.000286000
 Self time:   0.000286000

count     total (s)      self (s)
    1              0.000002000 scriptencoding utf-8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Author: Luan Santos <cfcluan@gmail.com>
                            " Description: Shows lint message for the current line as virtualtext, if any
                            
    1              0.000003000 if !hlexists('ALEVirtualTextError')
    1              0.000003000     highlight link ALEVirtualTextError Comment
    1              0.000001000 endif
                            
    1              0.000002000 if !hlexists('ALEVirtualTextStyleError')
    1              0.000003000     highlight link ALEVirtualTextStyleError ALEVirtualTextError
    1              0.000000000 endif
                            
    1              0.000003000 if !hlexists('ALEVirtualTextWarning')
    1              0.000003000     highlight link ALEVirtualTextWarning Comment
    1              0.000000000 endif
                            
    1              0.000002000 if !hlexists('ALEVirtualTextStyleWarning')
    1              0.000002000     highlight link ALEVirtualTextStyleWarning ALEVirtualTextWarning
    1              0.000001000 endif
                            
    1              0.000002000 if !hlexists('ALEVirtualTextInfo')
    1              0.000002000     highlight link ALEVirtualTextInfo ALEVirtualTextWarning
    1              0.000001000 endif
                            
    1              0.000003000 let g:ale_virtualtext_prefix =
                            \   get(g:, 'ale_virtualtext_prefix', '%comment% %type%: ')
                            " Controls the milliseconds delay before showing a message.
    1              0.000002000 let g:ale_virtualtext_delay = get(g:, 'ale_virtualtext_delay', 10)
                            
                            " Controls the positioning of virtualtext
    1              0.000002000 let g:ale_virtualtext_column = get(g:, 'ale_virtualtext_column', 0)
    1              0.000002000 let g:ale_virtualtext_maxcolumn = get(g:, 'ale_virtualtext_maxcolumn', 0)
                            " If 1, only show the first problem with virtualtext.
    1              0.000002000 let g:ale_virtualtext_single = get(g:, 'ale_virtualtext_single', v:true)
                            
    1              0.000002000 let s:cursor_timer = get(s:, 'cursor_timer', -1)
    1              0.000002000 let s:last_pos = get(s:, 'last_pos', [0, 0, 0])
    1              0.000001000 let s:hl_list = get(s:, 'hl_list', [])
    1              0.000001000 let s:last_message = ''
                            
    1              0.000001000 if !has_key(s:, 'has_virt_text')
    1              0.000001000     let s:has_virt_text = 0
    1              0.000001000     let s:emulate_virt = 0
    1              0.000001000     let s:last_virt = -1
                            
    1              0.000002000     if has('nvim-0.3.2')
                                    let s:ns_id = nvim_create_namespace('ale')
                                    let s:has_virt_text = 1
    1              0.000003000     elseif has('textprop') && has('popupwin')
    1              0.000001000         let s:has_virt_text = 1
    1              0.000002000         let s:emulate_virt = !has('patch-9.0.0297')
                            
    1              0.000000000         if s:emulate_virt
                                        call prop_type_add('ale', {})
    1              0.000000000         endif
    1              0.000001000     endif
    1              0.000000000 endif
                            
    1              0.000001000 function! s:StopCursorTimer() abort
                                if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#ResetDataForTests() abort
                                let s:last_pos = [0, 0, 0]
                                let s:last_message = ''
                            endfunction
                            
    1              0.000000000 function! ale#virtualtext#GetLastMessageForTests() abort
                                return s:last_message
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#GetComment(buffer) abort
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:split = split(getbufvar(a:buffer, '&commentstring'), '%s')
                            
                                return !empty(l:split) ? trim(l:split[0]) : '#'
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#Clear(buffer) abort
                                if !s:has_virt_text || !bufexists(str2nr(a:buffer))
                                    return
                                endif
                            
                                if has('nvim')
                                    call nvim_buf_clear_namespace(a:buffer, s:ns_id, 0, -1)
                                else
                                    if s:emulate_virt && s:last_virt != -1
                                        call prop_remove({'type': 'ale'})
                                        call popup_close(s:last_virt)
                                        let s:last_virt = -1
                                    elseif !empty(s:hl_list)
                                        call prop_remove({
                                        \   'types': s:hl_list,
                                        \   'all': 1,
                                        \   'bufnr': a:buffer,
                                        \})
                                    endif
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#GetGroup(item) abort
                                let l:type = get(a:item, 'type', 'E')
                                let l:sub_type = get(a:item, 'sub_type', '')
                            
                                if l:type is# 'E'
                                    if l:sub_type is# 'style'
                                        return 'ALEVirtualTextStyleError'
                                    endif
                            
                                    return 'ALEVirtualTextError'
                                endif
                            
                                if l:type is# 'W'
                                    if l:sub_type is# 'style'
                                        return 'ALEVirtualTextStyleWarning'
                                    endif
                            
                                    return 'ALEVirtualTextWarning'
                                endif
                            
                                return 'ALEVirtualTextInfo'
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#GetColumnPadding(buffer, line) abort
                                let l:mincol = ale#Var(a:buffer, 'virtualtext_column')
                                let l:maxcol = ale#Var(a:buffer, 'virtualtext_maxcolumn')
                                let l:win = bufwinnr(a:buffer)
                            
                                if l:mincol[len(l:mincol)-1] is# '%'
                                    let l:mincol = (winwidth(l:win) * l:mincol) / 100
                                endif
                            
                                if l:maxcol[len(l:maxcol)-1] is# '%'
                                    let l:maxcol = (winwidth(l:win) * l:maxcol) / 100
                                endif
                            
                                " Calculate padding for virtualtext alignment
                                if l:mincol > 0 || l:maxcol > 0
                                    let l:line_width = strdisplaywidth(getline(a:line))
                            
                                    if l:line_width < l:mincol
                                        return l:mincol - l:line_width
                                    elseif l:maxcol > 0 && l:line_width >= l:maxcol
                                        " Stop processing if virtualtext would start beyond maxcol
                                        return -1
                                    endif
                                endif
                            
                                " no padding.
                                return 0
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#ShowMessage(buffer, item) abort
                                if !s:has_virt_text || !bufexists(str2nr(a:buffer))
                                    return
                                endif
                            
                                let l:line = max([1, a:item.lnum])
                                let l:hl_group = ale#virtualtext#GetGroup(a:item)
                            
                                " Get a language-appropriate comment character, or default to '#'.
                                let l:comment = ale#virtualtext#GetComment(a:buffer)
                                let l:prefix = ale#Var(a:buffer, 'virtualtext_prefix')
                                let l:prefix = ale#GetLocItemMessage(a:item, l:prefix)
                                let l:prefix = substitute(l:prefix, '\V%comment%', '\=l:comment', 'g')
                                let l:msg = l:prefix . substitute(a:item.text, '\n', ' ', 'g')
                                let l:col_pad = ale#virtualtext#GetColumnPadding(a:buffer, l:line)
                            
                                " Store the last message we're going to set so we can read it in tests.
                                let s:last_message = l:msg
                            
                                " Discard virtualtext if padding is negative.
                                if l:col_pad < 0
                                    return
                                endif
                            
                                if has('nvim')
                                    call nvim_buf_set_virtual_text(
                                    \   a:buffer,
                                    \   s:ns_id, l:line - 1,
                                    \   [[l:msg, l:hl_group]],
                                    \   {}
                                    \)
                                elseif s:emulate_virt
                                    let l:left_pad = col('$')
                                    call prop_add(l:line, l:left_pad, {'type': 'ale'})
                                    let s:last_virt = popup_create(l:msg, {
                                    \   'line': -1,
                                    \   'padding': [0, 0, 0, 1],
                                    \   'mask': [[1, 1, 1, 1]],
                                    \   'textprop': 'ale',
                                    \   'highlight': l:hl_group,
                                    \   'fixed': 1,
                                    \   'wrap': 0,
                                    \   'zindex': 2
                                    \})
                                else
                                    let l:type = prop_type_get(l:hl_group)
                            
                                    if l:type == {}
                                        call prop_type_add(l:hl_group, {'highlight': l:hl_group})
                                    endif
                            
                                    " Add highlight groups to the list so we can clear them later.
                                    if index(s:hl_list, l:hl_group) == -1
                                        call add(s:hl_list, l:hl_group)
                                    endif
                            
                                    " We ignore all errors from prop_add.
                                    silent! call prop_add(l:line, 0, {
                                    \   'type': l:hl_group,
                                    \   'text': ' ' . l:msg,
                                    \   'bufnr': a:buffer,
                                    \   'text_padding_left': l:col_pad,
                                    \})
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#ShowCursorWarning(...) abort
                                if g:ale_virtualtext_cursor isnot# 'current'
                                \&& g:ale_virtualtext_cursor != 1
                                    return
                                endif
                            
                                let l:buffer = bufnr('')
                            
                                if mode(1) isnot# 'n'
                                \|| g:ale_use_neovim_diagnostics_api
                                \|| ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                let [l:info, l:item] = ale#util#FindItemAtCursor(l:buffer)
                                call ale#virtualtext#Clear(l:buffer)
                            
                                if !empty(l:item)
                                    call ale#virtualtext#ShowMessage(l:buffer, l:item)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#ShowCursorWarningWithDelay() abort
                                let l:buffer = bufnr('')
                            
                                if g:ale_virtualtext_cursor isnot# 'current'
                                \&& g:ale_virtualtext_cursor != 1
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                if mode(1) isnot# 'n'
                                \|| g:ale_use_neovim_diagnostics_api
                                    return
                                endif
                            
                                let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should show something. Otherwise we can end up doing processing
                                " the show message far too frequently.
                                if l:pos != s:last_pos
                                    let l:delay = ale#Var(l:buffer, 'virtualtext_delay')
                            
                                    let s:last_pos = l:pos
                                    let s:cursor_timer = timer_start(
                                    \   l:delay,
                                    \   function('ale#virtualtext#ShowCursorWarning')
                                    \)
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#CompareSeverityPerLine(left, right) abort
                                " Compare lines
                                if a:left.lnum < a:right.lnum
                                    return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                " Put highest priority items first.
                                if l:left_priority > l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority < l:right_priority
                                    return 1
                                endif
                            
                                " Put the first seen problem first.
                                return a:left.col - a:right.col
                            endfunction
                            
    1              0.000001000 function! ale#virtualtext#SetTexts(buffer, loclist) abort
                                if !has('nvim') && s:emulate_virt
                                    return
                                endif
                            
                                call ale#virtualtext#Clear(a:buffer)
                            
                                let l:buffer_list = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
                            
                                if ale#Var(a:buffer,'virtualtext_single')
                                    " If we want a single problem per line, sort items on each line by
                                    " highest severity and then lowest column position, then de-duplicate
                                    " the items by line.
                                    call uniq(
                                    \   sort(l:buffer_list, function('ale#virtualtext#CompareSeverityPerLine')),
                                    \   {a, b -> a.lnum - b.lnum}
                                    \)
                                endif
                            
                                for l:item in l:buffer_list
                                    call ale#virtualtext#ShowMessage(a:buffer, l:item)
                                endfor
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/modes.vim/autoload/modes/color.vim
Sourced 1 time
Total time:   0.001144000
 Self time:   0.001144000

count     total (s)      self (s)
    1              0.000013000 vim9script
                            
    1              0.000025000 export def GetNormalBgColor(): string
                              var hlid = hlID('Normal')
                              # Resolve any links
                              hlid = synIDtrans(hlid)
                              # Get the background color in #RRGGBB format
                              return synIDattr(hlid, 'bg#')
                            enddef
                            
    1              0.000011000 export def ComputeBlendedColor(rgb_fg: string, blend: number): string
                              var rgb_bg = GetNormalBgColor()
                              # blend is 0-100
                              var alpha = blend / 100.0
                              var r = float2nr(str2nr(strpart(rgb_fg, 1, 2), 16) * alpha + str2nr(strpart(rgb_bg, 1, 2), 16) * (1 - alpha))
                              var g = float2nr(str2nr(strpart(rgb_fg, 3, 2), 16) * alpha + str2nr(strpart(rgb_bg, 3, 2), 16) * (1 - alpha))
                              var b = float2nr(str2nr(strpart(rgb_fg, 5, 2), 16) * alpha + str2nr(strpart(rgb_bg, 5, 2), 16) * (1 - alpha))
                            
                              return printf('#%02x%02x%02x', r, g, b)
                            enddef
                            
    1              0.000005000 def GetNormalBgColorCterm(): number
                                # Get the highlight ID for 'Normal'
                                var hlid = hlID('Normal')
                                # Resolve any links
                                hlid = synIDtrans(hlid)
                                # Get the background color in cterm format
                                var bg_color = synIDattr(hlid, 'ctermbg')
                                return str2nr(bg_color)
                            enddef
                            
    1              0.000007000 def CtermToRGB(cterm: number): list<number>
                                # Standard 256-color palette conversion
                                if cterm < 16
                                    # Standard 16 colors
                                    var colors = [
                                        \ [0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0],
                                        \ [0, 0, 128], [128, 0, 128], [0, 128, 128], [192, 192, 192],
                                        \ [128, 128, 128], [255, 0, 0], [0, 255, 0], [255, 255, 0],
                                        \ [0, 0, 255], [255, 0, 255], [0, 255, 255], [255, 255, 255]
                                    \ ]
                                    return colors[cterm]
                                elseif cterm < 232
                                    # 216 color cube (6x6x6)
                                    var idx = cterm - 16
                                    var r = (idx / 36) * 51
                                    var g = ((idx % 36) / 6) * 51
                                    var b = (idx % 6) * 51
                                    return [r, g, b]
                                else
                                    # Grayscale (24 shades)
                                    var gray = 8 + (cterm - 232) * 10
                                    return [gray, gray, gray]
                                endif
                            enddef
                            
    1              0.000010000 def RGBToCterm(r: number, g: number, b: number): number
                                # Try to match to the 6x6x6 color cube for best results
                                var ri = float2nr(round(r / 51.0))
                                var gi = float2nr(round(g / 51.0))
                                var bi = float2nr(round(b / 51.0))
                            
                                # Clamp to valid range
                                ri = min([max([ri, 0]), 5])
                                gi = min([max([gi, 0]), 5])
                                bi = min([max([bi, 0]), 5])
                            
                                return 16 + ri * 36 + gi * 6 + bi
                            enddef
                            
    1              0.000008000 export def ComputeBlendedColorCterm(cterm_bg: number, blend: number): number
                              var cterm_fg = GetNormalBgColorCterm()
                              # blend is 0-100
                              # Convert cterm colors to RGB, blend, then convert back to nearest cterm color
                              var alpha = blend / 100.0
                            
                              # Get RGB values for cterm colors
                              var rgb_fg = CtermToRGB(cterm_fg)
                              var rgb_bg = CtermToRGB(cterm_bg)
                            
                              # Blend the RGB values
                              var r = float2nr(rgb_fg[0] * alpha + rgb_bg[0] * (1 - alpha))
                              var g = float2nr(rgb_fg[1] * alpha + rgb_bg[1] * (1 - alpha))
                              var b = float2nr(rgb_fg[2] * alpha + rgb_bg[2] * (1 - alpha))
                            
                              # Find nearest cterm color
                              return RGBToCterm(r, g, b)
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/ag.vim/autoload/ag.vim
Sourced 1 time
Total time:   0.067735000
 Self time:   0.002041000

count     total (s)      self (s)
                            " NOTE: You must, of course, install ag / the_silver_searcher
                            
                            " FIXME: Delete deprecated options below on or after 2016-4 (6 months from when the deprecation warning was added) {{{
                            
    1              0.000027000 if exists("g:agprg")
                              let g:ag_prg = g:agprg
                              echohl WarningMsg
                              call input('g:agprg is deprecated and will be removed. Please use g:ag_prg')
                              echohl None
    1              0.000002000 endif
                            
    1              0.000006000 if exists("g:aghighlight")
                              let g:ag_highlight = g:aghighlight
                              echohl WarningMsg
                              call input('g:aghighlight is deprecated and will be removed. Please use g:ag_highlight')
                              echohl None
    1              0.000002000 endif
                            
    1              0.000004000 if exists("g:agformat")
                              let g:ag_format = g:agformat
                              echohl WarningMsg
                              call input('g:agformat is deprecated and will be removed. Please use g:ag_format')
                              echohl None
    1              0.000001000 endif
                            
                            " }}} FIXME: Delete the deprecated options above on or after 15-7 (6 months from when they were changed)
                            
                            " Location of the ag utility
    1              0.000008000 if !exists("g:ag_prg")
                              " --vimgrep (consistent output we can parse) is available from version  0.25.0+
    1   0.066153000   0.000459000   if split(system("ag --version"), "[ \n\r\t]")[2] =~ '\d\+.\(\(2[5-9]\)\|\([3-9][0-9]\)\)\(.\d\+\)\?'
                                let g:ag_prg="ag --vimgrep"
    1              0.000003000   else
                                " --noheading seems odd here, but see https://github.com/ggreer/the_silver_searcher/issues/361
    1              0.000010000     let g:ag_prg="ag --column --nogroup --noheading"
    1              0.000001000   endif
    1              0.000001000 endif
                            
    1              0.000008000 if !exists("g:ag_apply_qmappings")
    1              0.000004000   let g:ag_apply_qmappings=1
    1              0.000001000 endif
                            
    1              0.000004000 if !exists("g:ag_apply_lmappings")
    1              0.000002000   let g:ag_apply_lmappings=1
    1              0.000001000 endif
                            
    1              0.000003000 if !exists("g:ag_qhandler")
    1              0.000003000   let g:ag_qhandler="botright copen"
    1              0.000001000 endif
                            
    1              0.000003000 if !exists("g:ag_lhandler")
    1              0.000002000   let g:ag_lhandler="botright lopen"
    1              0.000001000 endif
                            
    1              0.000005000 if !exists("g:ag_mapping_message")
    1              0.000002000   let g:ag_mapping_message=1
    1              0.000001000 endif
                            
    1              0.000003000 if !exists("g:ag_working_path_mode")
    1              0.000002000     let g:ag_working_path_mode = 'c'
    1              0.000001000 endif
                            
    1              0.000007000 function! ag#AgBuffer(cmd, args)
                              let l:bufs = filter(range(1, bufnr('$')), 'buflisted(v:val)')
                              let l:files = []
                              for buf in l:bufs
                                let l:file = fnamemodify(bufname(buf), ':p')
                                if !isdirectory(l:file)
                                  call add(l:files, l:file)
                                endif
                              endfor
                              call ag#Ag(a:cmd, a:args . ' ' . join(l:files, ' '))
                            endfunction
                            
    1              0.000003000 function! ag#Ag(cmd, args)
                              let l:ag_executable = get(split(g:ag_prg, " "), 0)
                            
                              " Ensure that `ag` is installed
                              if !executable(l:ag_executable)
                                echoe "Ag command '" . l:ag_executable . "' was not found. Is the silver searcher installed and on your $PATH?"
                                return
                              endif
                            
                              " If no pattern is provided, search for the word under the cursor
                              if empty(a:args)
                                let l:grepargs = expand("<cword>")
                              else
                                let l:grepargs = a:args . join(a:000, ' ')
                              end
                            
                              if empty(l:grepargs)
                                echo "Usage: ':Ag {pattern}' (or just :Ag to search for the word under the cursor). See ':help :Ag' for more information."
                                return
                              endif
                            
                              " Format, used to manage column jump
                              if a:cmd =~# '-g$'
                                let s:ag_format_backup=g:ag_format
                                let g:ag_format="%f"
                              elseif exists("s:ag_format_backup")
                                let g:ag_format=s:ag_format_backup
                              elseif !exists("g:ag_format")
                                let g:ag_format="%f:%l:%c:%m"
                              endif
                            
                              let l:grepprg_bak=&grepprg
                              let l:grepformat_bak=&grepformat
                              let l:t_ti_bak=&t_ti
                              let l:t_te_bak=&t_te
                              try
                                let &grepprg=g:ag_prg
                                let &grepformat=g:ag_format
                                set t_ti=
                                set t_te=
                                if g:ag_working_path_mode ==? 'r' " Try to find the projectroot for current buffer
                                  let l:cwd_back = getcwd()
                                  let l:cwd = s:guessProjectRoot()
                                  try
                                    exe "lcd ".l:cwd
                                  catch
                                    echom 'Failed to change directory to:'.l:cwd
                                  finally
                                    silent! execute a:cmd . " " . escape(l:grepargs, '|')
                                    exe "lcd ".l:cwd_back
                                  endtry
                                else " Someone chose an undefined value or 'c' so we revert to the default
                                  silent! execute a:cmd . " " . escape(l:grepargs, '|')
                                endif
                              finally
                                let &grepprg=l:grepprg_bak
                                let &grepformat=l:grepformat_bak
                                let &t_ti=l:t_ti_bak
                                let &t_te=l:t_te_bak
                              endtry
                            
                              if a:cmd =~# '^l'
                                let l:match_count = len(getloclist(winnr()))
                              else
                                let l:match_count = len(getqflist())
                              endif
                            
                              if a:cmd =~# '^l' && l:match_count
                                exe g:ag_lhandler
                                let l:apply_mappings = g:ag_apply_lmappings
                                let l:matches_window_prefix = 'l' " we're using the location list
                              elseif l:match_count
                                exe g:ag_qhandler
                                let l:apply_mappings = g:ag_apply_qmappings
                                let l:matches_window_prefix = 'c' " we're using the quickfix window
                              endif
                            
                              " If highlighting is on, highlight the search keyword.
                              if exists('g:ag_highlight')
                                let @/ = matchstr(a:args, "\\v(-)\@<!(\<)\@<=\\w+|['\"]\\zs.{-}\\ze['\"]")
                                call feedkeys(":let &hlsearch=1 \| echo \<CR>", 'n')
                              end
                            
                              redraw!
                            
                              if l:match_count
                                if l:apply_mappings
                                  nnoremap <silent> <buffer> h  <C-W><CR><C-w>K
                                  nnoremap <silent> <buffer> H  <C-W><CR><C-w>K<C-w>b
                                  nnoremap <silent> <buffer> o  <CR>
                                  nnoremap <silent> <buffer> t  <C-w><CR><C-w>T
                                  nnoremap <silent> <buffer> T  <C-w><CR><C-w>TgT<C-W><C-W>
                                  nnoremap <silent> <buffer> v  <C-w><CR><C-w>H<C-W>b<C-W>J<C-W>t
                            
                                  exe 'nnoremap <silent> <buffer> e <CR><C-w><C-w>:' . l:matches_window_prefix .'close<CR>'
                                  exe 'nnoremap <silent> <buffer> go <CR>:' . l:matches_window_prefix . 'open<CR>'
                                  exe 'nnoremap <silent> <buffer> q  :' . l:matches_window_prefix . 'close<CR>'
                            
                                  exe 'nnoremap <silent> <buffer> gv :let b:height=winheight(0)<CR><C-w><CR><C-w>H:' . l:matches_window_prefix . 'open<CR><C-w>J:exe printf(":normal %d\<lt>c-w>_", b:height)<CR>'
                                  " Interpretation:
                                  " :let b:height=winheight(0)<CR>                      Get the height of the quickfix/location list window
                                  " <CR><C-w>                                           Open the current item in a new split
                                  " <C-w>H                                              Slam the newly opened window against the left edge
                                  " :copen<CR> -or- :lopen<CR>                          Open either the quickfix window or the location list (whichever we were using)
                                  " <C-w>J                                              Slam the quickfix/location list window against the bottom edge
                                  " :exe printf(":normal %d\<lt>c-w>_", b:height)<CR>   Restore the quickfix/location list window's height from before we opened the match
                            
                                  if g:ag_mapping_message && l:apply_mappings
                                    echom "ag.vim keys: q=quit <cr>/e/t/h/v=enter/edit/tab/split/vsplit go/T/H/gv=preview versions of same"
                                  endif
                                endif
                              else " Close the split window automatically:
                                cclose
                                lclose
                                echohl WarningMsg
                                echom 'No matches for "'.a:args.'"'
                                echohl None
                              endif
                            endfunction
                            
    1              0.000003000 function! ag#AgFromSearch(cmd, args)
                              let search =  getreg('/')
                              " translate vim regular expression to perl regular expression.
                              let search = substitute(search,'\(\\<\|\\>\)','\\b','g')
                              call ag#Ag(a:cmd, '"' .  search .'" '. a:args)
                            endfunction
                            
    1              0.000002000 function! ag#GetDocLocations()
                              let dp = ''
                              for p in split(&runtimepath,',')
                                let p = p.'doc/'
                                if isdirectory(p)
                                  let dp = p.'*.txt '.dp
                                endif
                              endfor
                              return dp
                            endfunction
                            
    1              0.000002000 function! ag#AgHelp(cmd,args)
                              let args = a:args.' '.ag#GetDocLocations()
                              call ag#Ag(a:cmd,args)
                            endfunction
                            
    1              0.000004000 function! s:guessProjectRoot()
                              let l:splitsearchdir = split(getcwd(), "/")
                            
                              while len(l:splitsearchdir) > 2
                                let l:searchdir = '/'.join(l:splitsearchdir, '/').'/'
                                for l:marker in ['.rootdir', '.git', '.hg', '.svn', 'bzr', '_darcs', 'build.xml']
                                  " found it! Return the dir
                                  if filereadable(l:searchdir.l:marker) || isdirectory(l:searchdir.l:marker)
                                    return l:searchdir
                                  endif
                                endfor
                                let l:splitsearchdir = l:splitsearchdir[0:-2] " Splice the list to get rid of the tail directory
                              endwhile
                            
                              " Nothing found, fallback to current working dir
                              return getcwd()
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ack.vim/ftplugin/qf.vim
Sourced 10 times
Total time:   0.001517000
 Self time:   0.001517000

count     total (s)      self (s)
   10              0.000072000 if exists("g:ack_autofold_results") && g:ack_autofold_results
                              setlocal foldlevel=0
                              setlocal foldmethod=expr
                              setlocal foldexpr=matchstr(getline(v:lnum),'^[^\|]\\+')==#matchstr(getline(v:lnum+1),'^[^\|]\\+')?1:'<1'
                              setlocal foldenable
                              setlocal foldclose=all
                              setlocal foldopen=all
                              nnoremap <buffer> j jzz
   10              0.000018000 endif

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/ftplugin/qf.vim
Sourced 10 times
Total time:   0.000931000
 Self time:   0.000931000

count     total (s)      self (s)
                            " Vim filetype plugin file
                            " Language:     Vim's quickfix window
                            " Maintainer:   Lech Lorens <Lech.Lorens@gmail.com>
                            " Last Change: 	2019 Jul 15
                            
   10              0.000046000 if exists("b:did_ftplugin")
                              finish
   10              0.000008000 endif
                            
                            " Don't load another plugin for this buffer
   10              0.000022000 let b:did_ftplugin = 1
                            
   10              0.000031000 if !get(g:, 'qf_disable_statusline')
   10              0.000017000   let b:undo_ftplugin = "set stl<"
                            
                              " Display the command that produced the list in the quickfix window:
   10              0.000073000   setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P
   10              0.000015000 endif

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/qf.vim
Sourced 10 times
Total time:   0.001551000
 Self time:   0.001551000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:	Quickfix window
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Quit when a syntax file was already loaded
   10              0.000044000 if exists("b:current_syntax")
                              finish
   10              0.000007000 endif
                            
                            " A bunch of useful C keywords
   10              0.000166000 syn match	qfFileName	"^[^|]*" nextgroup=qfSeparator
   10              0.000102000 syn match	qfSeparator	"|" nextgroup=qfLineNr contained
   10              0.000098000 syn match	qfLineNr	"[^|]*" contained contains=qfError
   10              0.000045000 syn match	qfError		"error" contained
                            
                            " The default highlighting.
   10              0.000131000 hi def link qfFileName	Directory
   10              0.000079000 hi def link qfLineNr	LineNr
   10              0.000071000 hi def link qfError	Error
                            
   10              0.000030000 let b:current_syntax = "qf"
                            
                            " vim: ts=8

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/ftplugin/help.vim
Sourced 3 times
Total time:   0.000768000
 Self time:   0.000768000

count     total (s)      self (s)
                            " Vim filetype plugin file
                            " Language:             Vim help file
                            " Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:      2018-12-29
                            
    3              0.000024000 if exists("b:did_ftplugin")
                              finish
    3              0.000003000 endif
    3              0.000009000 let b:did_ftplugin = 1
                            
    3              0.000013000 let s:cpo_save = &cpo
    3              0.000025000 set cpo&vim
                            
    3              0.000006000 let b:undo_ftplugin = "setl fo< tw< cole< cocu< keywordprg<"
                            
    3              0.000048000 setlocal formatoptions+=tcroql textwidth=78 keywordprg=:help
    3              0.000012000 if has("conceal")
    3              0.000016000   setlocal cole=2 cocu=nc
    3              0.000003000 endif
                            
    3              0.000008000 if has("gui_macvim")
                              " Use swipe gesture to navigate back/forward
    3              0.000025000   nmap <buffer> <silent> <SwipeLeft>  :po<CR>
    3              0.000012000   nmap <buffer> <silent> <SwipeRight> :ta<CR>
    3              0.000002000 endif
                            
    3              0.000015000 let &cpo = s:cpo_save
    3              0.000010000 unlet s:cpo_save

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/help.vim
Sourced 3 times
Total time:   0.003289000
 Self time:   0.003289000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:	Vim help file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Quit when a (custom) syntax file was already loaded
    3              0.000014000 if exists("b:current_syntax")
                              finish
    3              0.000002000 endif
                            
    3              0.000012000 let s:cpo_save = &cpo
    3              0.000010000 set cpo&vim
                            
    3              0.000060000 syn match helpHeadline		"^[A-Z.][-A-Z0-9 .,()_']*?\=\ze\(\s\+\*\|$\)"
    3              0.000015000 syn match helpSectionDelim	"^===.*===$"
    3              0.000011000 syn match helpSectionDelim	"^---.*--$"
    3              0.000007000 if has("conceal")
    3              0.000044000   syn region helpExample	matchgroup=helpIgnore start=" >$" start="^>$" end="^[^ \t]"me=e-1 end="^<" concealends
                            else
                              syn region helpExample	matchgroup=helpIgnore start=" >$" start="^>$" end="^[^ \t]"me=e-1 end="^<"
    3              0.000003000 endif
    3              0.000005000 if has("ebcdic")
                              syn match helpHyperTextJump	"\\\@<!|[^"*|]\+|" contains=helpBar
                              syn match helpHyperTextEntry	"\*[^"*|]\+\*\s"he=e-1 contains=helpStar
                              syn match helpHyperTextEntry	"\*[^"*|]\+\*$" contains=helpStar
    3              0.000002000 else
    3              0.000026000   syn match helpHyperTextJump	"\\\@<!|[#-)!+-~]\+|" contains=helpBar
    3              0.000033000   syn match helpHyperTextEntry	"\*[#-)!+-~]\+\*\s"he=e-1 contains=helpStar
    3              0.000016000   syn match helpHyperTextEntry	"\*[#-)!+-~]\+\*$" contains=helpStar
    3              0.000002000 endif
    3              0.000006000 if has("conceal")
    3              0.000011000   syn match helpBar		contained "|" conceal
    3              0.000014000   syn match helpBacktick	contained "`" conceal
    3              0.000008000   syn match helpStar		contained "\*" conceal
                            else
                              syn match helpBar		contained "|"
                              syn match helpBacktick	contained "`"
                              syn match helpStar		contained "\*"
    3              0.000001000 endif
    3              0.000012000 syn match helpNormal		"|.*====*|"
    3              0.000008000 syn match helpNormal		"|||"
    3              0.000011000 syn match helpNormal		":|vim:|"	" for :help modeline
    3              0.000015000 syn match helpVim		"\<Vim version [0-9][0-9.a-z]*"
    3              0.000012000 syn match helpVim		"VIM REFERENCE.*"
    3              0.000012000 syn match helpVim		"MACVIM REFERENCE.*"
    3              0.000014000 syn match helpOption		"'[a-z]\{2,\}'"
    3              0.000009000 syn match helpOption		"'t_..'"
    3              0.000015000 syn match helpNormal		"'ab'"
    3              0.000021000 syn match helpCommand		"`[^` \t]\+`"hs=s+1,he=e-1 contains=helpBacktick
    3              0.000027000 syn match helpCommand		"\(^\|[^a-z"[]\)\zs`[^`]\+`\ze\([^a-z\t."']\|$\)"hs=s+1,he=e-1 contains=helpBacktick
    3              0.000021000 syn match helpHeader		"\s*\zs.\{-}\ze\s\=\~$" nextgroup=helpIgnore
    3              0.000017000 syn match helpGraphic		".* \ze`$" nextgroup=helpIgnore
    3              0.000006000 if has("conceal")
    3              0.000008000   syn match helpIgnore		"." contained conceal
                            else
                              syn match helpIgnore		"." contained
    3              0.000001000 endif
    3              0.000017000 syn keyword helpNote		note Note NOTE note: Note: NOTE: Notes Notes:
    3              0.000011000 syn keyword helpWarning		WARNING WARNING: Warning:
    3              0.000015000 syn keyword helpDeprecated	DEPRECATED DEPRECATED: Deprecated:
    3              0.000009000 syn match helpSpecial		"\<N\>"
    3              0.000008000 syn match helpSpecial		"\<N\.$"me=e-1
    3              0.000007000 syn match helpSpecial		"\<N\.\s"me=e-2
    3              0.000010000 syn match helpSpecial		"(N\>"ms=s+1
                            
    3              0.000008000 syn match helpSpecial		"\[N]"
                            " avoid highlighting N  N in help.txt
    3              0.000008000 syn match helpSpecial		"N  N"he=s+1
    3              0.000007000 syn match helpSpecial		"Nth"me=e-2
    3              0.000006000 syn match helpSpecial		"N-1"me=e-2
    3              0.000023000 syn match helpSpecial		"{[-a-zA-Z0-9'"*+/:%#=[\]<>.,]\+}"
    3              0.000018000 syn match helpSpecial		"\s\[[-a-z^A-Z0-9_]\{2,}]"ms=s+1
    3              0.000012000 syn match helpSpecial		"<[-a-zA-Z0-9_]\+>"
    3              0.000008000 syn match helpSpecial		"<[SCM]-.>"
    3              0.000008000 syn match helpNormal		"<---*>"
    3              0.000008000 syn match helpSpecial		"\[range]"
    3              0.000008000 syn match helpSpecial		"\[line]"
    3              0.000008000 syn match helpSpecial		"\[count]"
    3              0.000010000 syn match helpSpecial		"\[offset]"
    3              0.000007000 syn match helpSpecial		"\[cmd]"
    3              0.000013000 syn match helpNormal		"vim9\[cmd]"
    3              0.000007000 syn match helpSpecial		"\[num]"
    3              0.000008000 syn match helpSpecial		"\[+num]"
    3              0.000006000 syn match helpSpecial		"\[-num]"
    3              0.000007000 syn match helpSpecial		"\[+cmd]"
    3              0.000008000 syn match helpSpecial		"\[++opt]"
    3              0.000008000 syn match helpSpecial		"\[arg]"
    3              0.000009000 syn match helpSpecial		"\[arguments]"
    3              0.000007000 syn match helpSpecial		"\[ident]"
    3              0.000008000 syn match helpSpecial		"\[addr]"
    3              0.000008000 syn match helpSpecial		"\[group]"
                            " Don't highlight [converted] and others that do not have a tag
    3              0.000022000 syn match helpNormal		"\[\(readonly\|fifo\|socket\|converted\|crypted\)]"
                            
    3              0.000008000 syn match helpSpecial		"CTRL-."
    3              0.000014000 syn match helpSpecial		"CTRL-SHIFT-."
    3              0.000015000 syn match helpSpecial		"CTRL-Break"
    3              0.000008000 syn match helpSpecial		"CTRL-PageUp"
    3              0.000010000 syn match helpSpecial		"CTRL-PageDown"
    3              0.000008000 syn match helpSpecial		"CTRL-Insert"
    3              0.000007000 syn match helpSpecial		"CTRL-Del"
    3              0.000009000 syn match helpSpecial		"CTRL-{char}"
    3              0.000041000 syn region helpNotVi		start="{Vi[: ]" start="{not" start="{only" end="}" contains=helpLeadBlank,helpHyperTextJump
    3              0.000010000 syn match helpLeadBlank		"^\s\+" contained
                            
                            " Highlight group items in their own color.
    3              0.000015000 syn match helpComment		"\t[* ]Comment\t\+[a-z].*"
    3              0.000012000 syn match helpConstant		"\t[* ]Constant\t\+[a-z].*"
    3              0.000011000 syn match helpString		"\t[* ]String\t\+[a-z].*"
    3              0.000013000 syn match helpCharacter		"\t[* ]Character\t\+[a-z].*"
    3              0.000010000 syn match helpNumber		"\t[* ]Number\t\+[a-z].*"
    3              0.000011000 syn match helpBoolean		"\t[* ]Boolean\t\+[a-z].*"
    3              0.000011000 syn match helpFloat		"\t[* ]Float\t\+[a-z].*"
    3              0.000013000 syn match helpIdentifier	"\t[* ]Identifier\t\+[a-z].*"
    3              0.000011000 syn match helpFunction		"\t[* ]Function\t\+[a-z].*"
    3              0.000013000 syn match helpStatement		"\t[* ]Statement\t\+[a-z].*"
    3              0.000016000 syn match helpConditional	"\t[* ]Conditional\t\+[a-z].*"
    3              0.000015000 syn match helpRepeat		"\t[* ]Repeat\t\+[a-z].*"
    3              0.000016000 syn match helpLabel		"\t[* ]Label\t\+[a-z].*"
    3              0.000013000 syn match helpOperator		"\t[* ]Operator\t\+["a-z].*"
    3              0.000011000 syn match helpKeyword		"\t[* ]Keyword\t\+[a-z].*"
    3              0.000011000 syn match helpException		"\t[* ]Exception\t\+[a-z].*"
    3              0.000010000 syn match helpPreProc		"\t[* ]PreProc\t\+[a-z].*"
    3              0.000010000 syn match helpInclude		"\t[* ]Include\t\+[a-z].*"
    3              0.000012000 syn match helpDefine		"\t[* ]Define\t\+[a-z].*"
    3              0.000011000 syn match helpMacro		"\t[* ]Macro\t\+[a-z].*"
    3              0.000011000 syn match helpPreCondit		"\t[* ]PreCondit\t\+[a-z].*"
    3              0.000012000 syn match helpType		"\t[* ]Type\t\+[a-z].*"
    3              0.000021000 syn match helpStorageClass	"\t[* ]StorageClass\t\+[a-z].*"
    3              0.000011000 syn match helpStructure		"\t[* ]Structure\t\+[a-z].*"
    3              0.000012000 syn match helpTypedef		"\t[* ]Typedef\t\+[Aa-z].*"
    3              0.000009000 syn match helpSpecial		"\t[* ]Special\t\+[a-z].*"
    3              0.000013000 syn match helpSpecialChar	"\t[* ]SpecialChar\t\+[a-z].*"
    3              0.000020000 syn match helpTag		"\t[* ]Tag\t\+[a-z].*"
    3              0.000010000 syn match helpDelimiter		"\t[* ]Delimiter\t\+[a-z].*"
    3              0.000013000 syn match helpSpecialComment	"\t[* ]SpecialComment\t\+[a-z].*"
    3              0.000011000 syn match helpDebug		"\t[* ]Debug\t\+[a-z].*"
    3              0.000011000 syn match helpUnderlined	"\t[* ]Underlined\t\+[a-z].*"
    3              0.000010000 syn match helpError		"\t[* ]Error\t\+[a-z].*"
    3              0.000013000 syn match helpTodo		"\t[* ]Todo\t\+[a-z].*"
                            
    3              0.000046000 syn match helpURL `\v<(((https?|ftp|gopher)://|(mailto|file|news):)[^' 	<>"]+|(www|web|w3)[a-z0-9_-]*\.[a-z0-9._-]+\.[^' 	<>"]+)[a-zA-Z0-9/]`
                            
    3              0.000014000 syn match helpDiffAdded		"\t[* ]Added\t\+[a-z].*"
    3              0.000015000 syn match helpDiffChanged	"\t[* ]Changed\t\+[a-z].*"
    3              0.000011000 syn match helpDiffRemoved	"\t[* ]Removed\t\+[a-z].*"
                            
                            " Additionally load a language-specific syntax file "help_ab.vim".
    3              0.000029000 let s:i = match(expand("%"), '\.\a\ax$')
    3              0.000005000 if s:i > 0
                              exe "runtime syntax/help_" . strpart(expand("%"), s:i + 1, 2) . ".vim"
    3              0.000003000 endif
                            
                            " Italian
    3              0.000024000 if v:lang =~ '\<IT\>' || v:lang =~ '_IT\>' || v:lang =~? "italian"
                              syn keyword helpNote		nota Nota NOTA nota: Nota: NOTA: notare Notare NOTARE notare: Notare: NOTARE:
                              syn match helpSpecial		"Nma"me=e-2
                              syn match helpSpecial		"Nme"me=e-2
                              syn match helpSpecial		"Nmi"me=e-2
                              syn match helpSpecial		"Nmo"me=e-2
                              syn match helpSpecial		"\[interv.]"
                              syn region helpNotVi		start="{non" start="{solo" start="{disponibile" end="}" contains=helpLeadBlank,helpHyperTextJump
    3              0.000003000 endif
                            
    3              0.000006000 syn sync minlines=40
                            
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
    3              0.000035000 hi def link helpIgnore		Ignore
    3              0.000014000 hi def link helpHyperTextJump	Identifier
    3              0.000012000 hi def link helpBar		Ignore
    3              0.000011000 hi def link helpBacktick	Ignore
    3              0.000012000 hi def link helpStar		Ignore
    3              0.000013000 hi def link helpHyperTextEntry	String
    3              0.000014000 hi def link helpHeadline	Statement
    3              0.000011000 hi def link helpHeader		PreProc
    3              0.000013000 hi def link helpSectionDelim	PreProc
    3              0.000011000 hi def link helpVim		Identifier
    3              0.000012000 hi def link helpCommand		Comment
    3              0.000013000 hi def link helpExample		Comment
    3              0.000012000 hi def link helpOption		Type
    3              0.000013000 hi def link helpNotVi		Special
    3              0.000011000 hi def link helpSpecial		Special
    3              0.000012000 hi def link helpNote		Todo
    3              0.000010000 hi def link helpWarning		Todo
    3              0.000012000 hi def link helpDeprecated	Todo
                            
    3              0.000012000 hi def link helpComment		Comment
    3              0.000013000 hi def link helpConstant	Constant
    3              0.000010000 hi def link helpString		String
    3              0.000012000 hi def link helpCharacter	Character
    3              0.000012000 hi def link helpNumber		Number
    3              0.000010000 hi def link helpBoolean		Boolean
    3              0.000013000 hi def link helpFloat		Float
    3              0.000011000 hi def link helpIdentifier	Identifier
    3              0.000011000 hi def link helpFunction	Function
    3              0.000012000 hi def link helpStatement	Statement
    3              0.000011000 hi def link helpConditional	Conditional
    3              0.000011000 hi def link helpRepeat		Repeat
    3              0.000011000 hi def link helpLabel		Label
    3              0.000011000 hi def link helpOperator	Operator
    3              0.000010000 hi def link helpKeyword		Keyword
    3              0.000011000 hi def link helpException	Exception
    3              0.000011000 hi def link helpPreProc		PreProc
    3              0.000010000 hi def link helpInclude		Include
    3              0.000011000 hi def link helpDefine		Define
    3              0.000016000 hi def link helpMacro		Macro
    3              0.000011000 hi def link helpPreCondit	PreCondit
    3              0.000011000 hi def link helpType		Type
    3              0.000012000 hi def link helpStorageClass	StorageClass
    3              0.000011000 hi def link helpStructure	Structure
    3              0.000010000 hi def link helpTypedef		Typedef
    3              0.000011000 hi def link helpSpecialChar	SpecialChar
    3              0.000010000 hi def link helpTag		Tag
    3              0.000011000 hi def link helpDelimiter	Delimiter
    3              0.000010000 hi def link helpSpecialComment	SpecialComment
    3              0.000011000 hi def link helpDebug		Debug
    3              0.000011000 hi def link helpUnderlined	Underlined
    3              0.000011000 hi def link helpError		Error
    3              0.000010000 hi def link helpTodo		Todo
    3              0.000011000 hi def link helpURL		String
    3              0.000011000 hi def link helpDiffAdded	Added
    3              0.000011000 hi def link helpDiffChanged	Changed
    3              0.000010000 hi def link helpDiffRemoved	Removed
                            
    3              0.000064000 if has('textprop') && expand('%:p') =~ '[/\\]doc[/\\]syntax.txt'
                              " highlight groups with their respective color
                              import 'dist/vimhelp.vim'
                              call vimhelp.HighlightGroups()
    3              0.000003000 endif
                            
    3              0.000006000 let b:current_syntax = "help"
                            
    3              0.000011000 let &cpo = s:cpo_save
    3              0.000006000 unlet s:cpo_save
                            " vim: ts=8 sw=2

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/help/alex.vim
Sourced 1 time
Total time:   0.000898000
 Self time:   0.000898000

count     total (s)      self (s)
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: alex for help files
                            
    1              0.000791000 call ale#handlers#alex#DefineLinter('help', '--text')

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/handlers/alex.vim
Sourced 1 time
Total time:   0.000247000
 Self time:   0.000247000

count     total (s)      self (s)
    1              0.000003000 scriptencoding utf-8
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: Error handling for errors in alex output format
                            
    1              0.000005000 function! ale#handlers#alex#GetExecutable(buffer) abort
                                return ale#path#FindExecutable(a:buffer, 'alex', [
                                \   'node_modules/.bin/alex',
                                \   'node_modules/alex/cli.js',
                                \])
                            endfunction
                            
    1              0.000003000 function! ale#handlers#alex#CreateCommandCallback(flags) abort
                                return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))
                                \            . ' --stdin '
                                \            . a:flags
                                \}
                            endfunction
                            
    1              0.000002000 function! ale#handlers#alex#Handle(buffer, lines) abort
                                " Example output:
                                "       6:256-6:262  warning  Be careful with “killed”, it’s profane in some cases      killed           retext-profanities
                                let l:pattern = '\v^ *(\d+):(\d+)-(\d+):(\d+) +warning +(.{-})  +(.{-})  +(.{-})$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'end_lnum': l:match[3] + 0,
                                    \   'end_col': l:match[4] - 1,
                                    \   'text': l:match[5] . ' (' . (l:match[7]) . ')',
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define a linter for a specific filetype. Accept flags to adapt to the filetype.
                            "    no flags  treat input as markdown
                            "    --html    treat input as HTML
                            "    --mdx     treat input as MDX
                            "    --text    treat input as plaintext
    1              0.000002000 function! ale#handlers#alex#DefineLinter(filetype, flags) abort
                                call ale#Set('alex_executable', 'alex')
                                call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'alex',
                                \   'executable': function('ale#handlers#alex#GetExecutable'),
                                \   'command': ale#handlers#alex#CreateCommandCallback(a:flags),
                                \   'output_stream': 'stderr',
                                \   'callback': 'ale#handlers#alex#Handle',
                                \})
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/help/cspell.vim
Sourced 1 time
Total time:   0.001709000
 Self time:   0.001709000

count     total (s)      self (s)
    1              0.000002000 scriptencoding utf-8
                            " Author: David Houston <houstdav000>
                            " Description: cspell support for help files.
                            
    1              0.001569000 call ale#handlers#cspell#DefineLinter('help')

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/handlers/cspell.vim
Sourced 1 time
Total time:   0.000992000
 Self time:   0.000992000

count     total (s)      self (s)
    1              0.000006000 scriptencoding utf-8
                            " Author: David Houston <houstdav000>
                            " Description: Define a handler function for cspell's output
                            
    1              0.000007000 function! ale#handlers#cspell#GetExecutable(buffer) abort
                                return ale#path#FindExecutable(a:buffer,
                                \    'cspell', [
                                \        'node_modules/.bin/cspell',
                                \        'node_modules/cspell/bin.js',
                                \    ]
                                \)
                            endfunction
                            
    1              0.000002000 function! ale#handlers#cspell#GetLanguageId(buffer) abort
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                if l:filetype is# 'tex'
                                    " Vim's tex corresponds to latex language-id in cspell
                                    return 'latex'
                                elseif l:filetype is# 'plaintex'
                                    " Vim's plaintex corresponds to tex language-id in cspell
                                    return 'tex'
                                else
                                    " Fallback to filetype for everything else.
                                    return l:filetype
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#handlers#cspell#GetCommand(buffer) abort
                                let l:executable = ale#handlers#cspell#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'cspell_options')
                                let l:language_id = ale#handlers#cspell#GetLanguageId(a:buffer)
                            
                                let l:language_id_option = empty(l:language_id) ? '' : '--language-id="' . l:language_id . '"'
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \   . ' lint --no-color --no-progress --no-summary'
                                \   . ale#Pad(l:language_id_option)
                                \   . ale#Pad(l:options)
                                \   . ' -- stdin'
                            endfunction
                            
    1              0.000002000 function! ale#handlers#cspell#Handle(buffer, lines) abort
                                " Look for lines like the following:
                                "
                                " /home/user/repos/ale/README.md:3:128 - Unknown word (Neovim)
                                " match1: 3
                                " match2: 128
                                " match3: Unknown word (Neovim)
                                " match4: Neovim
                                let l:pattern = '\v^.*:(\d+):(\d+) - ([^\(]+\(([^\)]+)\).*)$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'end_col': l:match[2] + len(l:match[4]) - 1,
                                    \   'text': l:match[3],
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1              0.000002000 function! ale#handlers#cspell#DefineLinter(filetype) abort
                                call ale#Set('cspell_executable', 'cspell')
                                call ale#Set('cspell_options', '')
                                call ale#Set('cspell_use_global', get(g:, 'ale_use_global_executables', 0))
                            
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'cspell',
                                \   'executable': function('ale#handlers#cspell#GetExecutable'),
                                \   'command': function('ale#handlers#cspell#GetCommand'),
                                \   'callback': 'ale#handlers#cspell#Handle',
                                \})
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/help/proselint.vim
Sourced 1 time
Total time:   0.000326000
 Self time:   0.000144000

count     total (s)      self (s)
                            " Author: Daniel M. Capella https://github.com/polyzen
                            " Description: proselint for Vim help files
                            
    1   0.000193000   0.000011000 call ale#linter#Define('help', {
                            \   'name': 'proselint',
                            \   'executable': 'proselint',
                            \   'command': 'proselint %t',
                            \   'callback': 'ale#handlers#unix#HandleAsWarning',
                            \})

SCRIPT  /Users/danbradbury/.vim/bundle/ale/ale_linters/help/writegood.vim
Sourced 1 time
Total time:   0.000688000
 Self time:   0.000688000

count     total (s)      self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: write-good for vim Help files
                            
    1              0.000567000 call ale#handlers#writegood#DefineLinter('help')

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/handlers/writegood.vim
Sourced 1 time
Total time:   0.000229000
 Self time:   0.000198000

count     total (s)      self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: Error handling for errors in the write-good format.
                            
    1              0.000003000 function! ale#handlers#writegood#ResetOptions() abort
                                call ale#Set('writegood_options', '')
                                call ale#Set('writegood_executable', 'write-good')
                                call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))
                            endfunction
                            
                            " Reset the options so the tests can test how they are set.
    1   0.000039000   0.000008000 call ale#handlers#writegood#ResetOptions()
                            
    1              0.000002000 function! ale#handlers#writegood#GetExecutable(buffer) abort
                                return ale#path#FindExecutable(a:buffer, 'writegood', [
                                \   'node_modules/.bin/write-good',
                                \   'node_modules/write-good/bin/write-good.js',
                                \])
                            endfunction
                            
    1              0.000002000 function! ale#handlers#writegood#GetCommand(buffer) abort
                                let l:executable = ale#handlers#writegood#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'writegood_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \   . (!empty(l:options) ? ' ' . l:options : '')
                                \   . ' %t'
                            endfunction
                            
    1              0.000002000 function! ale#handlers#writegood#Handle(buffer, lines) abort
                                " Look for lines like the following.
                                "
                                " "it is" is wordy or unneeded on line 20 at column 53
                                " "easily" can weaken meaning on line 154 at column 29
                                let l:marks_pattern = '\v^ *(\^+) *$'
                                let l:pattern = '\v^(".*"\s.*)\son\sline\s(\d+)\sat\scolumn\s(\d+)$'
                                let l:output = []
                                let l:last_len = 0
                            
                                for l:match in ale#util#GetMatches(a:lines, [l:marks_pattern, l:pattern])
                                    if empty(l:match[2])
                                        let l:last_len = len(l:match[1])
                                    else
                                        let l:col = l:match[3] + 1
                            
                                        " Add the linter error. Note that we need to add 1 to the col because
                                        " write-good reports the column corresponding to the space before the
                                        " offending word or phrase.
                                        call add(l:output, {
                                        \   'text': l:match[1],
                                        \   'lnum': l:match[2] + 0,
                                        \   'col': l:col,
                                        \   'end_col': l:last_len ? (l:col + l:last_len - 1) : l:col,
                                        \   'type': 'W',
                                        \})
                            
                                        let l:last_len = 0
                                    endif
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define the writegood linter for a given filetype.
    1              0.000002000 function! ale#handlers#writegood#DefineLinter(filetype) abort
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'writegood',
                                \   'aliases': ['write-good'],
                                \   'executable': function('ale#handlers#writegood#GetExecutable'),
                                \   'command': function('ale#handlers#writegood#GetCommand'),
                                \   'callback': 'ale#handlers#writegood#Handle',
                                \})
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/auth.vim
Sourced 1 time
Total time:   0.000334000
 Self time:   0.000334000

count     total (s)      self (s)
    1              0.000002000 vim9script
                            
    1              0.000102000 import autoload 'copilot_chat/api.vim' as api
    1              0.000103000 import autoload 'copilot_chat/config.vim' as config
                            
    1              0.000013000 var device_token_file: string = $'{g:copilot_chat_data_dir}/.device_token'
    1              0.000004000 var chat_token_file: string = $'{g:copilot_chat_data_dir}/.chat_token'
                            
    1              0.000004000 export def VerifySignin(): string
                              var chat_token: string = GetChatToken(false)
                              try
                                api.FetchModels(chat_token)
                              catch
                                chat_token = GetChatToken(true)
                              endtry
                              return chat_token
                            enddef
                            
    1              0.000005000 def GetChatToken(fetch_new: bool): any
                              if filereadable(chat_token_file) && fetch_new == false
                                return join(readfile(chat_token_file), "\n")
                              else
                                config.CreateDataDir()
                                var bearer_token = GetBearerToken()
                                var token_url = 'https://api.github.com/copilot_internal/v2/token'
                                var token_headers = [
                                  'Content-Type: application/json',
                                  'Editor-Version: vscode/1.80.1',
                                  $'Authorization: token {bearer_token}'
                                ]
                                var token_data = {
                                  'client_id': 'Iv1.b507a08c87ecfe98',
                                  'scope': 'read:user'
                                }
                                var response = api.Http('GET', token_url, token_headers, token_data)
                                var json_response = json_decode(response)
                                try
                                  var chat_token = json_response.token
                                  writefile([chat_token], chat_token_file)
                                  return chat_token
                                catch
                                  echom json_response.message
                                  return null
                                endtry
                              endif
                            enddef
                            
    1              0.000003000 def GetBearerToken(): string
                              if filereadable(device_token_file)
                                return join(readfile(device_token_file), "\n")
                              else
                                var response = GetDeviceToken()
                                var json_response = json_decode(response)
                                var device_code = json_response.device_code
                                var user_code = json_response.user_code
                                var verification_uri = json_response.verification_uri
                            
                                echo 'Please visit ' .. verification_uri .. ' and enter the code: ' .. user_code
                                input("Press Enter to continue...\n")
                            
                                var token_poll_url = 'https://github.com/login/oauth/access_token'
                                var token_poll_data = {
                                  'client_id': 'Iv1.b507a08c87ecfe98',
                                  'device_code': device_code,
                                  'grant_type': 'urn:ietf:params:oauth:grant-type:device_code'
                                }
                                var token_headers = [
                                  'Accept: application/json',
                                  'User-Agent: GithubCopilot/1.155.0',
                                  'Accept-Encoding: gzip,deflate,br',
                                  'Editor-Plugin-Version: copilot.vim/1.16.0',
                                  'Editor-Version: vim/9.0.1',
                                  'Content-Type: application/json'
                                ]
                            
                                var access_token_response = api.Http('POST', token_poll_url, token_headers, token_poll_data)
                                json_response = json_decode(access_token_response)
                                var bearer_token = json_response.access_token
                                call writefile([bearer_token], device_token_file)
                            
                                return bearer_token
                              endif
                            enddef
                            
    1              0.000002000 def GetDeviceToken(): string
                              var token_url = 'https://github.com/login/device/code'
                              var headers = [
                                'Accept: application/json',
                                'User-Agent: GithubCopilot/1.155.0',
                                'Accept-Encoding: gzip, deflate, br',
                                'Editor-Plugin-Version: copilot.vim/1.16.0',
                                'Editor-Version: Neovim/0.6.1',
                                'Content-Type: application/json',
                              ]
                              var data = {
                                'client_id': 'Iv1.b507a08c87ecfe98',
                                'scope': 'read: user'
                              }
                            
                              return api.Http('POST', token_url, headers, data)
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/ftplugin/copilot_chat.vim
Sourced 3 times
Total time:   0.000429000
 Self time:   0.000429000

count     total (s)      self (s)
    3              0.000125000 vim9script
                            
    3              0.000037000 setlocal wrap nonumber norelativenumber nobreakindent
                            
    3              0.000024000 if exists('g:copilot_chat_disable_mappings') && g:copilot_chat_disable_mappings == 1
                              finish
    3              0.000004000 endif
                            
    3              0.000026000 nnoremap <buffer> <leader>cs :CopilotChatSubmit<CR>
    3              0.000018000 nnoremap <buffer> <CR> :CopilotChatSubmit<CR>

SCRIPT  /Users/danbradbury/.vim/bundle/copilot-chat.vim/syntax/copilot_chat.vim
Sourced 3 times
Total time:   0.000820000
 Self time:   0.000820000

count     total (s)      self (s)
    3              0.000094000 vim9script
    3              0.000015000 scriptencoding utf-8
                            
    3              0.000074000 syntax match CopilotWelcome /^Welcome to Copilot Chat!.*$/
    3              0.000025000 syntax match CopilotSeparatorIcon /^/
    3              0.000012000 syntax match CopilotSeparatorIcon /^/
    3              0.000019000 syntax match CopilotSeparatorLine / ━\+$/
    3              0.000023000 syntax match CopilotWaiting /Waiting for response\.*$/
    3              0.000016000 syntax match CopilotPrompt /^> .*/
    3              0.000024000 syntax match CopilotFiles /^#file:.*/
                            
    3              0.000042000 syntax match CopilotCodeFence /^```\(\s*\w\+\)\?$/ contains=CopilotCodeLang
    3              0.000012000 syntax match CopilotCodeLang /\w\+/ contained
    3              0.000016000 syntax match CopilotCodeFenceEnd /^```$/
                            
    3              0.000065000 highlight CopilotWaiting ctermfg=46 guifg=#33FF33
    3              0.000025000 highlight CopilotWelcome ctermfg=205 guifg=#ff69b4
    3              0.000023000 highlight CopilotSeparatorIcon ctermfg=45 guifg=#00d7ff
    3              0.000018000 highlight CopilotSeparatorLine ctermfg=205 guifg=#ff69b4
    3              0.000022000 highlight CopilotPrompt ctermfg=230 guifg=#FFFF33
    3              0.000018000 highlight CopilotCodeFence ctermfg=240 guifg=#585858
    3              0.000018000 highlight CopilotCodeFenceEnd ctermfg=240 guifg=#585858
    3              0.000021000 highlight CopilotCodeLang ctermfg=111 guifg=#87afff
    3              0.000022000 highlight CopilotFiles ctermfg=12 guifg=#1E90FF
                            
    3              0.000016000 if !exists('g:syntax_on')
                              syntax enable
    3              0.000011000 endif

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/lua.vim
Sourced 8 times
Total time:   0.010650000
 Self time:   0.010647000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2022 Sep 07
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    8              0.000064000 if exists("b:current_syntax")
                              finish
    8              0.000018000 endif
                            
    8              0.000031000 let s:cpo_save = &cpo
    8   0.000041000   0.000039000 set cpo&vim
                            
    8              0.000022000 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000003000   let lua_version = 5
    1              0.000003000   let lua_subversion = 3
    7              0.000015000 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    8              0.000005000 endif
                            
    8              0.000007000 syn case match
                            
                            " syncing method
    8              0.000014000 syn sync minlines=1000
                            
    8              0.000015000 if lua_version >= 5
    8              0.000043000   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    8              0.000021000   syn keyword luaMetaMethod __eq __lt __le
    8              0.000024000   syn keyword luaMetaMethod __index __newindex __call
    8              0.000021000   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    8              0.000005000 endif
                            
    8              0.000023000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    8              0.000016000   syn keyword luaMetaMethod __mod __len
    8              0.000007000 endif
                            
    8              0.000017000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    8              0.000016000   syn keyword luaMetaMethod __pairs
    8              0.000003000 endif
                            
    8              0.000016000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    8              0.000019000   syn keyword luaMetaMethod __idiv __name
    8              0.000025000   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    8              0.000005000 endif
                            
    8              0.000023000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    8              0.000005000 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    8              0.000072000 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    8              0.000023000 syn match  luaParenError ")"
    8              0.000025000 syn match  luaError "}"
    8              0.000051000 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    8              0.000065000 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    8              0.000053000 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    8              0.000052000 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    8              0.000068000 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    8              0.000071000 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    8              0.000053000 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    8              0.000091000 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    8              0.000072000 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    8              0.000067000 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    8              0.000037000 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    8              0.000023000 syn keyword luaStatement return local break
    8              0.000021000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    8              0.000021000   syn keyword luaStatement goto
    8              0.000034000   syn match luaLabel "::\I\i*::"
    8              0.000002000 endif
                            
                            " operators
    8              0.000029000 syn keyword luaOperator and or not
                            
    8              0.000018000 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    8              0.000047000   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    8              0.000004000 endif
                            
                            " comments
    8              0.000030000 syn keyword luaTodo            contained TODO FIXME XXX
    8              0.000056000 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    8              0.000037000 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    8              0.000020000 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    8              0.000079000   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    8              0.000006000 endif
                            
                            " first line may start with #!
    8              0.000029000 syn match luaComment "\%^#!.*"
                            
    8              0.000025000 syn keyword luaConstant nil
    8              0.000009000 if lua_version > 4
    8              0.000021000   syn keyword luaConstant true false
    8              0.000008000 endif
                            
                            " strings
    8              0.000058000 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    8              0.000008000 if lua_version == 5
    8              0.000011000   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    8              0.000007000   else
    8              0.000009000     if lua_subversion >= 2
    8              0.000034000       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    8              0.000006000     endif
    8              0.000010000     if lua_subversion >= 3
    8              0.000109000       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    8              0.000008000     endif
    8              0.000057000     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    8              0.000006000   endif
    8              0.000006000 endif
    8              0.000074000 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    8              0.000063000 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    8              0.000031000 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    8              0.000045000 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    8              0.000037000 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    8              0.000033000 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    8              0.000011000 if lua_version >= 5
    8              0.000010000   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    8              0.000010000   elseif lua_subversion >= 2
    8              0.000044000     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    8              0.000004000   endif
    8              0.000006000 endif
                            
                            " tables
    8              0.000081000 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    8              0.000037000 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    8              0.000034000 syn keyword luaFunc assert collectgarbage dofile error next
    8              0.000034000 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    8              0.000011000 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    8              0.000010000 elseif lua_version == 5
    8              0.000025000   syn keyword luaFunc getmetatable setmetatable
    8              0.000017000   syn keyword luaFunc ipairs pairs
    8              0.000020000   syn keyword luaFunc pcall xpcall
    8              0.000022000   syn keyword luaFunc _G loadfile rawequal require
    8              0.000010000   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    8              0.000008000   else
    8              0.000021000     syn keyword luaFunc load select
    8              0.000029000     syn match   luaFunc /\<package\.cpath\>/
    8              0.000029000     syn match   luaFunc /\<package\.loaded\>/
    8              0.000027000     syn match   luaFunc /\<package\.loadlib\>/
    8              0.000029000     syn match   luaFunc /\<package\.path\>/
    8              0.000024000     syn match   luaFunc /\<package\.preload\>/
    8              0.000011000     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    8              0.000011000     elseif lua_subversion >= 2
    8              0.000017000       syn keyword luaFunc _ENV rawlen
    8              0.000025000       syn match   luaFunc /\<package\.config\>/
    8              0.000032000       syn match   luaFunc /\<package\.preload\>/
    8              0.000031000       syn match   luaFunc /\<package\.searchers\>/
    8              0.000028000       syn match   luaFunc /\<package\.searchpath\>/
    8              0.000003000     endif
                            
    8              0.000010000     if lua_subversion >= 3
    8              0.000032000       syn match luaFunc /\<coroutine\.isyieldable\>/
    8              0.000007000     endif
    8              0.000009000     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    8              0.000006000     endif
    8              0.000029000     syn match luaFunc /\<coroutine\.running\>/
    8              0.000007000   endif
    8              0.000030000   syn match   luaFunc /\<coroutine\.create\>/
    8              0.000026000   syn match   luaFunc /\<coroutine\.resume\>/
    8              0.000031000   syn match   luaFunc /\<coroutine\.status\>/
    8              0.000027000   syn match   luaFunc /\<coroutine\.wrap\>/
    8              0.000027000   syn match   luaFunc /\<coroutine\.yield\>/
                            
    8              0.000030000   syn match   luaFunc /\<string\.byte\>/
    8              0.000025000   syn match   luaFunc /\<string\.char\>/
    8              0.000024000   syn match   luaFunc /\<string\.dump\>/
    8              0.000025000   syn match   luaFunc /\<string\.find\>/
    8              0.000028000   syn match   luaFunc /\<string\.format\>/
    8              0.000024000   syn match   luaFunc /\<string\.gsub\>/
    8              0.000025000   syn match   luaFunc /\<string\.len\>/
    8              0.000028000   syn match   luaFunc /\<string\.lower\>/
    8              0.000023000   syn match   luaFunc /\<string\.rep\>/
    8              0.000030000   syn match   luaFunc /\<string\.sub\>/
    8              0.000026000   syn match   luaFunc /\<string\.upper\>/
    8              0.000010000   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    8              0.000006000   else
    8              0.000026000     syn match luaFunc /\<string\.gmatch\>/
    8              0.000024000     syn match luaFunc /\<string\.match\>/
    8              0.000026000     syn match luaFunc /\<string\.reverse\>/
    8              0.000005000   endif
    8              0.000009000   if lua_subversion >= 3
    8              0.000026000     syn match luaFunc /\<string\.pack\>/
    8              0.000025000     syn match luaFunc /\<string\.packsize\>/
    8              0.000028000     syn match luaFunc /\<string\.unpack\>/
    8              0.000025000     syn match luaFunc /\<utf8\.char\>/
    8              0.000032000     syn match luaFunc /\<utf8\.charpattern\>/
    8              0.000025000     syn match luaFunc /\<utf8\.codes\>/
    8              0.000027000     syn match luaFunc /\<utf8\.codepoint\>/
    8              0.000023000     syn match luaFunc /\<utf8\.len\>/
    8              0.000027000     syn match luaFunc /\<utf8\.offset\>/
    8              0.000004000   endif
                            
    8              0.000008000   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    8              0.000009000   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    8              0.000011000   elseif lua_subversion >= 2
    8              0.000023000     syn match luaFunc /\<table\.pack\>/
    8              0.000027000     syn match luaFunc /\<table\.unpack\>/
    8              0.000009000     if lua_subversion >= 3
    8              0.000024000       syn match luaFunc /\<table\.move\>/
    8              0.000004000     endif
    8              0.000006000   endif
    8              0.000024000   syn match   luaFunc /\<table\.concat\>/
    8              0.000026000   syn match   luaFunc /\<table\.insert\>/
    8              0.000022000   syn match   luaFunc /\<table\.sort\>/
    8              0.000028000   syn match   luaFunc /\<table\.remove\>/
                            
    8              0.000009000   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    8              0.000006000   endif
                            
    8              0.000025000   syn match   luaFunc /\<math\.abs\>/
    8              0.000032000   syn match   luaFunc /\<math\.acos\>/
    8              0.000023000   syn match   luaFunc /\<math\.asin\>/
    8              0.000024000   syn match   luaFunc /\<math\.atan\>/
    8              0.000010000   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    8              0.000005000   endif
    8              0.000021000   syn match   luaFunc /\<math\.ceil\>/
    8              0.000024000   syn match   luaFunc /\<math\.sin\>/
    8              0.000022000   syn match   luaFunc /\<math\.cos\>/
    8              0.000022000   syn match   luaFunc /\<math\.tan\>/
    8              0.000021000   syn match   luaFunc /\<math\.deg\>/
    8              0.000023000   syn match   luaFunc /\<math\.exp\>/
    8              0.000029000   syn match   luaFunc /\<math\.floor\>/
    8              0.000024000   syn match   luaFunc /\<math\.log\>/
    8              0.000024000   syn match   luaFunc /\<math\.max\>/
    8              0.000023000   syn match   luaFunc /\<math\.min\>/
    8              0.000009000   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    8              0.000009000   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    8              0.000006000   endif
    8              0.000008000   if lua_subversion >= 1
    8              0.000025000     syn match luaFunc /\<math\.huge\>/
    8              0.000033000     syn match luaFunc /\<math\.fmod\>/
    8              0.000021000     syn match luaFunc /\<math\.modf\>/
    8              0.000014000     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    8              0.000006000     endif
    8              0.000002000   endif
    8              0.000024000   syn match   luaFunc /\<math\.rad\>/
    8              0.000024000   syn match   luaFunc /\<math\.sqrt\>/
    8              0.000010000   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    8              0.000006000   else
    8              0.000028000     syn match   luaFunc /\<math\.maxinteger\>/
    8              0.000028000     syn match   luaFunc /\<math\.mininteger\>/
    8              0.000027000     syn match   luaFunc /\<math\.tointeger\>/
    8              0.000021000     syn match   luaFunc /\<math\.type\>/
    8              0.000024000     syn match   luaFunc /\<math\.ult\>/
    8              0.000004000   endif
    8              0.000025000   syn match   luaFunc /\<math\.random\>/
    8              0.000040000   syn match   luaFunc /\<math\.randomseed\>/
    8              0.000023000   syn match   luaFunc /\<math\.pi\>/
                            
    8              0.000024000   syn match   luaFunc /\<io\.close\>/
    8              0.000031000   syn match   luaFunc /\<io\.flush\>/
    8              0.000022000   syn match   luaFunc /\<io\.input\>/
    8              0.000024000   syn match   luaFunc /\<io\.lines\>/
    8              0.000022000   syn match   luaFunc /\<io\.open\>/
    8              0.000031000   syn match   luaFunc /\<io\.output\>/
    8              0.000024000   syn match   luaFunc /\<io\.popen\>/
    8              0.000025000   syn match   luaFunc /\<io\.read\>/
    8              0.000021000   syn match   luaFunc /\<io\.stderr\>/
    8              0.000024000   syn match   luaFunc /\<io\.stdin\>/
    8              0.000020000   syn match   luaFunc /\<io\.stdout\>/
    8              0.000025000   syn match   luaFunc /\<io\.tmpfile\>/
    8              0.000021000   syn match   luaFunc /\<io\.type\>/
    8              0.000025000   syn match   luaFunc /\<io\.write\>/
                            
    8              0.000025000   syn match   luaFunc /\<os\.clock\>/
    8              0.000022000   syn match   luaFunc /\<os\.date\>/
    8              0.000025000   syn match   luaFunc /\<os\.difftime\>/
    8              0.000024000   syn match   luaFunc /\<os\.execute\>/
    8              0.000020000   syn match   luaFunc /\<os\.exit\>/
    8              0.000022000   syn match   luaFunc /\<os\.getenv\>/
    8              0.000022000   syn match   luaFunc /\<os\.remove\>/
    8              0.000024000   syn match   luaFunc /\<os\.rename\>/
    8              0.000046000   syn match   luaFunc /\<os\.setlocale\>/
    8              0.000025000   syn match   luaFunc /\<os\.time\>/
    8              0.000041000   syn match   luaFunc /\<os\.tmpname\>/
                            
    8              0.000027000   syn match   luaFunc /\<debug\.debug\>/
    8              0.000028000   syn match   luaFunc /\<debug\.gethook\>/
    8              0.000026000   syn match   luaFunc /\<debug\.getinfo\>/
    8              0.000026000   syn match   luaFunc /\<debug\.getlocal\>/
    8              0.000029000   syn match   luaFunc /\<debug\.getupvalue\>/
    8              0.000026000   syn match   luaFunc /\<debug\.setlocal\>/
    8              0.000028000   syn match   luaFunc /\<debug\.setupvalue\>/
    8              0.000026000   syn match   luaFunc /\<debug\.sethook\>/
    8              0.000028000   syn match   luaFunc /\<debug\.traceback\>/
    8              0.000010000   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    8              0.000007000   endif
    8              0.000009000   if lua_subversion >= 1
    8              0.000030000     syn match luaFunc /\<debug\.getmetatable\>/
    8              0.000027000     syn match luaFunc /\<debug\.setmetatable\>/
    8              0.000028000     syn match luaFunc /\<debug\.getregistry\>/
    8              0.000009000     if lua_subversion >= 2
    8              0.000029000       syn match luaFunc /\<debug\.getuservalue\>/
    8              0.000027000       syn match luaFunc /\<debug\.setuservalue\>/
    8              0.000026000       syn match luaFunc /\<debug\.upvalueid\>/
    8              0.000030000       syn match luaFunc /\<debug\.upvaluejoin\>/
    8              0.000013000     endif
    8              0.000011000     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    8              0.000006000     endif
    8              0.000009000   endif
    8              0.000003000 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    8              0.000075000 hi def link luaStatement        Statement
    8              0.000051000 hi def link luaRepeat           Repeat
    8              0.000051000 hi def link luaFor              Repeat
    8              0.000046000 hi def link luaString           String
    8              0.000045000 hi def link luaString2          String
    8              0.000035000 hi def link luaStringDelimiter  luaString
    8              0.000043000 hi def link luaNumber           Number
    8              0.000045000 hi def link luaOperator         Operator
    8              0.000025000 hi def link luaSymbolOperator   luaOperator
    8              0.000047000 hi def link luaConstant         Constant
    8              0.000046000 hi def link luaCond             Conditional
    8              0.000045000 hi def link luaCondElse         Conditional
    8              0.000045000 hi def link luaFunction         Function
    8              0.000044000 hi def link luaMetaMethod       Function
    8              0.000046000 hi def link luaComment          Comment
    8              0.000025000 hi def link luaCommentDelimiter luaComment
    8              0.000043000 hi def link luaTodo             Todo
    8              0.000075000 hi def link luaTable            Structure
    8              0.000049000 hi def link luaError            Error
    8              0.000048000 hi def link luaParenError       Error
    8              0.000045000 hi def link luaSpecial          SpecialChar
    8              0.000047000 hi def link luaFunc             Identifier
    8              0.000045000 hi def link luaLabel            Label
                            
                            
    8              0.000019000 let b:current_syntax = "lua"
                            
    8   0.000039000   0.000038000 let &cpo = s:cpo_save
    8              0.000012000 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/perl.vim
Sourced 8 times
Total time:   0.035055000
 Self time:   0.035054000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:      Perl
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Homepage:      https://github.com/vim-perl/vim-perl
                            " Bugs/requests: https://github.com/vim-perl/vim-perl/issues
                            " License:       Vim License (see :help license)
                            " Last Change:   2022 Jun 13
                            " Contributors:  Andy Lester <andy@petdance.com>
                            "                Hinrik Örn Sigurðsson <hinrik.sig@gmail.com>
                            "                Lukas Mai <l.mai.web.de>
                            "                Nick Hibma <nick@van-laarhoven.org>
                            "                Sonia Heimann <niania@netsurf.org>
                            "                Rob Hoelz <rob@hoelz.ro>
                            "                Doug Kearns <dougkearns@gmail.com>
                            "                and many others.
                            "
                            " Please download the most recent version first, before mailing
                            " any comments.
                            "
                            " The following parameters are available for tuning the
                            " perl syntax highlighting, with defaults given:
                            "
                            " let perl_include_pod = 1
                            " unlet perl_no_scope_in_variables
                            " unlet perl_no_extended_vars
                            " unlet perl_string_as_statement
                            " unlet perl_no_sync_on_sub
                            " unlet perl_no_sync_on_global_var
                            " let perl_sync_dist = 100
                            " unlet perl_fold
                            " unlet perl_fold_blocks
                            " unlet perl_nofold_packages
                            " unlet perl_nofold_subs
                            " unlet perl_fold_anonymous_subs
                            " unlet perl_no_subprototype_error
                            
    8              0.000058000 if exists("b:current_syntax")
                              finish
    8              0.000007000 endif
                            
    8              0.000023000 let s:cpo_save = &cpo
    8   0.000033000   0.000032000 set cpo&vim
                            
                            " POD starts with ^=<word> and ends with ^=cut
                            
    8              0.000025000 if get(g:, 'perl_include_pod', 1)
                              " Include a while extra syntax file
    8              0.010684000   syn include @Pod syntax/pod.vim
    8              0.000011000   unlet b:current_syntax
    8              0.000027000   if get(g:, 'perl_fold', 1)
    8              0.000097000     syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend fold extend
    8              0.000055000     syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend fold extend
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend
                                syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend
    8              0.000008000   endif
                            else
                              " Use only the bare minimum of rules
                              if get(g:, 'perl_fold', 1)
                                syn region perlPOD start="^=[a-z]" end="^=cut" fold
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut"
                              endif
    8              0.000008000 endif
                            
                            
    8              0.000017000 syn cluster perlTop		contains=TOP
                            
    8              0.000035000 syn region perlBraces start="{" end="}" transparent extend
                            
                            " All keywords
                            "
    8              0.000053000 syn match perlConditional		"\<\%(if\|elsif\|unless\|given\|when\|default\)\>"
    8              0.000066000 syn match perlConditional		"\<else\%(\%(\_s\*if\>\)\|\>\)" contains=perlElseIfError skipwhite skipnl skipempty
    8              0.000053000 syn match perlRepeat			"\<\%(while\|for\%(each\)\=\|do\|until\|continue\)\>"
    8              0.000066000 syn match perlOperator			"\<\%(defined\|undef\|eq\|ne\|[gl][et]\|cmp\|not\|and\|or\|xor\|not\|bless\|ref\|do\)\>"
                            " for some reason, adding this as the nextgroup for perlControl fixes BEGIN
                            " folding issues...
    8              0.000027000 syn match perlFakeGroup 		"" contained
    8              0.000071000 syn match perlControl			"\<\%(BEGIN\|CHECK\|INIT\|END\|UNITCHECK\)\>\_s*" nextgroup=perlFakeGroup
                            
    8              0.000039000 syn match perlStatementStorage		"\<\%(my\|our\|local\|state\)\>"
    8              0.000044000 syn match perlStatementControl		"\<\%(return\|last\|next\|redo\|goto\|break\)\>"
    8              0.000076000 syn match perlStatementScalar		"\<\%(chom\=p\|chr\|crypt\|r\=index\|lc\%(first\)\=\|length\|ord\|pack\|sprintf\|substr\|fc\|uc\%(first\)\=\)\>"
    8              0.000038000 syn match perlStatementRegexp		"\<\%(pos\|quotemeta\|split\|study\)\>"
    8              0.000054000 syn match perlStatementNumeric		"\<\%(abs\|atan2\|cos\|exp\|hex\|int\|log\|oct\|rand\|sin\|sqrt\|srand\)\>"
    8              0.000062000 syn match perlStatementList		"\<\%(splice\|unshift\|shift\|push\|pop\|join\|reverse\|grep\|map\|sort\|unpack\)\>"
    8              0.000046000 syn match perlStatementHash		"\<\%(delete\|each\|exists\|keys\|values\)\>"
    8              0.000040000 syn match perlStatementIOfunc		"\<\%(syscall\|dbmopen\|dbmclose\)\>"
    8              0.000115000 syn match perlStatementFiledesc		"\<\%(binmode\|close\%(dir\)\=\|eof\|fileno\|getc\|lstat\|printf\=\|read\%(dir\|line\|pipe\)\|rewinddir\|say\|select\|stat\|tell\%(dir\)\=\|write\)\>" nextgroup=perlFiledescStatementNocomma skipwhite
    8              0.000098000 syn match perlStatementFiledesc		"\<\%(fcntl\|flock\|ioctl\|open\%(dir\)\=\|read\|seek\%(dir\)\=\|sys\%(open\|read\|seek\|write\)\|truncate\)\>" nextgroup=perlFiledescStatementComma skipwhite
    8              0.000047000 syn match perlStatementVector		"\<vec\>"
    8              0.000072000 syn match perlStatementFiles		"\<\%(ch\%(dir\|mod\|own\|root\)\|glob\|link\|mkdir\|readlink\|rename\|rmdir\|symlink\|umask\|unlink\|utime\)\>"
    8              0.000037000 syn match perlStatementFiles		"-[rwxoRWXOezsfdlpSbctugkTBMAC]\>"
    8              0.000052000 syn match perlStatementFlow		"\<\%(caller\|die\|dump\|eval\|exit\|wantarray\|evalbytes\)\>"
    8              0.000043000 syn match perlStatementInclude		"\<\%(require\|import\|unimport\)\>"
    8              0.000224000 syn match perlStatementInclude		"\<\%(use\|no\)\s\+\%(\%(attributes\|attrs\|autodie\%(::\%(exception\%(::system\)\=\|hints\|skip\)\)\=\|autouse\|parent\|base\|big\%(int\|num\|rat\)\|blib\|bytes\|charnames\|constant\|deprecate\|diagnostics\|encoding\%(::warnings\)\=\|experimental\|feature\|fields\|filetest\|if\|integer\|less\|lib\|locale\|mro\|ok\|open\|ops\|overload\|overloading\|re\|sigtrap\|sort\|strict\|subs\|threads\%(::shared\)\=\|utf8\|vars\|version\|vmsish\|warnings\%(::register\)\=\)\>\)\="
    8              0.000080000 syn match perlStatementProc		"\<\%(alarm\|exec\|fork\|get\%(pgrp\|ppid\|priority\)\|kill\|pipe\|set\%(pgrp\|priority\)\|sleep\|system\|times\|wait\%(pid\)\=\)\>"
    8              0.000077000 syn match perlStatementSocket		"\<\%(accept\|bind\|connect\|get\%(peername\|sock\%(name\|opt\)\)\|listen\|recv\|send\|setsockopt\|shutdown\|socket\%(pair\)\=\)\>"
    8              0.000065000 syn match perlStatementIPC		"\<\%(msg\%(ctl\|get\|rcv\|snd\)\|sem\%(ctl\|get\|op\)\|shm\%(ctl\|get\|read\|write\)\)\>"
    8              0.000096000 syn match perlStatementNetwork		"\<\%(\%(end\|[gs]et\)\%(host\|net\|proto\|serv\)ent\|get\%(\%(host\|net\)by\%(addr\|name\)\|protoby\%(name\|number\)\|servby\%(name\|port\)\)\)\>"
    8              0.000067000 syn match perlStatementPword		"\<\%(get\%(pw\%(uid\|nam\)\|gr\%(gid\|nam\)\|login\)\)\|\%(end\|[gs]et\)\%(pw\|gr\)ent\>"
    8              0.000042000 syn match perlStatementTime		"\<\%(gmtime\|localtime\|time\)\>"
                            
    8              0.000059000 syn match perlStatementMisc		"\<\%(warn\|format\|formline\|reset\|scalar\|prototype\|lock\|tied\=\|untie\)\>"
                            
    8              0.000039000 syn keyword perlTodo			TODO TODO: TBD TBD: FIXME FIXME: XXX XXX: NOTE NOTE: contained
                            
    8              0.000096000 syn region perlStatementIndirObjWrap   matchgroup=perlStatementIndirObj start="\%(\<\%(map\|grep\|sort\|printf\=\|say\|system\|exec\)\>\s*\)\@<={" end="}" transparent extend
                            
    8              0.000055000 syn match perlLabel      "^\s*\h\w*\s*::\@!\%(\<v\d\+\s*:\)\@<!"
                            
                            " Perl Identifiers.
                            "
                            " Should be cleaned up to better handle identifiers in particular situations
                            " (in hash keys for example)
                            "
                            " Plain identifiers: $foo, @foo, $#foo, %foo, &foo and dereferences $$foo, @$foo, etc.
                            " We do not process complex things such as @{${"foo"}}. Too complicated, and
                            " too slow. And what is after the -> is *not* considered as part of the
                            " variable - there again, too complicated and too slow.
                            
                            " Special variables first ($^A, ...) and ($|, $', ...)
    8              0.000043000 syn match  perlVarPlain		 "$^[ACDEFHILMNOPRSTVWX]\="
    8              0.000044000 syn match  perlVarPlain		 "$[\\\"\[\]'&`+*.,;=%~!?@#$<>(-]"
    8              0.000023000 syn match  perlVarPlain		 "@[-+]"
    8              0.000032000 syn match  perlVarPlain		 "$\%(0\|[1-9]\d*\)"
                            " Same as above, but avoids confusion in $::foo (equivalent to $main::foo)
    8              0.000048000 syn match  perlVarPlain		 "$::\@!"
                            " These variables are not recognized within matches.
    8              0.000031000 syn match  perlVarNotInMatches	 "$[|)]"
                            " This variable is not recognized within matches delimited by m//.
    8              0.000028000 syn match  perlVarSlash		 "$/"
                            
                            " And plain identifiers
    8              0.000059000 syn match  perlPackageRef	 "[$@#%*&]\%(\%(::\|'\)\=\I\i*\%(\%(::\|'\)\I\i*\)*\)\=\%(::\|'\)\I"ms=s+1,me=e-1 contained
                            
                            " To not highlight packages in variables as a scope reference - i.e. in
                            " $pack::var, pack:: is a scope, just set "perl_no_scope_in_variables"
                            " If you don't want complex things like @{${"foo"}} to be processed,
                            " just set the variable "perl_no_extended_vars"...
                            
    8              0.000031000 if !get(g:, 'perl_no_scope_in_variables', 0)
    8              0.000139000   syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
    8              0.000119000   syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
    8              0.000115000   syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
                            else
                              syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
                              syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
                              syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
    8              0.000004000 endif
                            
    8              0.000028000 syn match  perlVarPlain2	 "%[-+]"
                            
    8              0.000023000 if !get(g:, 'perl_no_extended_vars', 0)
    8              0.000546000   syn cluster perlExpr		contains=perlStatementIndirObjWrap,perlStatementScalar,perlStatementRegexp,perlStatementNumeric,perlStatementList,perlStatementHash,perlStatementFiles,perlStatementTime,perlStatementMisc,perlVarPlain,perlVarPlain2,perlVarNotInMatches,perlVarSlash,perlVarBlock,perlVarBlock2,perlShellCommand,perlFloat,perlNumber,perlStringUnexpanded,perlString,perlQ,perlQQ,perlQW,perlQR,perlArrow,perlBraces
    8              0.000099000   syn region perlArrow		matchgroup=perlArrow start="->\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    8              0.000098000   syn region perlArrow		matchgroup=perlArrow start="->\s*\[" end="\]" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    8              0.000132000   syn region perlArrow		matchgroup=perlArrow start="->\s*{" end="}" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    8              0.000120000   syn match  perlArrow		"->\s*{\s*\I\i*\s*}" contains=perlVarSimpleMemberName nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    8              0.000225000   syn region perlVarBlock	matchgroup=perlVarPlain start="\%($#\|[$@]\)\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    8              0.000145000   syn region perlVarBlock2	matchgroup=perlVarPlain start="[%&*]\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    8              0.000098000   syn match  perlVarPlain2	"[%&*]\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    8              0.000092000   syn match  perlVarPlain	"\%(\$#\|[@$]\)\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    8              0.000110000   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\={" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    8              0.000107000   syn match  perlVarSimpleMember	"\%(->\)\={\s*\I\i*\s*}" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contains=perlVarSimpleMemberName contained extend
    8              0.000023000   syn match  perlVarSimpleMemberName	"\I\i*" contained
    8              0.000102000   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\=\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    8              0.000049000   syn match perlPackageConst	"__PACKAGE__" nextgroup=perlPostDeref
    8              0.000087000   syn match  perlPostDeref	"->\%($#\|[$@%&*]\)\*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlPostDeref
    8              0.000103000   syn region  perlPostDeref	start="->\%($#\|[$@%&*]\)\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlPostDeref
    8              0.000109000   syn region  perlPostDeref	matchgroup=perlPostDeref start="->\%($#\|[$@%&*]\){" skip="\\}" end="}" keepend extend contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlPostDeref
    8              0.000007000 endif
                            
                            " File Descriptors
    8              0.000038000 syn match  perlFiledescRead	"<\h\w*>"
                            
    8              0.000058000 syn match  perlFiledescStatementComma	"(\=\s*\<\u\w*\>\s*,"me=e-1 transparent contained contains=perlFiledescStatement
    8              0.000054000 syn match  perlFiledescStatementNocomma "(\=\s*\<\u\w*\>\s*[^, \t]"me=e-1 transparent contained contains=perlFiledescStatement
                            
    8              0.000025000 syn match  perlFiledescStatement	"\<\u\w*\>" contained
                            
                            " Special characters in strings and matches
    8              0.000060000 syn match  perlSpecialString	"\\\%(\o\{1,3}\|x\%({\x\+}\|\x\{1,2}\)\|c.\|[^cx]\)" contained extend
    8              0.000090000 syn match  perlSpecialStringU2	"\\." extend contained contains=NONE
    8              0.000025000 syn match  perlSpecialStringU	"\\\\" contained
    8              0.000027000 syn match  perlSpecialMatch	"\\[1-9]" contained extend
    8              0.000064000 syn match  perlSpecialMatch	"\\g\%(\d\+\|{\%(-\=\d\+\|\h\w*\)}\)" contained
    8              0.000032000 syn match  perlSpecialMatch	"\\k\%(<\h\w*>\|'\h\w*'\)" contained
    8              0.000032000 syn match  perlSpecialMatch	"{\d\+\%(,\%(\d\+\)\=\)\=}" contained
    8              0.000040000 syn match  perlSpecialMatch	"\[[]-]\=[^\[\]]*[]-]\=\]" contained extend
    8              0.000031000 syn match  perlSpecialMatch	"[+*()?.]" contained
    8              0.000023000 syn match  perlSpecialMatch	"(?[#:=!]" contained
    8              0.000039000 syn match  perlSpecialMatch	"(?[impsx]*\%(-[imsx]\+\)\=)" contained
    8              0.000031000 syn match  perlSpecialMatch	"(?\%([-+]\=\d\+\|R\))" contained
    8              0.000029000 syn match  perlSpecialMatch	"(?\%(&\|P[>=]\)\h\w*)" contained
    8              0.000068000 syn match  perlSpecialMatch	"(\*\%(\%(PRUNE\|SKIP\|THEN\)\%(:[^)]*\)\=\|\%(MARK\|\):[^)]*\|COMMIT\|F\%(AIL\)\=\|ACCEPT\))" contained
                            
                            " Possible errors
                            "
                            " Highlight lines with only whitespace (only in blank delimited here documents) as errors
    8              0.000028000 syn match  perlNotEmptyLine	"^\s\+$" contained
                            " Highlight "} else if (...) {", it should be "} else { if (...) { " or "} elsif (...) {"
    8              0.000054000 syn match perlElseIfError	"else\_s*if" containedin=perlConditional
    8              0.000048000 syn keyword perlElseIfError	elseif containedin=perlConditional
                            
                            " Variable interpolation
                            "
                            " These items are interpolated inside "" strings and similar constructs.
    8              0.000104000 syn cluster perlInterpDQ	contains=perlSpecialString,perlVarPlain,perlVarNotInMatches,perlVarSlash,perlVarBlock
                            " These items are interpolated inside '' strings and similar constructs.
    8              0.000045000 syn cluster perlInterpSQ	contains=perlSpecialStringU,perlSpecialStringU2
                            " These items are interpolated inside m// matches and s/// substitutions.
    8              0.000080000 syn cluster perlInterpSlash	contains=perlSpecialString,perlSpecialMatch,perlVarPlain,perlVarBlock
                            " These items are interpolated inside m## matches and s### substitutions.
    8              0.000031000 syn cluster perlInterpMatch	contains=@perlInterpSlash,perlVarSlash
                            
                            " Shell commands
    8              0.000049000 syn region  perlShellCommand	matchgroup=perlMatchStartEnd start="`" end="`" contains=@perlInterpDQ keepend
                            
                            " Constants
                            "
                            " Numbers
    8              0.000009000 syn case   ignore
    8              0.000053000 syn match  perlNumber	"\<\%(0\|[1-9]\%(_\=\d\)*\)\>"
    8              0.000059000 syn match  perlNumber	"\<0\%(x\x\%(_\=\x\)*\|b[01]\%(_\=[01]\)*\|o\=\%(_\=\o\)*\)\>"
    8              0.000039000 syn match  perlFloat	"\<\d\%(_\=\d\)*e[-+]\=\d\%(_\=\d\)*"
    8              0.000045000 syn match  perlFloat	"\<\d\%(_\=\d\)*\.\%(\d\%(_\=\d\)*\)\=\%(e[-+]\=\d\%(_\=\d\)*\)\="
    8              0.000038000 syn match  perlFloat    "\.\d\%(_\=\d\)*\%(e[-+]\=\d\%(_\=\d\)*\)\="
    8              0.000044000 syn match  perlFloat	"\<0x\x\%(_\=\x\)*p[-+]\=\d\%(_\=\d\)*"
    8              0.000041000 syn match  perlFloat	"\<0x\x\%(_\=\x\)*\.\%(\x\%(_\=\x\)*\)\=\%(p[-+]\=\d\%(_\=\d\)*\)\="
    8              0.000041000 syn match  perlFloat    "\<0x\.\x\%(_\=\x\)*\%(p[-+]\=\d\%(_\=\d\)*\)\="
    8              0.000007000 syn case   match
                            
    8              0.000085000 syn match  perlString	"\<\%(v\d\+\%(\.\d\+\)*\|\d\+\%(\.\d\+\)\{2,}\)\>" contains=perlVStringV
    8              0.000021000 syn match  perlVStringV	"\<v" contained
                            
                            
    8              0.000050000 syn region perlParensSQ		start=+(+ end=+)+ extend contained contains=perlParensSQ,@perlInterpSQ keepend
    8              0.000055000 syn region perlBracketsSQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsSQ,@perlInterpSQ keepend
    8              0.000048000 syn region perlBracesSQ		start=+{+ end=+}+ extend contained contains=perlBracesSQ,@perlInterpSQ keepend
    8              0.000048000 syn region perlAnglesSQ		start=+<+ end=+>+ extend contained contains=perlAnglesSQ,@perlInterpSQ keepend
                            
    8              0.000047000 syn region perlParensDQ		start=+(+ end=+)+ extend contained contains=perlParensDQ,@perlInterpDQ keepend
    8              0.000050000 syn region perlBracketsDQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsDQ,@perlInterpDQ keepend
    8              0.000045000 syn region perlBracesDQ		start=+{+ end=+}+ extend contained contains=perlBracesDQ,@perlInterpDQ keepend
    8              0.000042000 syn region perlAnglesDQ		start=+<+ end=+>+ extend contained contains=perlAnglesDQ,@perlInterpDQ keepend
                            
                            
                            " Simple version of searches and matches
    8              0.000043000 syn match  perlMatchModifiers "[msixpadluncgo]\+" contained
    8              0.000098000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+ contains=@perlInterpMatch keepend extend nextgroup=perlMatchModifiers
    8              0.000071000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m#+ end=+#+ contains=@perlInterpMatch keepend extend nextgroup=perlMatchModifiers
    8              0.001063000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*'+ end=+'+ contains=@perlInterpSQ keepend extend nextgroup=perlMatchModifiers
    8              0.000067000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*/+ end=+/+ contains=@perlInterpSlash keepend extend nextgroup=perlMatchModifiers
    8              0.000079000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ keepend extend nextgroup=perlMatchModifiers
    8              0.000081000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ extend nextgroup=perlMatchModifiers
    8              0.000074000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ keepend extend nextgroup=perlMatchModifiers
    8              0.000081000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ keepend extend nextgroup=perlMatchModifiers
                            
                            " Below some hacks to recognise the // variant. This is virtually impossible to catch in all
                            " cases as the / is used in so many other ways, but these should be the most obvious ones.
    8              0.000203000 syn region perlMatch	matchgroup=perlMatchStartEnd start="\%([$@%&*]\@<!\%(\<split\|\<while\|\<if\|\<unless\|\.\.\|[-+*!~(\[{=]\)\s*\)\@<=/\%(/=\)\@!" start=+^/\%(/=\)\@!+ start=+\s\@<=/\%(/=\)\@![^[:space:][:digit:]$@%=]\@=\%(/\_s*\%([([{$@%&*[:digit:]"'`]\|\_s\w\|[[:upper:]_abd-fhjklnqrt-wyz]\)\)\@!+ skip=+\\/+ end=+/+ contains=@perlInterpSlash extend nextgroup=perlMatchModifiers
                            
                            
                            " Substitutions
                            " perlMatch is the first part, perlSubstitution* is the substitution part
    8              0.000041000 syn match  perlSubstitutionModifiers "[msixpadluncgero]\+" contained
    8              0.000083000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    8              0.000075000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*'+  end=+'+me=e-1 contains=@perlInterpSQ nextgroup=perlSubstitutionSQ keepend extend
    8              0.000060000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*/+  end=+/+me=e-1 contains=@perlInterpSlash nextgroup=perlSubstitutionGQQ keepend extend
    8              0.000065000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s#+  end=+#+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    8              0.000084000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    8              0.000076000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    8              0.000080000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    8              0.000079000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    8              0.000065000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]'([{<]\)+ end=+\z1+ keepend contained contains=@perlInterpDQ extend nextgroup=perlSubstitutionModifiers
    8              0.000069000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+(+ end=+)+ contained contains=@perlInterpDQ,perlParensDQ keepend extend nextgroup=perlSubstitutionModifiers
    8              0.000066000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\]+ contained contains=@perlInterpDQ,perlBracketsDQ keepend extend nextgroup=perlSubstitutionModifiers
    8              0.000085000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+{+ end=+}+ contained contains=@perlInterpDQ,perlBracesDQ keepend extend extend nextgroup=perlSubstitutionModifiers
    8              0.000065000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+<+ end=+>+ contained contains=@perlInterpDQ,perlAnglesDQ keepend extend nextgroup=perlSubstitutionModifiers
    8              0.000049000 syn region perlSubstitutionSQ		matchgroup=perlMatchStartEnd start=+'+  end=+'+ contained contains=@perlInterpSQ keepend extend nextgroup=perlSubstitutionModifiers
                            
                            " Translations
                            " perlMatch is the first part, perlTranslation* is the second, translator part.
    8              0.000036000 syn match  perlTranslationModifiers "[cdsr]\+" contained
    8              0.000082000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\>\s*\z([^[:space:]([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    8              0.000067000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)#+ end=+#+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    8              0.000085000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    8              0.000080000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    8              0.000082000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    8              0.000077000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    8              0.000059000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]([{<]\)+ end=+\z1+ contained nextgroup=perlTranslationModifiers
    8              0.000066000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+(+ end=+)+ contains=perlParensSQ contained nextgroup=perlTranslationModifiers
    8              0.000063000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\]+ contains=perlBracketsSQ contained nextgroup=perlTranslationModifiers
    8              0.000063000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+{+ end=+}+ contains=perlBracesSQ contained nextgroup=perlTranslationModifiers
    8              0.000060000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+<+ end=+>+ contains=perlAnglesSQ contained nextgroup=perlTranslationModifiers
                            
                            
                            " Strings and q, qq, qw and qr expressions
                            
    8              0.000049000 syn region perlStringUnexpanded	matchgroup=perlStringStartEnd start="'" end="'" contains=@perlInterpSQ keepend extend
    8              0.000041000 syn region perlString		matchgroup=perlStringStartEnd start=+"+  end=+"+ contains=@perlInterpDQ keepend extend
    8              0.000056000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpSQ keepend extend
    8              0.000049000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q#+ end=+#+ contains=@perlInterpSQ keepend extend
    8              0.000065000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    8              0.000071000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    8              0.000063000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    8              0.000061000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    8              0.000058000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpDQ keepend extend
    8              0.000047000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]#+ end=+#+ contains=@perlInterpDQ keepend extend
    8              0.000064000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*(+ end=+)+ contains=@perlInterpDQ,perlParensDQ keepend extend
    8              0.000064000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*\[+ end=+\]+ contains=@perlInterpDQ,perlBracketsDQ keepend extend
    8              0.000061000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*{+ end=+}+ contains=@perlInterpDQ,perlBracesDQ keepend extend
    8              0.000075000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*<+ end=+>+ contains=@perlInterpDQ,perlAnglesDQ keepend extend
                            
    8              0.000073000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\z([^[:space:]#([{<]\)+  end=+\z1+ contains=@perlInterpSQ keepend extend
    8              0.000052000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw#+  end=+#+ contains=@perlInterpSQ keepend extend
    8              0.000062000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*(+  end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    8              0.000067000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\[+  end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    8              0.000065000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*{+  end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    8              0.000063000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*<+  end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    8              0.000034000 syn match  perlQRModifiers "[msixpadluno]\+" contained
    8              0.000078000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\>\s*\z([^[:space:]#([{<'/]\)+  end=+\z1+ contains=@perlInterpMatch keepend extend nextgroup=perlQRModifiers
    8              0.000067000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*/+  end=+/+ contains=@perlInterpSlash keepend extend nextgroup=perlQRModifiers
    8              0.000062000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr#+  end=+#+ contains=@perlInterpMatch keepend extend nextgroup=perlQRModifiers
    8              0.000066000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*'+  end=+'+ contains=@perlInterpSQ keepend extend nextgroup=perlQRModifiers
    8              0.000077000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*(+  end=+)+ contains=@perlInterpMatch,perlParensDQ keepend extend nextgroup=perlQRModifiers
                            
                            " A special case for qr{}, qr<> and qr[] which allows for comments and extra whitespace in the pattern
    8              0.000098000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*{+  end=+}+ contains=@perlInterpMatch,perlBracesDQ,perlComment keepend extend nextgroup=perlQRModifiers
    8              0.000095000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*<+  end=+>+ contains=@perlInterpMatch,perlAnglesDQ,perlComment keepend extend nextgroup=perlQRModifiers
    8              0.000092000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*\[+  end=+\]+ contains=@perlInterpMatch,perlBracketsDQ,perlComment keepend extend nextgroup=perlQRModifiers
                            
                            " Constructs such as print <<EOF [...] EOF, 'here' documents
                            "
                            " XXX Any statements after the identifier are in perlString colour (i.e.
                            " 'if $a' in 'print <<EOF if $a'). This is almost impossible to get right it
                            " seems due to the 'auto-extending nature' of regions.
                            " XXX Indented heredocs are not perfect - they sometimes seem to take a moment
                            "     to update if switched from double to single quotes and vice versa.
                            "
                            " Note: bare delimiters such as << to mean <<"" are not supported. These are a
                            "       fatal error since 5.28 and, apparently, a rarely used feature.
                            
    8              0.000054000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\I\i*+                         end=+$+     contains=@perlTop oneline
    8              0.000047000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\\\I\i*+                       end=+$+     contains=@perlTop oneline
    8              0.000060000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*"[^\\"]*\%(\\.[^\\"]*\)*"+  end=+$+     contains=@perlTop oneline
    8              0.000050000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*'[^\\']*\%(\\.[^\\']*\)*'+  end=+$+     contains=@perlTop oneline
    8              0.000047000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*`[^\\`]*\%(\\.[^\\`]*\)*`+  end=+$+     contains=@perlTop oneline
    8              0.000044000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*""+                         end=+$+     contains=@perlTop oneline
    8              0.000039000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*''+                         end=+$+     contains=@perlTop oneline
    8              0.000040000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*``+                         end=+$+     contains=@perlTop oneline
                            
    8              0.000070000 if get(g:, 'perl_fold', 0)
                              syn region perlHereDoc	start=+<<\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ fold extend
                              syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ fold extend
                              syn region perlHereDoc	start=+<<\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*""+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	start=+<<\s*''+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	start=+<<\s*``+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
    8              0.000006000 else
    8              0.000063000   syn region perlHereDoc	start=+<<\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    8              0.000059000   syn region perlHereDoc	start=+<<\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ
    8              0.000070000   syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    8              0.000070000   syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ
    8              0.000073000   syn region perlHereDoc	start=+<<\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    8              0.000080000   syn region perlHereDoc	start=+<<\s*""+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    8              0.000071000   syn region perlHereDoc	start=+<<\s*''+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine
    8              0.000072000   syn region perlHereDoc	start=+<<\s*``+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    8              0.000004000 endif
                            
    8              0.000016000 if get(g:, 'perl_fold', 0)
                              syn region perlIndentedHereDoc	start=+<<\~\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpDQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpSQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpDQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpSQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpDQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*""+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlIndentedHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*''+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlIndentedHereDocStart,@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*``+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlIndentedHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
    8              0.000029000 else
    8              0.000066000   syn region perlIndentedHereDoc	start=+<<\~\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpDQ
    8              0.000066000   syn region perlIndentedHereDoc	start=+<<\~\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpSQ
    8              0.000065000   syn region perlIndentedHereDoc	start=+<<\~\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpDQ
    8              0.000066000   syn region perlIndentedHereDoc	start=+<<\~\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpSQ
    8              0.000064000   syn region perlIndentedHereDoc	start=+<<\~\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpDQ
    8              0.000072000   syn region perlIndentedHereDoc	start=+<<\~\s*""+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    8              0.000071000   syn region perlIndentedHereDoc	start=+<<\~\s*''+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine
    8              0.000073000   syn region perlIndentedHereDoc	start=+<<\~\s*``+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    8              0.000004000 endif
                            
                            
                            " Class declarations
                            "
    8              0.000067000 syn match   perlPackageDecl		"\<package\s\+\%(\h\|::\)\%(\w\|::\)*" contains=perlStatementPackage
    8              0.000021000 syn keyword perlStatementPackage	package contained
                            
                            " Functions
    8              0.000019000 if get(g:, "perl_sub_signatures", 0)
                                syn match perlSubSignature "\s*([^)]*)" contained extend
    8              0.000006000 else
    8              0.000038000     syn match perlSubPrototype "\s*([\\$@%&*\[\];]*)" contained extend
    8              0.000005000 endif
    8              0.000046000 syn match perlSubAttribute "\s*:\s*\h\w*\%(([^)]*)\|\)" contained extend
    8              0.000043000 syn match perlSubName "\%(\h\|::\|'\w\)\%(\w\|::\|'\w\)*\s*" contained extend
    8              0.000113000 syn region perlSubDeclaration start="" end="[;{]" contains=perlSubName,perlSubPrototype,perlSubAttribute,perlSubSignature,perlComment contained transparent
    8              0.000047000 syn match perlFunction "\<sub\>\_s*" nextgroup=perlSubDeclaration
                            
                            " The => operator forces a bareword to the left of it to be interpreted as
                            " a string
    8              0.000039000 syn match  perlString "\I\@<!-\?\I\i*\%(\s*=>\)\@="
                            
                            " All other # are comments, except ^#!
    8              0.000052000 syn match  perlComment		"#.*" contains=perlTodo,@Spell extend
    8              0.000028000 syn match  perlSharpBang	"^#!.*"
                            
                            " Formats
    8              0.000141000 syn region perlFormat		matchgroup=perlStatementIOFunc start="^\s*\<format\s\+\k\+\s*=\s*$"rs=s+6 end="^\s*\.\s*$" contains=perlFormatName,perlFormatField,perlVarPlain,perlVarPlain2
    8              0.000034000 syn match  perlFormatName	"format\s\+\k\+\s*="lc=7,me=e-1 contained
    8              0.000031000 syn match  perlFormatField	"[@^][|<>~]\+\%(\.\.\.\)\=" contained
    8              0.000021000 syn match  perlFormatField	"[@^]#[#.]*" contained
    8              0.000018000 syn match  perlFormatField	"@\*" contained
    8              0.000031000 syn match  perlFormatField	"@[^A-Za-z_|<>~#*]"me=e-1 contained
    8              0.000018000 syn match  perlFormatField	"@$" contained
                            
                            " __END__ and __DATA__ clauses
                            
                            " Vim excludes empty syn-region end lines from the fold region.  This is
                            " probably a bug and means a DATA section ending with an empty line does not
                            " have that final line included in the fold.
                            "
                            " As a workaround we exploit an unterminated syntax region here with an end
                            " pattern that will (probably) never match.  This forces all lines to be
                            " included in the fold region.  Of course, if it does match then there's
                            " nothing to work around as it is a non-empty line.
                            "
                            " This problem also exists with empty string delimited heredocs but there's no
                            " known workaround for that case.
    8              0.000015000 if get(g:, 'perl_fold', 0)
                              syntax region perlDATA matchgroup=perlDATAStart start="^__DATA__$" end="VIM_PERL_EOF\%$" contains=@perlDATA fold
                              syntax region perlEND  matchgroup=perlENDStart  start="^__END__$"  end="VIM_PERL_EOF\%$" contains=@perlDATA fold
    8              0.000006000 else
    8              0.000055000   syntax region perlDATA matchgroup=perlDATAStart start="^__DATA__$" end="\%$" contains=@perlDATA
    8              0.000056000   syntax region perlEND  matchgroup=perlENDStart  start="^__END__$"  end="\%$" contains=@perlDATA
    8              0.000005000 endif
                            
                            " TODO: generalise this to allow other filetypes
    8              0.000020000 if get(g:, 'perl_highlight_data', 0)
                              syn cluster perlDATA add=perlPOD
    8              0.000015000 else
    8              0.000032000   syn cluster perlDATA remove=perlPOD
    8              0.000003000 endif
                            
                            "
                            " Folding
    8              0.000014000 if get(g:, 'perl_fold', 0)
                              " Note: this bit must come before the actual highlighting of the "package"
                              " keyword, otherwise this will screw up Pod lines that match /^package/
                              if !get(g:, 'perl_nofold_packages', 0)
                                syn region perlPackageFold start="^package \S\+;\s*\%(#.*\)\=$" end="^1;\=\s*\%(#.*\)\=$" end="\n\+package"me=s-1 transparent fold keepend
                                syn region perlPackageFold start="^\z(\s*\)package\s*\S\+\s*{" end="^\z1}" transparent fold keepend
                              endif
                              if !get(g:, 'perl_nofold_subs', 0)
                                if get(g:, "perl_fold_anonymous_subs", 0)
                                  " EXPLANATION:
                                  " \<sub\>                  - "sub" keyword
                                  " \_[^;{]*                 - any characters, including new line, but not ";" or "{", zero or more times
                                  " \%(([\\$@%&*\[\];]*)\)\= - prototype definition, \$@%&*[]; characters between (), zero or 1 times
                                  " \_[^;]*                  - any characters, including new line, but not ";" or "{", zero or more times
                                  " {                        - start subroutine block
                                  syn region perlSubFold start="\<sub\>\_[^;{]*\%(([\\$@%&*\[\];]*)\)\=\_[^;{]*{" end="}" transparent fold keepend extend
                                else
                                  " EXPLANATION:
                                  " same, as above, but first non-space character after "sub" keyword must
                                  " be [A-Za-z_] 
                                  syn region perlSubFold start="\<sub\>\s*\h\_[^;{]*\%(([\\$@%&*\[\];]*)\)\=\_[^;]*{" end="}" transparent fold keepend extend
                                endif
                            
                                syn region perlSubFold start="\<\%(BEGIN\|END\|CHECK\|INIT\|UNITCHECK\)\>\_s*{" end="}" transparent fold keepend
                              endif
                            
                              if get(g:, 'perl_fold_blocks', 0)
                                syn region perlBlockFold start="^\z(\s*\)\%(if\|elsif\|unless\|for\|while\|until\|given\)\s*(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" start="^\z(\s*\)for\%(each\)\=\s*\%(\%(my\|our\)\=\s*\S\+\s*\)\=(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                            
                                " TODO this is works incorrectly
                                syn region perlBlockFold start="^\z(\s*\)\%(do\|else\)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*while" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                              else
                                if get(g:, 'perl_fold_do_blocks', 0)
                                  syn region perlDoBlockDeclaration start="" end="{" contains=perlComment contained transparent
                                  syn match perlOperator "\<do\>\_s*" nextgroup=perlDoBlockDeclaration
                            
                                  syn region perlDoBlockFold start="\<do\>\_[^{]*{" end="}" transparent fold keepend extend
                                endif
                              endif
                            
                              syn sync fromstart
    8              0.000008000 else
                              " fromstart above seems to set minlines even if perl_fold is not set.
    8              0.000011000   syn sync minlines=0
    8              0.000005000 endif
                            
                            " NOTE: If you're linking new highlight groups to perlString, please also put
                            "       them into b:match_skip in ftplugin/perl.vim.
                            
                            " The default highlighting.
    8              0.000050000 hi def link perlSharpBang		PreProc
    8              0.000047000 hi def link perlControl			PreProc
    8              0.000045000 hi def link perlInclude			Include
    8              0.000046000 hi def link perlSpecial			Special
    8              0.000042000 hi def link perlString			String
    8              0.000048000 hi def link perlCharacter		Character
    8              0.000043000 hi def link perlNumber			Number
    8              0.000042000 hi def link perlFloat			Float
    8              0.000046000 hi def link perlType			Type
    8              0.000047000 hi def link perlIdentifier		Identifier
    8              0.000041000 hi def link perlLabel			Label
    8              0.000046000 hi def link perlStatement		Statement
    8              0.000043000 hi def link perlConditional		Conditional
    8              0.000047000 hi def link perlRepeat			Repeat
    8              0.000043000 hi def link perlOperator		Operator
    8              0.000039000 hi def link perlFunction		Keyword
    8              0.000042000 hi def link perlSubName			Function
    8              0.000042000 hi def link perlSubPrototype		Type
    8              0.000043000 hi def link perlSubSignature		Type
    8              0.000045000 hi def link perlSubAttribute		PreProc
    8              0.000044000 hi def link perlComment			Comment
    8              0.000042000 hi def link perlTodo			Todo
    8              0.000019000 if get(g:, 'perl_string_as_statement', 0)
                              hi def link perlStringStartEnd	perlStatement
    8              0.000008000 else
    8              0.000022000   hi def link perlStringStartEnd	perlString
    8              0.000002000 endif
    8              0.000020000 hi def link perlVStringV		perlStringStartEnd
    8              0.000019000 hi def link perlList			perlStatement
    8              0.000019000 hi def link perlMisc			perlStatement
    8              0.000019000 hi def link perlVarPlain		perlIdentifier
    8              0.000020000 hi def link perlVarPlain2		perlIdentifier
    8              0.000018000 hi def link perlArrow			perlIdentifier
    8              0.000019000 hi def link perlFiledescRead		perlIdentifier
    8              0.000021000 hi def link perlFiledescStatement	perlIdentifier
    8              0.000019000 hi def link perlVarSimpleMember		perlIdentifier
    8              0.000021000 hi def link perlVarSimpleMemberName	perlString
    8              0.000033000 hi def link perlVarNotInMatches		perlIdentifier
    8              0.000018000 hi def link perlVarSlash		perlIdentifier
    8              0.000020000 hi def link perlQ			perlString
    8              0.000022000 hi def link perlQQ			perlString
    8              0.000019000 hi def link perlQW			perlString
    8              0.000021000 hi def link perlQR			perlString
    8              0.000020000 hi def link perlMatchModifiers          perlMatchStartEnd
    8              0.000022000 hi def link perlSubstitutionModifiers   perlMatchStartEnd
    8              0.000021000 hi def link perlTranslationModifiers    perlMatchStartEnd
    8              0.000019000 hi def link perlQRModifiers             perlStringStartEnd
    8              0.000020000 hi def link perlHereDoc			perlString
    8              0.000019000 hi def link perlIndentedHereDoc		perlString
    8              0.000020000 hi def link perlStringUnexpanded	perlString
    8              0.000021000 hi def link perlSubstitutionSQ		perlString
    8              0.000019000 hi def link perlSubstitutionGQQ		perlString
    8              0.000019000 hi def link perlTranslationGQ		perlString
    8              0.000018000 hi def link perlMatch			perlString
    8              0.000019000 hi def link perlMatchStartEnd		perlStatement
    8              0.000016000 hi def link perlFormatName		perlIdentifier
    8              0.000020000 hi def link perlFormatField		perlString
    8              0.000017000 hi def link perlPackageDecl		perlType
    8              0.000021000 hi def link perlStorageClass		perlType
    8              0.000016000 hi def link perlPackageRef		perlType
    8              0.000017000 hi def link perlStatementPackage	perlStatement
    8              0.000021000 hi def link perlStatementStorage	perlStatement
    8              0.000020000 hi def link perlStatementControl	perlStatement
    8              0.000020000 hi def link perlStatementScalar		perlStatement
    8              0.000020000 hi def link perlStatementRegexp		perlStatement
    8              0.000019000 hi def link perlStatementNumeric	perlStatement
    8              0.000020000 hi def link perlStatementList		perlStatement
    8              0.000018000 hi def link perlStatementHash		perlStatement
    8              0.000020000 hi def link perlStatementIOfunc		perlStatement
    8              0.000019000 hi def link perlStatementFiledesc	perlStatement
    8              0.000020000 hi def link perlStatementVector		perlStatement
    8              0.000021000 hi def link perlStatementFiles		perlStatement
    8              0.000019000 hi def link perlStatementFlow		perlStatement
    8              0.000019000 hi def link perlStatementInclude	perlStatement
    8              0.000018000 hi def link perlStatementProc		perlStatement
    8              0.000018000 hi def link perlStatementSocket		perlStatement
    8              0.000019000 hi def link perlStatementIPC		perlStatement
    8              0.000020000 hi def link perlStatementNetwork	perlStatement
    8              0.000019000 hi def link perlStatementPword		perlStatement
    8              0.000017000 hi def link perlStatementTime		perlStatement
    8              0.000020000 hi def link perlStatementMisc		perlStatement
    8              0.000020000 hi def link perlStatementIndirObj	perlStatement
    8              0.000017000 hi def link perlFunctionName		perlIdentifier
    8              0.000019000 hi def link perlMethod			perlIdentifier
    8              0.000019000 hi def link perlPostDeref		perlIdentifier
    8              0.000019000 hi def link perlFunctionPRef		perlType
                            
    8              0.000017000 if !get(g:, 'perl_include_pod', 1)
                              hi def link perlPOD		perlComment
    8              0.000006000 endif
    8              0.000020000 hi def link perlShellCommand		perlString
    8              0.000021000 hi def link perlSpecialAscii		perlSpecial
    8              0.000019000 hi def link perlSpecialDollar		perlSpecial
    8              0.000018000 hi def link perlSpecialString		perlSpecial
    8              0.000019000 hi def link perlSpecialStringU		perlSpecial
    8              0.000018000 hi def link perlSpecialMatch		perlSpecial
    8              0.000016000 hi def link perlEND			perlComment
    8              0.000015000 hi def link perlENDStart		perlEND
    8              0.000016000 hi def link perlDATA			perlComment
    8              0.000016000 hi def link perlDATAStart		perlDATA
                            
                            " NOTE: Due to a bug in Vim (or more likely, a misunderstanding on my part),
                            "	I had to remove the transparent property from the following regions
                            "	in order to get them to highlight correctly.  Feel free to remove
                            "	these and reinstate the transparent property if you know how.
    8              0.000020000 hi def link perlParensSQ		perlString
    8              0.000021000 hi def link perlBracketsSQ		perlString
    8              0.000017000 hi def link perlBracesSQ		perlString
    8              0.000020000 hi def link perlAnglesSQ		perlString
                            
    8              0.000018000 hi def link perlParensDQ		perlString
    8              0.000019000 hi def link perlBracketsDQ		perlString
    8              0.000020000 hi def link perlBracesDQ		perlString
    8              0.000018000 hi def link perlAnglesDQ		perlString
                            
    8              0.000022000 hi def link perlSpecialStringU2	perlString
                            
                            " Possible errors
    8              0.000045000 hi def link perlNotEmptyLine		Error
    8              0.000045000 hi def link perlElseIfError		Error
                            
                            " Syncing to speed up processing
                            "
    8              0.000021000 if !get(g:, 'perl_no_sync_on_sub', 0)
    8              0.000040000   syn sync match perlSync	grouphere NONE "^\s*\<package\s"
    8              0.000028000   syn sync match perlSync	grouphere NONE "^\s*\<sub\>"
    8              0.000021000   syn sync match perlSync	grouphere NONE "^}"
    8              0.000005000 endif
                            
    8              0.000017000 if !get(g:, 'perl_no_sync_on_global_var', 0)
    8              0.000038000   syn sync match perlSync	grouphere NONE "^$\I[[:alnum:]_:]+\s*=\s*{"
    8              0.000033000   syn sync match perlSync	grouphere NONE "^[@%]\I[[:alnum:]_:]+\s*=\s*("
    8              0.000006000 endif
                            
    8              0.000015000 if get(g:, 'perl_sync_dist', 0)
                              execute "syn sync maxlines=" . perl_sync_dist
    8              0.000007000 else
    8              0.000008000   syn sync maxlines=100
    8              0.000004000 endif
                            
    8              0.000045000 syn sync match perlSyncPOD	grouphere perlPOD "^=pod"
    8              0.000038000 syn sync match perlSyncPOD	grouphere perlPOD "^=head"
    8              0.000034000 syn sync match perlSyncPOD	grouphere perlPOD "^=item"
    8              0.000024000 syn sync match perlSyncPOD	grouphere NONE "^=cut"
                            
    8              0.000019000 let b:current_syntax = "perl"
                            
    8              0.000034000 let &cpo = s:cpo_save
    8              0.000009000 unlet s:cpo_save
                            
                            " XXX Change to sts=4:sw=4
                            " vim:ts=8:sts=2:sw=2:expandtab:ft=vim

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/pod.vim
Sourced 8 times
Total time:   0.006536000
 Self time:   0.006533000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      https://github.com/vim-perl/vim-perl
                            " Bugs/requests: https://github.com/vim-perl/vim-perl/issues
                            " License:       Vim License (see :help license)
                            " Last Change:   2022 Jun 13
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " quit when a syntax file was already loaded
    8              0.000048000 if exists("b:current_syntax")
                              finish
    8              0.000004000 endif
                            
    8              0.000023000 let s:cpo_save = &cpo
    8   0.000026000   0.000024000 set cpo&vim
                            
                            " TODO: add supported encodings when we can utilize better performing Vim 8 features
    8              0.000063000 syn match podEncoding	"[0-9A-Za-z_-]\+" contained contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
    8              0.000085000 syn region podCmdText	start="\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
    8              0.000038000 syn match podOverIndent	"\d*\.\=\d\+\>" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
    8              0.000033000 syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
    8              0.000054000 syn region podVerbatim	start="^\s\+\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contains=@NoSpell
                            
    8              0.000101000 syn region podOrdinary	start="^\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contains=podFormat,podSpecial,@Spell
                            
                            " Inline textual items handled specially by POD
    8              0.000046000 syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
    8              0.000041000 syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
                            
    8              0.000061000 syn cluster podFormat contains=podFormat,podFormatError
                            
    8              0.000035000 syn match  podFormatError "[ADGHJKM-RT-WY]<"
                            
    8              0.000065000 syn region podFormat	matchgroup=podFormatDelimiter start="[IBSCLFX]<"              end=">"              contains=@podFormat,@NoSpell
    8              0.000069000 syn region podFormat	matchgroup=podFormatDelimiter start="[IBSCLFX]<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=@podFormat,@NoSpell
                            
    8              0.000024000 syn match  podFormat	"Z<>"
                            
    8              0.000096000 syn region podFormat	matchgroup=podFormatDelimiter start="E<" end=">" oneline contains=podEscape,podEscape2,@NoSpell
                            
                            " HTML entities {{{1
                            " Source: Pod/Escapes.pm
    8              0.000467000 syn keyword podEscape contained lt gt quot amp apos sol verbar lchevron rchevron nbsp iexcl cent pound curren yen brvbar sect uml copy ordf laquo not shy reg macr deg plusmn sup2 sup3 acute micro para middot cedil sup1 ordm raquo frac14 frac12 frac34 iquest Agrave Aacute Acirc Atilde Auml Aring AElig Ccedil Egrave Eacute Ecirc Euml Igrave Iacute Icirc Iuml ETH Ntilde Ograve Oacute Ocirc Otilde Ouml times Oslash Ugrave Uacute Ucirc Uuml Yacute THORN szlig agrave aacute acirc atilde auml aring aelig ccedil egrave eacute ecirc euml igrave iacute icirc iuml eth ntilde ograve oacute ocirc otilde ouml divide oslash ugrave uacute ucirc uuml yacute thorn yuml fnof Alpha Beta Gamma Delta Epsilon Zeta Eta Theta Iota Kappa Lambda Mu Nu Xi Omicron Pi Rho Sigma Tau Upsilon Phi Chi Psi Omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho sigmaf sigma tau upsilon phi chi psi omega thetasym upsih piv bull hellip prime Prime oline frasl weierp image real trade alefsym larr uarr rarr d
                            " }}}
                            
    8              0.000031000 syn match  podEscape2	"\d\+"     contained contains=@NoSpell
    8              0.000032000 syn match  podEscape2	"0\=x\x\+" contained contains=@NoSpell
    8              0.000025000 syn match  podEscape2	"0\o\+"    contained contains=@NoSpell
                            
                            
                            " POD commands
    8              0.000061000 syn match podCommand    "^=encoding\>"   nextgroup=podEncoding skipwhite contains=@NoSpell
    8              0.000060000 syn match podCommand    "^=head[1234]\>" nextgroup=podCmdText skipwhite skipnl contains=@NoSpell
    8              0.000053000 syn match podCommand    "^=item\>"       nextgroup=podCmdText skipwhite skipnl contains=@NoSpell
    8              0.000052000 syn match podCommand    "^=over\>"       nextgroup=podOverIndent skipwhite contains=@NoSpell
    8              0.000028000 syn match podCommand    "^=back"         contains=@NoSpell
    8              0.000027000 syn match podCommand    "^=cut"          contains=@NoSpell
    8              0.000031000 syn match podCommand    "^=pod"          contains=@NoSpell
    8              0.000048000 syn match podCommand    "^=for"          nextgroup=podForKeywd skipwhite contains=@NoSpell
    8              0.000048000 syn match podCommand    "^=begin"        nextgroup=podForKeywd skipwhite contains=@NoSpell
    8              0.000045000 syn match podCommand    "^=end"          nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Comments
                            
    8              0.000048000 syn keyword podForKeywd comment contained nextgroup=podForComment skipwhite skipnl
                            
    8              0.000024000 if exists("perl_pod_no_comment_fold")
                              syn region podBeginComment start="^=begin\s\+comment\s*$" end="^=end\s\+comment\ze\s*$" keepend extend contains=podCommand
                              syn region podForComment start="\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contained contains=@Spell,podTodo
    8              0.000009000 else
    8              0.000096000   syn region podBeginComment start="^=begin\s\+comment\s*$" end="^=end\s\+comment\ze\s*$" keepend extend contains=podCommand,podTodo fold
    8              0.000074000   syn region podForComment start="\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contained contains=@Spell,podTodo fold
    8              0.000003000 endif
                            
    8              0.000023000 syn keyword podTodo contained TODO FIXME XXX
                            
                            " Plain Pod files
    8              0.000051000 syn region podNonPod			   start="\%^\%(=\w\+\>\)\@!" end="^\ze=\a\w*\>"
    8              0.000047000 syn region podNonPod matchgroup=podCommand start="^=cut\>"	      end="\%$"
    8              0.000047000 syn region podNonPod matchgroup=podCommand start="^=cut\>"	      end="^\ze=\a\w*\>"
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    8              0.000055000 hi def link podCommand		Statement
    8              0.000048000 hi def link podBeginComment	Comment
    8              0.000048000 hi def link podForComment	Comment
    8              0.000046000 hi def link podNonPod		Comment
    8              0.000047000 hi def link podTodo		Todo
    8              0.000046000 hi def link podCmdText		String
    8              0.000048000 hi def link podEncoding		Constant
    8              0.000047000 hi def link podOverIndent	Number
    8              0.000047000 hi def link podForKeywd		Identifier
    8              0.000051000 hi def link podVerbatim		PreProc
    8              0.000047000 hi def link podFormat		Identifier
    8              0.000030000 hi def link podFormatDelimiter	podFormat
    8              0.000046000 hi def link podFormatError	Error
    8              0.000044000 hi def link podSpecial		Identifier
    8              0.000047000 hi def link podEscape		Constant
    8              0.000047000 hi def link podEscape2		Number
                            
    8              0.000023000 if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn region podCmdText start="\S.*$" end="^\s*$" end="^\ze=cut\>" contained contains=podFormat
    8              0.000006000 endif
                            
    8              0.000016000 if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" contains=@podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=@podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn region podFormat	start="E<" end=">" oneline contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<<\%(\s\+\|$\)" contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<<\%(\s\+\|$\)" contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<<\%(\s\+\|$\)" contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<<\%(\s\+\|$\)" contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">"
                              syn region podItalicBold contained start="B<[^<]"me=e end=">"
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\%(\s\+\|$\)"ms=s-2 end="\%(\s\+\|^\)>>"me=e contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\%(\s\+\|$\)"ms=s-2 end="\%(\s\+\|^\)>>"me=e contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn region podVerbatim start="^\s\+\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=@podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=@podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
    8              0.000009000 endif
                            
    8              0.000017000 let b:current_syntax = "pod"
                            
    8   0.000035000   0.000034000 let &cpo = s:cpo_save
    8              0.000010000 unlet s:cpo_save
                            
                            " vim: ts=8 fdm=marker:

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/ruby.vim
Sourced 8 times
Total time:   0.092550000
 Self time:   0.083952000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2023 Mar 16
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
                            " Prelude {{{1
    8              0.000041000 if exists("b:current_syntax")
                              finish
    8              0.000007000 endif
                            
                            " this file uses line continuations
    8              0.000024000 let s:cpo_sav = &cpo
    8              0.000023000 set cpo&vim
                            
                            " eRuby Config {{{1
    8              0.000018000 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
    8              0.000005000 endif
                            
                            " Folding Config {{{1
    8              0.000027000 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
    8              0.000003000 endif
                            
    8              0.000109000 let s:foldable_groups = split(
                                  \	  get(
                                  \	    b:,
                                  \	    'ruby_foldable_groups',
                                  \	    get(g:, 'ruby_foldable_groups', 'ALL')
                                  \	  )
                                  \	)
                            
    8              0.000028000 function! s:foldable(...) abort
                              if index(s:foldable_groups, 'NONE') > -1
                                return 0
                              endif
                            
                              if index(s:foldable_groups, 'ALL') > -1
                                return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
    8              0.000016000 function! s:run_syntax_fold(args) abort
                              let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
                              if call('s:foldable', split(groups))
                                let cmd .= ' fold'
                              endif
                              exe cmd
                            endfunction
                            
    8              0.000039000 com! -nargs=* SynFold call s:run_syntax_fold(<q-args>)
                            
                            " Not-Top Cluster {{{1
    8              0.000219000 syn cluster rubyNotTop contains=@rubyCommentNotTop,@rubyStringNotTop,@rubyRegexpSpecial,@rubyDeclaration,@rubyExceptionHandler,@rubyClassOperator,rubyConditional,rubyModuleName,rubyClassName,rubySymbolDelimiter,rubyDoubleQuoteSymbolDelimiter,rubySingleQuoteSymbolDelimiter,rubyParentheses,@Spell
                            
                            " Whitespace Errors {{{1
    8              0.000021000 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
    8              0.000005000 endif
                            
                            " Operators {{{1
                            
    8              0.000034000 syn match rubyEnglishBooleanOperator "\<\%(and\|or\|not\)\>"
                            
    8              0.000024000 if exists("ruby_operators") || exists("ruby_pseudo_operators")
                              syn match rubyDotOperator	   "\.\|&\."
                            
                              syn match rubyTernaryOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!?\|:"
                              syn match rubyArithmeticOperator "\*\*\|[*/%+]\|->\@!"
                              syn match rubyComparisonOperator "<=>\|<=\|<\|>=\|[-=]\@1<!>"
                              syn match rubyBitwiseOperator    "[~^|]\|&\.\@!\|<<\|>>"
                              syn match rubyBooleanOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!!\|&&\|||"
                              syn match rubyRangeOperator	   "\.\.\.\="
                              syn match rubyAssignmentOperator "=>\@!\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|||=\||=\|%=\|+=\|>>=\|<<=\|\^="
                              syn match rubyAssignmentOperator "=>\@!" contained containedin=rubyBlockParameterList " TODO: this is inelegant
                              syn match rubyEqualityOperator   "===\|==\|!=\|!\~\|=\~"
                            
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<=\[" end="]" contains=ALLBUT,@rubyNotTop
                            
                              syn match rubyScopeOperator	    "::"
                              syn match rubySuperClassOperator  "<"	 contained
                              syn match rubyEigenClassOperator  "<<" contained
                              syn match rubyLambdaOperator	    "->"
                              syn match rubySplatOperator	    "\%([[{(|,=]\_s*\)\@<=\*"
                              syn match rubySplatOperator	    "\%(^\|\s\)\@1<=\*\%(\h\|[^\x00-\x7F]\|[:$@[]\)\@="
                              syn match rubyDoubleSplatOperator "\%([{(|,]\_s*\)\@<=\*\*"
                              syn match rubyDoubleSplatOperator "\s\@1<=\*\*\%(\h\|[^\x00-\x7F]\|[:$@{]\)\@="
                              syn match rubyProcOperator	    "\%([[(|,]\_s*\)\@<=&"
                              syn match rubyProcOperator	    "\s\@1<=&\%(\h\|[^\x00-\x7F]\|[:$@]\|->\)\@="
                            
                              syn cluster rubyProperOperator contains=rubyTernaryOperator,rubyArithmeticOperator,rubyComparisonOperator,rubyBitwiseOperator,rubyBooleanOperator,rubyRangeOperator,rubyAssignmentOperator,rubyEqualityOperator,rubyDefinedOperator,rubyEnglishBooleanOperator
                              syn cluster rubyClassOperator  contains=rubyEigenClassOperator,rubySuperClassOperator
                              syn cluster rubyPseudoOperator contains=rubyDotOperator,rubyScopeOperator,rubyEigenClassOperator,rubySuperClassOperator,rubyLambdaOperator,rubySplatOperator,rubyDoubleSplatOperator,rubyProcOperator
                              syn cluster rubyOperator	 contains=ruby.*Operator
    8              0.000006000 endif
                            
                            " String Interpolation and Backslash Notation {{{1
    8              0.000049000 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    8              0.000067000 syn match  rubyInterpolation	      "#\$\%(-\w\|[!$&"'*+,./0:;<>?@\`~_]\|\w\+\)" display contained contains=rubyInterpolationDelimiter,@rubyGlobalVariable
    8              0.000080000 syn match  rubyInterpolation	      "#@@\=\w\+"				   display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable
    8              0.000024000 syn match  rubyInterpolationDelimiter "#\ze[$@]"				   display contained
                            
    8              0.000024000 syn match rubyStringEscape "\\\_."											   contained display
    8              0.000035000 syn match rubyStringEscape "\\\o\{1,3}\|\\x\x\{1,2}"									   contained display
    8              0.000046000 syn match rubyStringEscape "\\u\%(\x\{4}\|{\x\{1,6}\%(\s\+\x\{1,6}\)*}\)"						   contained display
    8              0.000060000 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=.\)" contained display
                            
    8              0.000023000 syn match rubyBackslashEscape "\\\\" contained display
    8              0.000022000 syn match rubyQuoteEscape     "\\'"  contained display
    8              0.000021000 syn match rubySpaceEscape     "\\ "  contained display
                            
    8              0.000024000 syn match rubyParenthesisEscape	  "\\[()]"  contained display
    8              0.000023000 syn match rubyCurlyBraceEscape	  "\\[{}]"  contained display
    8              0.000024000 syn match rubyAngleBracketEscape  "\\[<>]"  contained display
    8              0.000029000 syn match rubySquareBracketEscape "\\[[\]]" contained display
                            
    8              0.000047000 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  end=")"	transparent contained
    8              0.000033000 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  end="}"	transparent contained
    8              0.000042000 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  end=">"	transparent contained
    8              0.000043000 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" end="\]"	transparent contained
                            
    8              0.000118000 syn cluster rubySingleCharEscape contains=rubyBackslashEscape,rubyQuoteEscape,rubySpaceEscape,rubyParenthesisEscape,rubyCurlyBraceEscape,rubyAngleBracketEscape,rubySquareBracketEscape
    8              0.003919000 syn cluster rubyNestedBrackets	 contains=rubyNested.\+
    8              0.000043000 syn cluster rubyStringSpecial	 contains=rubyInterpolation,rubyStringEscape
    8              0.000020000 syn cluster rubyStringNotTop	 contains=@rubyStringSpecial,@rubyNestedBrackets,@rubySingleCharEscape
                            
                            " Regular Expression Metacharacters {{{1
    8              0.000052000 syn region rubyRegexpComment	  matchgroup=rubyRegexpSpecial	 start="(?#"								     skip="\\\\\|\\)"  end=")"	contained
    8              0.000090000 syn region rubyRegexpParens	  matchgroup=rubyRegexpSpecial	 start="(\%(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\\\\|\\)"  end=")"	contained transparent contains=@rubyRegexpSpecial
    8              0.000137000 syn region rubyRegexpBrackets	  matchgroup=rubyRegexpCharClass start="\[\^\="								     skip="\\\\\|\\\]" end="\]" contained transparent contains=rubyRegexpBrackets,rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass,rubyRegexpIntersection oneline
    8              0.000039000 syn match  rubyRegexpCharClass	  "\\[DdHhRSsWw]"	 contained display
    8              0.000059000 syn match  rubyRegexpCharClass	  "\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|word\|xdigit\):\]" contained
    8              0.000028000 syn match  rubyRegexpCharClass	  "\\[pP]{^\=.\{-}}"	 contained display
    8              0.000031000 syn match  rubyRegexpEscape	  "\\[].*?+^$|\\/(){}[]" contained " see commit e477f10
    8              0.000031000 syn match  rubyRegexpQuantifier	  "[*?+][?+]\="		 contained display
    8              0.000025000 syn match  rubyRegexpQuantifier	  "{\d\+\%(,\d*\)\=}?\=" contained display
    8              0.000033000 syn match  rubyRegexpAnchor	  "[$^]\|\\[ABbGZz]"	 contained display
    8              0.000022000 syn match  rubyRegexpDot	  "\.\|\\X"		 contained display
    8              0.000018000 syn match  rubyRegexpIntersection "&&"			 contained display
    8              0.000020000 syn match  rubyRegexpSpecial	  "\\K"			 contained display
    8              0.000016000 syn match  rubyRegexpSpecial	  "|"			 contained display
    8              0.000025000 syn match  rubyRegexpSpecial	  "\\[1-9]\d\=\d\@!"	 contained display
    8              0.000038000 syn match  rubyRegexpSpecial	  "\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    8              0.000052000 syn match  rubyRegexpSpecial	  "\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    8              0.000025000 syn match  rubyRegexpSpecial	  "\\g<\%([a-z_]\w*\|-\=\d\+\)>"		contained display
    8              0.000026000 syn match  rubyRegexpSpecial	  "\\g'\%([a-z_]\w*\|-\=\d\+\)'"		contained display
                            
    8              0.000155000 syn cluster rubyRegexpSpecial contains=@rubyStringSpecial,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment,rubyRegexpIntersection
                            
                            " Numbers {{{1
    8              0.000065000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"							       display
    8              0.000056000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"					       display
    8              0.000047000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"							       display
    8              0.000045000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"						       display
    8              0.000059000 syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"				       display
    8              0.000066000 syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)i\=\>" display
                            
                            " Identifiers {{{1
    8              0.000050000 syn match rubyClassName	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
    8              0.000040000 syn match rubyModuleName       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
    8              0.000053000 syn match rubyConstant	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    8              0.000052000 syn match rubyClassVariable    "@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    8              0.000032000 syn match rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
    8              0.000041000 syn match rubyGlobalVariable   "$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    8              0.000046000 syn match rubySymbolDelimiter  ":" contained
    8              0.000099000 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)" contains=rubySymbolDelimiter
    8              0.000059000 syn match rubySymbol	       "[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"			    contains=rubySymbolDelimiter
    8              0.000062000 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  contains=rubySymbolDelimiter
    8              0.000056000 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\=" contains=rubySymbolDelimiter
                            
    8   0.000652000   0.000563000 SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,rubyBackslashEscape
    8   0.000498000   0.000441000 SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
                            
    8              0.000046000 syn match rubyCapitalizedMethod "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@="
                            
    8              0.000050000 syn region rubyParentheses	  start="("				 end=")" contains=ALLBUT,@rubyNotTop contained containedin=rubyBlockParameterList
    8              0.000055000 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" contains=ALLBUT,@rubyNotTop,@rubyProperOperator
                            
    8              0.000021000 if exists('ruby_global_variable_error')
                              syn match rubyGlobalVariableError "$[^A-Za-z_]"	display
                              syn match rubyGlobalVariableError "$-[^0FIKWadilpvw]" display
    8              0.000004000 endif
                            
    8              0.000034000 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<>?@\`~]#
    8              0.000022000 syn match rubyPredefinedVariable "$\d\+"									    display
    8              0.000021000 syn match rubyPredefinedVariable "$_\>"										    display
    8              0.000027000 syn match rubyPredefinedVariable "$-[0FIWadilpvw]\>"								    display
    8              0.000029000 syn match rubyPredefinedVariable "$\%(stderr\|stdin\|stdout\)\>"						    display
    8              0.000049000 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    8              0.000082000 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\)\>\%(\s*(\)\@!"
    8              0.000073000 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Deprecated/removed in 1.9
    8              0.000020000 syn match rubyPredefinedVariable "$="
    8              0.000022000 syn match rubyPredefinedVariable "$-K\>"		  display
    8              0.000025000 syn match rubyPredefinedVariable "$\%(deferr\|defout\)\>" display
    8              0.000022000 syn match rubyPredefinedVariable "$KCODE\>"		  display
                            " Deprecated/removed in 2.4
    8              0.000036000 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(FALSE\|NIL\|TRUE\)\>\%(\s*(\)\@!"
                            
    8              0.000055000 syn cluster rubyGlobalVariable contains=rubyGlobalVariable,rubyPredefinedVariable,rubyGlobalVariableError
                            
                            " Normal Regular Expressions {{{1
    8   0.000628000   0.000536000 SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
    8   0.000509000   0.000438000 SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\s\+\)\@<=/\%(=\|\_s\)\@!"					   end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
                            
                            " Generalized Regular Expressions {{{1
    8   0.000457000   0.000389000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
    8   0.000388000   0.000332000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r{"				   end="}[iomxneus]*"	skip="\\\\\|\\}"   contains=@rubyRegexpSpecial
    8   0.000399000   0.000345000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r<"				   end=">[iomxneus]*"	skip="\\\\\|\\>"   contains=@rubyRegexpSpecial,rubyNestedAngleBrackets
    8   0.000375000   0.000311000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\["				   end="\][iomxneus]*"	skip="\\\\\|\\\]"  contains=@rubyRegexpSpecial
    8   0.000361000   0.000312000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r("				   end=")[iomxneus]*"	skip="\\\\\|\\)"   contains=@rubyRegexpSpecial
    8   0.000369000   0.000319000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z(\s\)"			   end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                            
                            " Characters {{{1
    8              0.000089000 syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\[[:space:]]\|\\\=[^[:space:]]\)\)"
    8              0.000049000 syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!?\\u\%(\x\{4}\|{\x\{1,6}}\)"
                            
                            " Normal Strings {{{1
    8              0.000038000 let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
    8   0.000082000   0.000074000 let s:fold_arg	    = s:foldable('string')		? ' fold'   : ''
    8              0.000081000 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\""  contains=@rubyStringSpecial'		       . s:spell_cluster . s:fold_arg
    8              0.000095000 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''"  contains=rubyQuoteEscape,rubyBackslashEscape' . s:spell_cluster . s:fold_arg
    8              0.000014000 unlet s:spell_cluster s:fold_arg
                            
                            " Shell Command Output {{{1
    8   0.000350000   0.000300000 SynFold 'string' syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
                            
                            " Generalized Single Quoted Strings, Symbols, Array of Strings and Array of Symbols {{{1
                            
                            " Non-bracket punctuation delimiters {{{2
    8              0.000112000 let s:names = { '~': 'Tilde', '`': 'BackQuote', '!': 'Bang', '@': 'At', '#': 'Hash', '$': 'Dollar', '%': 'Percent', '^': 'Caret',
                                  \		'&': 'Ampersand', '*': 'Asterix', '_': 'Underscore', '-': 'Dash', '+': 'Plus', '=': 'Equals', '|': 'Bar',
                                  \		'\': 'Backslash', ':': 'Colon', ';': 'Semicolon', '"': 'DoubleQuote', "'": 'Quote', ',': 'Comma', '.': 'Period',
                                  \		'?': 'QuestionMark', '/': 'ForwardSlash' }
                            
  200              0.000216000 for s:delimiter in keys(s:names)
  192              0.000401000   let s:group = 'ruby' . s:names[s:delimiter] . 'Escape'
                            
  192              0.000405000   if s:delimiter =~ '[\"]'
   16              0.000024000     let s:delimiter = '\' . s:delimiter
  192              0.000083000   endif
                            
  192              0.000917000   exe 'syn match ' . s:group . ' "\V\\' . s:delimiter . '" contained display'
  192              0.003324000   exe 'syn cluster rubySingleCharEscape add=' . s:group
  192   0.010624000   0.009310000   exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%q' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
  192   0.011041000   0.009730000   exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%w' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
  192   0.010372000   0.009127000   exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%s' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
  192   0.010971000   0.009674000   exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%i' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
  192              0.000745000   exe 'hi def link ' . s:group . ' rubyStringEscape'
  200              0.000114000 endfor
                            
    8              0.000023000 unlet s:delimiter s:group s:names
                            " }}}2
                            
    8   0.000403000   0.000353000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    8   0.000395000   0.000345000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    8   0.000404000   0.000354000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    8   0.000390000   0.000340000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
    8   0.000378000   0.000319000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
                            
    8   0.000434000   0.000383000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    8   0.000424000   0.000372000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    8   0.000425000   0.000372000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    8   0.000411000   0.000360000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
                            
    8   0.000387000   0.000339000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    8   0.000384000   0.000335000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    8   0.000394000   0.000344000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    8   0.000396000   0.000342000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
    8   0.000364000   0.000317000 SynFold '%' syn region rubyString matchgroup=rubyPercentSymbolDelimiter start="%s\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
                            
    8   0.000475000   0.000423000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    8   0.000416000   0.000365000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    8   0.000514000   0.000368000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    8   0.000410000   0.000358000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
                            
                            " Generalized Double Quoted Strings, Array of Strings, Array of Symbols and Shell Command Output {{{1
    8   0.000399000   0.000349000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\%(\%(\w\|[^\x00-\x7F]\|]\)\s*\)\@<!%=" end="="	 skip="\\\\\|\\="   contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    8   0.000391000   0.000340000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    8   0.000396000   0.000345000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    8   0.000371000   0.000324000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\={"			       end="}"	 skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces
    8   0.000359000   0.000312000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=<"			       end=">"	 skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets
    8   0.000363000   0.000315000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=\["			       end="\]"  skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets
    8   0.000354000   0.000308000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=("			       end=")"	 skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses
    8   0.000330000   0.000286000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[Qx]\z(\s\)"			       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                            
    8   0.000375000   0.000325000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    8   0.000362000   0.000316000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I{"				   end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces
    8   0.000347000   0.000303000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I<"				   end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets
    8   0.000351000   0.000306000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\["				   end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets
    8   0.000341000   0.000296000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I("				   end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses
                            
                            " Here Documents {{{1
    8              0.000100000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    8              0.000065000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
    8              0.000053000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
    8              0.000051000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    8   0.000560000   0.000493000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2  matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
    8   0.000475000   0.000416000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
    8   0.000453000   0.000396000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart		     keepend
    8   0.000446000   0.000389000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
                            
    8   0.000517000   0.000450000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3 matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
    8   0.000455000   0.000397000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
    8   0.000437000   0.000381000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     keepend
    8   0.000451000   0.000391000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                            
                            " Module, Class, Method and Alias Declarations {{{1
    8              0.000063000 syn match rubyAliasDeclaration	"[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable nextgroup=rubyAliasDeclaration2 skipwhite
    8              0.000039000 syn match rubyAliasDeclaration2 "[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable
    8              0.000107000 syn match rubyMethodDeclaration "[^[:space:];#(]\+"   contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    8              0.000067000 syn match rubyClassDeclaration	"[^[:space:];#<]\+"   contained contains=rubyClassName,rubyScopeOperator nextgroup=rubySuperClassOperator skipwhite
    8              0.000046000 syn match rubyModuleDeclaration "[^[:space:];#<]\+"   contained contains=rubyModuleName,rubyScopeOperator
                            
    8              0.000068000 syn match rubyMethodName "\<\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%([[:alnum:]_.:?!=]\|[^\x00-\x7F]\)\@!"			      contained containedin=rubyMethodDeclaration
    8              0.000069000 syn match rubyMethodName "\%(\s\|^\)\@1<=\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%(\s\|$\)\@="					      contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    8              0.000100000 syn match rubyMethodName "\%([[:space:].]\|^\)\@1<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    8              0.000070000 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyMethodName
                            
                            " Keywords {{{1
                            " TODO: reorganise
    8              0.000055000 syn match rubyControl	     "\%#=1\<\%(break\|in\|next\|redo\|retry\|return\)\>"
    8              0.000030000 syn match rubyKeyword	     "\%#=1\<\%(super\|yield\)\>"
    8              0.000030000 syn match rubyBoolean	     "\%#=1\<\%(true\|false\)\>[?!]\@!"
    8              0.000027000 syn match rubyPseudoVariable "\%#=1\<\%(self\|nil\)\>[?!]\@!"
    8              0.000051000 syn match rubyPseudoVariable "\%#=1\<__\%(ENCODING\|dir\|FILE\|LINE\|callee\|method\)__\>"
    8              0.000028000 syn match rubyBeginEnd	     "\%#=1\<\%(BEGIN\|END\)\>"
                            
                            " Expensive Mode {{{1
                            " Match 'end' with the appropriate opening keyword for syntax based folding
                            " and special highlighting of module/class/method definitions
    8              0.000083000 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    8              0.000042000   syn match rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration			  skipwhite skipnl
    8              0.000041000   syn match rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration			  skipwhite skipnl
    8              0.000029000   syn match rubyDefine "\<undef\>"  nextgroup=rubyMethodName				  skipwhite skipnl
    8              0.000047000   syn match rubyClass  "\<class\>"  nextgroup=rubyClassDeclaration,rubyEigenClassOperator skipwhite skipnl
    8              0.000035000   syn match rubyModule "\<module\>" nextgroup=rubyModuleDeclaration			  skipwhite skipnl
                            
    8   0.000411000   0.000352000   SynFold 'def'    syn region rubyMethodBlock start="\<def\>"	 matchgroup=rubyDefine skip="\<end:\|\%(\<def\_s\+\)\@<=end\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
    8   0.000373000   0.000324000   SynFold 'class'  syn region rubyClassBlock  start="\<class\>"  matchgroup=rubyClass  skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
    8   0.000337000   0.000288000   SynFold 'module' syn region rubyModuleBlock start="\<module\>" matchgroup=rubyModule skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
                              " endless def
    8              0.000053000   syn match rubyDefine "\<def\s\+\ze[^[:space:];#(]\+\%(\s\+\|\s*(.*)\s*\)=" nextgroup=rubyMethodDeclaration skipwhite
                            
                              " modifiers
    8              0.000027000   syn match rubyLineContinuation    "\\$" nextgroup=@rubyModifier skipwhite skipnl
    8              0.000028000   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
    8              0.000028000   syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
    8              0.000034000   syn match rubyRescueModifier	    "\<rescue\>"
                            
    8              0.000037000   syn cluster rubyModifier contains=rubyConditionalModifier,rubyRepeatModifier,rubyRescueModifier
                            
    8   0.000328000   0.000282000   SynFold 'do' syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
                              " curly bracket block or hash literal
    8   0.000310000   0.000258000   SynFold '{' syn region rubyCurlyBlock   matchgroup=rubyCurlyBlockDelimiter start="{"						    end="}" contains=ALLBUT,@rubyNotTop
    8   0.000357000   0.000302000   SynFold '[' syn region rubyArrayLiteral matchgroup=rubyArrayDelimiter      start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<!\[" end="]" contains=ALLBUT,@rubyNotTop
                            
                              " statements without 'do'
    8   0.000329000   0.000281000   SynFold 'begin' syn region rubyBlockExpression matchgroup=rubyControl     start="\<begin\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
    8   0.000334000   0.000285000   SynFold 'case'  syn region rubyCaseExpression  matchgroup=rubyConditional start="\<case\>"  skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
    8   0.000502000   0.000435000   SynFold 'if' syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\<then\s\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
    8              0.000039000   syn match rubyConditional "\<\%(then\|else\|when\)\>"	 contained containedin=rubyCaseExpression
    8              0.000033000   syn match rubyConditional "\<\%(then\|else\|elsif\)\>" contained containedin=rubyConditionalExpression
                            
    8              0.000054000   syn match   rubyExceptionHandler  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyBlockExpression,rubyDoBlock
    8              0.000060000   syn match   rubyExceptionHandler2 "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyModuleBlock,rubyClassBlock,rubyMethodBlock
    8              0.000029000   syn cluster rubyExceptionHandler  contains=rubyExceptionHandler,rubyExceptionHandler2
                            
                              " statements with optional 'do'
    8              0.000114000   syn region rubyOptionalDoLine matchgroup=rubyRepeat start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\<do\>" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
                            
    8   0.000541000   0.000470000   SynFold 'for' syn region rubyRepeatExpression start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
                            
                            else
                              syn match rubyControl "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match rubyControl "\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match rubyControl "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                              syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|rescue\|ensure\|then\|when\|end\)\>"
                              syn match rubyKeyword "\<\%(alias\|undef\)\>"
    8              0.000007000 endif
                            
    8              0.000018000 if !exists("ruby_minlines")
    1              0.000002000   let ruby_minlines = 500
    8              0.000004000 endif
    8              0.000032000 exe "syn sync minlines=" . ruby_minlines
                            
                            " Special Methods {{{1
    8              0.000016000 if !exists("ruby_no_special_methods")
    8              0.000138000   syn match rubyAccess	  "\<\%(public\|protected\|private\)\>" " use re=2
    8              0.000038000   syn match rubyAccess	  "\%#=1\<\%(public\|private\)_class_method\>"
    8              0.000032000   syn match rubyAccess	  "\%#=1\<\%(public\|private\)_constant\>"
    8              0.000022000   syn match rubyAccess	  "\%#=1\<module_function\>"
    8              0.000049000   syn match rubyAttribute "\%#=1\%(\%(^\|;\)\s*\)\@<=attr\>\%(\s*[.=]\)\@!" " attr is a common variable name
    8              0.000036000   syn match rubyAttribute "\%#=1\<attr_\%(accessor\|reader\|writer\)\>"
    8              0.000040000   syn match rubyControl   "\%#=1\<\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>"
    8              0.000022000   syn match rubyEval	  "\%#=1\<eval\>"
    8              0.000033000   syn match rubyEval	  "\%#=1\<\%(class\|instance\|module\)_eval\>"
    8              0.000036000   syn match rubyException "\%#=1\<\%(raise\|fail\|catch\|throw\)\>"
    8              0.000053000   syn match rubyInclude   "\%#=1\<\%(autoload\|gem\|load\|require\%(_relative\)\=\)\>"
    8              0.000031000   syn match rubyKeyword   "\%#=1\<\%(callcc\|caller\|lambda\|proc\)\>"
    8              0.000039000   syn match rubyMacro	  "\%#=1\<\%(extend\|include\|prepend\|refine\|using\)\>"
    8              0.000044000   syn match rubyMacro	  "\%#=1\<\%(alias\|define\|define_singleton\|remove\|undef\)_method\>"
    8              0.000005000 endif
                            
                            " Comments and Documentation {{{1
    8              0.000030000 syn match   rubySharpBang    "\%^#!.*" display
    8              0.000028000 syn keyword rubyTodo	     FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
    8              0.000025000 syn match   rubyEncoding     "[[:alnum:]-_]\+" contained display
    8              0.000045000 syn match   rubyMagicComment "\c\%<3l#\s*\zs\%(coding\|encoding\):"					contained nextgroup=rubyEncoding skipwhite
    8              0.000054000 syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(frozen[-_]string[-_]literal\|warn[-_]indent\|warn[-_]past[-_]scope\):" contained nextgroup=rubyBoolean  skipwhite
    8              0.000037000 syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(shareable[-_]constant[-_]value\):"				contained nextgroup=rubyEncoding  skipwhite
    8              0.000048000 syn match   rubyComment	     "#.*" contains=@rubyCommentSpecial,rubySpaceError,@Spell
                            
    8              0.000030000 syn cluster rubyCommentSpecial contains=rubySharpBang,rubyTodo,rubyMagicComment
    8              0.000020000 syn cluster rubyCommentNotTop  contains=@rubyCommentSpecial,rubyEncoding
                            
    8   0.000081000   0.000074000 if !exists("ruby_no_comment_fold") && s:foldable('#')
    8              0.000055000   syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    8              0.000064000   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$"      contains=rubySpaceError,rubyTodo,@Spell fold
                            else
                              syn region rubyDocumentation	  start="^=begin\s*$"		 end="^=end\s*$"              contains=rubySpaceError,rubyTodo,@Spell
    8              0.000001000 endif
                            
                            " {{{1 Useless Line Continuations
    8              0.000060000 syn match rubyUselessLineContinuation "\%([.:,;{([<>~\*%&^|+=-]\|%(\%(\w\|[^\x00-\x7F]\)\@1<![?!]\)\s*\zs\\$" nextgroup=rubyUselessLineContinuation skipwhite skipempty
    8              0.000024000 syn match rubyUselessLineContinuation "\\$"								      nextgroup=rubyUselessLineContinuation skipwhite skipempty contained
                            
                            " Keyword Nobbling {{{1
                            " prevent methods with keyword names being highlighted as keywords when called
    8              0.000076000 syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|&\.\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\%(BEGIN\|END\)\>\)" transparent contains=rubyDotOperator,rubyScopeOperator
                            
                            " Bang and Predicate Methods and Operators {{{1
    8              0.000038000 syn match rubyBangPredicateMethod "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]"
                            
    8              0.000017000 if !exists("ruby_no_special_methods")
    8              0.000023000   syn match rubyControl "\%#=1\<exit!" display
    8              0.000002000 endif
    8              0.000023000 syn match rubyDefinedOperator "\%#=1\<defined?" display
                            
                            " 1.9-style Hash Keys and Keyword Parameters {{{1
    8              0.000060000 syn match rubySymbol "\%(\w\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]\=::\@!"he=e-1 contained containedin=rubyBlockParameterList,rubyCurlyBlock
    8              0.000047000 syn match rubySymbol "[]})\"':]\@1<!\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="he=e-1
    8              0.000042000 syn match rubySymbol "[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="hs=s+1,he=e-1
    8              0.000016000 syn match rubySingleQuoteSymbolDelimiter "'" contained
    8              0.000089000 syn match rubySymbol "'\%(\\.\|[^']\)*'::\@!"he=e-1 contains=rubyQuoteEscape,rubyBackslashEscape,rubySingleQuoteSymbolDelimiter
    8              0.000015000 syn match rubyDoubleQuoteSymbolDelimiter "\"" contained
    8              0.000054000 syn match rubySymbol "\"\%(\\.\|[^\"]\)*\"::\@!"he=e-1 contains=@rubyStringSpecial,rubyDoubleQuoteSymbolDelimiter
                            
                            " __END__ Directive {{{1
    8   0.000324000   0.000263000 SynFold '__END__' syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
                            
                            " Default Highlighting {{{1
    8              0.000016000 hi def link rubyClass			rubyDefine
    8              0.000013000 hi def link rubyModule			rubyDefine
    8              0.000014000 hi def link rubyExceptionHandler2	rubyDefine
    8              0.000048000 hi def link rubyDefine			Define
    8              0.000010000 hi def link rubyAccess			rubyMacro
    8              0.000012000 hi def link rubyAttribute		rubyMacro
    8              0.000033000 hi def link rubyMacro			Macro
    8              0.000020000 hi def link rubyMethodName		rubyFunction
    8              0.000031000 hi def link rubyFunction		Function
    8              0.000039000 hi def link rubyConditional		Conditional
    8              0.000020000 hi def link rubyConditionalModifier	rubyConditional
    8              0.000015000 hi def link rubyExceptionHandler	rubyConditional
    8              0.000012000 hi def link rubyRescueModifier		rubyExceptionHandler
    8              0.000037000 hi def link rubyRepeat			Repeat
    8              0.000014000 hi def link rubyRepeatModifier		rubyRepeat
    8              0.000009000 hi def link rubyOptionalDo		rubyRepeat
    8              0.000036000 hi def link rubyControl			Statement
    8              0.000034000 hi def link rubyInclude			Include
    8              0.000038000 hi def link rubyInteger			Number
    8              0.000036000 hi def link rubyCharacter		Character
    8              0.000035000 hi def link rubyFloat			Float
    8              0.000038000 hi def link rubyBoolean			Boolean
    8              0.000032000 hi def link rubyException		Exception
    8              0.000017000 if !exists("ruby_no_identifiers")
    8              0.000039000   hi def link rubyIdentifier		Identifier
                            else
                              hi def link rubyIdentifier		NONE
    8              0.000003000 endif
    8              0.000016000 hi def link rubyClassVariable		rubyIdentifier
    8              0.000037000 hi def link rubyConstant		Type
    8              0.000018000 hi def link rubyClassName		rubyConstant
    8              0.000017000 hi def link rubyModuleName		rubyConstant
    8              0.000015000 hi def link rubyGlobalVariable		rubyIdentifier
    8              0.000013000 hi def link rubyInstanceVariable	rubyIdentifier
    8              0.000012000 hi def link rubyPredefinedIdentifier	rubyIdentifier
    8              0.000015000 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    8              0.000015000 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    8              0.000036000 hi def link rubySymbol			Constant
    8              0.000035000 hi def link rubyKeyword			Keyword
                            
    8              0.000041000 hi def link rubyOperator		Operator
    8              0.000010000 hi def link rubyDefinedOperator		rubyOperator
    8              0.000015000 hi def link rubyEnglishBooleanOperator	rubyOperator
    8              0.000013000 if exists("ruby_operators")
                              hi def link rubyTernaryOperator	rubyOperator
                              hi def link rubyArithmeticOperator	rubyOperator
                              hi def link rubyComparisonOperator	rubyOperator
                              hi def link rubyBitwiseOperator	rubyOperator
                              hi def link rubyBooleanOperator	rubyOperator
                              hi def link rubyRangeOperator		rubyOperator
                              hi def link rubyAssignmentOperator	rubyOperator
                              hi def link rubyEqualityOperator	rubyOperator
    8              0.000006000 endif
                            
    8              0.000014000 if exists("ruby_pseudo_operators")
                              hi def link rubyPseudoOperator	Special
                              hi def link rubyDotOperator		rubyPseudoOperator
                              hi def link rubyScopeOperator		rubyPseudoOperator
                              hi def link rubySuperClassOperator	rubyPseudoOperator
                              hi def link rubyEigenClassOperator	rubyPseudoOperator
                              hi def link rubyLambdaOperator	rubyPseudoOperator
                              hi def link rubyDoubleSplatOperator	rubyPseudoOperator
                              hi def link rubySplatOperator		rubyPseudoOperator
                              hi def link rubyProcOperator		rubyPseudoOperator
    8              0.000005000 endif
                            
    8              0.000037000 hi def link rubyBeginEnd		Statement
    8              0.000034000 hi def link rubyEval			Statement
    8              0.000038000 hi def link rubyPseudoVariable		Constant
    8              0.000038000 hi def link rubyCapitalizedMethod	NONE
                            
    8              0.000035000 hi def link rubyComment			Comment
    8              0.000036000 hi def link rubyEncoding		Constant
    8              0.000036000 hi def link rubyMagicComment		SpecialComment
    8              0.000036000 hi def link rubyData			Comment
    8              0.000033000 hi def link rubyDataDirective		Delimiter
    8              0.000036000 hi def link rubyDocumentation		Comment
    8              0.000035000 hi def link rubyTodo			Todo
                            
    8              0.000020000 hi def link rubyBackslashEscape		rubyStringEscape
    8              0.000018000 hi def link rubyQuoteEscape		rubyStringEscape
    8              0.000017000 hi def link rubySpaceEscape		rubyStringEscape
    8              0.000017000 hi def link rubyParenthesisEscape	rubyStringEscape
    8              0.000018000 hi def link rubyCurlyBraceEscape	rubyStringEscape
    8              0.000016000 hi def link rubyAngleBracketEscape	rubyStringEscape
    8              0.000019000 hi def link rubySquareBracketEscape	rubyStringEscape
    8              0.000042000 hi def link rubyStringEscape		Special
                            
    8              0.000039000 hi def link rubyInterpolationDelimiter	Delimiter
    8              0.000038000 hi def link rubySharpBang		PreProc
    8              0.000036000 hi def link rubyStringDelimiter		Delimiter
    8              0.000018000 hi def link rubyHeredocDelimiter	rubyStringDelimiter
    8              0.000015000 hi def link rubyPercentRegexpDelimiter	rubyRegexpDelimiter
    8              0.000014000 hi def link rubyPercentStringDelimiter	rubyStringDelimiter
    8              0.000018000 hi def link rubyPercentSymbolDelimiter	rubySymbolDelimiter
    8              0.000027000 hi def link rubyDoubleQuoteSymbolDelimiter rubySymbolDelimiter
    8              0.000019000 hi def link rubySingleQuoteSymbolDelimiter rubySymbolDelimiter
    8              0.000018000 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    8              0.000017000 hi def link rubySymbolDelimiter		rubySymbol
    8              0.000038000 hi def link rubyString			String
    8              0.000018000 hi def link rubyRegexpEscape		rubyRegexpSpecial
    8              0.000018000 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    8              0.000017000 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    8              0.000016000 hi def link rubyRegexpDot		rubyRegexpCharClass
    8              0.000016000 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    8              0.000020000 hi def link rubyRegexpIntersection	rubyRegexpSpecial
    8              0.000038000 hi def link rubyRegexpSpecial		Special
    8              0.000038000 hi def link rubyRegexpComment		Comment
    8              0.000017000 hi def link rubyRegexp			rubyString
                            
    8              0.000037000 hi def link rubyError			Error
    8              0.000018000 if exists("ruby_line_continuation_error")
                              hi def link rubyUselessLineContinuation rubyError
    8              0.000006000 endif
    8              0.000015000 hi def link rubyGlobalVariableError	rubyError
    8              0.000009000 hi def link rubySpaceError		rubyError
                            
                            " Postscript {{{1
    8              0.000010000 let b:current_syntax = "ruby"
                            
    8              0.000031000 let &cpo = s:cpo_sav
    8              0.000009000 unlet! s:cpo_sav
                            
    8              0.000018000 delc SynFold
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/python.vim
Sourced 8 times
Total time:   0.005065000
 Self time:   0.005063000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2023 Feb 28
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            " The use of Python 2 compatible syntax highlighting can be enforced.
                            " The straddling code (Python 2 and 3 compatible), up to Python 3.5,
                            " will be also supported.
                            "
                            "   let python_use_python2_syntax = 1
                            "
                            " This option will exclude all modern Python 3.6 or higher features.
                            "
                            
                            " quit when a syntax file was already loaded.
    8              0.000030000 if exists("b:current_syntax")
                              finish
    8              0.000004000 endif
                            
                            " Use of Python 2 and 3.5 or lower requested.
    8              0.000016000 if exists("python_use_python2_syntax")
                              runtime! syntax/python2.vim
                              finish
    8              0.000003000 endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    8              0.000018000 let s:cpo_save = &cpo
    8   0.000023000   0.000022000 set cpo&vim
                            
    8              0.000016000 if exists("python_no_doctest_highlight")
                              let python_no_doctest_code_highlight = 1
    8              0.000005000 endif
                            
    8              0.000015000 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
    8              0.000001000 endif
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " The list can be checked using:
                            "
                            " python3 -c 'import keyword, pprint; pprint.pprint(keyword.kwlist + keyword.softkwlist, compact=True)'
                            "
    8              0.000021000 syn keyword pythonStatement	False None True
    8              0.000026000 syn keyword pythonStatement	as assert break continue del global
    8              0.000016000 syn keyword pythonStatement	lambda nonlocal pass return with yield
    8              0.000029000 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    8              0.000019000 syn keyword pythonConditional	elif else if
    8              0.000017000 syn keyword pythonRepeat	for while
    8              0.000024000 syn keyword pythonOperator	and in is not or
    8              0.000022000 syn keyword pythonException	except finally raise try
    8              0.000016000 syn keyword pythonInclude	from import
    8              0.000017000 syn keyword pythonAsync		async await
                            
                            " Soft keywords
                            " These keywords do not mean anything unless used in the right context.
                            " See https://docs.python.org/3/reference/lexical_analysis.html#soft-keywords
                            " for more on this.
    8              0.000031000 syn match   pythonConditional   "^\s*\zscase\%(\s\+.*:.*$\)\@="
    8              0.000031000 syn match   pythonConditional   "^\s*\zsmatch\%(\s\+.*:\s*\%(#.*\)\=$\)\@="
                            
                            " Decorators
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    8              0.000017000 syn match   pythonDecorator	"@" display contained
    8              0.000035000 syn match   pythonDecoratorName	"@\s*\h\%(\w\|\.\)*" display contains=pythonDecorator
                            
                            " Python 3.5 introduced the use of the same symbol for matrix multiplication:
                            " https://www.python.org/dev/peps/pep-0465/.  We now have to exclude the
                            " symbol from highlighting when used in that context.
                            " Single line multiplication.
    8              0.000080000 syn match   pythonMatrixMultiply
                                  \ "\%(\w\|[])]\)\s*@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication continued on the next line after backslash.
    8              0.000067000 syn match   pythonMatrixMultiply
                                  \ "[^\\]\\\s*\n\%(\s*\.\.\.\s\)\=\s\+@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication in a parenthesized expression over multiple lines with @ at
                            " the start of each continued line; very similar to decorators and complex.
    8              0.000095000 syn match   pythonMatrixMultiply
                                  \ "^\s*\%(\%(>>>\|\.\.\.\)\s\+\)\=\zs\%(\h\|\%(\h\|[[(]\).\{-}\%(\w\|[])]\)\)\s*\n\%(\s*\.\.\.\s\)\=\s\+@\%(.\{-}\n\%(\s*\.\.\.\s\)\=\s\+@\)*"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            
    8              0.000021000 syn match   pythonFunction	"\h\w*" display contained
                            
    8              0.000038000 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    8              0.000016000 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    8              0.000091000 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    8              0.000074000 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    8              0.000052000 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    8              0.000054000 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    8              0.000019000 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    8              0.000017000 syn match   pythonEscape	"\\\o\{1,3}" contained
    8              0.000016000 syn match   pythonEscape	"\\x\x\{2}" contained
    8              0.000026000 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    8              0.000027000 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    8              0.000013000 syn match   pythonEscape	"\\$"
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/reference/lexical_analysis.html#numeric-literals
    8              0.000017000 if !exists("python_no_number_highlight")
                              " numbers (including complex)
    8              0.000031000   syn match   pythonNumber	"\<0[oO]\%(_\=\o\)\+\>"
    8              0.000027000   syn match   pythonNumber	"\<0[xX]\%(_\=\x\)\+\>"
    8              0.000020000   syn match   pythonNumber	"\<0[bB]\%(_\=[01]\)\+\>"
    8              0.000028000   syn match   pythonNumber	"\<\%([1-9]\%(_\=\d\)*\|0\+\%(_\=0\)*\)\>"
    8              0.000020000   syn match   pythonNumber	"\<\d\%(_\=\d\)*[jJ]\>"
    8              0.000026000   syn match   pythonNumber	"\<\d\%(_\=\d\)*[eE][+-]\=\d\%(_\=\d\)*[jJ]\=\>"
    8              0.000037000   syn match   pythonNumber
                                    \ "\<\d\%(_\=\d\)*\.\%([eE][+-]\=\d\%(_\=\d\)*\)\=[jJ]\=\%(\W\|$\)\@="
    8              0.000041000   syn match   pythonNumber
                                    \ "\%(^\|\W\)\zs\%(\d\%(_\=\d\)*\)\=\.\d\%(_\=\d\)*\%([eE][+-]\=\d\%(_\=\d\)*\)\=[jJ]\=\>"
    8              0.000006000 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/library/constants.html
                            " http://docs.python.org/library/functions.html
                            " Python built-in functions are in alphabetical order.
                            "
                            " The list can be checked using:
                            "
                            " python3 -c 'import builtins, pprint; pprint.pprint(dir(builtins), compact=True)'
                            "
                            " The constants added by the `site` module are not listed below because they
                            " should not be used in programs, only in interactive interpreter.
                            " Similarly for some other attributes and functions `__`-enclosed from the
                            " output of the above command.
                            "
    8              0.000017000 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    8              0.000017000   syn keyword pythonBuiltin	False True None
    8              0.000018000   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " constants added by the `site` module
    8              0.000016000   syn keyword pythonBuiltin	quit exit copyright credits license
                              " built-in functions
    8              0.000017000   syn keyword pythonBuiltin	abs all any ascii bin bool breakpoint bytearray
    8              0.000021000   syn keyword pythonBuiltin	bytes callable chr classmethod compile complex
    8              0.000020000   syn keyword pythonBuiltin	delattr dict dir divmod enumerate eval exec
    8              0.000018000   syn keyword pythonBuiltin	filter float format frozenset getattr globals
    8              0.000019000   syn keyword pythonBuiltin	hasattr hash help hex id input int isinstance
    8              0.000019000   syn keyword pythonBuiltin	issubclass iter len list locals map max
    8              0.000022000   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    8              0.000017000   syn keyword pythonBuiltin	print property range repr reversed round set
    8              0.000020000   syn keyword pythonBuiltin	setattr slice sorted staticmethod str sum super
    8              0.000015000   syn keyword pythonBuiltin	tuple type vars zip __import__
                              " avoid highlighting attributes as builtins
    8              0.000052000   syn match   pythonAttribute	/\.\h\w*/hs=s+1
                            	\ contains=ALLBUT,pythonBuiltin,pythonFunction,pythonAsync
                            	\ transparent
    8              0.000006000 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/library/exceptions.html
    8              0.000016000 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    8              0.000020000   syn keyword pythonExceptions	BaseException Exception
    8              0.000012000   syn keyword pythonExceptions	ArithmeticError BufferError LookupError
                              " builtin exceptions (actually raised)
    8              0.000013000   syn keyword pythonExceptions	AssertionError AttributeError EOFError
    8              0.000015000   syn keyword pythonExceptions	FloatingPointError GeneratorExit ImportError
    8              0.000012000   syn keyword pythonExceptions	IndentationError IndexError KeyError
    8              0.000011000   syn keyword pythonExceptions	KeyboardInterrupt MemoryError
    8              0.000013000   syn keyword pythonExceptions	ModuleNotFoundError NameError
    8              0.000014000   syn keyword pythonExceptions	NotImplementedError OSError OverflowError
    8              0.000011000   syn keyword pythonExceptions	RecursionError ReferenceError RuntimeError
    8              0.000014000   syn keyword pythonExceptions	StopAsyncIteration StopIteration SyntaxError
    8              0.000015000   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    8              0.000010000   syn keyword pythonExceptions	UnboundLocalError UnicodeDecodeError
    8              0.000012000   syn keyword pythonExceptions	UnicodeEncodeError UnicodeError
    8              0.000009000   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    8              0.000009000   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin exception aliases for OSError
    8              0.000013000   syn keyword pythonExceptions	EnvironmentError IOError WindowsError
                              " builtin OS exceptions in Python 3
    8              0.000010000   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    8              0.000015000   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    8              0.000010000   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    8              0.000013000   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    8              0.000010000   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    8              0.000013000   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    8              0.000015000   syn keyword pythonExceptions	PermissionError ProcessLookupError TimeoutError
                              " builtin warnings
    8              0.000014000   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    8              0.000010000   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    8              0.000010000   syn keyword pythonExceptions	ResourceWarning RuntimeWarning
    8              0.000010000   syn keyword pythonExceptions	SyntaxWarning UnicodeWarning
    8              0.000011000   syn keyword pythonExceptions	UserWarning Warning
    8              0.000004000 endif
                            
    8              0.000015000 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
    8              0.000004000 endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    8              0.000015000 if !exists("python_no_doctest_highlight")
    8              0.000018000   if !exists("python_no_doctest_code_highlight")
    8              0.000061000     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,pythonFunction,@Spell
    8              0.000041000     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
                              else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
    8              0.000007000   endif
    8              0.000004000 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    8              0.000041000 syn sync match pythonSync grouphere NONE "^\%(def\|class\)\s\+\h\w*\s*[(:]"
                            
                            " The default highlight links.  Can be overridden later.
    8              0.000038000 hi def link pythonStatement		Statement
    8              0.000038000 hi def link pythonConditional		Conditional
    8              0.000038000 hi def link pythonRepeat		Repeat
    8              0.000034000 hi def link pythonOperator		Operator
    8              0.000035000 hi def link pythonException		Exception
    8              0.000033000 hi def link pythonInclude		Include
    8              0.000033000 hi def link pythonAsync			Statement
    8              0.000036000 hi def link pythonDecorator		Define
    8              0.000034000 hi def link pythonDecoratorName		Function
    8              0.000035000 hi def link pythonFunction		Function
    8              0.000036000 hi def link pythonComment		Comment
    8              0.000035000 hi def link pythonTodo			Todo
    8              0.000033000 hi def link pythonString		String
    8              0.000035000 hi def link pythonRawString		String
    8              0.000033000 hi def link pythonQuotes		String
    8              0.000009000 hi def link pythonTripleQuotes		pythonQuotes
    8              0.000034000 hi def link pythonEscape		Special
    8              0.000014000 if !exists("python_no_number_highlight")
    8              0.000037000   hi def link pythonNumber		Number
    8              0.000005000 endif
    8              0.000012000 if !exists("python_no_builtin_highlight")
    8              0.000036000   hi def link pythonBuiltin		Function
    8              0.000003000 endif
    8              0.000014000 if !exists("python_no_exception_highlight")
    8              0.000033000   hi def link pythonExceptions		Structure
    8              0.000005000 endif
    8              0.000011000 if exists("python_space_error_highlight")
                              hi def link pythonSpaceError		Error
    8              0.000005000 endif
    8              0.000009000 if !exists("python_no_doctest_highlight")
    8              0.000040000   hi def link pythonDoctest		Special
    8              0.000033000   hi def link pythonDoctestValue	Define
    8              0.000006000 endif
                            
    8              0.000012000 let b:current_syntax = "python"
                            
    8   0.000027000   0.000026000 let &cpo = s:cpo_save
    8              0.000008000 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/scripts.vim
Sourced 7 times
Total time:   0.006984000
 Self time:   0.006984000

count     total (s)      self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 27
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Bail out when a FileType autocommand has already set the filetype.
    7              0.000046000 if did_filetype()
                              finish
    7              0.000012000 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    7              0.000057000 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    7              0.000007000 endif
                            
                            " The main code is in a compiled function for speed.
    7              0.004983000 call dist#script#DetectFiletype()

SCRIPT  /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/script.vim
Sourced 1 time
Total time:   0.000623000
 Self time:   0.000623000

count     total (s)      self (s)
    1              0.000007000 vim9script
                            
                            # Vim function for detecting a filetype from the file contents.
                            # Invoked from "scripts.vim" in 'runtimepath'
                            #
                            # Maintainer:	The Vim Project <https://github.com/vim/vim>
                            # Last Change:	2023 Aug 10
                            # Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
    1              0.000011000 export def DetectFiletype()
                              var line1 = getline(1)
                              if line1[0] == '#' && line1[1] == '!'
                                # File that starts with "#!".
                                DetectFromHashBang(line1)
                              else
                                # File does not start with "#!".
                                DetectFromText(line1)
                              endif
                            enddef
                            
                            # Called for a script that has "#!" in the first line.
    1              0.000011000 def DetectFromHashBang(firstline: string)
                              var line1 = firstline
                            
                              # Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                              # "#!/usr/bin/bash" to make matching easier.
                              # Recognize only a few {options} that are commonly used.
                              if line1 =~ '^#!\s*\S*\<env\s'
                                line1 = substitute(line1, '\S\+=\S\+', '', 'g')
                                line1 = substitute(line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                line1 = substitute(line1, '\<env\s\+', '', '')
                              endif
                            
                              # Get the program name.
                              # Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              # If the word env is used, use the first word after the space:
                              # "#!/usr/bin/env perl [path/args]"
                              # If there is no path use the first word: "#!perl [path/args]".
                              # Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              var name: string
                              if line1 =~ '^#!\s*\a:[/\\]'
                                name = substitute(line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif line1 =~ '^#!.*\<env\>'
                                name = substitute(line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                name = substitute(line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                name = substitute(line1, '^#!\s*\S*[/\\]\(\f\+\).*', '\1', '')
                              endif
                            
                              # tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              # third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                name = 'wish'
                              endif
                            
                              var ft = Exe2filetype(name, line1)
                              if ft != ''
                                exe 'setl ft=' .. ft
                              endif
                            enddef
                            
                            # Returns the filetype name associated with program "name".
                            # "line1" is the #! line at the top of the file.  Use the same as "name" if
                            # not available.
                            # Returns an empty string when not recognized.
    1              0.000008000 export def Exe2filetype(name: string, line1: string): string
                                # Bourne-like shell scripts: bash bash2 dash ksh ksh93 sh
                              if name =~ '^\(bash\d*\|dash\|ksh\d*\|sh\)\>'
                                return dist#ft#SetFileTypeSH(line1, false)
                            
                                # csh scripts
                              elseif name =~ '^csh\>'
                                return dist#ft#SetFileTypeShell(exists("g:filetype_csh") ? g:filetype_csh : 'csh', false)
                            
                                # tcsh scripts
                              elseif name =~ '^tcsh\>'
                                return dist#ft#SetFileTypeShell("tcsh", false)
                            
                                # Z shell scripts
                              elseif name =~ '^zsh\>'
                                return 'zsh'
                            
                                # TCL scripts
                              elseif name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                return 'tcl'
                            
                                # Expect scripts
                              elseif name =~ '^expect\>'
                                return 'expect'
                            
                                # Gnuplot scripts
                              elseif name =~ '^gnuplot\>'
                                return 'gnuplot'
                            
                                # Makefiles
                              elseif name =~ 'make\>'
                                return 'make'
                            
                                # Pike
                              elseif name =~ '^pike\%(\>\|[0-9]\)'
                                return 'pike'
                            
                                # Lua
                              elseif name =~ 'lua'
                                return 'lua'
                            
                                # Perl
                              elseif name =~ 'perl'
                                return 'perl'
                            
                                # PHP
                              elseif name =~ 'php'
                                return 'php'
                            
                                # Python
                              elseif name =~ 'python'
                                return 'python'
                            
                                # Groovy
                              elseif name =~ '^groovy\>'
                                return 'groovy'
                            
                                # Raku
                              elseif name =~ 'raku'
                                return 'raku'
                            
                                # Ruby
                              elseif name =~ 'ruby'
                                return 'ruby'
                            
                                # JavaScript
                              elseif name =~ 'node\(js\)\=\>\|js\>' || name =~ 'rhino\>'
                                return 'javascript'
                            
                                # BC calculator
                              elseif name =~ '^bc\>'
                                return 'bc'
                            
                                # sed
                              elseif name =~ 'sed\>'
                                return 'sed'
                            
                                # OCaml-scripts
                              elseif name =~ 'ocaml'
                                return 'ocaml'
                            
                                # Awk scripts; also finds "gawk"
                              elseif name =~ 'awk\>'
                                return 'awk'
                            
                                # Website MetaLanguage
                              elseif name =~ 'wml'
                                return 'wml'
                            
                                # Scheme scripts
                              elseif name =~ 'scheme'
                                return 'scheme'
                            
                                # CFEngine scripts
                              elseif name =~ 'cfengine'
                                return 'cfengine'
                            
                                # Erlang scripts
                              elseif name =~ 'escript'
                                return 'erlang'
                            
                                # Haskell
                              elseif name =~ 'haskell'
                                return 'haskell'
                            
                                # Scala
                              elseif name =~ 'scala\>'
                                return 'scala'
                            
                                # Clojure
                              elseif name =~ 'clojure'
                                return 'clojure'
                            
                                # Free Pascal
                              elseif name =~ 'instantfpc\>'
                                return 'pascal'
                            
                                # Fennel
                              elseif name =~ 'fennel\>'
                                return 'fennel'
                            
                                # MikroTik RouterOS script
                              elseif name =~ 'rsc\>'
                                return 'routeros'
                            
                                # Fish shell
                              elseif name =~ 'fish\>'
                                return 'fish'
                            
                                # Gforth
                              elseif name =~ 'gforth\>'
                                return 'forth'
                            
                                # Icon
                              elseif name =~ 'icon\>'
                                return 'icon'
                            
                                # Guile
                              elseif name =~ 'guile'
                                return 'scheme'
                            
                                # Nix
                              elseif name =~ 'nix-shell'
                                return 'nix'
                            
                                # Crystal
                              elseif name =~ '^crystal\>'
                                return 'crystal'
                            
                                # Rexx
                              elseif name =~ '^\%(rexx\|regina\)\>'
                                return 'rexx'
                            
                                # Janet
                              elseif name =~ '^janet\>'
                                return 'janet'
                            
                                # Dart
                              elseif name =~ '^dart\>'
                                return 'dart'
                            
                                # Execline (s6)
                              elseif name =~ '^execlineb\>'
                                return 'execline'
                            
                                # Vim
                              elseif name =~ '^vim\>'
                                return 'vim'
                            
                              endif
                            
                              return ''
                            enddef
                            
                            
                            # Called for a script that does not have "#!" in the first line.
    1              0.000004000 def DetectFromText(line1: string)
                              var line2 = getline(2)
                              var line3 = getline(3)
                              var line4 = getline(4)
                              var line5 = getline(5)
                            
                              # Bourne-like shell scripts: sh ksh bash bash2
                              if line1 =~ '^:$'
                                call dist#ft#SetFileTypeSH(line1)
                            
                              # Z shell scripts
                              elseif line1 =~ '^#compdef\>'
                                  || line1 =~ '^#autoload\>'
                                  || "\n" .. line1 .. "\n" .. line2 .. "\n" .. line3 ..
                            	 "\n" .. line4 .. "\n" .. line5
                            	 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                setl ft=zsh
                            
                              # ELM Mail files
                              elseif line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                setl ft=mail
                            
                              # Mason
                              elseif line1 =~ '^<[%&].*>'
                                setl ft=mason
                            
                              # Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif line1 =~ '^" *[vV]im$'
                                setl ft=vim
                            
                              # libcxx and libstdc++ standard library headers like "iostream" do not have
                              # an extension, recognize the Emacs file mode.
                              elseif line1 =~? '-\*-.*C++.*-\*-'
                                setl ft=cpp
                            
                              # MOO
                              elseif line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                setl ft=moo
                            
                                # Diff file:
                                # - "diff" in first line (context diff)
                                # - "Only in " in first line
                                # - "--- " in first line and "+++ " in second line (unified diff).
                                # - "*** " in first line and "--- " in second line (context diff).
                                # - "# It was generated by makepatch " in the second line (makepatch diff).
                                # - "Index: <filename>" in the first line (CVS file)
                                # - "=== ", line of "=", "---", "+++ " (SVK diff)
                                # - "=== ", "--- ", "+++ " (bzr diff, common case)
                                # - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                # - "# HG changeset patch" in first line (Mercurial export format)
                              elseif line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	 || (line1 =~ '^--- ' && line2 =~ '^+++ ')
                            	 || (line1 =~ '^\* looking for ' && line2 =~ '^\* comparing to ')
                            	 || (line1 =~ '^\*\*\* ' && line2 =~ '^--- ')
                            	 || (line1 =~ '^=== ' && ((line2 =~ '^=\{66\}' && line3 =~ '^--- ' && line4 =~ '^+++') || (line2 =~ '^--- ' && line3 =~ '^+++ ')))
                            	 || (line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                setl ft=diff
                            
                                # PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif line1 =~ '^%![ \t]*PS'
                                setl ft=postscr
                            
                                # M4 scripts: Guess there is a line that starts with "dnl".
                              elseif line1 =~ '^\s*dnl\>'
                            	 || line2 =~ '^\s*dnl\>'
                            	 || line3 =~ '^\s*dnl\>'
                            	 || line4 =~ '^\s*dnl\>'
                            	 || line5 =~ '^\s*dnl\>'
                                setl ft=m4
                            
                                # AmigaDos scripts
                              elseif $TERM == "amiga" && (line1 =~ "^;" || line1 =~? '^\.bra')
                                setl ft=amiga
                            
                                # SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif line1 =~? '^ *proc[nd] *$'
                                setl ft=sicad
                            
                                # Purify log files start with "****  Purify"
                              elseif line1 =~ '^\*\*\*\*  Purify'
                                setl ft=purifylog
                            
                                # XML
                              elseif line1 =~ '<?\s*xml.*?>'
                                setl ft=xml
                            
                                # XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif line1 =~ '\<DTD\s\+XHTML\s'
                                setl ft=xhtml
                            
                                # HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                # Avoid "doctype html", used by slim.
                              elseif line1 =~? '<!DOCTYPE\s\+html\>'
                                setl ft=html
                            
                                # PDF
                              elseif line1 =~ '^%PDF-'
                                setl ft=pdf
                            
                                # XXD output
                              elseif line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                setl ft=xxd
                            
                                # RCS/CVS log output
                              elseif line1 =~ '^RCS file:' || line2 =~ '^RCS file:'
                                setl ft=rcslog
                            
                                # CVS commit
                              elseif line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                setl ft=cvs
                            
                                # Prescribe
                              elseif line1 =~ '^!R!'
                                setl ft=prescribe
                            
                                # Send-pr
                              elseif line1 =~ '^SEND-PR:'
                                setl ft=sendpr
                            
                                # SNNS files
                              elseif line1 =~ '^SNNS network definition file'
                                setl ft=snnsnet
                              elseif line1 =~ '^SNNS pattern definition file'
                                setl ft=snnspat
                              elseif line1 =~ '^SNNS result file'
                                setl ft=snnsres
                            
                                # Virata
                              elseif line1 =~ '^%.\{-}[Vv]irata'
                            	 || line2 =~ '^%.\{-}[Vv]irata'
                            	 || line3 =~ '^%.\{-}[Vv]irata'
                            	 || line4 =~ '^%.\{-}[Vv]irata'
                            	 || line5 =~ '^%.\{-}[Vv]irata'
                                setl ft=virata
                            
                                # Strace
                                # inaccurate fast match first, then use accurate slow match
                              elseif (line1 =~ 'execve(' && line1 =~ '^[0-9:. ]*execve(')
                            	   || line1 =~ '^__libc_start_main'
                                setl ft=strace
                            
                                # VSE JCL
                              elseif line1 =~ '^\* $$ JOB\>' || line1 =~ '^// *JOB\>'
                                setl ft=vsejcl
                            
                                # TAK and SINDA
                              elseif line4 =~ 'K & K  Associates' || line2 =~ 'TAK 2000'
                                setl ft=takout
                              elseif line3 =~ 'S Y S T E M S   I M P R O V E D '
                                setl ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                setl ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                setl ft=sindacmp
                            
                                # DNS zone files
                              elseif line1 .. line2 .. line3 .. line4 =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setl ft=bindzone
                            
                                # BAAN
                              elseif line1 =~ '|\*\{1,80}' && line2 =~ 'VRC '
                            	 || line2 =~ '|\*\{1,80}' && line3 =~ 'VRC '
                                setl ft=baan
                            
                                # Valgrind
                              elseif line1 =~ '^==\d\+== valgrind' || line3 =~ '^==\d\+== Using valgrind'
                                setl ft=valgrind
                            
                                # Go docs
                              elseif line1 =~ '^PACKAGE DOCUMENTATION$'
                                setl ft=godoc
                            
                                # Renderman Interface Bytestream
                              elseif line1 =~ '^##RenderMan'
                                setl ft=rib
                            
                                # Scheme scripts
                              elseif line1 =~ 'exec\s\+\S*scheme' || line2 =~ 'exec\s\+\S*scheme'
                                setl ft=scheme
                            
                                # Git output
                              elseif line1 =~ '^\(commit\|tree\|object\) \x\{40,\}\>\|^tag \S\+$'
                                setl ft=git
                            
                                # Gprof (gnu profiler)
                              elseif line1 == 'Flat profile:'
                            	&& line2 == ''
                            	&& line3 =~ '^Each sample counts as .* seconds.$'
                                setl ft=gprof
                            
                                # Erlang terms
                                # (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif line1 =~? '-\*-.*erlang.*-\*-'
                                setl ft=erlang
                            
                                # YAML
                              elseif line1 =~ '^%YAML'
                                setl ft=yaml
                            
                                # MikroTik RouterOS script
                              elseif line1 =~ '^#.*by RouterOS.*$'
                                setl ft=routeros
                            
                                # Sed scripts
                                # #ncomment is allowed but most likely a false positive so require a space
                                # before any trailing comment text
                              elseif line1 =~ '^#n\%($\|\s\)'
                                setl ft=sed
                            
                              else
                                var lnum = 1
                                while getline(lnum) =~ "^? " && lnum < line("$")
                                  lnum += 1
                                endwhile
                                if getline(lnum) =~ '^Index:\s\+\f\+$'
                                  # CVS diff
                                  setl ft=diff
                            
                                  # locale input files: Formal Definitions of Cultural Conventions
                                  # filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  lnum = 1
                                  while lnum < 100 && lnum < line("$")
                            	if getline(lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	lnum += 1
                                  endwhile
                                endif
                              endif
                            enddef

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/ftplugin/vader.vim
Sourced 2 times
Total time:   0.001672000
 Self time:   0.001659000

count     total (s)      self (s)
                            " Copyright (c) 2014 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
                            " Only do this when not done yet for this buffer
    2              0.000014000 if exists('b:did_ftplugin')
                              finish
    2              0.000002000 endif
                            
    2              0.000015000 let s:save_cpo = &cpo
    2              0.000016000 set cpo-=C
                            
    2   0.000618000   0.000609000 let b:vader_label = vader#syntax#_head()
    2   0.000022000   0.000018000 let b:vader_eos = '\(.*\n'.vader#syntax#_head().'\)\|\%$'
                            
    2              0.000037000 setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
    2              0.000104000 setlocal iskeyword+=#
    2              0.000008000 setlocal keywordprg=:help
    2              0.000010000 let &l:commentstring = '" %s'
    2              0.000011000 let &l:comments      = 'sO:" -,mO:"  ,eO:"",:"'
                            
    2              0.000042000 nnoremap <buffer><silent> [[ :call search(b:vader_label, 'bW')<CR>
    2              0.000011000 nnoremap <buffer><silent> [] :call search(b:vader_eos, 'bW')<CR>
                            
    2              0.000011000 nnoremap <buffer><silent> ]] :call search(b:vader_label, 'W')<CR>
    2              0.000011000 nnoremap <buffer><silent> ][ :call search(b:vader_eos, 'W')<CR>
                            
    2              0.000019000 vnoremap <buffer><silent> [[ <ESC>:execute "normal! gv"<BAR>call search(b:vader_label, 'bW')<CR>
    2              0.000016000 vnoremap <buffer><silent> [] <ESC>:execute "normal! gv"<BAR>call search(b:vader_eos, 'bW')<CR>
                            
    2              0.000016000 vnoremap <buffer><silent> ]] <ESC>:execute "normal! gv"<BAR>call search(b:vader_label, 'W')<CR>
    2              0.000015000 vnoremap <buffer><silent> ][ <ESC>:execute "normal! gv"<BAR>call search(b:vader_eos, 'W')<CR>
                            
    2              0.000007000 augroup vader_syntax
    2              0.000126000   autocmd!
    2              0.000010000   if exists('##TextChangedI')
    2              0.000015000     autocmd TextChangedI <buffer> call vader#syntax#include('.', '.')
                              else
                                autocmd CursorMovedI <buffer> call vader#syntax#include('.', '.')
    2              0.000002000   endif
                              " autocmd FileType <buffer> call vader#syntax#include(1, '$')
    2              0.000004000 augroup END
                            
    2              0.000013000 let b:undo_ftplugin = 'setl sw< ts< sts< et< cms< isk< kp<'
                                  \ . ' | exe "au! vader_syntax * <buffer>"'
                                  \ . ' | unlet b:vader_label b:vader_eos'
                            
    2              0.000021000 let &cpo = s:save_cpo

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/autoload/vader/syntax.vim
Sourced 1 time
Total time:   0.000364000
 Self time:   0.000364000

count     total (s)      self (s)
                            " Copyright (c) 2014 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000007000 let s:ifs = ['lua', 'perl', 'ruby', 'python']
                            
    1              0.000003000 function! vader#syntax#reset()
                              let b:vader_types = {}
                            endfunction
                            
    1              0.000003000 function! vader#syntax#include(l1, l2)
                              let lines = filter(getline(a:l1, a:l2), '!empty(v:val) && v:val[0] != " "')
                              for line in lines
                                let match = matchlist(line, '^\(Given\|Expect\|Execute\)\s\+\([^:; (]\+\)')
                                if len(match) >= 3
                                  silent! call s:load(match[2])
                                endif
                              endfor
                            endfunction
                            
    1              0.000002000 function! vader#syntax#_head()
                              return '\(\(^\(Given\|Expect\|Do\|Execute\|Then\|Before\|After\)\(\s\+[^:;(]\+\)\?\s*\((.*)\)\?\s*[:;]\s*$\)\|\(^Include\(\s*(.*)\)\?\s*:\)\)\@='
                            endfunction
                            
    1              0.000002000 function! s:load(type)
                              let b:vader_types = get(b:, 'vader_types', {})
                              if has_key(b:vader_types, a:type)
                                return
                              endif
                            
                              if empty(globpath(&rtp, "syntax/".a:type.".vim", 1))
                                return
                              endif
                            
                              let b:vader_types[a:type] = 1
                            
                              unlet! b:current_syntax
                              execute printf('syn include @%sSnippet syntax/%s.vim', a:type, a:type)
                              execute printf('syn region vader_%s start=/^\s\{2,}/ end=/^\S\@=/ contains=@%sSnippet contained', a:type, a:type)
                              execute printf('syn region vader_raw_%s start=/\(;\s*$\)\@<=/ end=/%s/ contains=@%sSnippet contained', a:type, vader#syntax#_head(), a:type)
                            
                              call s:define_syntax_region('Given', a:type)
                              call s:define_syntax_region('Expect', a:type)
                              if index(s:ifs, a:type) >= 0
                                call s:define_syntax_region('Execute', a:type)
                              endif
                              let b:current_syntax = 'vader'
                            endfunction
                            
    1              0.000003000 function! s:define_syntax_region(block, lang)
                              execute printf('syn region vader%s start=/^%s\s\+%s\s*\((.*)\)\?\s*:\s*$/ end=/\(^[^ ^#~=*-]\)\@=/ contains=vader%sType,vaderMessage,@vaderIgnored,vader_%s nextgroup=@vaderTopLevel skipempty keepend', a:block, a:block, a:lang, a:block, a:lang)
                              execute printf('syn region vader%sRaw start=/^%s\s\+%s\s*\((.*)\)\?\s*;\s*$/ end=/%s/ contains=vader%sType,vaderMessage,@vaderIgnored,vader_raw_%s nextgroup=@vaderTopLevel skipempty keepend', a:block, a:block, a:lang, vader#syntax#_head(), a:block, a:lang)
                            endfunction
                            

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/syntax/vader.vim
Sourced 2 times
Total time:   0.068195000
 Self time:   0.068195000

count     total (s)      self (s)
                            " Copyright (c) 2014 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    2              0.000009000 if exists("b:current_syntax")
                              finish
    2              0.000001000 endif
                            
    2              0.000006000 let s:oisk = &isk
                            
    2              0.000003000 syn clear
    2              0.066556000 syn include @vimSnippet syntax/vim.vim syntax/vim/*.vim
                            
    2              0.000014000 syn region vaderText    start=/^\s\{2,}/ end=/^\S\@=/ contained
    2              0.000012000 syn region vaderCommand start=/^\s\{2,}/ end=/^\S\@=/ contains=@vimSnippet contained
                            
    2              0.000046000 execute printf('syn region vaderTextRaw start=/\(;$\)\@<=/ end=/%s/ contained', vader#syntax#_head())
    2              0.000036000 execute printf('syn region vaderCommandRaw start=/\(;$\)\@<=/ end=/%s/ contains=@vimSnippet contained', vader#syntax#_head())
                            
    2              0.000023000 syn match vaderMessage /(\@<=.*)\@=/ contained contains=Todo
    2              0.000011000 syn match vaderGivenType /\(Given\s*\)\@<=[^:; (]\+/ contained
    2              0.000011000 syn match vaderExpectType /\(Expect\s*\)\@<=[^:; (]\+/ contained
    2              0.000009000 syn match vaderExecuteType /\(Execute\s*\)\@<=[^:; (]\+/ contained
                            
    2              0.000021000 syn match vaderComment /^["#].*/ contains=Todo
    2              0.000021000 syn match vaderSepCaret /^^.*/ contains=Todo
    2              0.000020000 syn match vaderSepTilde /^\~.*/ contains=Todo
    2              0.000021000 syn match vaderSepDouble /^=.*/ contains=Todo
    2              0.000020000 syn match vaderSepSingle /^-.*/ contains=Todo
    2              0.000020000 syn match vaderSepAsterisk /^\*.*/ contains=Todo
    2              0.000010000 syn cluster vaderIgnored contains=vaderComment,vaderSepCaret,vaderSepTilde,vaderSepDouble,vaderSepSingle,vaderSepAsterisk
                            
    2              0.000022000 syn region vaderGiven   start=/^Given\(\s*(.*)\)\?\s*:\s*$/   end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderText,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
    2              0.000020000 syn region vaderExpect  start=/^Expect\(\s*(.*)\)\?\s*:\s*$/  end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderText,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
    2              0.000016000 syn region vaderDo      start=/^Do\(\s*(.*)\)\?\s*:\s*$/      end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderCommand,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
    2              0.000017000 syn region vaderThen    start=/^Then\(\s*(.*)\)\?\s*:\s*$/    end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderCommand,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
    2              0.000015000 syn region vaderExecute start=/^Execute\(\s*(.*)\)\?\s*:\s*$/ end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderCommand,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
    2              0.000023000 syn region vaderBefore  start=/^Before\(\s*(.*)\)\?\s*:\s*$/  end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderCommand,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
    2              0.000017000 syn region vaderAfter   start=/^After\(\s*(.*)\)\?\s*:\s*$/   end=/\(^[^ "^#~=*-]\)\@=/ contains=vaderMessage,vaderCommand,vaderComment,@vaderIgnored nextgroup=@vaderTopLevel skipempty
                            
    2              0.000044000 execute printf('syn region vaderGivenRaw   start=/^Given\(\s*(.*)\)\?\s*;\s*$/   end=/%s/ contains=vaderMessage,vaderTextRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
    2              0.000048000 execute printf('syn region vaderExpectRaw  start=/^Expect\(\s*(.*)\)\?\s*;\s*$/  end=/%s/ contains=vaderMessage,vaderTextRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
    2              0.000038000 execute printf('syn region vaderDoRaw      start=/^Do\(\s*(.*)\)\?\s*;\s*$/      end=/%s/ contains=vaderMessage,vaderCommandRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
    2              0.000045000 execute printf('syn region vaderThenRaw    start=/^Then\(\s*(.*)\)\?\s*;\s*$/    end=/%s/ contains=vaderMessage,vaderCommandRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
    2              0.000037000 execute printf('syn region vaderExecuteRaw start=/^Execute\(\s*(.*)\)\?\s*;\s*$/ end=/%s/ contains=vaderMessage,vaderCommandRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
    2              0.000039000 execute printf('syn region vaderBeforeRaw  start=/^Before\(\s*(.*)\)\?\s*;\s*$/  end=/%s/ contains=vaderMessage,vaderCommandRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
    2              0.000036000 execute printf('syn region vaderAfterRaw   start=/^After\(\s*(.*)\)\?\s*;\s*$/   end=/%s/ contains=vaderMessage,vaderCommandRaw,@vaderIgnored nextgroup=@vaderTopLevel skipempty', vader#syntax#_head())
                            
    2              0.000010000 syn match vaderInclude /^Include\(\s*(.*)\)\?\s*:/ contains=vaderMessage
    2              0.000016000 syn cluster vaderTopLevel contains=vaderGiven,vaderExpect,vaderDo,vaderText,vaderExpect,vaderBefore,vaderAfter,vaderExpectRaw,vaderDoRaw,vaderThenRaw,vaderExpectRaw,vaderBeforeRaw,vaderAfterRaw,vaderInclude
                            
    2              0.000010000 syn keyword Todo TODO FIXME XXX TBD
                            
    2              0.000008000 hi def link vaderInclude     Repeat
    2              0.000008000 hi def link vaderGiven       Include
    2              0.000008000 hi def link vaderGivenRaw    Include
    2              0.000009000 hi def link vaderBefore      Special
    2              0.000008000 hi def link vaderBeforeRaw   Special
    2              0.000007000 hi def link vaderAfter       Special
    2              0.000008000 hi def link vaderAfterRaw    Special
    2              0.000009000 hi def link vaderDo          PreProc
    2              0.000008000 hi def link vaderDoRaw       PreProc
    2              0.000009000 hi def link vaderThen        Conditional
    2              0.000008000 hi def link vaderThenRaw     Conditional
    2              0.000009000 hi def link vaderExecute     Statement
    2              0.000008000 hi def link vaderExecuteRaw  Statement
    2              0.000007000 hi def link vaderExecuteType Identifier
    2              0.000009000 hi def link vaderExpect      Boolean
    2              0.000008000 hi def link vaderExpectRaw   Boolean
    2              0.000009000 hi def link vaderMessage     Title
    2              0.000008000 hi def link vaderGivenType   Identifier
    2              0.000009000 hi def link vaderExpectType  Identifier
    2              0.000008000 hi def link vaderText        String
    2              0.000007000 hi def link vaderTextRaw     String
    2              0.000009000 hi def link vaderComment     Comment
    2              0.000008000 hi def link vaderSepCaret    Error
    2              0.000009000 hi def link vaderSepTilde    Debug
    2              0.000007000 hi def link vaderSepDouble   Label
    2              0.000009000 hi def link vaderSepSingle   Label
    2              0.000008000 hi def link vaderSepAsterisk Exception
                            
    2              0.000003000 let b:current_syntax = 'vader'
    2              0.000013000 call vader#syntax#reset()
    2              0.000116000 call vader#syntax#include(1, '$')
                            
    2              0.000074000 let &isk = s:oisk
                            

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/lsp_linter.vim
Sourced 1 time
Total time:   0.000502000
 Self time:   0.000502000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Integration between linters and LSP/tsserver.
                            
                            " This code isn't loaded if a user never users LSP features or linters.
                            
                            " Associates LSP connection IDs with linter names.
    1              0.000003000 if !has_key(s:, 'lsp_linter_map')
    1              0.000002000     let s:lsp_linter_map = {}
    1              0.000000000 endif
                            
                            " Clear LSP linter data for the linting engine.
    1              0.000001000 function! ale#lsp_linter#ClearLSPData() abort
                                let s:lsp_linter_map = {}
                            endfunction
                            
                            " Only for internal use.
    1              0.000001000 function! ale#lsp_linter#GetLSPLinterMap() abort
                                return s:lsp_linter_map
                            endfunction
                            
                            " Just for tests.
    1              0.000001000 function! ale#lsp_linter#SetLSPLinterMap(replacement_map) abort
                                let s:lsp_linter_map = a:replacement_map
                            endfunction
                            
                            " A map for tracking URIs for diagnostic request IDs
    1              0.000002000 if !has_key(s:, 'diagnostic_uri_map')
    1              0.000003000     let s:diagnostic_uri_map = {}
    1              0.000001000 endif
                            
                            " For internal use only.
    1              0.000001000 function! ale#lsp_linter#ClearDiagnosticURIMap() abort
                                let s:diagnostic_uri_map = {}
                            endfunction
                            
                            " For internal use only.
    1              0.000001000 function! ale#lsp_linter#GetDiagnosticURIMap() abort
                                return s:diagnostic_uri_map
                            endfunction
                            
                            " Just for tests.
    1              0.000002000 function! ale#lsp_linter#SetDiagnosticURIMap(replacement_map) abort
                                let s:diagnostic_uri_map = a:replacement_map
                            endfunction
                            
                            " Get all enabled LSP linters.
                            " This list still includes linters ignored with `ale_linters_ignore`.
                            "
                            " `ale_linters_ignore` is designed to allow language servers to be used for
                            " their functionality while ignoring the diagnostics they return.
    1              0.000001000 function! ale#lsp_linter#GetEnabled(buffer) abort
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                " Only LSP linters are included here.
                                let l:linters = filter(ale#linter#Get(l:filetype), '!empty(v:val.lsp)')
                                let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
                                " Only load code for ignoring linters if we need it.
                                if (
                                \   l:disable_lsp is 1
                                \   || l:disable_lsp is v:true
                                \   || (l:disable_lsp is# 'auto' && get(g:, 'lspconfig', 0))
                                \)
                                    let l:linters = ale#engine#ignore#Exclude(
                                    \   l:filetype,
                                    \   l:linters,
                                    \   [],
                                    \   l:disable_lsp,
                                    \)
                                endif
                            
                                return l:linters
                            endfunction
                            
                            " Check if diagnostics for a particular linter should be ignored.
    1              0.000002000 function! s:ShouldIgnoreDiagnostics(buffer, linter) abort
                                let l:config = ale#Var(a:buffer, 'linters_ignore')
                                let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
                                " Only load code for ignoring linters if we need it.
                                if (
                                \   !empty(l:config)
                                \   || l:disable_lsp is 1
                                \   || l:disable_lsp is v:true
                                \   || (l:disable_lsp is# 'auto' && get(g:, 'lspconfig', 0))
                                \)
                                    " Re-use the ignore implementation just for this linter.
                                    return empty(
                                    \   ale#engine#ignore#Exclude(
                                    \       getbufvar(a:buffer, '&filetype'),
                                    \       [a:linter],
                                    \       l:config,
                                    \       l:disable_lsp,
                                    \   )
                                    \)
                                endif
                            
                                return 0
                            endfunction
                            
                            " Handle LSP diagnostics for a given URI.
                            " The special value 'unchanged' can be used for diagnostics to indicate
                            " that diagnostics haven't changed since we last checked.
    1              0.000001000 function! ale#lsp_linter#HandleLSPDiagnostics(conn_id, uri, diagnostics) abort
                                let l:linter = get(s:lsp_linter_map, a:conn_id)
                            
                                if empty(l:linter)
                                    return
                                endif
                            
                                let l:filename = ale#util#ToResource(a:uri)
                                let l:escaped_name = escape(
                                \   fnameescape(l:filename),
                                \   has('win32') ? '^' : '^,}]'
                                \)
                                let l:buffer = bufnr('^' . l:escaped_name . '$')
                                let l:info = get(g:ale_buffer_info, l:buffer, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                if s:ShouldIgnoreDiagnostics(l:buffer, l:linter)
                                    return
                                endif
                            
                                if a:diagnostics is# 'unchanged'
                                    call ale#engine#MarkLinterInactive(l:info, l:linter)
                                else
                                    let l:loclist = ale#lsp#response#ReadDiagnostics(a:diagnostics)
                                    call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist, 0)
                                endif
                            endfunction
                            
    1              0.000001000 function! s:HandleTSServerDiagnostics(response, error_type) abort
                                " Re-create a fake linter object for tsserver.
                                let l:linter = {
                                \   'name': 'tsserver',
                                \   'aliases': [],
                                \   'lsp': 'tsserver',
                                \}
                                let l:escaped_name = escape(
                                \   fnameescape(a:response.body.file),
                                \   has('win32') ? '^' : '^,}]'
                                \)
                                let l:buffer = bufnr('^' . l:escaped_name . '$')
                                let l:info = get(g:ale_buffer_info, l:buffer, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                call ale#engine#MarkLinterInactive(l:info, l:linter.name)
                            
                                if s:ShouldIgnoreDiagnostics(l:buffer, l:linter)
                                    return
                                endif
                            
                                let l:thislist = ale#lsp#response#ReadTSServerDiagnostics(a:response)
                                let l:no_changes = 0
                            
                                " tsserver sends syntax and semantic errors in separate messages, so we
                                " have to collect the messages separately for each buffer and join them
                                " back together again.
                                if a:error_type is# 'syntax'
                                    if len(l:thislist) is 0 && len(get(l:info, 'syntax_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
                                    let l:info.syntax_loclist = l:thislist
                                elseif a:error_type is# 'semantic'
                                    if len(l:thislist) is 0 && len(get(l:info, 'semantic_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
                                    let l:info.semantic_loclist = l:thislist
                                else
                                    if len(l:thislist) is 0 && len(get(l:info, 'suggestion_loclist', [])) is 0
                                        let l:no_changes = 1
                                    endif
                            
                                    let l:info.suggestion_loclist = l:thislist
                                endif
                            
                                if l:no_changes
                                    return
                                endif
                            
                                let l:loclist = get(l:info, 'semantic_loclist', [])
                                \   + get(l:info, 'suggestion_loclist', [])
                                \   + get(l:info, 'syntax_loclist', [])
                            
                                call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist, 0)
                            endfunction
                            
    1              0.000001000 function! s:HandleLSPErrorMessage(linter, response) abort
                                if !g:ale_history_enabled || !g:ale_history_log_output
                                    return
                                endif
                            
                                if empty(a:linter)
                                    return
                                endif
                            
                                let l:message = ale#lsp#response#GetErrorMessage(a:response)
                            
                                if empty(l:message)
                                    return
                                endif
                            
                                call ale#lsp_linter#AddErrorMessage(a:linter.name, l:message)
                            endfunction
                            
    1              0.000001000 function! ale#lsp_linter#AddErrorMessage(linter_name, message) abort
                                " This global variable is set here so we don't load the debugging.vim file
                                " until someone uses :ALEInfo.
                                let g:ale_lsp_error_messages = get(g:, 'ale_lsp_error_messages', {})
                            
                                if !has_key(g:ale_lsp_error_messages, a:linter_name)
                                    let g:ale_lsp_error_messages[a:linter_name] = []
                                endif
                            
                                call add(g:ale_lsp_error_messages[a:linter_name], a:message)
                            endfunction
                            
    1              0.000002000 function! ale#lsp_linter#HandleLSPResponse(conn_id, response) abort
                                let l:method = get(a:response, 'method', '')
                            
                                if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
                                    let l:linter = get(s:lsp_linter_map, a:conn_id, {})
                            
                                    call s:HandleLSPErrorMessage(l:linter, a:response)
                                elseif l:method is# 'textDocument/publishDiagnostics'
                                    let l:uri = a:response.params.uri
                                    let l:diagnostics = a:response.params.diagnostics
                            
                                    call ale#lsp_linter#HandleLSPDiagnostics(a:conn_id, l:uri, l:diagnostics)
                                elseif has_key(s:diagnostic_uri_map, get(a:response, 'id'))
                                    let l:uri = remove(s:diagnostic_uri_map, a:response.id)
                                    let l:diagnostics = a:response.result.kind is# 'unchanged'
                                    \   ? 'unchanged'
                                    \   : a:response.result.items
                            
                                    call ale#lsp_linter#HandleLSPDiagnostics(a:conn_id, l:uri, l:diagnostics)
                                elseif l:method is# 'window/showMessage'
                                    call ale#lsp_window#HandleShowMessage(
                                    \   s:lsp_linter_map[a:conn_id].name,
                                    \   g:ale_lsp_show_message_format,
                                    \   a:response.params
                                    \)
                                elseif get(a:response, 'type', '') is# 'event'
                                \&& get(a:response, 'event', '') is# 'semanticDiag'
                                    call s:HandleTSServerDiagnostics(a:response, 'semantic')
                                elseif get(a:response, 'type', '') is# 'event'
                                \&& get(a:response, 'event', '') is# 'syntaxDiag'
                                    call s:HandleTSServerDiagnostics(a:response, 'syntax')
                                elseif get(a:response, 'type', '') is# 'event'
                                \&& get(a:response, 'event', '') is# 'suggestionDiag'
                                \&& get(g:, 'ale_lsp_suggestions')
                                    call s:HandleTSServerDiagnostics(a:response, 'suggestion')
                                endif
                            endfunction
                            
    1              0.000001000 function! ale#lsp_linter#GetOptions(buffer, linter) abort
                                if has_key(a:linter, 'initialization_options_callback')
                                    return ale#util#GetFunction(a:linter.initialization_options_callback)(a:buffer)
                                endif
                            
                                if has_key(a:linter, 'initialization_options')
                                    let l:Options = a:linter.initialization_options
                            
                                    if type(l:Options) is v:t_func
                                        let l:Options = l:Options(a:buffer)
                                    endif
                            
                                    return l:Options
                                endif
                            
                                return {}
                            endfunction
                            
    1              0.000001000 function! ale#lsp_linter#GetConfig(buffer, linter) abort
                                if has_key(a:linter, 'lsp_config_callback')
                                    return ale#util#GetFunction(a:linter.lsp_config_callback)(a:buffer)
                                endif
                            
                                if has_key(a:linter, 'lsp_config')
                                    let l:Config = a:linter.lsp_config
                            
                                    if type(l:Config) is v:t_func
                                        let l:Config = l:Config(a:buffer)
                                    endif
                            
                                    return l:Config
                                endif
                            
                                return {}
                            endfunction
                            
    1              0.000001000 function! ale#lsp_linter#FindProjectRoot(buffer, linter) abort
                                let l:buffer_ale_root = getbufvar(a:buffer, 'ale_root', {})
                            
                                if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
                                endif
                            
                                " Try to get a buffer-local setting for the root
                                if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Try to get a global setting for the root
                                if has_key(g:ale_root, a:linter.name)
                                    let l:Root = g:ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
                                endif
                            
                                " Fall back to the linter-specific configuration
                                if has_key(a:linter, 'project_root')
                                    let l:Root = a:linter.project_root
                            
                                    return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)
                            endfunction
                            
                            " This function is accessible so tests can call it.
    1              0.000001000 function! ale#lsp_linter#OnInit(linter, details, Callback) abort
                                let l:buffer = a:details.buffer
                                let l:conn_id = a:details.connection_id
                                let l:command = a:details.command
                            
                                let l:config = ale#lsp_linter#GetConfig(l:buffer, a:linter)
                            
                                call ale#lsp#UpdateConfig(l:conn_id, l:buffer, l:config)
                            
                                if ale#lsp#OpenDocument(l:conn_id, l:buffer)
                                    if g:ale_history_enabled && !empty(l:command)
                                        call ale#history#Add(l:buffer, 'started', l:conn_id, l:command)
                                    endif
                                endif
                            
                                " The change message needs to be sent for tsserver before doing anything.
                                if a:linter.lsp is# 'tsserver'
                                    call ale#lsp#NotifyForChanges(l:conn_id, l:buffer)
                                endif
                            
                                " Tell the relevant buffer that the LSP has started via an autocmd.
                                if l:buffer > 0
                                    if l:buffer == bufnr('')
                                        silent doautocmd <nomodeline> User ALELSPStarted
                                    else
                                        execute 'augroup ALELSPStartedGroup' . l:buffer
                                            autocmd!
                            
                                            execute printf(
                                            \   'autocmd BufEnter <buffer=%d>'
                                            \       . ' doautocmd <nomodeline> User ALELSPStarted',
                                            \   l:buffer
                                            \)
                            
                                            " Replicate ++once behavior for backwards compatibility.
                                            execute printf(
                                            \   'autocmd BufEnter <buffer=%d>'
                                            \       . ' autocmd! ALELSPStartedGroup%d',
                                            \   l:buffer, l:buffer
                                            \)
                                        augroup END
                                    endif
                                endif
                            
                                call a:Callback(a:linter, a:details)
                            endfunction
                            
    1              0.000002000 function! s:StartLSP(options, address, executable, command) abort
                                let l:buffer = a:options.buffer
                                let l:linter = a:options.linter
                                let l:root = a:options.root
                                let l:Callback = a:options.callback
                            
                                let l:init_options = ale#lsp_linter#GetOptions(l:buffer, l:linter)
                            
                                if l:linter.lsp is# 'socket'
                                    let l:conn_id = ale#lsp#Register(
                                    \   a:address,
                                    \   l:root,
                                    \   l:linter.language,
                                    \   l:init_options
                                    \)
                                    let l:ready = ale#lsp#ConnectToAddress(l:conn_id, a:address)
                                    let l:command = ''
                                else
                                    let l:conn_id = ale#lsp#Register(
                                    \   a:executable,
                                    \   l:root,
                                    \   l:linter.language,
                                    \   l:init_options
                                    \)
                            
                                    " tsserver behaves differently, so tell the LSP API that it is tsserver.
                                    if l:linter.lsp is# 'tsserver'
                                        call ale#lsp#MarkConnectionAsTsserver(l:conn_id)
                                    endif
                            
                                    let l:cwd = ale#linter#GetCwd(l:buffer, l:linter)
                                    let l:command = ale#command#FormatCommand(
                                    \   l:buffer,
                                    \   a:executable,
                                    \   a:command,
                                    \   0,
                                    \   v:false,
                                    \   l:cwd,
                                    \   ale#GetFilenameMappings(l:buffer, l:linter.name),
                                    \)[1]
                                    let l:command = ale#job#PrepareCommand(l:buffer, l:command)
                                    let l:ready = ale#lsp#StartProgram(l:conn_id, a:executable, l:command)
                                endif
                            
                                if !l:ready
                                    if g:ale_history_enabled && !empty(a:command)
                                        call ale#history#Add(l:buffer, 'failed', l:conn_id, a:command)
                                    endif
                            
                                    return 0
                                endif
                            
                                let l:details = {
                                \   'buffer': l:buffer,
                                \   'connection_id': l:conn_id,
                                \   'command': l:command,
                                \   'project_root': l:root,
                                \}
                            
                                call ale#lsp#OnInit(l:conn_id, {->
                                \   ale#lsp_linter#OnInit(l:linter, l:details, l:Callback)
                                \})
                            
                                return 1
                            endfunction
                            
    1              0.000001000 function! s:StartWithAddress(options, address) abort
                                if ale#command#IsDeferred(a:address)
                                    let a:address.result_callback = {
                                    \   address -> s:StartWithAddress(a:options, address)
                                    \}
                            
                                    return 1
                                endif
                            
                                if empty(a:address)
                                    return 0
                                endif
                            
                                return s:StartLSP(a:options, a:address, '', '')
                            endfunction
                            
    1              0.000001000 function! s:StartWithCommand(options, executable, command) abort
                                if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {
                                    \   command -> s:StartWithCommand(a:options, a:executable, command)
                                    \}
                            
                                    return 1
                                endif
                            
                                if empty(a:command)
                                    return 0
                                endif
                            
                                return s:StartLSP(a:options, '', a:executable, a:command)
                            endfunction
                            
    1              0.000001000 function! s:StartIfExecutable(options, executable) abort
                                if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {
                                    \   executable -> s:StartIfExecutable(a:options, executable)
                                    \}
                            
                                    return 1
                                endif
                            
                                if !ale#engine#IsExecutable(a:options.buffer, a:executable)
                                    return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)
                            endfunction
                            
                            " Given a buffer, an LSP linter, start up an LSP linter and get ready to
                            " receive messages for the document.
    1              0.000001000 function! ale#lsp_linter#StartLSP(buffer, linter, Callback) abort
                                let l:command = ''
                                let l:address = ''
                                let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
                                if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    call ale#lsp_linter#AddErrorMessage(a:linter.name, "Failed to find project root, language server won't start.")
                            
                                    return 0
                                endif
                            
                                let l:options = {
                                \   'buffer': a:buffer,
                                \   'linter': a:linter,
                                \   'callback': a:Callback,
                                \   'root': l:root,
                                \}
                            
                                if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
                                endif
                            
                                let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
                                return s:StartIfExecutable(l:options, l:executable)
                            endfunction
                            
    1              0.000001000 function! s:CheckWithLSP(linter, details) abort
                                let l:buffer = a:details.buffer
                                let l:info = get(g:ale_buffer_info, l:buffer)
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                let l:id = a:details.connection_id
                            
                                " Register a callback now for handling errors now.
                                let l:Callback = function('ale#lsp_linter#HandleLSPResponse')
                                call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                " Remember the linter this connection is for.
                                let s:lsp_linter_map[l:id] = a:linter
                            
                                if a:linter.lsp is# 'tsserver'
                                    let l:message = ale#lsp#tsserver_message#Geterr(l:buffer)
                                    let l:notified = ale#lsp#Send(l:id, l:message) != 0
                            
                                    if l:notified
                                        call ale#engine#MarkLinterActive(l:info, a:linter)
                                    endif
                                elseif !g:ale_use_neovim_lsp_api
                                    let l:notified = ale#lsp#NotifyForChanges(l:id, l:buffer)
                            
                                    " If this was a file save event, also notify the server of that.
                                    if getbufvar(l:buffer, 'ale_save_event_fired', 0)
                                    \&& ale#lsp#HasCapability(l:id, 'did_save')
                                        let l:include_text = ale#lsp#HasCapability(l:id, 'includeText')
                                        let l:save_message = ale#lsp#message#DidSave(l:buffer, l:include_text)
                                        let l:notified = ale#lsp#Send(l:id, l:save_message) != 0
                                    endif
                            
                                    let l:diagnostic_request_id = 0
                            
                                    " If the document is updated and we can pull diagnostics, try to.
                                    if ale#lsp#HasCapability(l:id, 'pull_model')
                                        let l:diagnostic_message = ale#lsp#message#Diagnostic(l:buffer)
                            
                                        let l:diagnostic_request_id = ale#lsp#Send(l:id, l:diagnostic_message)
                                    endif
                            
                                    " If we are going to pull diagnostics, then mark the linter as active,
                                    " and remember the URI we sent the request for.
                                    if l:diagnostic_request_id
                                        call ale#engine#MarkLinterActive(l:info, a:linter)
                                        let s:diagnostic_uri_map[l:diagnostic_request_id] =
                                        \   l:diagnostic_message[2].textDocument.uri
                                    endif
                                endif
                            endfunction
                            
    1              0.000003000 function! ale#lsp_linter#CheckWithLSP(buffer, linter) abort
                                return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))
                            endfunction
                            
    1              0.000002000 function! s:HandleLSPResponseToCustomRequests(conn_id, response) abort
                                if has_key(a:response, 'id')
                                    " Get the custom handlers Dictionary from the linter map.
                                    let l:linter = get(s:lsp_linter_map, a:conn_id, {})
                                    let l:custom_handlers = get(l:linter, 'custom_handlers', {})
                            
                                    if has_key(l:custom_handlers, a:response.id)
                                        let l:Handler = remove(l:custom_handlers, a:response.id)
                                        call l:Handler(a:response)
                                    endif
                                endif
                            endfunction
                            
    1              0.000002000 function! s:OnReadyForCustomRequests(args, linter, lsp_details) abort
                                let l:id = a:lsp_details.connection_id
                                let l:request_id = ale#lsp#Send(l:id, a:args.message)
                            
                                if l:request_id > 0 && has_key(a:args, 'handler')
                                    let l:Callback = function('s:HandleLSPResponseToCustomRequests')
                                    call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                    " Remember the linter this connection is for.
                                    let s:lsp_linter_map[l:id] = a:linter
                            
                                    " Add custom_handlers to the linter Dictionary.
                                    if !has_key(a:linter, 'custom_handlers')
                                        let a:linter.custom_handlers = {}
                                    endif
                            
                                    " Put the handler function in the map to call later.
                                    let a:linter.custom_handlers[l:request_id] = a:args.handler
                                endif
                            endfunction
                            
                            " Send a custom request to an LSP linter.
    1              0.000001000 function! ale#lsp_linter#SendRequest(buffer, linter_name, message, ...) abort
                                let l:filetype = ale#linter#ResolveFiletype(getbufvar(a:buffer, '&filetype'))
                                let l:linter_list = ale#linter#GetAll(l:filetype)
                                let l:linter_list = filter(l:linter_list, {_, v -> v.name is# a:linter_name})
                            
                                if len(l:linter_list) < 1
                                    throw 'Linter "' . a:linter_name . '" not found!'
                                endif
                            
                                let l:linter = l:linter_list[0]
                            
                                if empty(l:linter.lsp)
                                    throw 'Linter "' . a:linter_name . '" does not support LSP!'
                                endif
                            
                                let l:is_notification = a:message[0]
                                let l:callback_args = {'message': a:message}
                            
                                if !l:is_notification && a:0
                                    let l:callback_args.handler = a:1
                                endif
                            
                                let l:Callback = function('s:OnReadyForCustomRequests', [l:callback_args])
                            
                                return ale#lsp_linter#StartLSP(a:buffer, l:linter, l:Callback)
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ale/autoload/ale/path.vim
Sourced 1 time
Total time:   0.000320000
 Self time:   0.000293000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for working with paths in the filesystem.
                            
                            " simplify a path, and fix annoying issues with paths on Windows.
                            "
                            " Forward slashes are changed to back slashes so path equality works better
                            " on Windows. Back slashes are changed to forward slashes on Unix.
                            "
                            " Unix paths can technically contain back slashes, but in practice no path
                            " should, and replacing back slashes with forward slashes makes linters work
                            " in environments like MSYS.
                            "
                            " Paths starting with more than one forward slash are changed to only one
                            " forward slash, to prevent the paths being treated as special MSYS paths.
    1              0.000002000 function! ale#path#Simplify(path) abort
                                if has('unix')
                                    let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
                                    return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks
                            endfunction
                            
                            " Simplify a path without a Windows drive letter.
                            " This function can be used for checking if paths are equal.
    1              0.000002000 function! ale#path#RemoveDriveLetter(path) abort
                                return has('win32') && a:path[1:2] is# ':\'
                                \   ? ale#path#Simplify(a:path[2:])
                                \   : ale#path#Simplify(a:path)
                            endfunction
                            
                            " Given a buffer and a filename, find the nearest file by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000001000 function! ale#path#FindNearestFile(buffer, filename) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer and a directory name, find the nearest directory by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000001000 function! ale#path#FindNearestDirectory(buffer, directory_name) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer and a filename, find the nearest file or directory by
                            " searching upwards through the paths relative to the given buffer.
    1              0.000001000 function! ale#path#FindNearestFileOrDirectory(buffer, filename) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path_file = findfile(a:filename, l:buffer_filename . ';')
                                let l:relative_path_dir = finddir(a:filename, l:buffer_filename . ';')
                            
                                " If we find both a file and directory, choose the shorter response by
                                " making the longer one empty instead.
                                if !empty(l:relative_path_file) && !empty(l:relative_path_dir)
                                    if strlen(l:relative_path_file) > strlen(l:relative_path_dir)
                                        let l:relative_path_dir = ''
                                    else
                                        let l:relative_path_file = ''
                                    endif
                                endif
                            
                                if !empty(l:relative_path_file)
                                    return fnamemodify(l:relative_path_file, ':p')
                                endif
                            
                                if !empty(l:relative_path_dir)
                                    return fnamemodify(l:relative_path_dir, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer, a string to search for, and a global fallback for when
                            " the search fails, look for a file in parent paths, and if that fails,
                            " use the global fallback path instead.
    1              0.000001000 function! ale#path#ResolveLocalPath(buffer, search_string, global_fallback) abort
                                " Search for a locally installed file first.
                                let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
                            
                                " If the search fails, try the global executable instead.
                                if empty(l:path)
                                    let l:path = a:global_fallback
                                endif
                            
                                return l:path
                            endfunction
                            
                            " Given a buffer number, a base variable name, and a list of paths to search
                            " for in ancestor directories, detect the executable path for a program.
    1              0.000001000 function! ale#path#FindNearestExecutable(buffer, path_list) abort
                                for l:path in a:path_list
                                    if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
                                    else
                                        let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                                    endif
                            
                                    if !empty(l:executable)
                                        return l:executable
                                    endif
                                endfor
                            
                                return ''
                            endfunction
                            
                            " Given a buffer number, a base variable name, and a list of paths to search
                            " for in ancestor directories, detect the executable path for a program.
                            "
                            " The use_global and executable options for the relevant program will be used.
    1              0.000001000 function! ale#path#FindExecutable(buffer, base_var_name, path_list) abort
                                if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
                                let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
                                if !empty(l:nearest)
                                    return l:nearest
                                endif
                            
                                return ale#Var(a:buffer, a:base_var_name . '_executable')
                            endfunction
                            
                            " Return 1 if a path is an absolute path.
    1              0.000001000 function! ale#path#IsAbsolute(filename) abort
                                if has('win32')
                                    return a:filename[:0] =~# '[\\/]' || a:filename[0:2] =~? '[A-Z]:[/\\]'
                                else
                                    return a:filename[:0] is# '/'
                                endif
                            endfunction
                            
    1   0.000038000   0.000011000 let s:temp_dir = ale#path#Simplify(fnamemodify(ale#util#Tempname(), ':h:h'))
    1              0.000014000 let s:resolved_temp_dir = resolve(s:temp_dir)
                            
                            " Given a filename, return 1 if the file represents some temporary file
                            " created by Vim. If the temporary location is symlinked (e.g. macOS), some
                            " linters may report the resolved version of the path, so both are checked.
    1              0.000001000 function! ale#path#IsTempName(filename) abort
                                let l:filename = ale#path#Simplify(a:filename)
                            
                                return l:filename[:len(s:temp_dir) - 1] is# s:temp_dir
                                \|| l:filename[:len(s:resolved_temp_dir) - 1] is# s:resolved_temp_dir
                            endfunction
                            
                            " Given a base directory, which must not have a trailing slash, and a
                            " filename, which may have an absolute path a path relative to the base
                            " directory, return the absolute path to the file.
    1              0.000001000 function! ale#path#GetAbsPath(base_directory, filename) abort
                                if ale#path#IsAbsolute(a:filename)
                                    return ale#path#Simplify(a:filename)
                                endif
                            
                                let l:sep = has('win32') ? '\' : '/'
                            
                                return ale#path#Simplify(a:base_directory . l:sep . a:filename)
                            endfunction
                            
                            " Given a path, return the directory name for that path, with no trailing
                            " slashes. If the argument is empty(), return an empty string.
    1              0.000001000 function! ale#path#Dirname(path) abort
                                if empty(a:path)
                                    return ''
                                endif
                            
                                " For /foo/bar/ we need :h:h to get /foo
                                if a:path[-1:] is# '/' || (has('win32') && a:path[-1:] is# '\')
                                    return fnamemodify(a:path, ':h:h')
                                endif
                            
                                return fnamemodify(a:path, ':h')
                            endfunction
                            
                            " Given a buffer number and a relative or absolute path, return 1 if the
                            " two paths represent the same file on disk.
    1              0.000001000 function! ale#path#IsBufferPath(buffer, complex_filename) abort
                                " If the path is one of many different names for stdin, we have a match.
                                if a:complex_filename is# '-'
                                \|| a:complex_filename is# 'stdin'
                                \|| a:complex_filename[:0] is# '<'
                                    return 1
                                endif
                            
                                let l:test_filename = ale#path#Simplify(a:complex_filename)
                            
                                if l:test_filename[:1] is# './'
                                    let l:test_filename = l:test_filename[2:]
                                endif
                            
                                if l:test_filename[:1] is# '..'
                                    " Remove ../../ etc. from the front of the path.
                                    let l:test_filename = substitute(l:test_filename, '\v^(\.\.[/\\])+', '/', '')
                                endif
                            
                                " Use the basename for temporary files, as they are likely our files.
                                if ale#path#IsTempName(l:test_filename)
                                    let l:test_filename = fnamemodify(l:test_filename, ':t')
                                endif
                            
                                let l:buffer_filename = expand('#' . a:buffer . ':p')
                            
                                return l:buffer_filename is# l:test_filename
                                \   || l:buffer_filename[-len(l:test_filename):] is# l:test_filename
                            endfunction
                            
                            " Given a path, return every component of the path, moving upwards.
    1              0.000001000 function! ale#path#Upwards(path) abort
                                let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
                                let l:sep = has('win32') ? '\' : '/'
                                let l:parts = split(ale#path#Simplify(a:path), l:pattern)
                                let l:path_list = []
                            
                                while !empty(l:parts)
                                    call add(l:path_list, join(l:parts, l:sep))
                                    let l:parts = l:parts[:-2]
                                endwhile
                            
                                if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
                                    call map(l:path_list, '''/'' . v:val')
                                    call add(l:path_list, '/')
                                endif
                            
                                return l:path_list
                            endfunction
                            
                            " Convert a filesystem path to a file:// URI
                            " relatives paths will not be prefixed with the protocol.
                            " For Windows paths, the `:` in C:\ etc. will not be percent-encoded.
    1              0.000001000 function! ale#path#ToFileURI(path) abort
                                let l:has_drive_letter = a:path[1:2] is# ':\'
                            
                                return substitute(
                                \   ((l:has_drive_letter || a:path[:0] is# '/') ? 'file://' : '')
                                \       . (l:has_drive_letter ? '/' . a:path[:2] : '')
                                \       . ale#uri#Encode(l:has_drive_letter ? a:path[3:] : a:path),
                                \   '\\',
                                \   '/',
                                \   'g',
                                \)
                            endfunction
                            
    1              0.000000000 function! ale#path#FromFileURI(uri) abort
                                if a:uri[:6] is? 'file://'
                                    let l:encoded_path = a:uri[7:]
                                elseif a:uri[:4] is? 'file:'
                                    let l:encoded_path = a:uri[5:]
                                else
                                    let l:encoded_path = a:uri
                                endif
                            
                                let l:path = ale#uri#Decode(l:encoded_path)
                            
                                " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
                                if has('win32') && l:path =~# '^/[a-zA-Z][:|]'
                                    let l:path = substitute(l:path[1:], '/', '\\', 'g')
                                    let l:path = l:path[0] . ':' . l:path[2:]
                                endif
                            
                                return l:path
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/autoload/vader.vim
Sourced 1 time
Total time:   0.005271000
 Self time:   0.005271000

count     total (s)      self (s)
                            " Copyright (c) 2015 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000026000 let s:register = {}
    1              0.000005000 let s:register_undefined = []
    1              0.000005000 let s:indent = 2
                            " Fallback to 'type' (on Windows).
    1              0.004386000 let s:cat = executable('cat') ? 'cat' : 'type'
                            
    1              0.000027000 function! vader#run(bang, ...) range
                              let s:error_line = 0
                            
                              let g:vader_bang = a:bang
                            
                              if a:lastline - a:firstline > 0
                                if a:0 > 1
                                  echoerr "You can't apply range on multiple files"
                                  return
                                endif
                                let [line1, line2] = [a:firstline, a:lastline]
                              else
                                let [line1, line2] = [1, 0]
                              endif
                            
                              let options = {
                                    \ 'exitfirst': index(a:000, '-x') >= 0,
                                    \ 'quiet': index(a:000, '-q') >= 0,
                                    \ }
                              let patterns = filter(copy(a:000), "index(['-x', '-q'], v:val) == -1")
                              if empty(patterns)
                                let patterns = [expand('%')]
                              endif
                            
                              if a:bang && !options.quiet
                                redir => ver
                                silent version
                                redir END
                                call vader#print_stderr(ver . "\n\n")
                              endif
                            
                              call vader#assert#reset()
                              call s:prepare()
                              try
                                let all_cases = []
                                let qfl = []
                                let st  = reltime()
                                let [success, pending, total] = [0, 0, 0]
                            
                                for gl in patterns
                                  if filereadable(gl)
                                    let files = [gl]
                                  else
                                    let files = filter(split(glob(gl), "\n"),
                                          \ "fnamemodify(v:val, ':e') ==# 'vader'")
                                  endif
                                  for fn in files
                                    let afn = fnamemodify(fn, ':p')
                                    let cases = vader#parser#parse(afn, line1, line2)
                                    call add(all_cases, [afn, cases])
                                    let total += len(cases)
                                  endfor
                                endfor
                                if empty(all_cases)
                                  throw 'Vader: no tests found for patterns ('.join(patterns).')'
                                endif
                            
                                call vader#window#open()
                                call vader#window#append(
                                \ printf("Starting Vader: %d suite(s), %d case(s)", len(all_cases), total), 0)
                            
                                for pair in all_cases
                                  let [fn, case] = pair
                                  let [cs, cp, ct, lqfl] = s:run(fn, case, options)
                                  let success += cs
                                  let pending += cp
                                  call extend(qfl, lqfl)
                                  call vader#window#append(
                                        \ printf('Success/Total: %s/%s%s',
                                        \     cs, ct, cp > 0 ? (' ('.cp.' pending)') : ''),
                                        \ 1)
                                  if options.exitfirst && (cs + cp) < ct
                                    break
                                  endif
                                endfor
                            
                                let successful = success + pending == total
                                let g:vader_result = {
                                      \ 'total': total,
                                      \ 'success': success,
                                      \ 'pending': pending,
                                      \ 'successful': successful,
                                      \ }
                            
                                let stats = vader#assert#stat()
                                call vader#window#append(printf('Success/Total: %s/%s (%sassertions: %d/%d)',
                                      \ success, total, (pending > 0 ? pending . ' pending, ' : ''),
                                      \ stats[0], stats[1]), 0)
                                if 0 && exists('*reltimefloat')
                                  let duration = printf('%.2f', reltimefloat(reltime(st)))
                                else
                                  let duration = substitute(substitute(reltimestr(reltime(st)), '^\s*', '', ''), '\.\d\d\zs.*', '', '')
                                endif
                                call vader#window#append(printf('Elapsed time: %s sec.', duration), 0)
                                call vader#window#cleanup()
                            
                                if a:bang
                                  if exists('*s:output_stderr_buffer')
                                    call s:output_stderr_buffer()
                                  endif
                                  if successful
                                    qall!
                                  else
                                    cq
                                  endif
                                else
                                  let g:vader_report = join(getline(1, '$'), "\n")
                                  let g:vader_errors = qfl
                                  call setqflist(qfl)
                            
                                  if !empty(qfl)
                                    call vader#window#copen()
                                  endif
                                endif
                              catch
                                let error = 'Vader error: '.v:exception.' (in '.v:throwpoint.')'
                                if a:bang
                                  call vader#print_stderr(error)
                                  cq
                                else
                                  echoerr error
                                endif
                              finally
                                call s:cleanup()
                              endtry
                            endfunction
                            
                            " Define vader#print_stderr based on available features / used options.
                            " This is done a) for performance reasons, but b) mainly because `mode()`
                            " might be e.g. "ic" during tests, and we need to detect the initial usage of
                            " "-es" / "-Es".
    1              0.000014000 if !empty($VADER_OUTPUT_FILE)
                              function! vader#print_stderr(output) abort
                                let lines = split(a:output, '\n')
                                call writefile(lines, $VADER_OUTPUT_FILE, 'a')
                              endfunction
    1              0.000014000 elseif has('nvim')
                              if exists('v:stderr')
                                function! vader#print_stderr(output) abort
                                  call chansend(v:stderr, a:output)
                                endfunction
                              elseif filewritable('/dev/stderr')
                                function! vader#print_stderr(output) abort
                                  let lines = split(a:output, '\n')
                                  call writefile(lines, '/dev/stderr', 'a')
                                endfunction
                              else
                                " Assume --headless mode being used.  Could be detected using
                                " "len(nvim_list_uis()) == 0 after VimEnter", but not available with
                                " Neovim 0.2.0 at least.
                                function! vader#print_stderr(output) abort
                                  for line in split(a:output, '\n')
                                    echom line
                                  endfor
                                endfunction
                              endif
    1              0.000001000 else
    1              0.000006000   if v:version >= 702  " mode(1) only works with Vim v7.2a.
    1              0.000007000     let mode = mode(1)
                              else
                                let mode = ''
    1              0.000001000   endif
    1              0.000005000   if mode ==# 'ce' || mode ==# 'cv'  " -es (silent ex mode)
                                function! vader#print_stderr(output) abort
                                  let lines = split(a:output, '\n')
                                  for line in lines
                                    verbose echon line."\n"
                                  endfor
                                endfunction
    1              0.000001000   else
                                " Cannot output single lines reliably in this case.
    1              0.000004000     let s:stderr_buffer = []
    1              0.000003000     if !empty(mode)
    1              0.000026000       call add(s:stderr_buffer,
                                      \ printf('Vader note: cannot print to stderr reliably/directly.  Please consider using %s''s -es/-Es option (mode=%s).',
                                          \ has('nvim') ? 'Neovim' : 'Vim',
                                          \ mode))
    1              0.000002000     endif
    1              0.000004000     function! s:output_stderr_buffer() abort
                                  let s:tmpfile = tempname()
                                  call writefile(s:stderr_buffer, s:tmpfile)
                                  execute printf('silent !%s %s 1>&2', s:cat, s:tmpfile)
                                  let s:stderr_buffer = []
                                endfunction
    1              0.000007000     augroup vader_exit
    1              0.000029000       autocmd VimLeave * call s:output_stderr_buffer()
    1              0.000002000     augroup END
                            
    1              0.000003000     function! vader#print_stderr(output) abort
                                  let lines = split(a:output, '\n')
                                  call extend(s:stderr_buffer, lines)
                                endfunction
    1              0.000001000   endif
    1              0.000001000 endif
                            
    1              0.000003000 function! s:split_args(arg)
                              let varnames = split(a:arg, ',')
                              let names = []
                              for varname in varnames
                                let name = substitute(varname, '^\s*\(.*\)\s*$', '\1', '')
                                let name = substitute(name, '^''\(.*\)''$', '\1', '')
                                let name = substitute(name, '^"\(.*\)"$',  '\1', '')
                                call add(names, name)
                              endfor
                              return names
                            endfunction
                            
    1              0.000002000 function! vader#log(msg)
                              let msg = type(a:msg) == 1 ? a:msg : string(a:msg)
                              call vader#window#append('> ' . msg, s:indent)
                            endfunction
                            
    1              0.000002000 function! vader#save(args)
                              for varname in s:split_args(a:args)
                                if exists(varname)
                                  let s:register[varname] = deepcopy(eval(varname))
                                else
                                  let s:register_undefined += [varname]
                                endif
                              endfor
                            endfunction
                            
    1              0.000002000 function! vader#restore(args)
                              let varnames = s:split_args(a:args)
                              for varname in empty(varnames) ? keys(s:register) : varnames
                                if has_key(s:register, varname)
                                  execute printf("let %s = deepcopy(s:register['%s'])", varname, varname)
                                endif
                              endfor
                              let undefined = empty(varnames) ? s:register_undefined
                                    \ : filter(copy(varnames), 'index(s:register_undefined, v:val) != -1')
                              for varname in undefined
                                if varname[0] ==# '$'
                                  execute printf('let %s = ""', varname)
                                else
                                  execute printf('unlet! %s', varname)
                                endif
                              endfor
                            endfunction
                            
    1              0.000003000 function! s:prepare()
                              command! -nargs=+ Log            :call vader#log(<args>)
                              command! -nargs=+ Save           :call vader#save(<q-args>)
                              command! -nargs=* Restore        :call vader#restore(<q-args>)
                              command! -nargs=+ Assert         :call vader#assert#true(<args>)
                              command! -nargs=+ AssertEqual    :call vader#assert#equal(<args>)
                              command! -nargs=+ AssertNotEqual :call vader#assert#not_equal(<args>)
                              command! -nargs=+ AssertThrows   :call vader#assert#throws(<q-args>)
                              let g:SyntaxAt = function('vader#helper#syntax_at')
                              let g:SyntaxOf = function('vader#helper#syntax_of')
                            endfunction
                            
    1              0.000002000 function! s:cleanup()
                              let s:register = {}
                              let s:register_undefined = []
                              delcommand Log
                              delcommand Save
                              delcommand Restore
                              delcommand Assert
                              delcommand AssertEqual
                              delcommand AssertNotEqual
                              delcommand AssertThrows
                              unlet g:SyntaxAt
                              unlet g:SyntaxOf
                            endfunction
                            
    1              0.000003000 function! s:comment(case, label)
                              return get(a:case.comment, a:label, '')
                            endfunction
                            
    1              0.000003000 function! s:execute(prefix, type, block, lang_if)
                              try
                                call vader#window#execute(a:block, a:lang_if)
                                return 1
                              catch
                                call s:append(a:prefix, a:type, v:exception, 1)
                                call s:print_throwpoint()
                                return 0
                              endtry
                            endfunction
                            
    1              0.000003000 function! s:print_throwpoint()
                              if v:throwpoint !~ 'vader#assert'
                                Log v:throwpoint
                              endif
                            endfunction
                            
    1              0.000003000 function! s:run(filename, cases, options)
                              let given = []
                              let before = []
                              let after = []
                              let then = []
                              let comment = { 'given': '', 'before': '', 'after': '' }
                              let total = len(a:cases)
                              let just  = len(string(total))
                              let cnt = 0
                              let pending = 0
                              let success = 0
                              let exitfirst = get(a:options, 'exitfirst', 0)
                              let qfl = []
                              let g:vader_file = a:filename
                            
                              call vader#window#append("Starting Vader: ". a:filename, 1)
                            
                              for case in a:cases
                                let cnt += 1
                                let ok = 1
                                let prefix = printf('(%'.just.'d/%'.just.'d)', cnt, total)
                            
                                for label in ['given', 'before', 'after', 'then']
                                  if has_key(case, label)
                                    execute 'let '.label.' = case[label]'
                                    let comment[label] = get(case.comment, label, '')
                                  endif
                                endfor
                            
                                if !empty(given)
                                  call s:append(prefix, 'given', comment.given)
                                endif
                                call vader#window#prepare(given, get(case, 'type', ''))
                            
                                if !empty(before)
                                  let s:indent = 2
                                  let ok = ok && s:execute(prefix, 'before', before, '')
                                endif
                            
                                let s:indent = 3
                                if has_key(case, 'execute')
                                  call s:append(prefix, 'execute', s:comment(case, 'execute'))
                                  let ok = ok && s:execute(prefix, 'execute', case.execute, get(case, 'lang_if', ''))
                                elseif has_key(case, 'do')
                                  call s:append(prefix, 'do', s:comment(case, 'do'))
                                  try
                                    call vader#window#replay(case.do)
                                  catch
                                    call s:append(prefix, 'do', v:exception, 1)
                                    call s:print_throwpoint()
                                    let ok = 0
                                  endtry
                                endif
                            
                                if has_key(case, 'then')
                                  call s:append(prefix, 'then', s:comment(case, 'then'))
                                  let ok = ok && s:execute(prefix, 'then', then, '')
                                endif
                            
                                if has_key(case, 'expect')
                                  let result = vader#window#result()
                                  let match = case.expect ==# result
                                  if match
                                    call s:append(prefix, 'expect', s:comment(case, 'expect'))
                                  else
                                    let begin = s:append(prefix, 'expect', s:comment(case, 'expect'), 1)
                                    let ok = 0
                                    let data = { 'type': get(case, 'type', ''), 'got': result, 'expect': case.expect }
                                    call vader#window#append('- Expected:', 3)
                                    for line in case.expect
                                      call vader#window#append(line, 5, 0)
                                    endfor
                                    let end = vader#window#append('- Got:', 3)
                                    for line in result
                                      let end = vader#window#append(line, 5, 0)
                                    endfor
                                    call vader#window#set_data(begin, end, data)
                                  endif
                                endif
                            
                                if !empty(after)
                                  let s:indent = 2
                                  let g:vader_case_ok = ok
                                  let ok = s:execute(prefix, 'after', after, '') && ok
                                endif
                            
                                if ok
                                  let success += 1
                                else
                                  let pending += case.pending
                                  let description = join(filter([
                                        \ comment.given,
                                        \ get(case.comment, 'do', get(case.comment, 'execute', '')),
                                        \ get(case.comment, 'then', ''),
                                        \ get(case.comment, 'expect', '')], '!empty(v:val)'), ' / ') .
                                        \ ' (#'.s:error_line.')'
                                  call add(qfl, { 'type': 'E', 'filename': a:filename, 'lnum': case.lnum, 'text': description })
                                  if exitfirst && !case.pending
                                    call vader#window#append('Stopping after first failure.', 2)
                                    break
                                  endif
                                endif
                              endfor
                            
                              unlet g:vader_file
                              return [success, pending, total, qfl]
                            endfunction
                            
    1              0.000003000 function! s:append(prefix, type, message, ...)
                              let error = get(a:, 1, 0)
                              let message = (error ? '(X) ' : '') . a:message
                              let line = vader#window#append(printf("%s [%7s] %s", a:prefix, toupper(a:type), message), 2)
                              if error
                                let s:error_line = line
                              endif
                              return line
                            endfunction
                            

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/autoload/vader/assert.vim
Sourced 1 time
Total time:   0.000378000
 Self time:   0.000378000

count     total (s)      self (s)
                            " Copyright (c) 2013 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
                            
    1              0.000011000 let s:assertions = [0, 0]
                            
    1              0.000022000 let s:type_names = {
                                  \ 0: 'Number',
                                  \ 1: 'String',
                                  \ 2: 'Funcref',
                                  \ 3: 'List',
                                  \ 4: 'Dictionary',
                                  \ 5: 'Float',
                                  \ 6: 'Boolean',
                                  \ 7: 'Null' }
                            
    1              0.000005000 function! vader#assert#reset()
                              let s:assertions = [0, 0]
                            endfunction
                            
    1              0.000003000 function! vader#assert#stat()
                              return s:assertions
                            endfunction
                            
    1              0.000002000 function! vader#assert#true(...)
                              let s:assertions[1] += 1
                            
                              if a:0 == 1
                                let [expr, message] = [a:1, "Assertion failure"]
                              elseif a:0 == 2
                                let [expr, message] = a:000
                              else
                                throw 'Invalid number of arguments'
                              endif
                            
                              if !expr
                                throw message
                              endif
                              let s:assertions[0] += 1
                              return 1
                            endfunction
                            
    1              0.000003000 function! s:check_types(...)
                              let [Exp, Got] = a:000[0:1]
                              if type(Exp) !=# type(Got)
                                throw get(a:000, 2, printf("type mismatch: %s (%s) should be equal to %s (%s)",
                                      \ string(Got), get(s:type_names, type(Got), type(Got)),
                                      \ string(Exp), get(s:type_names, type(Exp), type(Exp))))
                              endif
                            endfunction
                            
    1              0.000003000 function! vader#assert#equal(...)
                              let [Exp, Got] = a:000[0:1]
                              let s:assertions[1] += 1
                            
                              call s:check_types(Exp, Got)
                              if Exp !=# Got
                                let type = type(Exp)
                                let type_name = get(s:type_names, type)
                                let type_name_plural = type_name ==# 'Dictionary' ? 'Dictionaries' : type_name.'s'
                                let msg = (type == type({}) || type == type([]))
                                      \ ? printf("Unequal %s\n      %%s should be equal to\n      %%s", type_name_plural)
                                      \ : '%s should be equal to %s'
                                throw get(a:000, 2, printf(msg, string(Got), string(Exp)))
                              endif
                              let s:assertions[0] += 1
                              return 1
                            endfunction
                            
    1              0.000002000 function! vader#assert#not_equal(...)
                              let [Exp, Got] = a:000[0:1]
                              let s:assertions[1] += 1
                            
                              call s:check_types(Exp, Got)
                              if Exp ==# Got
                                throw get(a:000, 2, printf("%s should not be equal to %s", string(Got), string(Exp)))
                              endif
                              let s:assertions[0] += 1
                              return 1
                            endfunction
                            
    1              0.000002000 function! vader#assert#throws(exp)
                              let s:assertions[1] += 1
                            
                              let g:vader_exception = ''
                              let g:vader_throwpoint = ''
                              let ok = 0
                              try
                                execute a:exp
                              catch
                                let g:vader_exception = v:exception
                                let g:vader_throwpoint = v:throwpoint
                                let ok = 1
                              endtry
                            
                              let s:assertions[0] += ok
                              if ok | return 1
                              else  | throw 'Exception expected but not raised: '.a:exp
                              endif
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/autoload/vader/parser.vim
Sourced 1 time
Total time:   0.000420000
 Self time:   0.000420000

count     total (s)      self (s)
                            " Copyright (c) 2013 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000007000 function! vader#parser#parse(fn, line1, line2)
                              return s:parse_vader(s:read_vader(a:fn, a:line1, a:line2), a:line1)
                            endfunction
                            
    1              0.000006000 function! s:flush_buffer(cases, case, fn, lnum, raw, label, newlabel, buffer, final)
                              let is_validation = index(['then', 'expect'], a:newlabel) >= 0
                              let fpos = a:fn.':'.a:lnum
                            
                              if empty(a:label)
                                if is_validation
                                  echoerr 'Expect/Then should not appear before Do/Execute ('.fpos.')'
                                endif
                              else
                                let rev = reverse(copy(a:buffer))
                                while len(rev) > 0 && empty(rev[0])
                                  call remove(rev, 0)
                                endwhile
                            
                                let data = map(reverse(rev), (a:case.raw ? 'v:val' : 'strpart(v:val, 2)'))
                                let a:case[a:label] = data
                                if !empty(a:buffer)
                                  call remove(a:buffer, 0, -1)
                                endif
                            
                                let fulfilled = has_key(a:case, 'do') || has_key(a:case, 'execute')
                                if is_validation
                                  if !fulfilled
                                    echoerr 'Expect/Then should not appear before Do/Execute ('.fpos.')'
                                  endif
                                  if has_key(a:case, a:newlabel)
                                    echoerr 'Expect/Then should appear only once for each Do/Execute ('.fpos.')'
                                  endif
                                endif
                            
                                if a:final ||
                                 \ a:newlabel == 'given' ||
                                 \ index(['before', 'after', 'do', 'execute'], a:newlabel) >= 0 && fulfilled
                                  call add(a:cases, deepcopy(a:case))
                                  let new = { 'comment': {}, 'lnum': a:lnum, 'pending': 0 }
                                  if !empty(get(a:case, 'type', ''))
                                    let new.type = a:case.type " To reuse Given block with type
                                  endif
                                  call extend(filter(a:case, '0'), new)
                                endif
                              endif
                              let a:case.raw = a:raw
                            endfunction
                            
    1              0.000002000 function! s:read_vader(fn, line1, line2)
                              let remains   = readfile(a:fn)[a:line1 - 1 : a:line2 - 1]
                              let lnum      = a:line1
                              let lines     = []
                              let reserved  = 0
                              let depth     = 0 " Not a strict depth
                              let max_depth = 10
                            
                              while len(remains) > 0
                                let line = remove(remains, 0)
                                let m = matchlist(line, '^Include\(\s*(.*)\s*\)\?:\s*\(.\{-}\)\s*$')
                                if !empty(m)
                                  let file = findfile(m[2], fnamemodify(a:fn, ':h'))
                                  if empty(file)
                                    echoerr "Cannot find ".m[2]
                                  endif
                                  if reserved > 0
                                    let depth += 1
                                    if depth >= max_depth
                                      echoerr 'Recursive inclusion limit exceeded'
                                    endif
                                    let reserved -= 1
                                  endif
                                  let included = readfile(file)
                                  let reserved += len(included)
                                  call extend(remains, included, 0)
                                  continue
                                end
                            
                                call add(lines, [a:fn, lnum, line])
                                if reserved > 0
                                  let reserved -= 1
                                end
                                if reserved == 0
                                  let depth = 0
                                  let lnum += 1
                                endif
                              endwhile
                            
                              return lines
                            endfunction
                            
    1              0.000002000 function! s:parse_vader(lines, line1)
                              let label    = ''
                              let newlabel = ''
                              let buffer   = []
                              let cases    = []
                              let case     = { 'lnum': a:line1, 'comment': {}, 'pending': 0, 'raw': 0 }
                            
                              if empty(a:lines)
                                return []
                              endif
                            
                              for [fn, lnum, line] in a:lines
                                " Comment / separators
                                if !case.raw && line =~ '^[#"=~*^-]'
                                  continue
                                endif
                            
                                let matched = 0
                                for l in ['Before', 'After', 'Given', 'Execute', 'Expect', 'Do', 'Then']
                                  let m = matchlist(line, '^'.l.'\%(\s\+\([^:;(]\+\)\)\?\s*\%((\(.*\))\)\?\s*\([:;]\)\s*$')
                                  if !empty(m)
                                    let newlabel = tolower(l)
                                    call s:flush_buffer(cases, case, fn, lnum, m[3] == ';', label, newlabel, buffer, 0)
                            
                                    let label   = newlabel
                                    let arg     = m[1]
                                    let comment = m[2]
                                    if !empty(arg)
                                      if     l == 'Given'   | let case.type    = arg
                                      elseif l == 'Execute' | let case.lang_if = arg
                                      end
                                    elseif l == 'Given'
                                      let case.type = ''
                                    endif
                                    if !empty(comment)
                                      let case.comment[tolower(l)] = comment
                                      if index(['do', 'execute'], label) >= 0 &&
                                            \ comment =~# '\<TODO\>\|\<FIXME\>'
                                        let case.pending = 1
                                      endif
                                    endif
                                    let matched = 1
                                    break
                                  endif
                                endfor
                                if matched | continue | endif
                            
                                " Continuation
                                if !empty(line) && !case.raw && line !~ '^  '
                                  throw 'Syntax error (line does not start with two spaces): ' . line
                                endif
                                if !empty(label)
                                  call add(buffer, line)
                                endif
                              endfor
                              call s:flush_buffer(cases, case, fn, lnum, case.raw, label, '', buffer, 1)
                            
                              let ret = []
                              let prev = {}
                              for case in cases
                                if has_key(case, "do") || has_key(case, "execute")
                                  call add(ret, extend(prev, case))
                                  let prev = {}
                                else
                                  let prev = case
                                endif
                              endfor
                              return ret
                            endfunction
                            

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/autoload/vader/window.vim
Sourced 1 time
Total time:   0.000452000
 Self time:   0.000452000

count     total (s)      self (s)
                            " Copyright (c) 2013 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000010000 let s:quickfix_bfr  = 0
    1              0.000004000 let s:console_bfr   = 0
    1              0.000004000 let s:console_tab   = 0
    1              0.000003000 let s:workbench_tab = 0
    1              0.000004000 let s:workbench_bfr = 0
                            
    1              0.000006000 function! s:switch_to_console()
                              execute 'normal! '.s:console_tab.'gt'
                              if tabpagenr() != s:console_tab
                                call vader#window#append(printf('Vader warning: could not change to console tab (%d)', s:console_tab), 0)
                              endif
                              call append(line('$') - 1, s:console_buffered)
                              let s:console_buffered = []
                            endfunction
                            
    1              0.000003000 function! s:switch_to_workbench()
                              execute 'normal! '.s:workbench_tab.'gt'
                              execute 'b!' s:workbench_bfr
                            endfunction
                            
    1              0.000003000 function! vader#window#open()
                              execute 'silent! bd' s:console_bfr
                              execute 'silent! bd' s:workbench_bfr
                              if bufexists(s:quickfix_bfr)
                                execute "silent! bd ".s:quickfix_bfr
                              endif
                            
                              let s:prev_winid = exists('*win_getid') ? win_getid() : 0
                              tabnew
                              setlocal buftype=nofile noswapfile nospell
                              setf vader-result
                              silent f \[Vader\]
                              let s:console_tab = tabpagenr()
                              let s:console_bfr = bufnr('')
                              let s:console_buffered = []
                              let b:vader_data = {}
                              nnoremap <silent> <buffer> <CR> :call <SID>action(line('.'))<CR>
                            
                              tabnew
                              setlocal buftype=nofile
                              setlocal noswapfile
                              silent f \[Vader-workbench\]
                              let s:workbench_tab = tabpagenr()
                              let s:workbench_bfr = bufnr('')
                            endfunction
                            
    1              0.000004000 function! vader#window#execute(lines, lang_if)
                              let temp = tempname()
                              try
                                if empty(a:lang_if)
                                  let lines = a:lines
                                else
                                  let lines = copy(a:lines)
                                  call insert(lines, a:lang_if . ' << __VADER__LANG__IF__')
                                  call add(lines, '__VADER__LANG__IF__')
                                endif
                                call writefile(lines, temp)
                                execute 'source '.temp
                              finally
                                call delete(temp)
                              endtry
                            endfunction
                            
    1              0.000003000 function! vader#window#replay(lines)
                              call setreg('x', substitute(join(a:lines, ''), '\\<[^>]\+>', '\=eval("\"".submatch(0)."\"")', 'g'), 'c')
                              normal! @x
                            endfunction
                            
    1              0.000002000 function! vader#window#result()
                              return getline(1, line('$'))
                            endfunction
                            
    1              0.000003000 function! vader#window#append(message, indent, ...)
                              let message = repeat('  ', a:indent) . a:message
                              if get(a:, 1, 1)
                                let message = substitute(message, '\s*$', '', '')
                              endif
                              if !exists('s:console_buffered')
                                call vader#print_stderr(printf("Vader: got message before startup: %s\n", message))
                                return 0
                              endif
                              if get(g:, 'vader_bang', 0)
                                call vader#print_stderr(message."\n")
                                return 0
                              endif
                              call add(s:console_buffered, message)
                              return len(s:console_buffered)
                            endfunction
                            
    1              0.000002000 function! vader#window#prepare(lines, type)
                              call s:switch_to_workbench()
                              execute 'setlocal modifiable filetype='.a:type
                            
                              silent %d _
                              for line in a:lines
                                call append(line('$') - 1, line)
                              endfor
                              silent d _
                              execute "normal! \<c-\>\<c-n>gg0"
                            
                              let &undolevels = &undolevels " Break undo block
                            endfunction
                            
    1              0.000003000 function! vader#window#cleanup()
                              execute 'silent! bd' s:workbench_bfr
                              call s:switch_to_console()
                              setlocal nomodifiable
                              nnoremap <silent> <buffer> q :call <SID>quit()<CR><CR>
                              normal! Gzb
                            endfunction
                            
    1              0.000002000 function! vader#window#copen()
                              copen
                              let s:quickfix_bfr = bufnr('')
                              1wincmd w
                              normal! Gzb
                              2wincmd w
                              nnoremap <silent> <buffer> q :call <SID>quit()<CR><CR>
                              nnoremap <silent> <buffer> <CR> :call <SID>move()<CR><CR>
                            endfunction
                            
    1              0.000003000 function! vader#window#set_data(l1, l2, data)
                              try
                                let var = getbufvar(s:console_bfr, 'vader_data', {})
                                for l in range(a:l1, a:l2)
                                  let var[l] = a:data
                                endfor
                                call setbufvar(s:console_bfr, 'vader_data', var)
                              catch
                              endtry
                            endfunction
                            
    1              0.000003000 function! s:scratch(type, data, title)
                              setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap modifiable
                              silent! execute 'setf '.a:type
                              call append(0, a:data)
                              nnoremap <silent> <buffer> q :tabclose<cr>
                              autocmd TabLeave <buffer> tabclose
                            
                              execute 'silent f '.escape(a:title, '[]')
                              normal! G"_ddgg
                              diffthis
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000002000 function! s:action(line)
                              if has_key(b:vader_data, a:line)
                                let data = b:vader_data[a:line]
                                if has_key(data, 'expect')
                                  tabnew
                                  call s:scratch(data.type, data.expect, '[Vader-expected]')
                            
                                  vertical botright new
                                  call s:scratch(data.type, data.got, '[Vader-got]')
                            
                                  redraw
                                  echo "Press 'q' to close"
                                endif
                              else
                                execute "normal! \<CR>"
                              endif
                            endfunction
                            
    1              0.000001000 function! s:move()
                              let lno = matchstr(getline('.'), '(#[0-9]\+)')[2:-2]
                              let wq = winnr()
                              let wc = bufwinnr(s:console_bfr)
                              if wc >= 0
                                execute wc . 'wincmd w'
                                let scrolloff = &scrolloff
                                set scrolloff=0
                                execute lno
                                normal! zt
                                redraw
                                let &scrolloff = scrolloff
                                execute wq . 'wincmd w'
                              endif
                            endfunction
                            
    1              0.000001000 function! s:quit()
                              if s:prev_winid
                                let [s:t, s:w] = win_id2tabwin(s:prev_winid)
                                if s:t
                                  execute printf('tabnext %d | %dwincmd w | %dtabclose', s:t, s:w, s:console_tab)
                                  return
                                endif
                              endif
                              tabclose
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/syntax/vader-result.vim
Sourced 5 times
Total time:   0.001903000
 Self time:   0.001903000

count     total (s)      self (s)
                            " Copyright (c) 2013 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    5              0.000022000 if exists("b:current_syntax")
                              finish
    5              0.000004000 endif
                            
    5              0.000083000 syntax match vaderResultTitle /^[^:]*/ contains=vaderResultNumber
    5              0.000035000 syntax match vaderResultTitle /^[^:]*:\@=/ contains=vaderResultNumber
    5              0.000037000 syntax match vaderResultTitleRest /\(^[^:]*:\)\@<=.*/ contains=vaderResultNumber
    5              0.000030000 syntax match vaderResultTitle2 /^  [^:]*:\@=/ contains=vaderResultNumber
    5              0.000045000 syntax match vaderResultTitle2Rest /\(^  [^:]*:\)\@<=.*/ contains=vaderResultNumber
    5              0.000024000 syntax match vaderResultNumber /-\?[0-9]\+\(\.[0-9]\+\)\?/ contained
    5              0.000073000 syntax match vaderResultItem /^    [^\]]\+\]\( (X).*\)\?/ contains=vaderResultSequence,vaderResultType,vaderResultError
    5              0.000035000 syntax match vaderResultSequence /^    ([0-9/ ]\+)/ contains=vaderResultNumber contained
    5              0.000111000 syntax match vaderResultType /\[[A-Z ]\+\]/ contained contains=vaderResultDo,vaderResultThen,vaderResultGiven,vaderResultExpect,vaderResultExecute,vaderResultBefore,vaderResultAfter
    5              0.000021000 syntax match vaderResultDiff /^          .*/
    5              0.000019000 syntax match vaderResultDo /DO/ contained
    5              0.000011000 syntax match vaderResultThen /THEN/ contained
    5              0.000012000 syntax match vaderResultGiven /GIVEN/ contained
    5              0.000014000 syntax match vaderResultExpect /EXPECT/ contained
    5              0.000012000 syntax match vaderResultExecute /EXECUTE/ contained
    5              0.000011000 syntax match vaderResultBefore /BEFORE/ contained
    5              0.000011000 syntax match vaderResultAfter /AFTER/ contained
    5              0.000011000 syntax match vaderResultError /(X).*/ contained
                            
    5              0.000028000 syntax match vaderResultExpected /^      - Expected/
    5              0.000025000 syntax match vaderResultGot      /^      - Got/
    5              0.000042000 syntax match vaderResultLog      /^    > .*/ contains=vaderResultLogBullet
    5              0.000020000 syntax match vaderResultLog      /^      > .*/ contains=vaderResultLogBullet
    5              0.000014000 syntax match vaderResultLogBullet /^\s*> / contained
                            
    5              0.000096000 hi def link vaderResultTitle Title
    5              0.000037000 hi def link vaderResultTitle2 Conditional
    5              0.000033000 hi def link vaderResultNumber Number
    5              0.000031000 hi def link vaderResultSequence Label
    5              0.000032000 hi def link vaderResultType Delimiter
                            
    5              0.000031000 hi def link vaderResultGiven Include
    5              0.000035000 hi def link vaderResultDo PreProc
    5              0.000031000 hi def link vaderResultThen Conditional
    5              0.000032000 hi def link vaderResultBefore Special
    5              0.000032000 hi def link vaderResultAfter Special
    5              0.000030000 hi def link vaderResultExecute Statement
    5              0.000031000 hi def link vaderResultExpect Boolean
    5              0.000032000 hi def link vaderResultError Error
    5              0.000030000 hi def link vaderResultDiff None
                            
    5              0.000033000 hi def link vaderResultExpected Conditional
    5              0.000030000 hi def link vaderResultGot Exception
    5              0.000031000 hi def link vaderResultLog String
    5              0.000032000 hi def link vaderResultLogBullet Special
                            

SCRIPT  /private/var/folders/rp/2bl5wj4s4zj0pvsc1zlw7jk00000gn/T/vGV7g9c/134
Sourced 1 time
Total time:   0.000966000
 Self time:   0.000966000

count     total (s)      self (s)
Cannot open file!

SCRIPT  /Users/danbradbury/Documents/Github/copilot-chat.vim/test/mocks/init.vim
Sourced 3 times
Total time:   0.001605000
 Self time:   0.001605000

count     total (s)      self (s)
    3              0.000483000 source ./test/mocks/copilot_chat/auth.vim
    2              6.682517000 source ./test/mocks/copilot_chat/api.vim
                            source ./test/mocks/copilot_chat/models.vim

SCRIPT  /Users/danbradbury/Documents/Github/copilot-chat.vim/test/mocks/copilot_chat/auth.vim
Sourced 3 times
Total time:   0.000194000
 Self time:   0.000194000

count     total (s)      self (s)
    3              0.000019000 function! copilot_chat#auth#VerifySignin()
                              return ''
                            endfunction
                            
    3              0.000006000 function! copilot_chat#auth#GetBearerToken()
                              return ''
                            endfunction

SCRIPT  /Users/danbradbury/Documents/Github/copilot-chat.vim/test/mocks/copilot_chat/api.vim
Sourced 3 times
Total time:   0.000191000
 Self time:   0.000191000

count     total (s)      self (s)
    2              6.682946000 if exists('*copilot_chat#api#FetchModels') | delfunction copilot_chat#api#FetchModels | endif
                            
                            function! copilot_chat#api#FetchModels(chat_token)
                              return []
                            endfunction

SCRIPT  /Users/danbradbury/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim
Sourced 1 time
Total time:   0.002713000
 Self time:   0.002678000

count     total (s)      self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp.vim
                            " Description:   Fuzzy file, buffer, mru, tag, etc finder.
                            " Author:        Kien Nguyen <github.com/kien>
                            " Version:       1.79
                            " =============================================================================
                            
                            " ** Static variables {{{1
                            " s:ignore() {{{2
    1              0.000007000 fu! s:ignore()
                            	let igdirs = [
                            		\ '\.git',
                            		\ '\.hg',
                            		\ '\.svn',
                            		\ '_darcs',
                            		\ '\.bzr',
                            		\ '\.cdv',
                            		\ '\~\.dep',
                            		\ '\~\.dot',
                            		\ '\~\.nib',
                            		\ '\~\.plst',
                            		\ '\.pc',
                            		\ '_MTN',
                            		\ 'blib',
                            		\ 'CVS',
                            		\ 'RCS',
                            		\ 'SCCS',
                            		\ '_sgbak',
                            		\ 'autom4te\.cache',
                            		\ 'cover_db',
                            		\ '_build',
                            		\ ]
                            	let igfiles = [
                            		\ '\~$',
                            		\ '#.+#$',
                            		\ '[._].*\.swp$',
                            		\ 'core\.\d+$',
                            		\ '\.exe$',
                            		\ '\.so$',
                            		\ '\.bak$',
                            		\ '\.png$',
                            		\ '\.jpg$',
                            		\ '\.gif$',
                            		\ '\.zip$',
                            		\ '\.rar$',
                            		\ '\.tar\.gz$',
                            		\ ]
                            	retu {
                            		\ 'dir': '\v[\/]('.join(igdirs, '|').')$',
                            		\ 'file': '\v'.join(igfiles, '|'),
                            		\ }
                            endf
                            " Script local vars {{{2
    1   0.000143000   0.000108000 let [s:pref, s:bpref, s:opts, s:new_opts, s:lc_opts] =
                            	\ ['g:ctrlp_', 'b:ctrlp_', {
                            	\ 'abbrev':                ['s:abbrev', {}],
                            	\ 'arg_map':               ['s:argmap', 0],
                            	\ 'buffer_func':           ['s:buffunc', {}],
                            	\ 'by_filename':           ['s:byfname', 0],
                            	\ 'custom_ignore':         ['s:usrign', s:ignore()],
                            	\ 'default_input':         ['s:deftxt', 0],
                            	\ 'dont_split':            ['s:nosplit', 'netrw'],
                            	\ 'dotfiles':              ['s:showhidden', 0],
                            	\ 'extensions':            ['s:extensions', []],
                            	\ 'follow_symlinks':       ['s:folsym', 0],
                            	\ 'highlight_match':       ['s:mathi', [1, 'CtrlPMatch']],
                            	\ 'jump_to_buffer':        ['s:jmptobuf', 'Et'],
                            	\ 'key_loop':              ['s:keyloop', 0],
                            	\ 'lazy_update':           ['s:lazy', 0],
                            	\ 'match_func':            ['s:matcher', {}],
                            	\ 'match_window':          ['s:mw', ''],
                            	\ 'match_window_bottom':   ['s:mwbottom', 1],
                            	\ 'match_window_reversed': ['s:mwreverse', 1],
                            	\ 'max_depth':             ['s:maxdepth', 40],
                            	\ 'max_files':             ['s:maxfiles', 10000],
                            	\ 'max_height':            ['s:mxheight', 10],
                            	\ 'max_history':           ['s:maxhst', exists('+hi') ? &hi : 20],
                            	\ 'mruf_default_order':    ['s:mrudef', 0],
                            	\ 'open_func':             ['s:openfunc', {}],
                            	\ 'open_multi':            ['s:opmul', '1v'],
                            	\ 'open_new_file':         ['s:newfop', 'v'],
                            	\ 'prompt_mappings':       ['s:urprtmaps', 0],
                            	\ 'regexp_search':         ['s:regexp', 0],
                            	\ 'root_markers':          ['s:rmarkers', []],
                            	\ 'split_window':          ['s:splitwin', 0],
                            	\ 'status_func':           ['s:status', {}],
                            	\ 'tabpage_position':      ['s:tabpage', 'ac'],
                            	\ 'use_caching':           ['s:caching', 1],
                            	\ 'use_migemo':            ['s:migemo', 0],
                            	\ 'user_command':          ['s:usrcmd', ''],
                            	\ 'working_path_mode':     ['s:pathmode', 'ra'],
                            	\ }, {
                            	\ 'open_multiple_files':   's:opmul',
                            	\ 'regexp':                's:regexp',
                            	\ 'reuse_window':          's:nosplit',
                            	\ 'show_hidden':           's:showhidden',
                            	\ 'switch_buffer':         's:jmptobuf',
                            	\ }, {
                            	\ 'root_markers':          's:rmarkers',
                            	\ 'user_command':          's:usrcmd',
                            	\ 'working_path_mode':     's:pathmode',
                            	\ }]
                            
                            " Global options
    1              0.000015000 let s:glbs = { 'magic': 1, 'to': 1, 'tm': 0, 'sb': 1, 'hls': 0, 'im': 0,
                            	\ 'report': 9999, 'sc': 0, 'ss': 0, 'siso': 0, 'mfd': 200, 'ttimeout': 0,
                            	\ 'gcr': 'a:blinkon0', 'ic': 1, 'lmap': '', 'mousef': 0, 'imd': 1 }
                            
                            " Keymaps
    1              0.000076000 let [s:lcmap, s:prtmaps] = ['nn <buffer> <silent>', {
                            	\ 'PrtBS()':              ['<bs>', '<c-]>'],
                            	\ 'PrtDelete()':          ['<del>'],
                            	\ 'PrtDeleteWord()':      ['<c-w>'],
                            	\ 'PrtClear()':           ['<c-u>'],
                            	\ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
                            	\ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
                            	\ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
                            	\ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
                            	\ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
                            	\ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
                            	\ 'PrtHistory(-1)':       ['<c-n>'],
                            	\ 'PrtHistory(1)':        ['<c-p>'],
                            	\ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
                            	\ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
                            	\ 'AcceptSelection("t")': ['<c-t>'],
                            	\ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
                            	\ 'ToggleFocus()':        ['<s-tab>'],
                            	\ 'ToggleRegex()':        ['<c-r>'],
                            	\ 'ToggleByFname()':      ['<c-d>'],
                            	\ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
                            	\ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
                            	\ 'PrtExpandDir()':       ['<tab>'],
                            	\ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
                            	\ 'PrtInsert()':          ['<c-\>'],
                            	\ 'PrtCurStart()':        ['<c-a>'],
                            	\ 'PrtCurEnd()':          ['<c-e>'],
                            	\ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
                            	\ 'PrtCurRight()':        ['<c-l>', '<right>'],
                            	\ 'PrtClearCache()':      ['<F5>'],
                            	\ 'PrtDeleteEnt()':       ['<F7>'],
                            	\ 'CreateNewFile()':      ['<c-y>'],
                            	\ 'MarkToOpen()':         ['<c-z>'],
                            	\ 'OpenMulti()':          ['<c-o>'],
                            	\ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
                            	\ }]
                            
    1              0.000006000 if !has('gui_running')
                            	cal add(s:prtmaps['PrtBS()'], remove(s:prtmaps['PrtCurLeft()'], 0))
    1              0.000001000 en
                            
    1              0.000003000 let s:compare_lim = 3000
                            
    1              0.000002000 let s:ficounts = {}
                            
    1              0.000004000 let s:ccex = s:pref.'clear_cache_on_exit'
                            
                            " Regexp
    1              0.000008000 let s:fpats = {
                            	\ '^\(\\|\)\|\(\\|\)$': '\\|',
                            	\ '^\\\(zs\|ze\|<\|>\)': '^\\\(zs\|ze\|<\|>\)',
                            	\ '^\S\*$': '\*',
                            	\ '^\S\\?$': '\\?',
                            	\ }
                            
                            " Keypad
    1              0.000008000 let s:kprange = {
                            	\ 'Plus': '+',
                            	\ 'Minus': '-',
                            	\ 'Divide': '/',
                            	\ 'Multiply': '*',
                            	\ 'Point': '.',
                            	\ }
                            
                            " Highlight groups
    1              0.000012000 let s:hlgrps = {
                            	\ 'NoEntries': 'Error',
                            	\ 'Mode1': 'Character',
                            	\ 'Mode2': 'LineNr',
                            	\ 'Stats': 'Function',
                            	\ 'Match': 'Identifier',
                            	\ 'PrtBase': 'Comment',
                            	\ 'PrtText': 'Normal',
                            	\ 'PrtCursor': 'Constant',
                            	\ }
                            " Get the options {{{2
    1              0.000003000 fu! s:opts(...)
                            	unl! s:usrign s:usrcmd s:urprtmaps
                            	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
                            		let {each} = s:{each}
                            	en | endfo
                            	for [ke, va] in items(s:opts)
                            		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
                            	endfo
                            	unl va
                            	for [ke, va] in items(s:new_opts)
                            		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
                            	endfo
                            	unl va
                            	for [ke, va] in items(s:lc_opts)
                            		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
                            		en
                            	endfo
                            	" Match window options
                            	cal s:match_window_opts()
                            	" One-time values
                            	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
                            	en
                            	for each in ['byfname', 'regexp'] | if exists(each)
                            		let s:{each} = {each}
                            	en | endfo
                            	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
                            	let s:maxdepth = min([s:maxdepth, 100])
                            	let s:glob = s:showhidden ? '.*\|*' : '*'
                            	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
                            	let s:lash = ctrlp#utils#lash()
                            	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
                            	en
                            	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
                            	en
                            	" Extensions
                            	if !( exists('extensions') && extensions == s:extensions )
                            		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
                            		endfo
                            	en
                            	" Keymaps
                            	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
                            	en
                            endf
                            
    1              0.000002000 fu! s:match_window_opts()
                            	let s:mw_pos =
                            		\ s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') :
                            		\ exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' )
                            		\ : 'bottom'
                            	let s:mw_order =
                            		\ s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') :
                            		\ exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' )
                            		\ : 'btt'
                            	let s:mw_max =
                            		\ s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) :
                            		\ exists('g:ctrlp_max_height') ? s:mxheight
                            		\ : 10
                            	let s:mw_min =
                            		\ s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
                            	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
                            	let s:mw_min = min([s:mw_min, s:mw_max])
                            	let s:mw_res =
                            		\ s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+'))
                            		\ : min([s:mw_max, &lines])
                            	let s:mw_res = max([s:mw_res, 1])
                            endf
                            "}}}1
                            " * Open & Close {{{1
    1              0.000002000 fu! s:Open()
                            	cal s:log(1)
                            	cal s:getenv()
                            	cal s:execextvar('enter')
                            	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
                            	cal s:buffunc(1)
                            	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
                            	let [s:focus, s:prompt] = [1, ['', '', '']]
                            	abc <buffer>
                            	if !exists('s:hstry')
                            		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
                            		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
                            	en
                            	for [ke, va] in items(s:glbs) | if exists('+'.ke)
                            		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
                            	en | endfo
                            	if s:opmul != '0' && has('signs')
                            		sign define ctrlpmark text=+> texthl=Search
                            	en
                            	cal s:setupblank()
                            endf
                            
    1              0.000002000 fu! s:Close()
                            	cal s:buffunc(0)
                            	if winnr('$') == 1
                            		bw!
                            	el
                            		try | bun!
                            		cat | clo! | endt
                            		cal s:unmarksigns()
                            	en
                            	for key in keys(s:glbs) | if exists('+'.key)
                            		sil! exe 'let &'.key.' = s:glb_'.key
                            	en | endfo
                            	if exists('s:glb_acd') | let &acd = s:glb_acd | en
                            	let g:ctrlp_lines = []
                            	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
                            		exe s:winres[0].s:winres[0]
                            	en
                            	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:cline s:init s:savestr
                            		\ s:mrbs s:did_exp
                            	cal ctrlp#recordhist()
                            	cal s:execextvar('exit')
                            	cal s:log(0)
                            	let v:errmsg = s:ermsg
                            	ec
                            endf
                            " * Clear caches {{{1
    1              0.000002000 fu! ctrlp#clr(...)
                            	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]
                            endf
                            
    1              0.000001000 fu! ctrlp#clra()
                            	let cadir = ctrlp#utils#cachedir()
                            	if isdirectory(cadir)
                            		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
                            		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
                            		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
                            	en
                            	cal ctrlp#clr()
                            endf
                            
    1              0.000002000 fu! s:Reset(args)
                            	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
                            	cal call('s:opts', opts)
                            	cal s:autocmds()
                            	cal ctrlp#utils#opts()
                            	cal s:execextvar('opts')
                            endf
                            " * Files {{{1
    1              0.000001000 fu! ctrlp#files()
                            	let cafile = ctrlp#utils#cachefile()
                            	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
                            		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
                            		if empty(lscmd)
                            			if !ctrlp#igncwd(s:dyncwd)
                            				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
                            			en
                            		el
                            			sil! cal ctrlp#progress('Indexing...')
                            			try | cal s:UserCmd(lscmd)
                            			cat | retu [] | endt
                            		en
                            		" Remove base directory
                            		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
                            		if len(g:ctrlp_allfiles) <= s:compare_lim
                            			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
                            		en
                            		cal s:writecache(cafile)
                            		let catime = getftime(cafile)
                            	el
                            		let catime = getftime(cafile)
                            		if !( exists('s:initcwd') && s:initcwd == s:dyncwd )
                            			\ || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
                            	en
                            	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
                            	retu g:ctrlp_allfiles
                            endf
                            
    1              0.000002000 fu! s:GlobPath(dirs, depth)
                            	let entries = split(globpath(a:dirs, s:glob), "\n")
                            	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
                            	cal extend(g:ctrlp_allfiles, dnf[1])
                            	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
                            		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
                            		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
                            	en
                            endf
                            
    1              0.000001000 fu! s:UserCmd(lscmd)
                            	let [path, lscmd] = [s:dyncwd, a:lscmd]
                            	let do_ign =
                            		\ type(s:usrcmd) == 4 && has_key(s:usrcmd, 'ignore') && s:usrcmd['ignore']
                            	if do_ign && ctrlp#igncwd(s:cwd) | retu | en
                            	if exists('+ssl') && &ssl
                            		let [ssl, &ssl, path] = [&ssl, 0, tr(path, '/', '\')]
                            	en
                            	if has('win32') || has('win64')
                            		let lscmd = substitute(lscmd, '\v(^|\&\&\s*)\zscd (/d)@!', 'cd /d ', '')
                            	en
                            	let path = exists('*shellescape') ? shellescape(path) : path
                            	let g:ctrlp_allfiles = split(system(printf(lscmd, path)), "\n")
                            	if exists('+ssl') && exists('ssl')
                            		let &ssl = ssl
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "\\", "/")')
                            	en
                            	if exists('s:vcscmd') && s:vcscmd
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "/", "\\")')
                            	en
                            	if do_ign
                            		if !empty(s:usrign)
                            			let g:ctrlp_allfiles = ctrlp#dirnfile(g:ctrlp_allfiles)[1]
                            		en
                            		if &wig != ''
                            			cal filter(g:ctrlp_allfiles, 'glob(v:val) != ""')
                            		en
                            	en
                            endf
                            
    1              0.000001000 fu! s:lsCmd()
                            	let cmd = s:usrcmd
                            	if type(cmd) == 1
                            		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                            		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
                            		let s:vcscmd = s:lash == '\'
                            		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en
                            endf
                            " - Buffers {{{1
    1              0.000002000 fu! ctrlp#buffers(...)
                            	let ids = sort(filter(range(1, bufnr('$')), 'empty(getbufvar(v:val, "&bt"))'
                            		\ .' && getbufvar(v:val, "&bl")'), 's:compmreb')
                            	if a:0 && a:1 == 'id'
                            		retu ids
                            	el
                            		let bufs = [[], []]
                            		for id in ids
                            			let bname = bufname(id)
                            			let ebname = bname == ''
                            			let fname = fnamemodify(ebname ? '['.id.'*No Name]' : bname, ':.')
                            			cal add(bufs[ebname], fname)
                            		endfo
                            		retu bufs[0] + bufs[1]
                            	en
                            endf
                            " * MatchedItems() {{{1
    1              0.000002000 fu! s:MatchIt(items, pat, limit, exc)
                            	let [lines, id] = [[], 0]
                            	let pat =
                            		\ s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val')
                            		\ : s:martcs.a:pat
                            	for item in a:items
                            		let id += 1
                            		try | if !( s:ispath && item == a:exc ) && call(s:mfunc, [item, pat]) >= 0
                            			cal add(lines, item)
                            		en | cat | brea | endt
                            		if a:limit > 0 && len(lines) >= a:limit | brea | en
                            	endfo
                            	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
                            	retu lines
                            endf
                            
    1              0.000003000 fu! s:MatchedItems(items, pat, limit)
                            	let exc = exists('s:crfilerel') ? s:crfilerel : ''
                            	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
                            	if s:matcher != {}
                            		let argms =
                            			\ has_key(s:matcher, 'arg_type') && s:matcher['arg_type'] == 'dict' ? [{
                            			\ 'items':  items,
                            			\ 'str':    a:pat,
                            			\ 'limit':  a:limit,
                            			\ 'mmode':  s:mmode(),
                            			\ 'ispath': s:ispath,
                            			\ 'crfile': exc,
                            			\ 'regex':  s:regexp,
                            			\ }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(s:matcher['match'], argms, s:matcher)
                            	el
                            		let lines = s:MatchIt(items, a:pat, a:limit, exc)
                            	en
                            	let s:matches = len(lines)
                            	unl! s:did_exp
                            	retu lines
                            endf
                            
    1              0.000002000 fu! s:SplitPattern(str)
                            	let str = a:str
                            	if s:migemo && s:regexp && len(str) > 0 && executable('cmigemo')
                            		let str = s:migemo(str)
                            	en
                            	let s:savestr = str
                            	if s:regexp
                            		let pat = s:regexfilter(str)
                            	el
                            		let lst = split(str, '\zs')
                            		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
                            		en
                            		for each in ['^', '$', '.']
                            			cal map(lst, 'escape(v:val, each)')
                            		endfo
                            	en
                            	if exists('lst')
                            		let pat = ''
                            		if !empty(lst)
                            			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
                            			el
                            				let pat = s:buildpat(lst)
                            			en
                            		en
                            	en
                            	retu escape(pat, '~')
                            endf
                            " * BuildPrompt() {{{1
    1              0.000002000 fu! s:Render(lines, pat)
                            	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
                            	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
                            	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
                            	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            	" Setup the match window
                            	sil! exe '%d _ | res' height
                            	" Print the new items
                            	if empty(lines)
                            		let [s:matched, s:lines] = [[], []]
                            		let lines = [' == NO ENTRIES ==']
                            		cal setline(1, s:offset(lines, height - 1))
                            		setl noma nocul
                            		exe cur_cmd
                            		cal s:unmarksigns()
                            		if s:dohighlight() | cal clearmatches() | en
                            		retu
                            	en
                            	let s:matched = copy(lines)
                            	" Sorting
                            	if !s:nosort()
                            		let s:compat = s:martcs.pat
                            		cal sort(lines, 's:mixedsort')
                            		unl s:compat
                            	en
                            	if s:mw_order == 'btt' | cal reverse(lines) | en
                            	let s:lines = copy(lines)
                            	cal map(lines, 's:formatline(v:val)')
                            	cal setline(1, s:offset(lines, height))
                            	setl noma cul
                            	exe cur_cmd
                            	cal s:unmarksigns()
                            	cal s:remarksigns()
                            	if exists('s:cline') && s:nolim != 1
                            		cal cursor(s:cline, 1)
                            	en
                            	" Highlighting
                            	if s:dohighlight()
                            		cal s:highlight(pat, s:mathi[1])
                            	en
                            endf
                            
    1              0.000003000 fu! s:Update(str)
                            	" Get the previous string if existed
                            	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
                            	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
                            	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
                            	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
                            	let pat = s:matcher == {} ? s:SplitPattern(str) : str
                            	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines)
                            		\ : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
                            	cal s:Render(lines, pat)
                            endf
                            
    1              0.000002000 fu! s:ForceUpdate()
                            	sil! cal s:Update(escape(s:getinput(), '\'))
                            endf
                            
    1              0.000002000 fu! s:BuildPrompt(upd)
                            	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
                            	let str = escape(s:getinput(), '\')
                            	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
                            	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp')
                            		\ || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
                            		sil! cal s:Update(str)
                            	en
                            	sil! cal ctrlp#statusline()
                            	" Toggling
                            	let [hiactive, hicursor, base] = s:focus
                            		\ ? ['CtrlPPrtText', 'CtrlPPrtCursor', base]
                            		\ : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
                            	let hibase = 'CtrlPPrtBase'
                            	" Build it
                            	redr
                            	let prt = copy(s:prompt)
                            	cal map(prt, 'escape(v:val, ''"\'')')
                            	exe 'echoh' hibase '| echon "'.base.'"
                            		\ | echoh' hiactive '| echon "'.prt[0].'"
                            		\ | echoh' hicursor '| echon "'.prt[1].'"
                            		\ | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
                            	if empty(prt[1]) && s:focus
                            		exe 'echoh' hibase '| echon "_" | echoh None'
                            	en
                            endf
                            " - SetDefTxt() {{{1
    1              0.000002000 fu! s:SetDefTxt()
                            	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt
                            endf
                            " ** Prt Actions {{{1
                            " Editing {{{2
    1              0.000001000 fu! s:PrtClear()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [s:prompt, s:matches] = [['', '', ''], 1]
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000001000 fu! s:PrtAdd(char)
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let s:prompt[0] .= a:char
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            
    1              0.000002000 fu! s:PrtBS()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000002000 fu! s:PrtDelete()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [prt, s:matches] = [s:prompt, 1]
                            	let prt[1] = matchstr(prt[2], '^.')
                            	let prt[2] = substitute(prt[2], '^.', '', '')
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000002000 fu! s:PrtDeleteWord()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [str, s:matches] = [s:prompt[0], 1]
                            	let str = str =~ '\W\w\+$' ? matchstr(str, '^.\+\W\ze\w\+$')
                            		\ : str =~ '\w\W\+$' ? matchstr(str, '^.\+\w\ze\W\+$')
                            		\ : str =~ '\s\+$' ? matchstr(str, '^.*\S\ze\s\+$')
                            		\ : str =~ '\v^(\S+|\s+)$' ? '' : str
                            	let s:prompt[0] = str
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000001000 fu! s:PrtInsert(...)
                            	if !s:focus | retu | en
                            	let type = !a:0 ? '' : a:1
                            	if !a:0
                            		let type = s:insertstr()
                            		if type == 'cancel' | retu | en
                            	en
                            	if type ==# 'r'
                            		let regcont = s:getregs()
                            		if regcont < 0 | retu | en
                            	en
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let s:prompt[0] .= type ==# 'w' ? s:crword
                            		\ : type ==# 'f' ? s:crgfile
                            		\ : type ==# 's' ? s:regisfilter('/')
                            		\ : type ==# 'v' ? s:crvisual
                            		\ : type ==# 'c' ? s:regisfilter('+')
                            		\ : type ==# 'r' ? regcont : ''
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            
    1              0.000002000 fu! s:PrtExpandDir()
                            	if !s:focus | retu | en
                            	let str = s:getinput('c')
                            	if str =~ '\v^\@(cd|lc[hd]?|chd)\s.+' && s:spi
                            		let hasat = split(str, '\v^\@(cd|lc[hd]?|chd)\s*\zs')
                            		let str = get(hasat, 1, '')
                            		if str =~# '\v^[~$]\i{-}[\/]?|^#(\<?\d+)?:(p|h|8|\~|\.|g?s+)'
                            			let str = expand(s:fnesc(str, 'g'))
                            		elsei str =~# '\v^(\%|\<c\h{4}\>):(p|h|8|\~|\.|g?s+)'
                            			let spc = str =~# '^%' ? s:crfile
                            				\ : str =~# '^<cfile>' ? s:crgfile
                            				\ : str =~# '^<cword>' ? s:crword
                            				\ : str =~# '^<cWORD>' ? s:crnbword : ''
                            			let pat = '(:(p|h|8|\~|\.|g?s(.)[^\3]*\3[^\3]*\3))+'
                            			let mdr = matchstr(str, '\v^[^:]+\zs'.pat)
                            			let nmd = matchstr(str, '\v^[^:]+'.pat.'\zs.{-}$')
                            			let str = fnamemodify(s:fnesc(spc, 'g'), mdr).nmd
                            		en
                            	en
                            	if str == '' | retu | en
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let [base, seed] = s:headntail(str)
                            	if str =~# '^[\/]'
                            		let base = expand('/').base
                            	en
                            	let dirs = s:dircompl(base, seed)
                            	if len(dirs) == 1
                            		let str = dirs[0]
                            	elsei len(dirs) > 1
                            		let str .= s:findcommon(dirs, str)
                            	en
                            	let s:prompt[0] = exists('hasat') ? hasat[0].str : str
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            " Movement {{{2
    1              0.000002000 fu! s:PrtCurLeft()
                            	if !s:focus | retu | en
                            	let prt = s:prompt
                            	if !empty(prt[0])
                            		let s:prompt = [substitute(prt[0], '.$', '', ''), matchstr(prt[0], '.$'),
                            			\ prt[1] . prt[2]]
                            	en
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000002000 fu! s:PrtCurRight()
                            	if !s:focus | retu | en
                            	let prt = s:prompt
                            	let s:prompt = [prt[0] . prt[1], matchstr(prt[2], '^.'),
                            		\ substitute(prt[2], '^.', '', '')]
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000002000 fu! s:PrtCurStart()
                            	if !s:focus | retu | en
                            	let str = join(s:prompt, '')
                            	let s:prompt = ['', matchstr(str, '^.'), substitute(str, '^.', '', '')]
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000001000 fu! s:PrtCurEnd()
                            	if !s:focus | retu | en
                            	let s:prompt = [join(s:prompt, ''), '', '']
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000002000 fu! s:PrtSelectMove(dir)
                            	let wht = winheight(0)
                            	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
                            	exe 'keepj norm!' dirs[a:dir]
                            	if s:nolim != 1 | let s:cline = line('.') | en
                            	if line('$') > winheight(0) | cal s:BuildPrompt(0) | en
                            endf
                            
    1              0.000003000 fu! s:PrtSelectJump(char)
                            	let lines = copy(s:lines)
                            	if s:byfname()
                            		cal map(lines, 'split(v:val, ''[\/]\ze[^\/]\+$'')[-1]')
                            	en
                            	" Cycle through matches, use s:jmpchr to store last jump
                            	let chr = escape(matchstr(a:char, '^.'), '.~')
                            	let smartcs = &scs && chr =~ '\u' ? '\C' : ''
                            	if match(lines, smartcs.'^'.chr) >= 0
                            		" If not exists or does but not for the same char
                            		let pos = match(lines, smartcs.'^'.chr)
                            		if !exists('s:jmpchr') || ( exists('s:jmpchr') && s:jmpchr[0] != chr )
                            			let [jmpln, s:jmpchr] = [pos, [chr, pos]]
                            		elsei exists('s:jmpchr') && s:jmpchr[0] == chr
                            			" Start of lines
                            			if s:jmpchr[1] == -1 | let s:jmpchr[1] = pos | en
                            			let npos = match(lines, smartcs.'^'.chr, s:jmpchr[1] + 1)
                            			let [jmpln, s:jmpchr] = [npos == -1 ? pos : npos, [chr, npos]]
                            		en
                            		exe 'keepj norm!' ( jmpln + 1 ).'G'
                            		if s:nolim != 1 | let s:cline = line('.') | en
                            		if line('$') > winheight(0) | cal s:BuildPrompt(0) | en
                            	en
                            endf
                            " Misc {{{2
    1              0.000001000 fu! s:PrtFocusMap(char)
                            	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])
                            endf
                            
    1              0.000002000 fu! s:PrtClearCache()
                            	if s:itemtype == 0
                            		cal ctrlp#clr()
                            	elsei s:itemtype > 2
                            		cal ctrlp#clr(s:statypes[s:itemtype][1])
                            	en
                            	if s:itemtype == 2
                            		let g:ctrlp_lines = ctrlp#mrufiles#refresh()
                            	el
                            		cal ctrlp#setlines()
                            	en
                            	let s:force = 1
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            
    1              0.000002000 fu! s:PrtDeleteEnt()
                            	if s:itemtype == 2
                            		cal s:PrtDeleteMRU()
                            	elsei type(s:getextvar('wipe')) == 1
                            		cal s:delent(s:getextvar('wipe'))
                            	en
                            endf
                            
    1              0.000001000 fu! s:PrtDeleteMRU()
                            	if s:itemtype == 2
                            		cal s:delent('ctrlp#mrufiles#remove')
                            	en
                            endf
                            
    1              0.000001000 fu! s:PrtExit()
                            	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
                            		noa cal s:Close()
                            		noa winc p
                            	en
                            endf
                            
    1              0.000002000 fu! s:PrtHistory(...)
                            	if !s:focus || !s:maxhst | retu | en
                            	let [str, hst, s:matches] = [join(s:prompt, ''), s:hstry, 1]
                            	" Save to history if not saved before
                            	let [hst[0], hslen] = [exists('s:hstgot') ? hst[0] : str, len(hst)]
                            	let idx = exists('s:hisidx') ? s:hisidx + a:1 : a:1
                            	" Limit idx within 0 and hslen
                            	let idx = idx < 0 ? 0 : idx >= hslen ? hslen > 1 ? hslen - 1 : 0 : idx
                            	let s:prompt = [hst[idx], '', '']
                            	let [s:hisidx, s:hstgot, s:force] = [idx, 1, 1]
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            "}}}1
                            " * Mappings {{{1
    1              0.000002000 fu! s:MapNorms()
                            	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
                            	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
                            	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
                            	let pfunc = 'PrtFocusMap'
                            	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
                            	for each in [34, 92, 124]
                            		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
                            	endfo
                            	for each in ranges
                            		exe printf(cmd, each, pfunc, nr2char(each))
                            	endfo
                            	for each in range(0, 9)
                            		exe printf(pcmd, each, pfunc, each)
                            	endfo
                            	for [ke, va] in items(s:kprange)
                            		exe printf(pcmd, ke, pfunc, va)
                            	endfo
                            	let s:nmapped = s:bufnr
                            endf
                            
    1              0.000003000 fu! s:MapSpecs()
                            	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
                            		if ( has('termresponse') && v:termresponse =~ "\<ESC>" )
                            			\ || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi'
                            			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
                            				exe s:lcmap.' <esc>['.each
                            			endfo
                            		en
                            	en
                            	for [ke, va] in items(s:prtmaps) | for kp in va
                            		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
                            	endfo | endfo
                            	let s:smapped = s:bufnr
                            endf
                            
    1              0.000002000 fu! s:KeyLoop()
                            	wh exists('s:init') && s:keyloop
                            		redr
                            		let nr = getchar()
                            		let chr = !type(nr) ? nr2char(nr) : nr
                            		if nr >=# 0x20
                            			cal s:PrtFocusMap(chr)
                            		el
                            			let cmd = matchstr(maparg(chr), ':<C-U>\zs.\+\ze<CR>$')
                            			exe ( cmd != '' ? cmd : 'norm '.chr )
                            		en
                            	endw
                            endf
                            " * Toggling {{{1
    1              0.000002000 fu! s:ToggleFocus()
                            	let s:focus = !s:focus
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000002000 fu! s:ToggleRegex()
                            	let s:regexp = !s:regexp
                            	cal s:PrtSwitcher()
                            endf
                            
    1              0.000001000 fu! s:ToggleByFname()
                            	if s:ispath
                            		let s:byfname = !s:byfname
                            		let s:mfunc = s:mfunc()
                            		cal s:PrtSwitcher()
                            	en
                            endf
                            
    1              0.000002000 fu! s:ToggleType(dir)
                            	let max = len(g:ctrlp_ext_vars) + 2
                            	let next = s:walker(max, s:itemtype, a:dir)
                            	cal ctrlp#syntax()
                            	cal ctrlp#setlines(next)
                            	cal s:PrtSwitcher()
                            endf
                            
    1              0.000001000 fu! s:ToggleKeyLoop()
                            	let s:keyloop = !s:keyloop
                            	if exists('+imd')
                            		let &imd = !s:keyloop
                            	en
                            	if s:keyloop
                            		let [&ut, s:lazy] = [0, 0]
                            		cal s:KeyLoop()
                            	elsei has_key(s:glbs, 'ut')
                            		let [&ut, s:lazy] = [s:glbs['ut'], 1]
                            	en
                            endf
                            
    1              0.000002000 fu! s:ToggleMRURelative()
                            	cal ctrlp#mrufiles#tgrel()
                            	cal s:PrtClearCache()
                            endf
                            
    1              0.000002000 fu! s:PrtSwitcher()
                            	let [s:force, s:matches] = [1, 1]
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            " - SetWD() {{{1
    1              0.000002000 fu! s:SetWD(args)
                            	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0
                            		\ && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
                            	en
                            	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
                            	en
                            	let pmode = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
                            	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
                            	if s:crfile =~ '^.\+://' | retu | en
                            	if pmode =~ 'c' || ( pmode =~ 'a' && stridx(s:crfpath, s:cwd) < 0 )
                            		\ || ( !type(pmode) && pmode )
                            		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                            		cal ctrlp#setdir(s:crfpath)
                            	en
                            	if pmode =~ 'r' || pmode == 2
                            		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
                            		let spath = pmode =~ 'd' ? s:dyncwd : pmode =~ 'w' ? s:cwd : s:crfpath
                            		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            		en
                            		cal s:findroot(spath, markers, 0, 0)
                            	en
                            endf
                            " * AcceptSelection() {{{1
    1              0.000001000 fu! ctrlp#acceptfile(...)
                            	let useb = 0
                            	if a:0 == 1 && type(a:1) == 4
                            		let [md, line] = [a:1['action'], a:1['line']]
                            		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
                            	el
                            		let [md, line] = [a:1, a:2]
                            		let atl = a:0 > 2 ? a:3 : ''
                            	en
                            	if !type(line)
                            		let [filpath, bufnr, useb] = [line, line, 1]
                            	el
                            		let filpath = fnamemodify(line, ':p')
                            		if s:nonamecond(line, filpath)
                            			let bufnr = str2nr(matchstr(line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			let [filpath, useb] = [bufnr, 1]
                            		el
                            			let bufnr = bufnr('^'.filpath.'$')
                            		en
                            	en
                            	cal s:PrtExit()
                            	let tail = s:tail()
                            	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
                            	if ( s:jmptobuf =~ md || ( s:jmptobuf && md =~ '[et]' ) ) && bufnr > 0
                            		\ && !( md == 'e' && bufnr == bufnr('%') )
                            		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
                            		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 )
                            			\ ? s:buftab(bufnr, md) : [0, 0]
                            	en
                            	" Switch to existing buffer or open new one
                            	if exists('jmpb') && bufwinnr > 0
                            		\ && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
                            		exe bufwinnr.'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	elsei exists('jmpb') && buftab[0]
                            		\ && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
                            		exe 'tabn' buftab[0]
                            		exe buftab[1].'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	el
                            		" Determine the command to use
                            		let useb = bufnr > 0 && buflisted(bufnr) && ( empty(tail) || useb )
                            		let cmd =
                            			\ md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) :
                            			\ md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) :
                            			\ md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) :
                            			\ call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
                            		" Reset &switchbuf option
                            		let [swb, &swb] = [&swb, '']
                            		" Open new window/buffer
                            		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
                            		let args = [cmd, fid, tail, 1, [useb, j2l]]
                            		cal call('s:openfile', args)
                            		let &swb = swb
                            	en
                            endf
                            
    1              0.000002000 fu! s:SpecInputs(str)
                            	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
                            		let cwd = s:dyncwd
                            		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ?
                            			\ '../'.repeat('../', strlen(a:str) - 2) : a:str)
                            		if cwd != s:dyncwd | cal ctrlp#setlines() | en
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str == s:lash && s:spi
                            		cal s:SetWD({ 'mode': 'rd' })
                            		cal ctrlp#setlines()
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str =~ '^@.\+' && s:spi
                            		retu s:at(a:str)
                            	elsei a:str == '?'
                            		cal s:PrtExit()
                            		let hlpwin = &columns > 159 ? '| vert res 80' : ''
                            		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000002000 fu! s:AcceptSelection(action)
                            	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
                            	let subm = icr || ( !icr && md == 'e' )
                            	if !subm && s:OpenMulti(md) != -1 | retu | en
                            	let str = s:getinput()
                            	if subm | if s:SpecInputs(str) | retu | en | en
                            	" Get the selected line
                            	let line = ctrlp#getcline()
                            	if !subm && !s:itemtype && line == '' && line('.') > s:offset
                            		\ && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
                            		cal s:CreateNewFile(md) | retu
                            	en
                            	if empty(line) | retu | en
                            	" Do something with it
                            	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            		let actfunc = s:openfunc[s:ctype]
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
                            	el
                            		if s:itemtype < 3
                            			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
                            		el
                            			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
                            			let type = exttype == 'dict' ? exttype : 'list'
                            		en
                            	en
                            	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr }]
                            		\ : [md, line]
                            	cal call(actfunc, actargs)
                            endf
                            " - CreateNewFile() {{{1
    1              0.000002000 fu! s:CreateNewFile(...)
                            	let [md, str] = ['', s:getinput('n')]
                            	if empty(str) | retu | en
                            	if s:argmap && !a:0
                            		" Get the extra argument
                            		let md = s:argmaps(md, 1)
                            		if md == 'cancel' | retu | en
                            	en
                            	let str = s:sanstail(str)
                            	let [base, fname] = s:headntail(str)
                            	if fname =~ '^[\/]$' | retu | en
                            	if exists('s:marked') && len(s:marked)
                            		" Use the first marked file's path
                            		let path = fnamemodify(values(s:marked)[0], ':p:h')
                            		let base = path.s:lash(path).base
                            		let str = fnamemodify(base.s:lash.fname, ':.')
                            	en
                            	if base != '' | if isdirectory(ctrlp#utils#mkdir(base))
                            		let optyp = str | en | el | let optyp = fname
                            	en
                            	if !exists('optyp') | retu | en
                            	let [filpath, tail] = [fnamemodify(optyp, ':p'), s:tail()]
                            	if !stridx(filpath, s:dyncwd) | cal s:insertcache(str) | en
                            	cal s:PrtExit()
                            	let cmd = md == 'r' ? ctrlp#normcmd('e') :
                            		\ s:newfop =~ '1\|t' || ( a:0 && a:1 == 't' ) || md == 't' ? 'tabe' :
                            		\ s:newfop =~ '2\|h' || ( a:0 && a:1 == 'h' ) || md == 'h' ? 'new' :
                            		\ s:newfop =~ '3\|v' || ( a:0 && a:1 == 'v' ) || md == 'v' ? 'vne' :
                            		\ ctrlp#normcmd('e')
                            	cal s:openfile(cmd, filpath, tail, 1)
                            endf
                            " * OpenMulti() {{{1
    1              0.000001000 fu! s:MarkToOpen()
                            	if s:bufnr <= 0 || s:opmul == '0'
                            		\ || ( s:itemtype > 2 && s:getextvar('opmul') != 1 )
                            		retu
                            	en
                            	let line = ctrlp#getcline()
                            	if empty(line) | retu | en
                            	let filpath = s:ispath ? fnamemodify(line, ':p') : line
                            	if exists('s:marked') && s:dictindex(s:marked, filpath) > 0
                            		" Unmark and remove the file from s:marked
                            		let key = s:dictindex(s:marked, filpath)
                            		cal remove(s:marked, key)
                            		if empty(s:marked) | unl s:marked | en
                            		if has('signs')
                            			exe 'sign unplace' key 'buffer='.s:bufnr
                            		en
                            	el
                            		" Add to s:marked and place a new sign
                            		if exists('s:marked')
                            			let vac = s:vacantdict(s:marked)
                            			let key = empty(vac) ? len(s:marked) + 1 : vac[0]
                            			let s:marked = extend(s:marked, { key : filpath })
                            		el
                            			let [key, s:marked] = [1, { 1 : filpath }]
                            		en
                            		if has('signs')
                            			exe 'sign place' key 'line='.line('.').' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	en
                            	sil! cal ctrlp#statusline()
                            endf
                            
    1              0.000002000 fu! s:OpenMulti(...)
                            	let has_marked = exists('s:marked')
                            	if ( !has_marked && a:0 ) || s:opmul == '0' || !s:ispath
                            		\ || ( s:itemtype > 2 && s:getextvar('opmul') != 1 )
                            		retu -1
                            	en
                            	" Get the options
                            	let [nr, md] = [matchstr(s:opmul, '\d\+'), matchstr(s:opmul, '[thvi]')]
                            	let [ur, jf] = [s:opmul =~ 'r', s:opmul =~ 'j']
                            	let md = a:0 ? a:1 : ( md == '' ? 'v' : md )
                            	let nopt = exists('g:ctrlp_open_multiple_files')
                            	if !has_marked
                            		let line = ctrlp#getcline()
                            		if line == '' | retu | en
                            		let marked = { 1 : fnamemodify(line, ':p') }
                            		let [nr, ur, jf, nopt] = ['1', 0, 0, 1]
                            	en
                            	if ( s:argmap || !has_marked ) && !a:0
                            		let md = s:argmaps(md, !has_marked ? 2 : 0)
                            		if md == 'c'
                            			cal s:unmarksigns()
                            			unl! s:marked
                            			cal s:BuildPrompt(0)
                            		elsei !has_marked && md =~ '[axd]'
                            			retu s:OpenNoMarks(md, line)
                            		en
                            		if md =~ '\v^c(ancel)?$' | retu | en
                            		let nr = nr == '0' ? ( nopt ? '' : '1' ) : nr
                            		let ur = !has_marked && md == 'r' ? 1 : ur
                            	en
                            	let mkd = values(has_marked ? s:marked : marked)
                            	cal s:sanstail(join(s:prompt, ''))
                            	cal s:PrtExit()
                            	if nr == '0' || md == 'i'
                            		retu map(mkd, "s:openfile('bad', v:val, '', 0)")
                            	en
                            	let tail = s:tail()
                            	let [emptytail, bufnr] = [empty(tail), bufnr('^'.mkd[0].'$')]
                            	let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            	" Move to a replaceable window
                            	let ncmd = ( useb ? ['b', 'bo vert sb'] : ['e', 'bo vne'] )
                            		\ + ( ur ? [] : ['ignruw'] )
                            	let fst = call('ctrlp#normcmd', ncmd)
                            	" Check if the current window has a replaceable buffer
                            	let repabl = !( md == 't' && !ur ) && empty(bufname('%')) && empty(&l:ft)
                            	" Commands for the rest of the files
                            	let [ic, cmds] = [1, { 'v': ['vert sb', 'vne'], 'h': ['sb', 'new'],
                            		\ 't': ['tab sb', 'tabe'] }]
                            	let [swb, &swb] = [&swb, '']
                            	if md == 't' && ctrlp#tabcount() < tabpagenr()
                            		let s:tabct = ctrlp#tabcount()
                            	en
                            	" Open the files
                            	for va in mkd
                            		let bufnr = bufnr('^'.va.'$')
                            		if bufnr < 0 && getftype(va) == '' | con | en
                            		let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            		let snd = md != '' && has_key(cmds, md) ?
                            			\ ( useb ? cmds[md][0] : cmds[md][1] ) : ( useb ? 'vert sb' : 'vne' )
                            		let cmd = ic == 1 && ( !( !ur && fst =~ '^[eb]$' ) || repabl ) ? fst : snd
                            		let conds = [( nr != '' && nr > 1 && nr < ic ) || ( nr == '' && ic > 1 ),
                            			\ nr != '' && nr < ic]
                            		if conds[nopt]
                            			if !buflisted(bufnr) | cal s:openfile('bad', va, '', 0) | en
                            		el
                            			cal s:openfile(cmd, useb ? bufnr : va, tail, ic == 1)
                            			if jf | if ic == 1
                            				let crpos = [tabpagenr(), winnr()]
                            			el
                            				let crpos[0] += tabpagenr() <= crpos[0]
                            				let crpos[1] += winnr() <= crpos[1]
                            			en | en
                            			let ic += 1
                            		en
                            	endfo
                            	if jf && exists('crpos') && ic > 2
                            		exe ( md == 't' ? 'tabn '.crpos[0] : crpos[1].'winc w' )
                            	en
                            	let &swb = swb
                            	unl! s:tabct
                            endf
                            
    1              0.000002000 fu! s:OpenNoMarks(md, line)
                            	if a:md == 'a'
                            		let [s:marked, key] = [{}, 1]
                            		for line in s:lines
                            			let s:marked = extend(s:marked, { key : fnamemodify(line, ':p') })
                            			let key += 1
                            		endfo
                            		cal s:remarksigns()
                            		cal s:BuildPrompt(0)
                            	elsei a:md == 'x'
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'dict'
                            		let argms = type == 'dict' ? [{ 'action': a:md, 'line': a:line }]
                            			\ : [a:md, a:line]
                            		cal call(s:openfunc[s:ctype], argms, s:openfunc)
                            	elsei a:md == 'd'
                            		let dir = fnamemodify(a:line, ':h')
                            		if isdirectory(dir)
                            			cal ctrlp#setdir(dir)
                            			cal ctrlp#switchtype(0)
                            			cal ctrlp#recordhist()
                            			cal s:PrtClear()
                            		en
                            	en
                            endf
                            " ** Helper functions {{{1
                            " Sorting {{{2
    1              0.000001000 fu! ctrlp#complen(...)
                            	" By length
                            	let [len1, len2] = [strlen(a:1), strlen(a:2)]
                            	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
                            endf
                            
    1              0.000002000 fu! s:compmatlen(...)
                            	" By match length
                            	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
                            	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
                            	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1
                            endf
                            
    1              0.000002000 fu! s:comptime(...)
                            	" By last modified time
                            	let [time1, time2] = [getftime(a:1), getftime(a:2)]
                            	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1
                            endf
                            
    1              0.000002000 fu! s:compmreb(...)
                            	" By last entered time (bufnr)
                            	let [id1, id2] = [index(s:mrbs, a:1), index(s:mrbs, a:2)]
                            	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
                            endf
                            
    1              0.000001000 fu! s:compmref(...)
                            	" By last entered time (MRU)
                            	let [id1, id2] = [index(g:ctrlp_lines, a:1), index(g:ctrlp_lines, a:2)]
                            	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
                            endf
                            
    1              0.000001000 fu! s:comparent(...)
                            	" By same parent dir
                            	if !stridx(s:crfpath, s:dyncwd)
                            		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
                            		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
                            		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
                            		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
                            		retu 0
                            	en
                            	retu 0
                            endf
                            
    1              0.000001000 fu! s:compfnlen(...)
                            	" By filename length
                            	let len1 = strlen(split(a:1, s:lash)[-1])
                            	let len2 = strlen(split(a:2, s:lash)[-1])
                            	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
                            endf
                            
    1              0.000001000 fu! s:matchlens(str, pat, ...)
                            	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
                            	let st   = a:0 ? a:1 : 0
                            	let lens = a:0 >= 2 ? a:2 : {}
                            	let nr   = a:0 >= 3 ? a:3 : 0
                            	if nr > 20 | retu {} | en
                            	if match(a:str, a:pat, st) >= 0
                            		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
                            		let lens = extend(lens, { nr : [strlen(mst), mst] })
                            		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
                            	en
                            	retu lens
                            endf
                            
    1              0.000004000 fu! s:shortest(lens)
                            	retu min(map(values(a:lens), 'v:val[0]'))
                            endf
                            
    1              0.000002000 fu! s:mixedsort(...)
                            	if s:itemtype == 1
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
                            	en
                            	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
                            	if s:ispath
                            		let ms = []
                            		if s:res_count < 21
                            			let ms += [s:compfnlen(a:1, a:2)]
                            			if s:itemtype !~ '^[12]$' | let ms += [s:comptime(a:1, a:2)] | en
                            			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
                            		en
                            		if s:itemtype =~ '^[12]$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
                            		en
                            		let ms += [cml, 0, 0, 0]
                            		let mp = call('s:multipliers', ms[:3])
                            		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2
                            endf
                            
    1              0.000002000 fu! s:multipliers(...)
                            	let mp0 = !a:1 ? 0 : 2
                            	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
                            	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
                            	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
                            	retu [mp0, mp1, mp2, mp3]
                            endf
                            
    1              0.000002000 fu! s:compval(...)
                            	retu a:1 - a:2
                            endf
                            " Statusline {{{2
    1              0.000001000 fu! ctrlp#statusline()
                            	if !exists('s:statypes')
                            		let s:statypes = [
                            			\ ['files', 'fil'],
                            			\ ['buffers', 'buf'],
                            			\ ['mru files', 'mru'],
                            			\ ]
                            		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars),
                            				\ 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
                            		en
                            	en
                            	let tps = s:statypes
                            	let max = len(tps) - 1
                            	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
                            	let prv = tps[s:walker(max, s:itemtype, -1)][1]
                            	let s:ctype = tps[s:itemtype][0]
                            	let focus   = s:focus ? 'prt'  : 'win'
                            	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
                            	let marked  = s:opmul != '0' ?
                            		\ exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
                            	if s:status != {}
                            		let argms =
                            			\ has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{
                            			\ 'focus':   focus,
                            			\ 'byfname': byfname,
                            			\ 'regex':   s:regexp,
                            			\ 'prev':    prv,
                            			\ 'item':    s:ctype,
                            			\ 'next':    nxt,
                            			\ 'marked':  marked,
                            			\ }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
                            		let &l:stl = call(s:status['main'], argms, s:status)
                            	el
                            		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
                            		let focus   = '%#CtrlPMode2# '.focus.' %*'
                            		let byfname = '%#CtrlPMode1# '.byfname.' %*'
                            		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
                            		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
                            		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
                            		let &l:stl  = focus.byfname.regex.slider.marked.dir
                            	en
                            endf
                            
    1              0.000002000 fu! s:dismrk()
                            	retu has('signs') ? len(s:marked) :
                            		\ '%<'.join(values(map(copy(s:marked), 'split(v:val, "[\\/]")[-1]')), ', ')
                            endf
                            
    1              0.000002000 fu! ctrlp#progress(enum, ...)
                            	if has('macunix') || has('mac') | sl 1m | en
                            	let txt = a:0 ? '(press ctrl-c to abort)' : ''
                            	if s:status != {}
                            		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict'
                            			\ ? [{ 'str': a:enum }] : [a:enum]
                            		let &l:stl = call(s:status['prog'], argms, s:status)
                            	el
                            		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
                            	en
                            	redraws
                            endf
                            " *** Paths {{{2
                            " Line formatting {{{3
    1              0.000002000 fu! s:formatline(str)
                            	let str = a:str
                            	if s:itemtype == 1
                            		let filpath = fnamemodify(str, ':p')
                            		let bufnr = s:nonamecond(str, filpath)
                            			\ ? str2nr(matchstr(str, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			\ : bufnr('^'.filpath.'$')
                            		let idc = ( bufnr == bufnr('#') ? '#' : '' )
                            			\ . ( getbufvar(bufnr, '&ma') ? '' : '-' )
                            			\ . ( getbufvar(bufnr, '&ro') ? '=' : '' )
                            			\ . ( getbufvar(bufnr, '&mod') ? '+' : '' )
                            		let str .= idc != '' ? ' '.idc : ''
                            	en
                            	let cond = s:ispath && ( s:winw - 4 ) < s:strwidth(str)
                            	retu '> '.( cond ? s:pathshorten(str) : str )
                            endf
                            
    1              0.000002000 fu! s:pathshorten(str)
                            	retu matchstr(a:str, '^.\{9}').'...'
                            		\ .matchstr(a:str, '.\{'.( s:winw - 16 ).'}$')
                            endf
                            
    1              0.000001000 fu! s:offset(lines, height)
                            	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
                            	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines
                            endf
                            " Directory completion {{{3
    1              0.000002000 fu! s:dircompl(be, sd)
                            	if a:sd == '' | retu [] | en
                            	if a:be == ''
                            		let [be, sd] = [s:dyncwd, a:sd]
                            	el
                            		let be = a:be.s:lash(a:be)
                            		let sd = be.a:sd
                            	en
                            	let dirs = split(globpath(s:fnesc(be, 'g', ','), a:sd.'*/'), "\n")
                            	if a:be == ''
                            		let dirs = ctrlp#rmbasedir(dirs)
                            	en
                            	cal filter(dirs, '!match(v:val, escape(sd, ''~$.\''))'
                            		\ . ' && v:val !~ ''\v(^|[\/])\.{1,2}[\/]$''')
                            	retu dirs
                            endf
                            
    1              0.000001000 fu! s:findcommon(items, seed)
                            	let [items, id, cmn, ic] = [copy(a:items), strlen(a:seed), '', 0]
                            	cal map(items, 'strpart(v:val, id)')
                            	for char in split(items[0], '\zs')
                            		for item in items[1:]
                            			if item[ic] != char | let brk = 1 | brea | en
                            		endfo
                            		if exists('brk') | brea | en
                            		let cmn .= char
                            		let ic += 1
                            	endfo
                            	retu cmn
                            endf
                            " Misc {{{3
    1              0.000001000 fu! s:headntail(str)
                            	let parts = split(a:str, '[\/]\ze[^\/]\+[\/:]\?$')
                            	retu len(parts) == 1 ? ['', parts[0]] : len(parts) == 2 ? parts : []
                            endf
                            
    1              0.000001000 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000001000 fu! s:ispathitem()
                            	retu s:itemtype < 3 || ( s:itemtype > 2 && s:getextvar('type') == 'path' )
                            endf
                            
    1              0.000002000 fu! ctrlp#igncwd(cwd)
                            	retu ctrlp#utils#glob(a:cwd, 0) == '' ||
                            		\ ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )
                            endf
                            
    1              0.000002000 fu! ctrlp#dirnfile(entries)
                            	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
                            	for each in a:entries
                            		let etype = getftype(each)
                            		if s:igntype >= 0 && s:usrign(each, etype) | con | en
                            		if etype == 'dir'
                            			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                            				cal add(items[0], each)
                            			en | el
                            				cal add(items[0], each)
                            			en
                            		elsei etype == 'link'
                            			if s:folsym
                            				let isfile = !isdirectory(each)
                            				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                            					cal add(items[isfile], each)
                            				en
                            			en
                            		elsei etype == 'file'
                            			cal add(items[1], each)
                            		en
                            	endfo
                            	retu items
                            endf
                            
    1              0.000002000 fu! s:usrign(item, type)
                            	retu s:igntype == 1 ? a:item =~ s:usrign
                            		\ : s:igntype == 4 && has_key(s:usrign, a:type) && s:usrign[a:type] != ''
                            		\ ? a:item =~ s:usrign[a:type] : 0
                            endf
                            
    1              0.000002000 fu! s:samerootsyml(each, isfile, cwd)
                            	let resolve = fnamemodify(resolve(a:each), ':p:h')
                            	let resolve .= s:lash(resolve)
                            	retu !( stridx(resolve, a:cwd) && ( stridx(a:cwd, resolve) || a:isfile ) )
                            endf
                            
    1              0.000002000 fu! ctrlp#rmbasedir(items)
                            	let cwd = s:dyncwd.s:lash()
                            	if a:items != [] && !stridx(a:items[0], cwd)
                            		let idx = strlen(cwd)
                            		retu map(a:items, 'strpart(v:val, idx)')
                            	en
                            	retu a:items
                            endf
                            " Working directory {{{3
    1              0.000017000 fu! s:getparent(item)
                            	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
                            	if parent == '' || parent !~ '[\/]'
                            		let parent .= s:lash
                            	en
                            	retu parent
                            endf
                            
    1              0.000002000 fu! s:findroot(curr, mark, depth, type)
                            	let [depth, fnd] = [a:depth + 1, 0]
                            	if type(a:mark) == 1
                            		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
                            	elsei type(a:mark) == 3
                            		for markr in a:mark
                            			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
                            				let fnd = 1
                            				brea
                            			en
                            		endfo
                            	en
                            	if fnd
                            		if !a:type | cal ctrlp#setdir(a:curr) | en
                            		retu [exists('markr') ? markr : a:mark, a:curr]
                            	elsei depth > s:maxdepth
                            		cal ctrlp#setdir(s:cwd)
                            	el
                            		let parent = s:getparent(a:curr)
                            		if parent != a:curr
                            			retu s:findroot(parent, a:mark, depth, a:type)
                            		en
                            	en
                            	retu []
                            endf
                            
    1              0.000002000 fu! ctrlp#setdir(path, ...)
                            	let cmd = a:0 ? a:1 : 'lc!'
                            	sil! exe cmd s:fnesc(a:path, 'c')
                            	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
                            endf
                            " Fallbacks {{{3
    1              0.000001000 fu! s:glbpath(...)
                            	retu call('ctrlp#utils#globpath', a:000)
                            endf
                            
    1              0.000002000 fu! s:fnesc(...)
                            	retu call('ctrlp#utils#fnesc', a:000)
                            endf
                            
    1              0.000001000 fu! ctrlp#setlcdir()
                            	if exists('*haslocaldir')
                            		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
                            	en
                            endf
                            " Highlighting {{{2
    1              0.000001000 fu! ctrlp#syntax()
                            	if ctrlp#nosy() | retu | en
                            	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
                            	if synIDattr(synIDtrans(hlID('Normal')), 'bg') !~ '^-1$\|^$'
                            		sil! exe 'hi CtrlPLinePre '.( has("gui_running") ? 'gui' : 'cterm' ).'fg=bg'
                            	en
                            	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
                            	if hlexists('CtrlPLinePre')
                            		sy match CtrlPLinePre '^>'
                            	en
                            endf
                            
    1              0.000002000 fu! s:highlight(pat, grp)
                            	if s:matcher != {} | retu | en
                            	cal clearmatches()
                            	if !empty(a:pat) && s:ispath
                            		let pat = s:regexp ? substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g') : a:pat
                            		if s:byfname
                            			let pat = substitute(pat, '\[\^\(.\{-}\)\]\\{-}', '[^\\/\1]\\{-}', 'g')
                            			let pat = substitute(pat, '\$\@<!$', '\\ze[^\\/]*$', 'g')
                            		en
                            		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
                            		cal matchadd('CtrlPLinePre', '^>')
                            	en
                            endf
                            
    1              0.000001000 fu! s:dohighlight()
                            	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()
                            endf
                            " Prompt history {{{2
    1              0.000001000 fu! s:gethistloc()
                            	let utilcadir = ctrlp#utils#cachedir()
                            	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
                            	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']
                            endf
                            
    1              0.000001000 fu! s:gethistdata()
                            	retu ctrlp#utils#readfile(s:gethistloc()[1])
                            endf
                            
    1              0.000002000 fu! ctrlp#recordhist()
                            	let str = join(s:prompt, '')
                            	if empty(str) || !s:maxhst | retu | en
                            	let hst = s:hstry
                            	if len(hst) > 1 && hst[1] == str | retu | en
                            	cal extend(hst, [str], 1)
                            	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
                            	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])
                            endf
                            " Signs {{{2
    1              0.000001000 fu! s:unmarksigns()
                            	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo
                            endf
                            
    1              0.000002000 fu! s:remarksigns()
                            	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo
                            endf
                            
    1              0.000002000 fu! s:dosigns()
                            	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')
                            endf
                            " Lists & Dictionaries {{{2
    1              0.000001000 fu! s:ifilter(list, str)
                            	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
                            	for each in a:list
                            		try
                            			if eval(estr)
                            				cal add(rlist, each)
                            			en
                            		cat | con | endt
                            	endfo
                            	retu rlist
                            endf
                            
    1              0.000001000 fu! s:dictindex(dict, expr)
                            	for key in keys(a:dict)
                            		if a:dict[key] == a:expr | retu key | en
                            	endfo
                            	retu -1
                            endf
                            
    1              0.000002000 fu! s:vacantdict(dict)
                            	retu filter(range(1, max(keys(a:dict))), '!has_key(a:dict, v:val)')
                            endf
                            
    1              0.000002000 fu! s:sublist(l, s, e)
                            	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)
                            endf
                            
    1              0.000002000 fu! s:sublist7071(l, s, e)
                            	let [newlist, id, ae] = [[], a:s, a:e == -1 ? len(a:l) - 1 : a:e]
                            	wh id <= ae
                            		cal add(newlist, get(a:l, id))
                            		let id += 1
                            	endw
                            	retu newlist
                            endf
                            " Buffers {{{2
    1              0.000002000 fu! s:buftab(bufnr, md)
                            	for tabnr in range(1, tabpagenr('$'))
                            		if tabpagenr() == tabnr && a:md == 't' | con | en
                            		let buflist = tabpagebuflist(tabnr)
                            		if index(buflist, a:bufnr) >= 0
                            			for winnr in range(1, tabpagewinnr(tabnr, '$'))
                            				if buflist[winnr - 1] == a:bufnr | retu [tabnr, winnr] | en
                            			endfo
                            		en
                            	endfo
                            	retu [0, 0]
                            endf
                            
    1              0.000001000 fu! s:bufwins(bufnr)
                            	let winns = 0
                            	for tabnr in range(1, tabpagenr('$'))
                            		let winns += count(tabpagebuflist(tabnr), a:bufnr)
                            	endfo
                            	retu winns
                            endf
                            
    1              0.000002000 fu! s:nonamecond(str, filpath)
                            	retu a:str =~ '[\/]\?\[\d\+\*No Name\]$' && !filereadable(a:filpath)
                            		\ && bufnr('^'.a:filpath.'$') < 1
                            endf
                            
    1              0.000002000 fu! ctrlp#normcmd(cmd, ...)
                            	if a:0 < 2 && s:nosplit() | retu a:cmd | en
                            	let norwins = filter(range(1, winnr('$')),
                            		\ 'empty(getbufvar(winbufnr(v:val), "&bt"))')
                            	for each in norwins
                            		let bufnr = winbufnr(each)
                            		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
                            			let fstemp = each | brea
                            		en
                            	endfo
                            	let norwin = empty(norwins) ? 0 : norwins[0]
                            	if norwin
                            		if index(norwins, winnr()) < 0
                            			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
                            		en
                            		retu a:cmd
                            	en
                            	retu a:0 ? a:1 : 'bo vne'
                            endf
                            
    1              0.000002000 fu! ctrlp#modfilecond(w)
                            	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf &&
                            		\ ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )
                            endf
                            
    1              0.000002000 fu! s:nosplit()
                            	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0
                            endf
                            
    1              0.000001000 fu! s:setupblank()
                            	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
                            	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
                            	if v:version > 702
                            		setl nornu noudf cc=0
                            	en
                            endf
                            
    1              0.000002000 fu! s:leavepre()
                            	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
                            	if !( exists(s:ccex) && !{s:ccex} )
                            		\ && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
                            		cal ctrlp#clra()
                            	en
                            endf
                            
    1              0.000001000 fu! s:checkbuf()
                            	if !exists('s:init') && exists('s:bufnr') && s:bufnr > 0
                            		exe s:bufnr.'bw!'
                            	en
                            endf
                            
    1              0.000002000 fu! s:iscmdwin()
                            	let ermsg = v:errmsg
                            	sil! noa winc p
                            	sil! noa winc p
                            	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
                            	retu ermsg =~ '^E11:'
                            endf
                            " Arguments {{{2
    1              0.000002000 fu! s:at(str)
                            	if a:str =~ '\v^\@(cd|lc[hd]?|chd).*'
                            		let str = substitute(a:str, '\v^\@(cd|lc[hd]?|chd)\s*', '', '')
                            		if str == '' | retu 1 | en
                            		let str = str =~ '^%:.\+' ? fnamemodify(s:crfile, str[1:]) : str
                            		let path = fnamemodify(expand(str, 1), ':p')
                            		if isdirectory(path)
                            			if path != s:dyncwd
                            				cal ctrlp#setdir(path)
                            				cal ctrlp#setlines()
                            			en
                            			cal ctrlp#recordhist()
                            			cal s:PrtClear()
                            		en
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000002000 fu! s:tail()
                            	if exists('s:optail') && !empty('s:optail')
                            		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
                            		retu tailpref.s:optail
                            	en
                            	retu ''
                            endf
                            
    1              0.000002000 fu! s:sanstail(str)
                            	let str = s:spi ?
                            		\ substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
                            	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
                            	unl! s:optail
                            	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
                            	en
                            	retu substitute(str, '\\\ze:', '', 'g')
                            endf
                            
    1              0.000001000 fu! s:argmaps(md, i)
                            	let roh = [
                            		\ ['Open Multiple Files', '/h[i]dden/[c]lear', ['i', 'c']],
                            		\ ['Create a New File', '/[r]eplace', ['r']],
                            		\ ['Open Selected', '/[r]eplace', ['r', 'd', 'a']],
                            		\ ]
                            	if a:i == 2
                            		if !buflisted(bufnr('^'.fnamemodify(ctrlp#getcline(), ':p').'$'))
                            			let roh[2][1] .= '/h[i]dden'
                            			let roh[2][2] += ['i']
                            		en
                            		if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            			let roh[2][1] .= '/e[x]ternal'
                            			let roh[2][2] += ['x']
                            		en
                            	en
                            	let str = roh[a:i][0].': [t]ab/[v]ertical/[h]orizontal'.roh[a:i][1].'? '
                            	retu s:choices(str, ['t', 'v', 'h'] + roh[a:i][2], 's:argmaps', [a:md, a:i])
                            endf
                            
    1              0.000001000 fu! s:insertstr()
                            	let str = 'Insert: c[w]ord/c[f]ile/[s]earch/[v]isual/[c]lipboard/[r]egister? '
                            	retu s:choices(str, ['w', 'f', 's', 'v', 'c', 'r'], 's:insertstr', [])
                            endf
                            
    1              0.000002000 fu! s:textdialog(str)
                            	redr | echoh MoreMsg | echon a:str | echoh None
                            	retu nr2char(getchar())
                            endf
                            
    1              0.000002000 fu! s:choices(str, choices, func, args)
                            	let char = s:textdialog(a:str)
                            	if index(a:choices, char) >= 0
                            		retu char
                            	elsei char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
                            		cal s:BuildPrompt(0)
                            		retu 'cancel'
                            	elsei char =~# "\<CR>" && a:args != []
                            		retu a:args[0]
                            	en
                            	retu call(a:func, a:args)
                            endf
                            
    1              0.000001000 fu! s:getregs()
                            	let char = s:textdialog('Insert from register: ')
                            	if char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
                            		cal s:BuildPrompt(0)
                            		retu -1
                            	elsei char =~# "\<CR>"
                            		retu s:getregs()
                            	en
                            	retu s:regisfilter(char)
                            endf
                            
    1              0.000002000 fu! s:regisfilter(reg)
                            	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')
                            endf
                            " Misc {{{2
    1              0.000002000 fu! s:modevar()
                            	let s:matchtype = s:mtype()
                            	let s:ispath = s:ispathitem()
                            	let s:mfunc = s:mfunc()
                            	let s:nolim = s:getextvar('nolim')
                            	let s:dosort = s:getextvar('sort')
                            	let s:spi = !s:itemtype || s:getextvar('specinput') > 0
                            endf
                            
    1              0.000001000 fu! s:nosort()
                            	retu s:matcher != {} || s:nolim == 1 || ( s:itemtype == 2 && s:mrudef )
                            		\ || ( s:itemtype =~ '\v^(1|2)$' && s:prompt == ['', '', ''] ) || !s:dosort
                            endf
                            
    1              0.000002000 fu! s:byfname()
                            	retu s:ispath && s:byfname
                            endf
                            
    1              0.000001000 fu! s:narrowable()
                            	retu exists('s:act_add') && exists('s:matched') && s:matched != []
                            		\ && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp]
                            		\ && s:matcher == {} && !exists('s:did_exp')
                            endf
                            
    1              0.000001000 fu! s:getinput(...)
                            	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
                            	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 )
                            				\ || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
                            	en
                            	retu spi == 'c' ? prt[0] : join(prt, '')
                            endf
                            
    1              0.000002000 fu! s:migemo(str)
                            	let [str, rtp] = [a:str, s:fnesc(&rtp, 'g')]
                            	let dict = s:glbpath(rtp, printf("dict/%s/migemo-dict", &enc), 1)
                            	if !len(dict)
                            		let dict = s:glbpath(rtp, "dict/migemo-dict", 1)
                            	en
                            	if len(dict)
                            		let [tokens, str, cmd] = [split(str, '\s'), '', 'cmigemo -v -w %s -d %s']
                            		for token in tokens
                            			let rtn = system(printf(cmd, shellescape(token), shellescape(dict)))
                            			let str .= !v:shell_error && strlen(rtn) > 0 ? '.*'.rtn : token
                            		endfo
                            	en
                            	retu str
                            endf
                            
    1              0.000002000 fu! s:strwidth(str)
                            	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)
                            endf
                            
    1              0.000001000 fu! ctrlp#j2l(nr)
                            	exe 'norm!' a:nr.'G'
                            	sil! norm! zvzz
                            endf
                            
    1              0.000001000 fu! s:maxf(len)
                            	retu s:maxfiles && a:len > s:maxfiles
                            endf
                            
    1              0.000001000 fu! s:regexfilter(str)
                            	let str = a:str
                            	for key in keys(s:fpats) | if str =~ key
                            		let str = substitute(str, s:fpats[key], '', 'g')
                            	en | endfo
                            	retu str
                            endf
                            
    1              0.000002000 fu! s:walker(m, p, d)
                            	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m
                            endf
                            
    1              0.000001000 fu! s:delent(rfunc)
                            	if a:rfunc == '' | retu | en
                            	let [s:force, tbrem] = [1, []]
                            	if exists('s:marked')
                            		let tbrem = values(s:marked)
                            		cal s:unmarksigns()
                            		unl s:marked
                            	en
                            	if tbrem == [] && ( has('dialog_gui') || has('dialog_con') ) &&
                            		\ confirm("Wipe all entries?", "&OK\n&Cancel") != 1
                            		unl s:force
                            		cal s:BuildPrompt(0)
                            		retu
                            	en
                            	let g:ctrlp_lines = call(a:rfunc, [tbrem])
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            " Entering & Exiting {{{2
    1              0.000002000 fu! s:getenv()
                            	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
                            	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
                            	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
                            	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
                            	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
                            	let s:crfile = bufname('%') == ''
                            		\ ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
                            	let s:crfpath = expand('%:p:h', 1)
                            	let s:mrbs = ctrlp#mrufiles#bufs()
                            endf
                            
    1              0.000001000 fu! s:lastvisual()
                            	let cview = winsaveview()
                            	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
                            	let [oureg, outype] = [getreg('"'), getregtype('"')]
                            	sil! norm! gv"vy
                            	let selected = s:regisfilter('v')
                            	cal setreg('v', ovreg, ovtype)
                            	cal setreg('"', oureg, outype)
                            	cal winrestview(cview)
                            	retu selected
                            endf
                            
    1              0.000002000 fu! s:log(m)
                            	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
                            	en | en
                            endf
                            
    1              0.000001000 fu! s:buffunc(e)
                            	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
                            	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
                            	en
                            endf
                            
    1              0.000003000 fu! s:openfile(cmd, fid, tail, chkmod, ...)
                            	let cmd = a:cmd
                            	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
                            		let cmd = cmd == 'b' ? 'sb' : 'sp'
                            	en
                            	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
                            	let j2l = a:0 && a:1[0] ? a:1[1] : 0
                            	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
                            	if j2l
                            		cal ctrlp#j2l(j2l)
                            	en
                            	if !empty(a:tail)
                            		sil! norm! zvzz
                            	en
                            	if cmd != 'bad'
                            		cal ctrlp#setlcdir()
                            	en
                            endf
                            
    1              0.000001000 fu! ctrlp#tabcount()
                            	if exists('s:tabct')
                            		let tabct = s:tabct
                            		let s:tabct += 1
                            	elsei !type(s:tabpage)
                            		let tabct = s:tabpage
                            	elsei type(s:tabpage) == 1
                            		let tabpos =
                            			\ s:tabpage =~ 'c' ? tabpagenr() :
                            			\ s:tabpage =~ 'f' ? 1 :
                            			\ s:tabpage =~ 'l' ? tabpagenr('$') :
                            			\ tabpagenr()
                            		let tabct =
                            			\ s:tabpage =~ 'a' ? tabpos :
                            			\ s:tabpage =~ 'b' ? tabpos - 1 :
                            			\ tabpos
                            	en
                            	retu tabct < 0 ? 0 : tabct
                            endf
                            
    1              0.000002000 fu! s:settype(type)
                            	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type
                            endf
                            " Matching {{{2
    1              0.000003000 fu! s:matchfname(item, pat)
                            	let parts = split(a:item, '[\/]\ze[^\/]\+$')
                            	let mfn = match(parts[-1], a:pat[0])
                            	retu len(a:pat) == 1 ? mfn : len(a:pat) == 2 ?
                            		\ ( mfn >= 0 && ( len(parts) == 2 ? match(parts[0], a:pat[1]) : -1 ) >= 0
                            		\ ? 0 : -1 ) : -1
                            	en
                            endf
                            
    1              0.000002000 fu! s:matchtabs(item, pat)
                            	retu match(split(a:item, '\t\+')[0], a:pat)
                            endf
                            
    1              0.000001000 fu! s:matchtabe(item, pat)
                            	retu match(split(a:item, '\t\+[^\t]\+$')[0], a:pat)
                            endf
                            
    1              0.000001000 fu! s:buildpat(lst)
                            	let pat = a:lst[0]
                            	for item in range(1, len(a:lst) - 1)
                            		let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
                            	endfo
                            	retu pat
                            endf
                            
    1              0.000002000 fu! s:mfunc()
                            	let mfunc = 'match'
                            	if s:byfname()
                            		let mfunc = 's:matchfname'
                            	elsei s:itemtype > 2
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
                            	en
                            	retu mfunc
                            endf
                            
    1              0.000001000 fu! s:mmode()
                            	let matchmodes = {
                            		\ 'match': 'full-line',
                            		\ 's:matchfname': 'filename-only',
                            		\ 's:matchtabs': 'first-non-tab',
                            		\ 's:matchtabe': 'until-last-tab',
                            		\ }
                            	retu matchmodes[s:mfunc]
                            endf
                            " Cache {{{2
    1              0.000002000 fu! s:writecache(cafile)
                            	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
                            		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
                            		let g:ctrlp_newcache = 0
                            	en
                            endf
                            
    1              0.000001000 fu! s:nocache(...)
                            	if !s:caching
                            		retu 1
                            	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000002000 fu! s:insertcache(str)
                            	let [data, g:ctrlp_newcache, str] = [g:ctrlp_allfiles, 1, a:str]
                            	if data == [] || strlen(str) <= strlen(data[0])
                            		let pos = 0
                            	elsei strlen(str) >= strlen(data[-1])
                            		let pos = len(data) - 1
                            	el
                            		let pos = 0
                            		for each in data
                            			if strlen(each) > strlen(str) | brea | en
                            			let pos += 1
                            		endfo
                            	en
                            	cal insert(data, str, pos)
                            	cal s:writecache(ctrlp#utils#cachefile())
                            endf
                            " Extensions {{{2
    1              0.000001000 fu! s:mtype()
                            	retu s:itemtype > 2 ? s:getextvar('type') : 'path'
                            endf
                            
    1              0.000002000 fu! s:execextvar(key)
                            	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars),
                            			\ 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
                            	en
                            endf
                            
    1              0.000005000 fu! s:getextvar(key)
                            	if s:itemtype > 2
                            		let vars = g:ctrlp_ext_vars[s:itemtype - 3]
                            		retu has_key(vars, a:key) ? vars[a:key] : -1
                            	en
                            	retu -1
                            endf
                            
    1              0.000002000 fu! ctrlp#getcline()
                            	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
                            	retu !empty(s:lines) && !( offset && linenr <= offset )
                            		\ ? s:lines[linenr - 1 - offset] : ''
                            endf
                            
    1              0.000003000 fu! ctrlp#getmarkedlist()
                            	retu exists('s:marked') ? values(s:marked) : []
                            endf
                            
    1              0.000001000 fu! ctrlp#exit()
                            	cal s:PrtExit()
                            endf
                            
    1              0.000002000 fu! ctrlp#prtclear()
                            	cal s:PrtClear()
                            endf
                            
    1              0.000002000 fu! ctrlp#switchtype(id)
                            	cal s:ToggleType(a:id - s:itemtype)
                            endf
                            
    1              0.000002000 fu! ctrlp#nosy()
                            	retu !( has('syntax') && exists('g:syntax_on') )
                            endf
                            
    1              0.000002000 fu! ctrlp#hicheck(grp, defgrp)
                            	if !hlexists(a:grp)
                            		exe 'hi link' a:grp a:defgrp
                            	en
                            endf
                            
    1              0.000001000 fu! ctrlp#call(func, ...)
                            	retu call(a:func, a:000)
                            endf
                            
    1              0.000001000 fu! ctrlp#getvar(var)
                            	retu {a:var}
                            endf
                            "}}}1
                            " * Initialization {{{1
    1              0.000001000 fu! ctrlp#setlines(...)
                            	if a:0 | let s:itemtype = a:1 | en
                            	cal s:modevar()
                            	let types = ['ctrlp#files()', 'ctrlp#buffers()', 'ctrlp#mrufiles#list()']
                            	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
                            	en
                            	let g:ctrlp_lines = eval(types[s:itemtype])
                            endf
                            
    1              0.000001000 fu! ctrlp#init(type, ...)
                            	if exists('s:init') || s:iscmdwin() | retu | en
                            	let [s:ermsg, v:errmsg] = [v:errmsg, '']
                            	let [s:matches, s:init] = [1, 1]
                            	cal s:Reset(a:0 ? a:1 : {})
                            	noa cal s:Open()
                            	cal s:SetWD(a:0 ? a:1 : {})
                            	cal s:MapNorms()
                            	cal s:MapSpecs()
                            	cal ctrlp#syntax()
                            	cal ctrlp#setlines(s:settype(a:type))
                            	cal s:SetDefTxt()
                            	cal s:BuildPrompt(1)
                            	if s:keyloop | cal s:KeyLoop() | en
                            endf
                            " - Autocmds {{{1
    1              0.000004000 if has('autocmd')
    1              0.000003000 	aug CtrlPAug
    1              0.000065000 		au!
    1              0.000014000 		au BufEnter ControlP cal s:checkbuf()
    1              0.000008000 		au BufLeave ControlP noa cal s:Close()
    1              0.000006000 		au VimLeavePre * cal s:leavepre()
    1              0.000001000 	aug END
    1              0.000001000 en
                            
    1              0.000002000 fu! s:autocmds()
                            	if !has('autocmd') | retu | en
                            	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
                            	en
                            	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
                            	en
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/danbradbury/.vim/bundle/nerdtree/syntax/nerdtree.vim
Sourced 16 times
Total time:   0.008029000
 Self time:   0.008029000

count     total (s)      self (s)
   16              0.000092000 let s:tree_up_dir_line = '.. (up a dir)'
   16              0.000122000 syn match NERDTreeIgnore #\~#
   16              0.000129000 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
   16              0.000138000 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line .'#'
                            
                            "quickhelp syntax elements
   16              0.000088000 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
   16              0.000051000 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
   16              0.000054000 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
   16              0.000059000 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
   16              0.000046000 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
   16              0.000062000 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
   16              0.000181000 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
   16              0.000120000 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
   16              0.000065000 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
   16              0.000062000 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighting to conceal the delimiter around the file/dir name
   16              0.000066000 if has('conceal')
   16              0.000171000     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
   16              0.000129000     setlocal conceallevel=2 concealcursor=nvic
                            else
                                exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
                                hi! link NERDTreeNodeDelimiters Ignore
   16              0.000016000 endif
                            
                            "highlighting for directory nodes and file nodes
   16              0.000058000 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
   16              0.000046000 if g:NERDTreeDirArrowExpandable !=# ''
   16              0.000187000     exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
   16              0.000137000     exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
   16              0.000095000     let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
   16              0.000109000     exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
   16              0.000173000     exec 'syn match NERDTreeExecFile #^.*'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmarkName'
   16              0.000241000     exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmarkName,NERDTreeExecFile'
                            else
                                exec 'syn match NERDTreeDir #[^'.g:NERDTreeNodeDelimiter.']\{-}/\ze\($\|'.g:NERDTreeNodeDelimiter.'\)#'
                                exec 'syn match NERDTreeExecFile #[^'.g:NERDTreeNodeDelimiter.']\{-}'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmarkName'
                                exec 'syn match NERDTreeFile     #^.*'.g:NERDTreeNodeDelimiter.'.*[^\/]\($\|'.g:NERDTreeNodeDelimiter.'.*\)# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmarkName,NERDTreeExecFile'
   16              0.000015000 endif
                            
                            "highlighting for readonly files
   16              0.000227000 exec 'syn match NERDTreeRO #.*'.g:NERDTreeNodeDelimiter.'\zs.*\ze'.g:NERDTreeNodeDelimiter.'.*\['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmarkName,NERDTreeFile'
                            
   16              0.000196000 exec 'syn match NERDTreeFlags #\[[^\]]*\]\ze'.g:NERDTreeNodeDelimiter.'# containedin=NERDTreeFile,NERDTreeExecFile,NERDTreeLinkFile,NERDTreeRO,NERDTreeDir'
                            
   16              0.000054000 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
   16              0.000046000 syn match NERDTreeBookmarkName # {.*}#hs=s+2,he=e-1
                            
                            "highlighting for the bookmarks table
   16              0.000043000 syn match NERDTreeBookmarksLeader #^>#
   16              0.000096000 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
   16              0.000074000 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
   16              0.000088000 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
   16              0.000293000 hi def link NERDTreePart Special
   16              0.000121000 hi def link NERDTreePartFile Type
   16              0.000126000 hi def link NERDTreeExecFile Title
   16              0.000110000 hi def link NERDTreeDirSlash Identifier
                            
   16              0.000116000 hi def link NERDTreeBookmarksHeader statement
   16              0.000110000 hi def link NERDTreeBookmarksLeader ignore
   16              0.000107000 hi def link NERDTreeBookmarkName Identifier
   16              0.000110000 hi def link NERDTreeBookmark normal
                            
   16              0.000108000 hi def link NERDTreeHelp String
   16              0.000109000 hi def link NERDTreeHelpKey Identifier
   16              0.000109000 hi def link NERDTreeHelpCommand Identifier
   16              0.000108000 hi def link NERDTreeHelpTitle Macro
   16              0.000114000 hi def link NERDTreeToggleOn Question
   16              0.000112000 hi def link NERDTreeToggleOff WarningMsg
                            
   16              0.000108000 hi def link NERDTreeLinkTarget Type
   16              0.000107000 hi def link NERDTreeLinkFile Macro
   16              0.000104000 hi def link NERDTreeLinkDir Macro
                            
   16              0.000117000 hi def link NERDTreeDir Directory
   16              0.000114000 hi def link NERDTreeUp Directory
   16              0.000112000 hi def link NERDTreeFile Normal
   16              0.000107000 hi def link NERDTreeCWD Statement
   16              0.000113000 hi def link NERDTreeOpenable Directory
   16              0.000110000 hi def link NERDTreeClosable Directory
   16              0.000108000 hi def link NERDTreeIgnore ignore
   16              0.000105000 hi def link NERDTreeRO WarningMsg
   16              0.000104000 hi def link NERDTreeBookmark Statement
   16              0.000109000 hi def link NERDTreeFlags Number
                            
   16              0.000117000 hi def link NERDTreeCurrentNode Search
                            
   16              0.000093000 hi NERDTreeFile ctermbg=NONE guibg=NONE

SCRIPT  /private/var/folders/rp/2bl5wj4s4zj0pvsc1zlw7jk00000gn/T/vGV7g9c/136
Sourced 1 time
Total time:   0.015572000
 Self time:   0.015572000

count     total (s)      self (s)
Cannot open file!

SCRIPT  /private/var/folders/rp/2bl5wj4s4zj0pvsc1zlw7jk00000gn/T/vGV7g9c/138
Sourced 1 time
Total time:   0.019384000
 Self time:   0.019384000

count     total (s)      self (s)
Cannot open file!

SCRIPT  /Users/danbradbury/.vim/bundle/vader.vim/autoload/vader/helper.vim
Sourced 1 time
Total time:   0.000281000
 Self time:   0.000281000

count     total (s)      self (s)
    1              0.000015000 function! vader#helper#syntax_at(...)
                              syntax sync fromstart
                              if a:0 < 2
                                let l:pos = getpos('.')
                                let l:cur_lnum = pos[1]
                                let l:cur_col = pos[2]
                                if a:0 == 0
                                  let l:lnum = l:cur_lnum
                                  let l:col = l:cur_col
                                else
                                  let l:lnum = l:cur_lnum
                                  let l:col = a:1
                                endif
                              else
                                let l:lnum = a:1
                                let l:col = a:2
                              endif
                              call map(synstack(l:lnum, l:col), 'synIDattr(v:val, "name")')
                              return synIDattr(synID(l:lnum, l:col, 1), 'name')
                            endfunction
                            
    1              0.000003000 function! vader#helper#syntax_of(pattern, ...)
                              if a:0 < 1
                                let l:nth = 1
                              else
                                let l:nth = a:1
                              endif
                            
                              let l:pos_init = getpos('.')
                              call cursor(1, 1)
                              let found = search(a:pattern, 'cW')
                              while found != 0 && nth > 1
                                let found = search(a:pattern, 'W')
                                let nth -= 1
                              endwhile
                            
                              if found
                                let l:pos = getpos('.')
                                let l:output = vader#helper#syntax_at(l:pos[1], l:pos[2])
                              else
                                let l:output = ''
                              endif
                              call setpos('.', l:pos_init)
                              return l:output
                            endfunction

SCRIPT  /private/var/folders/rp/2bl5wj4s4zj0pvsc1zlw7jk00000gn/T/vGV7g9c/142
Sourced 1 time
Total time:   0.000560000
 Self time:   0.000560000

count     total (s)      self (s)
Cannot open file!

SCRIPT  /private/var/folders/rp/2bl5wj4s4zj0pvsc1zlw7jk00000gn/T/vGV7g9c/151
Sourced 1 time
Total time:   0.000401000
 Self time:   0.000401000

count     total (s)      self (s)
Cannot open file!

FUNCTION  <SNR>116_VimExitCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:114
Called 131 times
Total time:   0.129324000
 Self time:   0.003935000

count     total (s)      self (s)
  131   0.001198000   0.000608000     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
  131                 0.000283000     let l:info = get(s:job_map, l:job_id, {})
                                  
  131                 0.000125000     if empty(l:info)
                                          return
  131                 0.000047000     endif
                                  
  131                 0.000211000     let l:info.exit_code = a:exit_code
                                  
                                      " The program can exit before the data has finished being read.
  131                 0.000322000     if ch_status(job_getchannel(a:job)) is# 'closed'
  107                 0.000069000         try
  107                 0.000220000             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                                  " We have to remove the callback, so we don't call it twice.
  107   0.125713000   0.000914000                 call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
  107                 0.000034000             endif
  107                 0.000046000         finally
                                              " Automatically forget about the job after it's done.
  107                 0.000130000             if has_key(s:job_map, l:job_id)
  107                 0.000140000                 call remove(s:job_map, l:job_id)
  107                 0.000032000             endif
  107                 0.000036000         endtry
  131                 0.000040000     endif

FUNCTION  <SNR>167_opts()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:186
Called 2 times
Total time:   0.001256000
 Self time:   0.001096000

count     total (s)      self (s)
    2                 0.000009000 	unl! s:usrign s:usrcmd s:urprtmaps
   12                 0.000036000 	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
    3                 0.000009000 		let {each} = s:{each}
   12                 0.000011000 	en | endfo
   74                 0.000128000 	for [ke, va] in items(s:opts)
   72                 0.000431000 		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
   74                 0.000046000 	endfo
    2                 0.000003000 	unl va
   12                 0.000022000 	for [ke, va] in items(s:new_opts)
   10                 0.000082000 		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
   12                 0.000006000 	endfo
    2                 0.000001000 	unl va
    8                 0.000016000 	for [ke, va] in items(s:lc_opts)
    6                 0.000017000 		if exists(s:bpref.ke)
                                  			unl {va}
                                  			let {va} = {s:bpref.ke}
    6                 0.000004000 		en
    8                 0.000002000 	endfo
                                  	" Match window options
    2   0.000161000   0.000015000 	cal s:match_window_opts()
                                  	" One-time values
    2                 0.000004000 	if a:0 && a:1 != {}
                                  		unl va
                                  		for [ke, va] in items(a:1)
                                  			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                                  			if has_key(s:lc_opts, opke)
                                  				let sva = s:lc_opts[opke]
                                  				unl {sva}
                                  				let {sva} = va
                                  			en
                                  		endfo
    2                 0.000002000 	en
    8                 0.000018000 	for each in ['byfname', 'regexp'] | if exists(each)
    2                 0.000006000 		let s:{each} = {each}
    8                 0.000006000 	en | endfo
    2                 0.000009000 	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
    2                 0.000006000 	let s:maxdepth = min([s:maxdepth, 100])
    2                 0.000006000 	let s:glob = s:showhidden ? '.*\|*' : '*'
    2                 0.000011000 	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
    2   0.000028000   0.000014000 	let s:lash = ctrlp#utils#lash()
    2                 0.000002000 	if s:keyloop
                                  		let [s:lazy, s:glbs['imd']] = [0, 0]
    2                 0.000001000 	en
    2                 0.000002000 	if s:lazy
                                  		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
    2                 0.000001000 	en
                                  	" Extensions
    2                 0.000006000 	if !( exists('extensions') && extensions == s:extensions )
    1                 0.000002000 		for each in s:extensions
                                  			exe 'ru autoload/ctrlp/'.each.'.vim'
    1                 0.000001000 		endfo
    2                 0.000002000 	en
                                  	" Keymaps
    2                 0.000005000 	if type(s:urprtmaps) == 4
                                  		cal extend(s:prtmaps, s:urprtmaps)
    2                 0.000001000 	en

FUNCTION  <SNR>167_lash()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1496
Called 133 times
Total time:   0.000853000
 Self time:   0.000853000

count     total (s)      self (s)
  133                 0.000819000 	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''

FUNCTION  <SNR>167_getparent()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1555
Called 118 times
Total time:   0.002402000
 Self time:   0.002402000

count     total (s)      self (s)
  118                 0.001785000 	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
  118                 0.000333000 	if parent == '' || parent !~ '[\/]'
                                  		let parent .= s:lash
  118                 0.000059000 	en
  118                 0.000087000 	retu parent

FUNCTION  3()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:14
Called 125 times
Total time:   0.009636000
 Self time:   0.005911000

count     total (s)      self (s)
  125                 0.000238000     let l:prependWorkingDir = 0
                                  
  125   0.001281000   0.000400000     if nerdtree#runningWindows()
                                          let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
  125                 0.000074000     else
  125                 0.000444000         let l:prependWorkingDir = a:pathStr !~# '^/'
  125                 0.000093000     endif
                                  
  125                 0.000199000     let l:result = a:pathStr
                                  
  125                 0.000161000     if l:prependWorkingDir
  108                 0.001991000         let l:result = getcwd()
                                  
  108   0.001932000   0.000450000         if l:result[-1:] == nerdtree#slash()
                                              let l:result = l:result . a:pathStr
  108                 0.000068000         else
  108   0.001778000   0.000416000             let l:result = l:result . nerdtree#slash() . a:pathStr
  108                 0.000065000         endif
  125                 0.000080000     endif
                                  
  125                 0.000140000     return l:result

FUNCTION  <SNR>11_BMRemove()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:784
Called 40 times
Total time:   0.001795000
 Self time:   0.001795000

count     total (s)      self (s)
   40                 0.000085000   if s:bmenu_wait == 0
   40                 0.000049000     var bufnum = expand("<abuf>")
   40                 0.000095000     if s:bmenu_items->has_key(bufnum)
   35                 0.000021000       var menu_name = s:bmenu_items[bufnum]
   35                 0.001252000       exe 'silent! aun &Buffers.' .. menu_name
   35                 0.000030000       s:bmenu_count = s:bmenu_count - 1
   35                 0.000042000       unlet s:bmenu_items[bufnum]
   35                 0.000002000     endif
   40                 0.000003000   endif

FUNCTION  6()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:93
Called 10 times
Total time:   0.000077000
 Self time:   0.000077000

count     total (s)      self (s)
   10                 0.000053000     if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
                                          return a:line
   10                 0.000001000     else
   10                 0.000010000         return a:line . g:NERDTreeNodeDelimiter
                                      endif

FUNCTION  copilot_chat#StartChat()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat.vim:19
Called 2 times
Total time:   0.030595000
 Self time:   0.000000000

count     total (s)      self (s)
    2   0.014169000   0.000000000   OpenChat()
    2   0.000009000   0.000005000   _buffer.AppendMessage(message)
    2   0.016365000   0.000108000   api.AsyncRequest([{'content': message, 'role': 'user'}], [])

FUNCTION  dist#script#DetectFiletype()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/script.vim:10
Called 7 times
Total time:   0.002947000
 Self time:   0.000593000

count     total (s)      self (s)
    7                 0.000020000   var line1 = getline(1)
    7                 0.000014000   if line1[0] == '#' && line1[1] == '!'
                                      # File that starts with "#!".
                                      DetectFromHashBang(line1)
                                    else
                                      # File does not start with "#!".
    7   0.002359000   0.000005000     DetectFromText(line1)
    7                 0.000000000   endif

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:42
Called 78 times
Total time:   0.094365000
 Self time:   0.001847000

count     total (s)      self (s)
                                      " Unmark a file as being changed outside of Vim after we try to check it.
   78                 0.000383000     call setbufvar(a:buffer, 'ale_file_changed', 0)
                                  
   78   0.001930000   0.000567000     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
   78   0.091688000   0.000533000         call ale#Queue(0, 'lint_file', a:buffer)
   78                 0.000046000     endif

FUNCTION  <SNR>160_parse_vader()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/parser.vim:114
Called 5 times
Total time:   0.038623000
 Self time:   0.037117000

count     total (s)      self (s)
    5                 0.000015000   let label    = ''
    5                 0.000013000   let newlabel = ''
    5                 0.000010000   let buffer   = []
    5                 0.000011000   let cases    = []
    5                 0.000050000   let case     = { 'lnum': a:line1, 'comment': {}, 'pending': 0, 'raw': 0 }
                                  
    5                 0.000017000   if empty(a:lines)
                                      return []
    5                 0.000005000   endif
                                  
   90                 0.000248000   for [fn, lnum, line] in a:lines
                                      " Comment / separators
   85                 0.000565000     if !case.raw && line =~ '^[#"=~*^-]'
                                        continue
   85                 0.000068000     endif
                                  
   85                 0.000156000     let matched = 0
  660                 0.001092000     for l in ['Before', 'After', 'Given', 'Execute', 'Expect', 'Do', 'Then']
  580                 0.007653000       let m = matchlist(line, '^'.l.'\%(\s\+\([^:;(]\+\)\)\?\s*\%((\(.*\))\)\?\s*\([:;]\)\s*$')
  580                 0.001339000       if !empty(m)
    5                 0.000043000         let newlabel = tolower(l)
    5   0.000809000   0.000114000         call s:flush_buffer(cases, case, fn, lnum, m[3] == ';', label, newlabel, buffer, 0)
                                  
    5                 0.000014000         let label   = newlabel
    5                 0.000020000         let arg     = m[1]
    5                 0.000017000         let comment = m[2]
    5                 0.000017000         if !empty(arg)
                                            if     l == 'Given'   | let case.type    = arg
                                            elseif l == 'Execute' | let case.lang_if = arg
                                            end
    5                 0.000013000         elseif l == 'Given'
                                            let case.type = ''
    5                 0.000006000         endif
    5                 0.000015000         if !empty(comment)
                                            let case.comment[tolower(l)] = comment
                                            if index(['do', 'execute'], label) >= 0 && comment =~# '\<TODO\>\|\<FIXME\>'
                                              let case.pending = 1
                                            endif
    5                 0.000004000         endif
    5                 0.000012000         let matched = 1
    5                 0.000021000         break
  575                 0.000411000       endif
  660                 0.000574000     endfor
  165                 0.000194000     if matched | continue | endif
                                  
                                      " Continuation
   80                 0.000565000     if !empty(line) && !case.raw && line !~ '^  '
                                        throw 'Syntax error (line does not start with two spaces): ' . line
   80                 0.000061000     endif
   80                 0.000175000     if !empty(label)
   80                 0.000237000       call add(buffer, line)
   80                 0.000066000     endif
   85                 0.000078000   endfor
    5   0.000888000   0.000077000   call s:flush_buffer(cases, case, fn, lnum, case.raw, label, '', buffer, 1)
                                  
    5                 0.000008000   let ret = []
    5                 0.000013000   let prev = {}
   10                 0.000018000   for case in cases
    5                 0.000023000     if has_key(case, "do") || has_key(case, "execute")
    5                 0.000022000       call add(ret, extend(prev, case))
    5                 0.000009000       let prev = {}
                                      else
                                        let prev = case
    5                 0.000003000     endif
   10                 0.000009000   endfor
    5                 0.000015000   return ret

FUNCTION  <SNR>122_process_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:297
Called 9 times
Total time:   0.000237000
 Self time:   0.000237000

count     total (s)      self (s)
    9                 0.000013000   let offset = 0
   42                 0.000031000   while offset < a:to_count
   33                 0.000036000     let line_number = a:to_line + offset
   33                 0.000059000     call add(a:modifications, [line_number, 'added'])
   33                 0.000029000     let offset += 1
   42                 0.000018000   endwhile

FUNCTION  ale#job#IsRunning()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:324
Called 24 times
Total time:   0.000328000
 Self time:   0.000328000

count     total (s)      self (s)
   24                 0.000060000     if has('nvim')
                                          try
                                              " In NeoVim, if the job isn't running, jobpid() will throw.
                                              call jobpid(a:job_id)
                                  
                                              return 1
                                          catch
                                          endtry
   24                 0.000057000     elseif has_key(s:job_map, a:job_id)
                                          let l:job = s:job_map[a:job_id].job
                                  
                                          return job_status(l:job) is# 'run'
   24                 0.000008000     endif
                                  
   24                 0.000012000     return 0

FUNCTION  <SNR>118_setup_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:169
Called 187 times
Total time:   0.022680000
 Self time:   0.001730000

count     total (s)      self (s)
  187   0.008502000   0.001385000   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                                  
    8   0.013936000   0.000103000   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  copilot_chat#api#Http()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/api.vim:154
Called 6 times
Total time:   3.053036000
 Self time:   3.053036000

count     total (s)      self (s)
    6                 0.000004000   var response = ''
    6                 0.000001000   if has('win32')
                                      var ps_cmd = 'powershell -Command "'
                                      ps_cmd ..= '$headers = @{'
                                      for header in headers
                                        var parts = split(header, ': ')
                                        var key = parts[0]
                                        var value = parts[1]
                                        ps_cmd ..= "'" .. key .. "'='" .. value .. "';"
                                      endfor
                                      ps_cmd ..= '};'
                                      if method !=# 'GET'
                                        ps_cmd ..= '$body = ConvertTo-Json @{'
                                        for obj in keys(body)
                                          ps_cmd ..= obj .. "='" .. body[obj] .. "';"
                                        endfor
                                        ps_cmd ..= '};'
                                      endif
                                      ps_cmd ..= "Invoke-WebRequest -Uri '" .. url .. "' -Method " .. method .. " -Headers $headers -Body $body -ContentType 'application/json' | Select-Object -ExpandProperty Content"
                                      ps_cmd ..= '"'
                                      response = system(ps_cmd)
    6                 0.000001000   else
    6                 0.000012000     var token_data = json_encode(body)
                                  
    6                 0.000006000     var curl_cmd = 'curl -s -X ' .. method .. ' --compressed '
    6                 0.000003000     for header in headers
   18                 0.000035000       curl_cmd ..= '-H "' .. header .. '" '
   18                 0.000002000     endfor
    6                 0.000013000     curl_cmd ..= "-d '" .. token_data .. "' " .. url
                                  
    6                 3.052811000     response = system(curl_cmd)
    6                 0.000051000     if v:shell_error != 0
                                        echom 'Error: ' .. v:shell_error
                                        return ''
                                      endif
    6                 0.000003000   endif
                                    return response

FUNCTION  <SNR>167_Render()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:531
Called 4 times
Total time:   0.012432000
 Self time:   0.000605000

count     total (s)      self (s)
    4   0.000033000   0.000029000 	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
    4                 0.000015000 	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
    4   0.000020000   0.000015000 	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
    4                 0.000009000 	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                                  	" Setup the match window
    4                 0.000062000 	sil! exe '%d _ | res' height
                                  	" Print the new items
    4                 0.000005000 	if empty(lines)
    2                 0.000005000 		let [s:matched, s:lines] = [[], []]
    2                 0.000002000 		let lines = [' == NO ENTRIES ==']
    2   0.000018000   0.000009000 		cal setline(1, s:offset(lines, height - 1))
    2                 0.000008000 		setl noma nocul
    2                 0.000011000 		exe cur_cmd
    2   0.000015000   0.000004000 		cal s:unmarksigns()
    2   0.000020000   0.000006000 		if s:dohighlight() | cal clearmatches() | en
    2                 0.000001000 		retu
    2                 0.000000000 	en
    2                 0.000007000 	let s:matched = copy(lines)
                                  	" Sorting
    2   0.000028000   0.000007000 	if !s:nosort()
    2                 0.000004000 		let s:compat = s:martcs.pat
    2   0.011217000   0.000126000 		cal sort(lines, 's:mixedsort')
    2                 0.000004000 		unl s:compat
    2                 0.000002000 	en
    2                 0.000011000 	if s:mw_order == 'btt' | cal reverse(lines) | en
    2                 0.000009000 	let s:lines = copy(lines)
    2   0.000602000   0.000055000 	cal map(lines, 's:formatline(v:val)')
    2   0.000065000   0.000049000 	cal setline(1, s:offset(lines, height))
    2   0.000025000   0.000021000 	setl noma cul
    2                 0.000038000 	exe cur_cmd
    2   0.000029000   0.000009000 	cal s:unmarksigns()
    2   0.000022000   0.000009000 	cal s:remarksigns()
    2                 0.000004000 	if exists('s:cline') && s:nolim != 1
                                  		cal cursor(s:cline, 1)
    2                 0.000001000 	en
                                  	" Highlighting
    2   0.000036000   0.000008000 	if s:dohighlight()
    2   0.000054000   0.000010000 		cal s:highlight(pat, s:mathi[1])
    2                 0.000000000 	en

FUNCTION  <SNR>40_ExecuteHighlight()
    Defined: ~/.vim/bundle/vim-poi/plugin/poi.vim:37
Called 75 times
Total time:   0.007904000
 Self time:   0.007904000

count     total (s)      self (s)
                                    "Deperately looking for any way to DRY this up..(figured it would be just like MakeBuff)
   75                 0.003972000   execute 'highlight poi1 ctermbg='.g:poi_bg1.' ctermfg='.g:poi_fg1.' guibg='g:g_poi_bg1.' guifg='.g:g_poi_fg1
   75                 0.001450000   execute 'highlight poi2 ctermbg='.g:poi_bg2.' ctermfg='.g:poi_fg2.' guibg='g:g_poi_bg2.' guifg='.g:g_poi_fg2
   75                 0.001163000   execute 'highlight poi3 ctermbg='.g:poi_bg3.' ctermfg='.g:poi_fg3.' guibg='g:g_poi_bg3.' guifg='.g:g_poi_fg3
   75                 0.001101000   execute 'highlight poi4 ctermbg='.g:poi_bg4.' ctermfg='.g:poi_fg4.' guibg='g:g_poi_bg4.' guifg='.g:g_poi_fg4

FUNCTION  <SNR>11_BMTruncName()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:932
Called 47 times
Total time:   0.006895000
 Self time:   0.006895000

count     total (s)      self (s)
   47                 0.000014000   var name = fname
   47                 0.000044000   if g:bmenu_max_pathlen < 5
                                      name = ""
                                    else
   47                 0.000018000     var len = strlen(name)
   47                 0.000022000     if len > g:bmenu_max_pathlen
   10                 0.000016000       var amountl = (g:bmenu_max_pathlen / 2) - 2
   10                 0.000001000       var amountr = g:bmenu_max_pathlen - amountl - 3
   10                 0.000028000       var pattern = '^\(.\{,' .. amountl .. '}\).\{-}\(.\{,' .. amountr .. '}\)$'
   10                 0.003432000       var left = substitute(name, pattern, '\1', '')
   10                 0.003211000       var right = substitute(name, pattern, '\2', '')
   10                 0.000008000       if strlen(left) + strlen(right) < len
   10                 0.000011000 	name = left .. '...' .. right
   10                 0.000001000       endif
   10                 0.000001000     endif
   47                 0.000001000   endif
                                    return name

FUNCTION  <SNR>76_filename()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 8 times
Total time:   0.000355000
 Self time:   0.000028000

count     total (s)      self (s)
    8   0.000354000   0.000027000   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>143_GetChatToken()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/auth.vim:19
Called 5 times
Total time:   0.487065000
 Self time:   0.012790000

count     total (s)      self (s)
    5                 0.001568000   if filereadable(chat_token_file) && fetch_new == false
                                      return join(readfile(chat_token_file), "\n")
                                    else
    1   0.001410000   0.001399000     config.CreateDataDir()
    1   0.000261000   0.000000000     var bearer_token = GetBearerToken()
    1                 0.000001000     var token_url = 'https://api.github.com/copilot_internal/v2/token'
    1                 0.000005000     var token_headers = [
                                        'Content-Type: application/json',
                                        'Editor-Version: vscode/1.80.1',
                                        $'Authorization: token {bearer_token}'
                                      ]
    1                 0.000002000     var token_data = {
                                        'client_id': 'Iv1.b507a08c87ecfe98',
                                        'scope': 'read:user'
                                      }
    1   0.474051000   0.000048000     var response = api.Http('GET', token_url, token_headers, token_data)
    1                 0.000084000     var json_response = json_decode(response)
    1                 0.000008000     try
    1                 0.000007000       var chat_token = json_response.token
    1                 0.009325000       writefile([chat_token], chat_token_file)
                                        return chat_token
                                      catch
                                        echom json_response.message
                                        return null
                                      endtry
                                    endif

FUNCTION  <SNR>80_map()
    Defined: ~/.vim/bundle/vim-dispatch/plugin/dispatch.vim:36
Called 20 times
Total time:   0.000777000
 Self time:   0.000777000

count     total (s)      self (s)
   20                 0.000054000   let flags = (a:0 ? a:1 : '') . (a:rhs =~# '^<Plug>' ? '' : '<script>')
   20                 0.000012000   let head = a:lhs
   20                 0.000010000   let tail = ''
   20                 0.000029000   let keys = get(g:, a:mode.'remap', {})
   20                 0.000024000   if type(keys) == type([])
                                      return
   20                 0.000005000   endif
   68                 0.000051000   while !empty(head)
   48                 0.000036000     if has_key(keys, head)
                                        let head = keys[head]
                                        if empty(head)
                                          return
                                        endif
                                        break
   48                 0.000015000     endif
   48                 0.000111000     let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
   48                 0.000108000     let head = substitute(head, '<[^<>]*>$\|.$', '', '')
   68                 0.000025000   endwhile
   20                 0.000085000   exe a:mode.'map' flags head.tail a:rhs

FUNCTION  gitgutter#utility#system()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:91
Called 1 time
Total time:   0.064030000
 Self time:   0.000669000

count     total (s)      self (s)
    1   0.000029000   0.000003000   call gitgutter#debug#log(a:cmd, a:000)
                                  
    1   0.000041000   0.000004000   call s:use_known_shell()
    1   0.063899000   0.000633000   silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    1   0.000058000   0.000026000   call s:restore_shell()
                                  
    1                 0.000001000   return output

FUNCTION  <SNR>167_MapNorms()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:853
Called 2 times
Total time:   0.001027000
 Self time:   0.001027000

count     total (s)      self (s)
    2                 0.000009000 	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
    1                 0.000011000 	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
    1                 0.000005000 	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
    1                 0.000001000 	let pfunc = 'PrtFocusMap'
    1                 0.000016000 	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
    4                 0.000004000 	for each in [34, 92, 124]
    3                 0.000036000 		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
    4                 0.000002000 	endfo
   93                 0.000074000 	for each in ranges
   92                 0.000641000 		exe printf(cmd, each, pfunc, nr2char(each))
   93                 0.000043000 	endfo
   11                 0.000010000 	for each in range(0, 9)
   10                 0.000080000 		exe printf(pcmd, each, pfunc, each)
   11                 0.000007000 	endfo
    6                 0.000010000 	for [ke, va] in items(s:kprange)
    5                 0.000036000 		exe printf(pcmd, ke, pfunc, va)
    6                 0.000005000 	endfo
    1                 0.000002000 	let s:nmapped = s:bufnr

FUNCTION  <SNR>77_get_background_colors()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:224
Called 1 time
Total time:   0.000064000
 Self time:   0.000011000

count     total (s)      self (s)
    1   0.000043000   0.000005000   let ctermbg = s:get_hl(a:group, 'bg', 'cterm')
    1   0.000020000   0.000005000   let guibg = s:get_hl(a:group, 'bg', 'gui')
    1                 0.000001000   return [guibg, ctermbg]

FUNCTION  <SNR>101_BlockStartKeyword()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:231
Called 64 times
Total time:   0.000090000
 Self time:   0.000090000

count     total (s)      self (s)
   64                 0.000065000     var kwd: string = line->matchstr('\l\+')
                                      return fullcommand(kwd, false)

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:376
Called 203 times
Total time:   0.126151000
 Self time:   0.061435000

count     total (s)      self (s)
  203                 0.001168000     let l:possibly_duplicated_linters = []
                                  
                                      " Handle dot-separated filetypes.
  406                 0.005244000     for l:original_filetype in split(a:original_filetypes, '\.')
  203   0.024824000   0.002116000         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
  203   0.012333000   0.001788000         let l:linter_names = s:GetLinterNames(l:original_filetype)
  203   0.033291000   0.001828000         let l:all_linters = ale#linter#GetAll(l:filetype)
  203                 0.000495000         let l:filetype_linters = []
                                  
  203                 0.001143000         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
   31                 0.000118000             let l:filetype_linters = l:all_linters
  172                 0.000642000         elseif type(l:linter_names) is v:t_list
                                              " Select only the linters we or the user has specified.
  860                 0.001636000             for l:linter in l:all_linters
  688                 0.004469000                 let l:name_list = [l:linter.name] + l:linter.aliases
                                  
 1214                 0.002198000                 for l:name in l:name_list
  693                 0.002784000                     if index(l:linter_names, l:name) >= 0
  167                 0.000909000                         call add(l:filetype_linters, l:linter)
  167                 0.000197000                         break
  526                 0.000491000                     endif
 1214                 0.001228000                 endfor
  860                 0.000835000             endfor
  203                 0.000882000         endif
                                  
  203                 0.000987000         call extend(l:possibly_duplicated_linters, l:filetype_linters)
  406                 0.000639000     endfor
                                  
  203                 0.000476000     let l:name_list = []
  203                 0.000500000     let l:combined_linters = []
                                  
                                      " Make sure we override linters so we don't get two with the same name,
                                      " like 'eslint' for both 'javascript' and 'typescript'
                                      "
                                      " Note that the reverse calls here modify the List variables.
  370                 0.001673000     for l:linter in reverse(l:possibly_duplicated_linters)
  167                 0.000718000         if index(l:name_list, l:linter.name) < 0
  167                 0.000625000             call add(l:name_list, l:linter.name)
  167                 0.000550000             call add(l:combined_linters, l:linter)
  167                 0.000167000         endif
  370                 0.000412000     endfor
                                  
  203                 0.000658000     return reverse(l:combined_linters)

FUNCTION  dist#script#Exe2filetype()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/script.vim:67
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      # Bourne-like shell scripts: bash bash2 dash ksh ksh93 sh
                                    if name =~ '^\(bash\d*\|dash\|ksh\d*\|sh\)\>'
                                      return dist#ft#SetFileTypeSH(line1, false)
                                  
                                      # csh scripts
                                    elseif name =~ '^csh\>'
                                      return dist#ft#SetFileTypeShell(exists("g:filetype_csh") ? g:filetype_csh : 'csh', false)
                                  
                                      # tcsh scripts
                                    elseif name =~ '^tcsh\>'
                                      return dist#ft#SetFileTypeShell("tcsh", false)
                                  
                                      # Z shell scripts
                                    elseif name =~ '^zsh\>'
                                      return 'zsh'
                                  
                                      # TCL scripts
                                    elseif name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                      return 'tcl'
                                  
                                      # Expect scripts
                                    elseif name =~ '^expect\>'
                                      return 'expect'
                                  
                                      # Gnuplot scripts
                                    elseif name =~ '^gnuplot\>'
                                      return 'gnuplot'
                                  
                                      # Makefiles
                                    elseif name =~ 'make\>'
                                      return 'make'
                                  
                                      # Pike
                                    elseif name =~ '^pike\%(\>\|[0-9]\)'
                                      return 'pike'
                                  
                                      # Lua
                                    elseif name =~ 'lua'
                                      return 'lua'
                                  
                                      # Perl
                                    elseif name =~ 'perl'
                                      return 'perl'
                                  
                                      # PHP
                                    elseif name =~ 'php'
                                      return 'php'
                                  
                                      # Python
                                    elseif name =~ 'python'
                                      return 'python'
                                  
                                      # Groovy
                                    elseif name =~ '^groovy\>'
                                      return 'groovy'
                                  
                                      # Raku
                                    elseif name =~ 'raku'
                                      return 'raku'
                                  
                                      # Ruby
                                    elseif name =~ 'ruby'
                                      return 'ruby'
                                  
                                      # JavaScript
                                    elseif name =~ 'node\(js\)\=\>\|js\>' || name =~ 'rhino\>'
                                      return 'javascript'
                                  
                                      # BC calculator
                                    elseif name =~ '^bc\>'
                                      return 'bc'
                                  
                                      # sed
                                    elseif name =~ 'sed\>'
                                      return 'sed'
                                  
                                      # OCaml-scripts
                                    elseif name =~ 'ocaml'
                                      return 'ocaml'
                                  
                                      # Awk scripts; also finds "gawk"
                                    elseif name =~ 'awk\>'
                                      return 'awk'
                                  
                                      # Website MetaLanguage
                                    elseif name =~ 'wml'
                                      return 'wml'
                                  
                                      # Scheme scripts
                                    elseif name =~ 'scheme'
                                      return 'scheme'
                                  
                                      # CFEngine scripts
                                    elseif name =~ 'cfengine'
                                      return 'cfengine'
                                  
                                      # Erlang scripts
                                    elseif name =~ 'escript'
                                      return 'erlang'
                                  
                                      # Haskell
                                    elseif name =~ 'haskell'
                                      return 'haskell'
                                  
                                      # Scala
                                    elseif name =~ 'scala\>'
                                      return 'scala'
                                  
                                      # Clojure
                                    elseif name =~ 'clojure'
                                      return 'clojure'
                                  
                                      # Free Pascal
                                    elseif name =~ 'instantfpc\>'
                                      return 'pascal'
                                  
                                      # Fennel
                                    elseif name =~ 'fennel\>'
                                      return 'fennel'
                                  
                                      # MikroTik RouterOS script
                                    elseif name =~ 'rsc\>'
                                      return 'routeros'
                                  
                                      # Fish shell
                                    elseif name =~ 'fish\>'
                                      return 'fish'
                                  
                                      # Gforth
                                    elseif name =~ 'gforth\>'
                                      return 'forth'
                                  
                                      # Icon
                                    elseif name =~ 'icon\>'
                                      return 'icon'
                                  
                                      # Guile
                                    elseif name =~ 'guile'
                                      return 'scheme'
                                  
                                      # Nix
                                    elseif name =~ 'nix-shell'
                                      return 'nix'
                                  
                                      # Crystal
                                    elseif name =~ '^crystal\>'
                                      return 'crystal'
                                  
                                      # Rexx
                                    elseif name =~ '^\%(rexx\|regina\)\>'
                                      return 'rexx'
                                  
                                      # Janet
                                    elseif name =~ '^janet\>'
                                      return 'janet'
                                  
                                      # Dart
                                    elseif name =~ '^dart\>'
                                      return 'dart'
                                  
                                      # Execline (s6)
                                    elseif name =~ '^execlineb\>'
                                      return 'execline'
                                  
                                      # Vim
                                    elseif name =~ '^vim\>'
                                      return 'vim'
                                  
                                    endif
                                  
                                    return ''

FUNCTION  <SNR>122_git_supports_command_line_config_override()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:8
Called 1 time
Total time:   0.064043000
 Self time:   0.000013000

count     total (s)      self (s)
    1   0.064040000   0.000010000   call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
    1                 0.000002000   return !v:shell_error

FUNCTION  <SNR>46_SplitCommands()
    Defined: ~/.vim/bundle/tabular/plugin/Tabular.vim:112
Called 9 times
Total time:   0.000991000
 Self time:   0.000369000

count     total (s)      self (s)
    9                 0.000015000   if a:string =~ '^\s*$'
                                      return []
    9                 0.000004000   endif
                                  
    9                 0.000021000   let end = match(a:string, "[\"'|]")
                                  
                                    " Loop until we find a delimiting | or end-of-string
   32                 0.000051000   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')
   23                 0.000020000     if a:string[end] == "'"
   21                 0.000034000       let end = match(a:string, "'", end+1) + 1
   21                 0.000013000       if end == 0
                                          throw "No matching end single quote"
   21                 0.000007000       endif
    2                 0.000002000     elseif a:string[end] == '"'
                                        " Find a " preceded by an even number of \ (or 0)
    2                 0.000002000       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'
    2                 0.000031000       let end = matchend(a:string, pattern, end+1) + 1
    2                 0.000001000       if end == 0
                                          throw "No matching end double quote"
    2                 0.000000000       endif
                                      else " Found ||
                                        let end += 2
   23                 0.000006000     endif
                                  
   23                 0.000036000     let end = match(a:string, "[\"'|]", end)
   32                 0.000008000   endwhile
                                  
    9                 0.000022000   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'
                                      throw "Empty element"
    9                 0.000002000   endif
                                  
    9                 0.000006000   if end == -1
    4                 0.000003000     let rv = [ a:string ]
    5                 0.000005000   else
    5                 0.000011000     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])
    9                 0.000003000   endif
                                  
    9                 0.000005000   return rv

FUNCTION  modes#color#ComputeBlendedColor()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes/color.vim:11
Called 92 times
Total time:   0.006516000
 Self time:   0.001744000

count     total (s)      self (s)
   92   0.004981000   0.000209000   var rgb_bg = GetNormalBgColor()
                                    # blend is 0-100
   92                 0.000100000   var alpha = blend / 100.0
   92                 0.000537000   var r = float2nr(str2nr(strpart(rgb_fg, 1, 2), 16) * alpha + str2nr(strpart(rgb_bg, 1, 2), 16) * (1 - alpha))
   92                 0.000139000   var g = float2nr(str2nr(strpart(rgb_fg, 3, 2), 16) * alpha + str2nr(strpart(rgb_bg, 3, 2), 16) * (1 - alpha))
   92                 0.000125000   var b = float2nr(str2nr(strpart(rgb_fg, 5, 2), 16) * alpha + str2nr(strpart(rgb_bg, 5, 2), 16) * (1 - alpha))
                                  
                                    return printf('#%02x%02x%02x', r, g, b)

FUNCTION  <SNR>11_BMHash()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:876
Called 47 times
Total time:   0.000689000
 Self time:   0.000689000

count     total (s)      self (s)
                                    # Make name all upper case, so that chars are between 32 and 96
   47                 0.000503000   var nm = substitute(name, ".*", '\U\0', "")
   47                 0.000001000   var sp: number
   47                 0.000005000   if has("ebcdic")
                                      # HACK: Replace all non alphabetics with 'Z'
                                      #       Just to make it work for now.
                                      nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                      sp = char2nr('A') - 1
   47                 0.000005000   else
   47                 0.000021000     sp = char2nr(' ')
   47                 0.000001000   endif
                                    # convert first six chars into a number for sorting:
                                    return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)

FUNCTION  <SNR>116_VimOutputCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:68
Called 108 times
Total time:   0.007259000
 Self time:   0.004331000

count     total (s)      self (s)
  108                 0.001467000     let l:job = ch_getjob(a:channel)
  108   0.002671000   0.001034000     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                                  
                                      " Only call the callbacks for jobs which are valid.
  108                 0.000470000     if l:job_id > 0 && has_key(s:job_map, l:job_id)
  108   0.002173000   0.000882000         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
  108                 0.000027000     endif

FUNCTION  nerdtree#runningCygwin()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:207
Called 1 time
Total time:   0.000001000
 Self time:   0.000001000

count     total (s)      self (s)
    1                 0.000001000     return has('win32unix')

FUNCTION  <SNR>34_WindowSplit()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:19
Called 3 times
Total time:   0.001180000
 Self time:   0.001171000

count     total (s)      self (s)
    3   0.000048000   0.000039000   var position: string = config.GetValue('window_position', 'right')
    3                 0.000021000   if exists('g:copilot_chat_window_position')
                                      position = g:copilot_chat_window_position
                                    endif
                                  
                                    # Create split based on position
    3                 0.000002000   if position ==# 'right'
    3                 0.001101000     rightbelow vsplit
    3                 0.000001000   elseif position ==# 'left'
                                      leftabove vsplit
                                    elseif position ==# 'top'
                                      topleft split
                                    elseif position ==# 'bottom'
                                      botright split
                                    endif

FUNCTION  <SNR>122_write_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:379
Called 93 times
Total time:   0.502379000
 Self time:   0.502379000

count     total (s)      self (s)
   93                 0.003432000   let bufcontents = getbufline(a:bufnr, 1, '$')
                                  
   93                 0.000404000   if bufcontents == [''] && line2byte(1) == -1
                                      " Special case: completely empty buffer.
                                      " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                      call writefile([], a:file)
                                      return
   93                 0.000068000   endif
                                  
   93                 0.000464000   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                      call map(bufcontents, 'v:val."\r"')
   93                 0.000053000   endif
                                  
   93                 0.000388000   if getbufvar(a:bufnr, '&endofline')
   93                 0.000354000     call add(bufcontents, '')
   93                 0.000061000   endif
                                  
   93                 0.000310000   let fenc = getbufvar(a:bufnr, '&fileencoding')
   93                 0.000353000   if fenc !=# &encoding
                                      call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
   93                 0.000078000   endif
                                  
   93                 0.000295000   if getbufvar(a:bufnr, '&bomb')
                                      let bufcontents[0]='﻿'.bufcontents[0]
   93                 0.000065000   endif
                                  
                                    " The file we are writing to is a temporary file.  Sometimes the parent
                                    " directory is deleted outside Vim but, because Vim caches the directory
                                    " name at startup and does not check for its existence subsequently, Vim
                                    " does not realise.  This causes E482 errors.
   93                 0.000109000   try
   93                 0.490846000     call writefile(bufcontents, a:file, 'b')
                                    catch /E482/
                                      call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                      call writefile(bufcontents, a:file, 'b')
   93                 0.000219000   endtry

FUNCTION  vader#assert#reset()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/assert.vim:37
Called 5 times
Total time:   0.000076000
 Self time:   0.000076000

count     total (s)      self (s)
    5                 0.000054000   let s:assertions = [0, 0]

FUNCTION  modes#color#ComputeBlendedColorCterm()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes/color.vim:71
Called 39 times
Total time:   0.002758000
 Self time:   0.000591000

count     total (s)      self (s)
   39   0.001343000   0.000137000   var cterm_fg = GetNormalBgColorCterm()
                                    # blend is 0-100
                                    # Convert cterm colors to RGB, blend, then convert back to nearest cterm color
   39                 0.000023000   var alpha = blend / 100.0
                                  
                                    # Get RGB values for cterm colors
   39   0.000575000   0.000127000   var rgb_fg = CtermToRGB(cterm_fg)
   39   0.000150000   0.000029000   var rgb_bg = CtermToRGB(cterm_bg)
                                  
                                    # Blend the RGB values
   39                 0.000052000   var r = float2nr(rgb_fg[0] * alpha + rgb_bg[0] * (1 - alpha))
   39                 0.000035000   var g = float2nr(rgb_fg[1] * alpha + rgb_bg[1] * (1 - alpha))
   39                 0.000027000   var b = float2nr(rgb_fg[2] * alpha + rgb_bg[2] * (1 - alpha))
                                  
                                    # Find nearest cterm color
                                    return RGBToCterm(r, g, b)

FUNCTION  <SNR>46_ParsePattern()
    Defined: ~/.vim/bundle/tabular/plugin/Tabular.vim:94
Called 6 times
Total time:   0.000389000
 Self time:   0.000231000

count     total (s)      self (s)
    6                 0.000007000   if a:string[0] != '/'
                                      return ['','']
    6                 0.000002000   endif
                                  
    6   0.000293000   0.000135000   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'
    6                 0.000043000   let format = matchstr(a:string[1:-1], pat)
    6                 0.000004000   if !empty(format)
    6                 0.000007000     let format = format[1 : -1]
    6                 0.000009000     let pattern = a:string[1 : -len(format) - 2]
                                    else
                                      let pattern = a:string[1 : -1]
    6                 0.000003000   endif
                                  
    6                 0.000006000   return [pattern, format]

FUNCTION  <SNR>167_comptime()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1277
Called 58 times
Total time:   0.000681000
 Self time:   0.000681000

count     total (s)      self (s)
                                  	" By last modified time
   58                 0.000508000 	let [time1, time2] = [getftime(a:1), getftime(a:2)]
   58                 0.000119000 	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1

FUNCTION  gitgutter#highlight#define_signs()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:124
Called 1 time
Total time:   0.000058000
 Self time:   0.000021000

count     total (s)      self (s)
    1                 0.000002000   sign define GitGutterLineAdded
    1                 0.000000000   sign define GitGutterLineModified
    1                 0.000001000   sign define GitGutterLineRemoved
    1                 0.000000000   sign define GitGutterLineRemovedFirstLine
    1                 0.000001000   sign define GitGutterLineRemovedAboveAndBelow
    1                 0.000000000   sign define GitGutterLineModifiedRemoved
                                  
    1   0.000017000   0.000004000   call s:define_sign_text()
    1   0.000013000   0.000004000   call gitgutter#highlight#define_sign_text_highlights()
    1   0.000011000   0.000004000   call s:define_sign_line_highlights()
    1   0.000013000   0.000005000   call s:define_sign_linenr_highlights()

FUNCTION  NERDTreeAddKeyMap()
    Defined: ~/.vim/bundle/nerdtree/plugin/NERD_tree.vim:189
Called 57 times
Total time:   0.001007000
 Self time:   0.000083000

count     total (s)      self (s)
   57   0.000997000   0.000073000     call g:NERDTreeKeyMap.Create(a:options)

FUNCTION  5()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:47
Called 78 times
Total time:   0.003981000
 Self time:   0.003062000

count     total (s)      self (s)
   78   0.000724000   0.000209000     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                                  
   78                 0.000057000     if self.isExecutable
   10   0.000101000   0.000024000         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
   78                 0.000032000     endif
                                  
   78                 0.000074000     let self._bookmarkNames = []
   78   0.000421000   0.000138000     for i in g:NERDTreeBookmark.Bookmarks()
                                          if i.path.equals(self)
                                              call add(self._bookmarkNames, i.name)
                                          endif
   78                 0.000039000     endfor
   78                 0.000105000     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
   78                 0.000030000     endif
                                  
   78                 0.000049000     if self.isSymLink
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
   78                 0.000024000     endif
                                  
   78   0.000179000   0.000135000     if !self.isDirectory && b:NERDTree.ui.getShowFileLines() != 0
                                          let l:bufname = self.str({'format': 'Edit'})
                                          let l:lines = 0
                                          if executable('wc') 
                                              let l:lines = split(system('wc -l "'.l:bufname.'"'))[0]
                                          elseif nerdtree#runningWindows()
                                              let l:lines = substitute(system('type "'.l:bufname.'" | find /c /v ""'), '\n', '', 'g')
                                          else 
                                              let s:lines = readfile(l:bufname)
                                              let l:lines = 0
                                              for s:line in s:lines
                                                  let l:lines += 1
                                                  if l:lines >= 20000 
                                                      break
                                                  endif
                                              endfor
                                          endif
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ('.l:lines.')'
   78                 0.000022000     endif
   78                 0.000064000     if self.isReadOnly
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
   78                 0.000027000     endif

FUNCTION  <SNR>118_clear()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:183
Called 13 times
Total time:   0.001241000
 Self time:   0.000212000

count     total (s)      self (s)
   13   0.000185000   0.000065000   call gitgutter#sign#clear_signs(a:bufnr)
   13   0.000581000   0.000048000   call gitgutter#hunk#reset(a:bufnr)
   13   0.000267000   0.000045000   call s:reset_tick(a:bufnr)
   13   0.000190000   0.000036000   call gitgutter#utility#setbufvar(a:bufnr, 'path', '')

FUNCTION  <SNR>49_init_var()
    Defined: ~/.vim/bundle/tagbar/plugin/tagbar.vim:45
Called 65 times
Total time:   0.000242000
 Self time:   0.000242000

count     total (s)      self (s)
   65                 0.000068000     if !exists('g:tagbar_' . a:var)
   65                 0.000146000         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)
   65                 0.000020000     endif

FUNCTION  ale#events#QuitRecently()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:19
Called 42 times
Total time:   0.000545000
 Self time:   0.000545000

count     total (s)      self (s)
   42                 0.000296000     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                                  
   42                 0.000153000     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>167_getextvar()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2191
Called 4 times
Total time:   0.000030000
 Self time:   0.000030000

count     total (s)      self (s)
    4                 0.000004000 	if s:itemtype > 2
                                  		let vars = g:ctrlp_ext_vars[s:itemtype - 3]
                                  		retu has_key(vars, a:key) ? vars[a:key] : -1
    4                 0.000003000 	en
    4                 0.000004000 	retu -1

FUNCTION  <SNR>108_GetLinterNames()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:339
Called 203 times
Total time:   0.010545000
 Self time:   0.010545000

count     total (s)      self (s)
  203                 0.001282000     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                                  
                                      " b:ale_linters can be set to 'all'
  203                 0.000562000     if l:buffer_ale_linters is# 'all'
                                          return 'all'
  203                 0.000204000     endif
                                  
                                      " b:ale_linters can be set to a List.
  203                 0.000786000     if type(l:buffer_ale_linters) is v:t_list
                                          return l:buffer_ale_linters
  203                 0.000207000     endif
                                  
                                      " Try to get a buffer-local setting for the filetype
  203                 0.000916000     if has_key(l:buffer_ale_linters, a:original_filetype)
                                          return l:buffer_ale_linters[a:original_filetype]
  203                 0.000165000     endif
                                  
                                      " Try to get a global setting for the filetype
  203                 0.001180000     if has_key(g:ale_linters, a:original_filetype)
  131                 0.000431000         return g:ale_linters[a:original_filetype]
   72                 0.000072000     endif
                                  
                                      " If the user has configured ALE to only enable linters explicitly, then
                                      " don't enable any linters by default.
   72                 0.000241000     if g:ale_linters_explicit
                                          return []
   72                 0.000069000     endif
                                  
                                      " Try to get a default setting for the filetype
   72                 0.000494000     if has_key(s:default_ale_linters, a:original_filetype)
   41                 0.000171000         return s:default_ale_linters[a:original_filetype]
   31                 0.000032000     endif
                                  
   31                 0.000050000     return 'all'

FUNCTION  <SNR>76_exists_file()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:240
Called 206 times
Total time:   0.045139000
 Self time:   0.010108000

count     total (s)      self (s)
  206   0.044928000   0.009897000   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  nerdtree#onBufLeave()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:239
Called 32 times
Total time:   0.017934000
 Self time:   0.001634000

count     total (s)      self (s)
                                      " detect whether we are in the middle of sourcing a session.
                                      " if it is a buffer from the sourced session we need to restore it.
   32                 0.000144000     if exists('g:SessionLoad') && !exists('b:NERDTree')
                                          let bname = bufname('%')
                                          " is the buffer for a tab tree?
                                          if bname =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'tab_\d\+$'
                                              " rename loaded buffer and mark it as trash to prevent this event
                                              " getting fired again
                                              exec 'file TRASH_' . bname
                                              " delete the trash buffer
                                              exec 'bwipeout!'
                                              " rescue the tab tree at the current working directory
                                              call g:NERDTreeCreator.CreateTabTree(getcwd())
                                          " is the buffer for a window tree?
                                          elseif bname =~# '^' . g:NERDTreeCreator.BufNamePrefix(). 'win_\d\+$'
                                              " rescue the window tree at the current working directory
                                              call g:NERDTreeCreator.CreateWindowTree(getcwd())
                                          else " unknown buffer type
                                              " rename buffer to mark it as broken.
                                              exec 'file BROKEN_' . bname
                                              call nerdtree#echoError('Failed to restore "' . bname . '" from session. Is this session created with an older version of NERDTree?')
                                          endif
   32                 0.000030000     else
   32   0.004562000   0.000135000         if g:NERDTree.IsOpen()
   32   0.012060000   0.000187000             call b:NERDTree.ui.saveScreenState()
   32                 0.000027000         endif
   32                 0.000023000     endif

FUNCTION  <SNR>101_RegisterCacheInvalidation()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:841
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      # invalidate the cache so that it's not used for the next `=` normal command
                                      autocmd_add([{
                                          cmd: 'unlet! b:vimindent',
                                          event: 'ModeChanged',
                                          group: '__VimIndent__',
                                          once: true,
                                          pattern: '*:n',
                                          replace: true,
                                      }])

FUNCTION  <SNR>167_regisfilter()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1895
Called 2 times
Total time:   0.000046000
 Self time:   0.000046000

count     total (s)      self (s)
    2                 0.000044000 	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')

FUNCTION  <SNR>125_BuildSignMap()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:307
Called 143 times
Total time:   0.009460000
 Self time:   0.007519000

count     total (s)      self (s)
  143   0.001567000   0.000397000     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                                  
  143                 0.000153000     if l:max_signs is 0
                                          let l:selected_grouped_items = []
  143                 0.000338000     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                          let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
  143                 0.000066000     else
  143                 0.000226000         let l:selected_grouped_items = a:grouped_items
  143                 0.000062000     endif
                                  
  143                 0.000150000     let l:sign_map = {}
  143                 0.000196000     let l:sign_offset = g:ale_sign_offset
                                  
  154                 0.000202000     for [l:line, l:sign_id, l:name] in a:current_sign_list
   11                 0.000038000         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                                  
                                          " Increment the sign offset for new signs, by the maximum sign ID.
   11                 0.000008000         if l:sign_id > l:sign_offset
   11                 0.000007000             let l:sign_offset = l:sign_id
   11                 0.000005000         endif
                                  
                                          " Remember the sign names and IDs in separate Lists, so they are easy
                                          " to work with.
   11                 0.000013000         call add(l:sign_info.current_id_list, l:sign_id)
   11                 0.000013000         call add(l:sign_info.current_name_list, l:name)
                                  
   11                 0.000012000         let l:sign_map[l:line] = l:sign_info
  154                 0.000122000     endfor
                                  
  179                 0.000197000     for l:group in l:selected_grouped_items
   36                 0.000032000         let l:line = l:group[0].lnum
   36                 0.000121000         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                                  
   36   0.000847000   0.000076000         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
   36                 0.000027000         let l:sign_info.items = l:group
                                  
   36                 0.000049000         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                                  
   36                 0.000021000         if l:index >= 0
                                              " We have a sign with this name already, so use the same ID.
    6                 0.000009000             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
   30                 0.000010000         else
                                              " This sign name replaces the previous name, so use a new ID.
   30                 0.000027000             let l:sign_info.new_id = l:sign_offset + 1
   30                 0.000022000             let l:sign_offset += 1
   36                 0.000011000         endif
                                  
   36                 0.000041000         let l:sign_map[l:line] = l:sign_info
  179                 0.000138000     endfor
                                  
  143                 0.000122000     return l:sign_map

FUNCTION  <SNR>167_offset()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1455
Called 4 times
Total time:   0.000025000
 Self time:   0.000025000

count     total (s)      self (s)
    4                 0.000010000 	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
    4                 0.000011000 	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines

FUNCTION  <SNR>48_savetofile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:84
Called 11 times
Total time:   0.088030000
 Self time:   0.000107000

count     total (s)      self (s)
   11   0.088019000   0.000096000 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>101_Unshorten()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:227
Called 62 times
Total time:   0.000106000
 Self time:   0.000031000

count     total (s)      self (s)
                                      return BlockStartKeyword(kwd)

FUNCTION  <lambda>11()
    Defined: ~/.vim/bundle/ale/ale_linters/vim/vimls.vim:51
Called 36 times
Total time:   0.017768000
 Self time:   0.000355000

count     total (s)      self (s)
                                  return ale#path#FindExecutable(b, 'vim_vimls', [       'node_modules/.bin/vim-language-server',   ])

FUNCTION  <SNR>167_ignore()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:10
Called 1 time
Total time:   0.000035000
 Self time:   0.000035000

count     total (s)      self (s)
    1                 0.000011000 	let igdirs = [ '\.git', '\.hg', '\.svn', '_darcs', '\.bzr', '\.cdv', '\~\.dep', '\~\.dot', '\~\.nib', '\~\.plst', '\.pc', '_MTN', 'blib', 'CVS', 'RCS', 'SCCS', '_sgbak', 'autom4te\.cache', 'cover_db', '_build', ]
    1                 0.000005000 	let igfiles = [ '\~$', '#.+#$', '[._].*\.swp$', 'core\.\d+$', '\.exe$', '\.so$', '\.bak$', '\.png$', '\.jpg$', '\.gif$', '\.zip$', '\.rar$', '\.tar\.gz$', ]
    1                 0.000016000 	retu { 'dir': '\v[\/]('.join(igdirs, '|').')$', 'file': '\v'.join(igfiles, '|'), }

FUNCTION  ctrlp#utils#writecache()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:63
Called 14 times
Total time:   0.111462000
 Self time:   0.111169000

count     total (s)      self (s)
   14   0.000402000   0.000140000 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
   14   0.110987000   0.110956000 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
   14                 0.000050000 	en

FUNCTION  ctrlp#mrufiles#opts()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:10
Called 1 time
Total time:   0.000046000
 Self time:   0.000046000

count     total (s)      self (s)
    1                 0.000005000 	let [pref, opts] = ['g:ctrlp_mruf_', { 'max': ['s:max', 250], 'include': ['s:in', ''], 'exclude': ['s:ex', ''], 'case_sensitive': ['s:cseno', 1], 'relative': ['s:re', 0], 'save_on_update': ['s:soup', 1], }]
    7                 0.000006000 	for [ke, va] in items(opts)
    6                 0.000028000 		let [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
    7                 0.000003000 	endfo

FUNCTION  <SNR>101_SearchPairEnd()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:997
Called 1 time
Total time:   0.001399000
 Self time:   0.000002000

count     total (s)      self (s)
                                      return SearchPair(start, middle, end, 'nW', stopline)

FUNCTION  ctrlp#nosy()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2221
Called 6 times
Total time:   0.000037000
 Self time:   0.000037000

count     total (s)      self (s)
    6                 0.000033000 	retu !( has('syntax') && exists('g:syntax_on') )

FUNCTION  test#get_runners()
    Defined: ~/.vim/bundle/vim-test/autoload/test.vim:133
Called 1 time
Total time:   0.000097000
 Self time:   0.000013000

count     total (s)      self (s)
    1                 0.000002000   if exists('g:test#runners')
                                      let custom_runners = g:test#runners
    1                 0.000002000   elseif exists('g:test#custom_runners')
                                      let custom_runners = g:test#custom_runners
    1                 0.000000000   else
    1                 0.000002000     let custom_runners = {}
    1                 0.000000000   endif
                                  
    1   0.000089000   0.000005000   return s:extend(custom_runners, g:test#default_runners)

FUNCTION  <SNR>68_customOpenFile()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:92
Called 4 times
Total time:   0.194915000
 Self time:   0.000088000

count     total (s)      self (s)
    4   0.194895000   0.000068000     call a:node.activate(s:initCustomOpenArgs().file)

FUNCTION  <SNR>77_get_foreground_colors()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:218
Called 12 times
Total time:   0.000190000
 Self time:   0.000052000

count     total (s)      self (s)
   12   0.000105000   0.000023000   let ctermfg = s:get_hl(a:group, 'fg', 'cterm')
   12   0.000077000   0.000021000   let guifg = s:get_hl(a:group, 'fg', 'gui')
   12                 0.000008000   return [guifg, ctermfg]

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:250
Called 143 times
Total time:   0.004272000
 Self time:   0.000934000

count     total (s)      self (s)
  143                 0.000348000     if exists('*sign_getplaced')
  143   0.003805000   0.000467000         return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                      else
                                          let l:line_list = ale#sign#ReadSigns(a:buffer)
                                  
                                          return ale#sign#ParseSigns(l:line_list)
                                      endif

FUNCTION  <SNR>122_is_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 211 times
Total time:   0.000385000
 Self time:   0.000385000

count     total (s)      self (s)
  211                 0.000342000   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>167_buildpat()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2111
Called 2 times
Total time:   0.000013000
 Self time:   0.000013000

count     total (s)      self (s)
    2                 0.000002000 	let pat = a:lst[0]
    2                 0.000005000 	for item in range(1, len(a:lst) - 1)
                                  		let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
    2                 0.000000000 	endfo
    2                 0.000001000 	retu pat

FUNCTION  <SNR>101_CacheHeredoc()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:766
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var endmarker: string = line_A.text->matchstr(ASSIGNS_HEREDOC)
                                      var endlnum: number = search($'^\s*{endmarker}$', 'nW')
                                      var is_trimmed: bool = line_A.text =~ $'.*\s\%(trim\%(\s\+eval\)\=\)\s\+[A-Z]\+{END_OF_LINE}'
                                      b:vimindent = {
                                          is_HereDoc: true,
                                          startlnum: line_A.lnum,
                                          endlnum: endlnum,
                                          endmarker: endmarker,
                                          is_trimmed: is_trimmed,
                                      }
                                      if is_trimmed
                                          b:vimindent.startindent = Indent(line_A.lnum)
                                      endif
                                      RegisterCacheInvalidation()

FUNCTION  <SNR>167_BuildPrompt()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:591
Called 55 times
Total time:   0.671602000
 Self time:   0.653060000

count     total (s)      self (s)
   55   0.000278000   0.000194000 	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
   55   0.001829000   0.000202000 	let str = escape(s:getinput(), '\')
   55                 0.000186000 	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
   55                 0.000601000 	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp') || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
    4   0.013932000   0.000017000 		sil! cal s:Update(str)
   55                 0.000026000 	en
   55   0.003050000   0.000134000 	sil! cal ctrlp#statusline()
                                  	" Toggling
   55                 0.000212000 	let [hiactive, hicursor, base] = s:focus ? ['CtrlPPrtText', 'CtrlPPrtCursor', base] : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
   55                 0.000047000 	let hibase = 'CtrlPPrtBase'
                                  	" Build it
   55                 0.648785000 	redr
   55                 0.000178000 	let prt = copy(s:prompt)
   55                 0.000307000 	cal map(prt, 'escape(v:val, ''"\'')')
   55                 0.001475000 	exe 'echoh' hibase '| echon "'.base.'" | echoh' hiactive '| echon "'.prt[0].'" | echoh' hicursor '| echon "'.prt[1].'" | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                                  	" Append the cursor at the end
   55                 0.000107000 	if empty(prt[1]) && s:focus
   55                 0.000350000 		exe 'echoh' hibase '| echon "_" | echoh None'
   55                 0.000023000 	en

FUNCTION  vader#window#execute()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:70
Called 5 times
Total time:   0.071166000
 Self time:   0.034192000

count     total (s)      self (s)
    5                 0.000019000   let temp = tempname()
    5                 0.000005000   try
    5                 0.000010000     if empty(a:lang_if)
    5                 0.000005000       let lines = a:lines
                                      else
                                        let lines = copy(a:lines)
                                        call insert(lines, a:lang_if . ' << __VADER__LANG__IF__')
                                        call add(lines, '__VADER__LANG__IF__')
    5                 0.000002000     endif
    5                 0.032212000     call writefile(lines, temp)
    5   0.037633000   0.000659000     execute 'source '.temp
    5                 0.000034000   finally
    5                 0.001180000     call delete(temp)
    4                 5.138950000   endtry

FUNCTION  <SNR>49_setup_options()
    Defined: ~/.vim/bundle/tagbar/plugin/tagbar.vim:51
Called 1 time
Total time:   0.000299000
 Self time:   0.000142000

count     total (s)      self (s)
    1                 0.000002000     if exists('g:tagbar_position')
                                          " Map older deprecated values to correct values
                                          if g:tagbar_position ==# 'top'
                                              let g:tagbar_position = 'leftabove'
                                          elseif g:tagbar_position ==# 'bottom'
                                              let g:tagbar_position = 'rightbelow'
                                          elseif g:tagbar_position ==# 'left'
                                              let g:tagbar_position = 'topleft vertical'
                                          elseif g:tagbar_position ==# 'right'
                                              let g:tagbar_position = 'botright vertical'
                                          endif
                                          if g:tagbar_position !~# 'vertical'
                                              let previewwin_pos = 'rightbelow vertical'
                                          else
                                              let previewwin_pos = 'topleft'
                                          endif
                                          let default_pos = g:tagbar_position
    1                 0.000000000     else
    1                 0.000001000         if exists('g:tagbar_vertical') && g:tagbar_vertical > 0
                                              let previewwin_pos = 'rightbelow vertical'
                                              if exists('g:tagbar_left') && g:tagbar_left
                                                  let default_pos = 'leftabove'
                                              else
                                                  let default_pos = 'rightbelow'
                                              endif
                                              let g:tagbar_height = g:tagbar_vertical
    1                 0.000001000         elseif exists('g:tagbar_left') && g:tagbar_left
                                              let previewwin_pos = 'topleft'
                                              let default_pos = 'topleft vertical'
    1                 0.000000000         else
    1                 0.000001000             let previewwin_pos = 'topleft'
    1                 0.000001000             let default_pos = 'botright vertical'
    1                 0.000000000         endif
    1                 0.000001000     endif
    1                 0.000019000     let options = [ ['autoclose', 0], ['autoclose_netrw', 0], ['autofocus', 0], ['autopreview', 0], ['autoshowtag', 0], ['case_insensitive', 0], ['compact', 0], ['expand', 0], ['file_size_limit', 0], ['foldlevel', 99], ['hide_nonpublic', 0], ['height', 10], ['indent', 2], ['jump_offset', 0], ['jump_lazy_scroll', 0], ['left', 0], ['help_visibility', 0], ['highlight_follow_insert', 0], ['highlight_method', 'nearest-stl'], ['ignore_anonymous', 0], ['no_autocmds', 0], ['position', default_pos], ['previewwin_pos', previewwin_pos], ['scopestrs', {}], ['scrolloff', 0], ['show_balloon', 1], ['show_data_type', 0], ['show_visibility', 1], ['show_linenumbers', 0], ['show_prefix', 1], ['show_suffix', 1], ['show_tag_count', 0], ['show_tag_linenumbers', 0], ['singleclick', 0], ['sort', 1], ['systemenc', &encoding], ['vertical', 0], ['width', 40], ['zoomwidth', 1], ['silent', 0], ['use_cache', 1], ['wrap', 0], ]
                                  
   43                 0.000019000     for [opt, val] in options
   42   0.000205000   0.000048000         call s:init_var(opt, val)
   42                 0.000014000         unlet val
   43                 0.000017000     endfor

FUNCTION  ctrlp#dirnfile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1509
Called 4 times
Total time:   0.001963000
 Self time:   0.000818000

count     total (s)      self (s)
    4   0.000042000   0.000019000 	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
   38                 0.000027000 	for each in a:entries
   34                 0.000100000 		let etype = getftype(each)
   64   0.001228000   0.000106000 		if s:igntype >= 0 && s:usrign(each, etype) | con | en
   34                 0.000026000 		if etype == 'dir'
    9                 0.000010000 			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                                  				cal add(items[0], each)
    9                 0.000008000 			en | el
    9                 0.000019000 				cal add(items[0], each)
    9                 0.000003000 			en
   25                 0.000018000 		elsei etype == 'link'
                                  			if s:folsym
                                  				let isfile = !isdirectory(each)
                                  				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                                  					cal add(items[isfile], each)
                                  				en
                                  			en
   25                 0.000017000 		elsei etype == 'file'
   25                 0.000041000 			cal add(items[1], each)
   34                 0.000011000 		en
   38                 0.000019000 	endfo
    4                 0.000000000 	retu items

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:144
Called 8 times
Total time:   0.013833000
 Self time:   0.000530000

count     total (s)      self (s)
                                    " Values of path:
                                    " * non-empty string - path
                                    " *               -1 - pending
                                    " *               -2 - not tracked by git
                                    " *               -3 - assume unchanged
                                  
    8   0.000098000   0.000019000   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    8   0.001342000   0.000064000   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args. ' ls-files -v --error-unmatch --full-name -z -- '. gitgutter#utility#shellescape(s:filename(a:bufnr)))
                                  
    8   0.000497000   0.000212000   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    8                 0.000024000     let handler = copy(s:set_path_handler)
    8                 0.000014000     let handler.continuation = a:continuation
    8   0.011815000   0.000154000     call gitgutter#async#execute(cmd, a:bufnr, handler)
    8                 0.000015000     return 'async'
                                    endif
                                  
                                    let listing = gitgutter#utility#system(cmd)
                                  
                                    if v:shell_error
                                      call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                      return
                                    endif
                                  
                                    let listing = s:strip_trailing_new_line(listing)
                                    let [status, path] = [listing[0], listing[2:]]
                                    if status =~# '[a-z]'
                                      call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                                    else
                                      call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                                    endif

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:118
Called 36 times
Total time:   0.000771000
 Self time:   0.000436000

count     total (s)      self (s)
   36                 0.000050000     let l:priority = g:ale#util#style_warning_priority
                                  
                                      " Determine the highest priority item for the line.
   74                 0.000043000     for l:item in a:sublist
   38   0.000408000   0.000073000         let l:item_priority = ale#util#GetItemPriority(l:item)
                                  
   38                 0.000025000         if l:item_priority > l:priority
   36                 0.000025000             let l:priority = l:item_priority
   38                 0.000012000         endif
   74                 0.000027000     endfor
                                  
   36                 0.000027000     if l:priority is# g:ale#util#error_priority
   36                 0.000016000         return 'ALEErrorSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#warning_priority
                                          return 'ALEWarningSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#style_error_priority
                                          return 'ALEStyleErrorSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#style_warning_priority
                                          return 'ALEStyleWarningSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#info_priority
                                          return 'ALEInfoSign'
                                      endif
                                  
                                      " Use the error sign for invalid severities.
                                      return 'ALEErrorSign'

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:47
Called 1236 times
Total time:   0.020909000
 Self time:   0.012635000

count     total (s)      self (s)
 1236   0.011810000   0.003536000     if nerdtree#runningWindows()
                                          if exists('+shellslash') && &shellslash
                                              return '/'
                                          endif
                                  
                                          return '\'
 1236                 0.000789000     endif
                                  
 1236                 0.001197000     return '/'

FUNCTION  nerdtree#pathEquals()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:229
Called 143 times
Total time:   0.002700000
 Self time:   0.001315000

count     total (s)      self (s)
  143   0.001831000   0.000446000     if nerdtree#caseSensitiveFS()
                                          return a:lhs ==# a:rhs
  143                 0.000117000     else
  143                 0.000405000         return a:lhs ==? a:rhs
                                      endif

FUNCTION  ShouldMatchWhitespace()
    Defined: ~/.vim/bundle/vim-trailing-whitespace/plugin/trailing-whitespace.vim:8
Called 96 times
Total time:   0.003197000
 Self time:   0.003197000

count     total (s)      self (s)
   96                 0.000988000     for ft in g:extra_whitespace_ignored_filetypes
                                          if ft ==# &filetype | return 0 | endif
   96                 0.000194000     endfor
   96                 0.000831000     if &buftype ==# 'terminal' | return 0 | endif
   96                 0.000187000     return 1

FUNCTION  <SNR>167_Update()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:573
Called 4 times
Total time:   0.013915000
 Self time:   0.000125000

count     total (s)      self (s)
                                  	" Get the previous string if existed
    4                 0.000009000 	let oldstr = exists('s:savestr') ? s:savestr : ''
                                  	" Get the new string sans tail
    4   0.000135000   0.000014000 	let str = s:sanstail(a:str)
                                  	" Stop if the string's unchanged
    4                 0.000012000 	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
    4                 0.000019000 	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
    4   0.000232000   0.000020000 	let pat = s:matcher == {} ? s:SplitPattern(str) : str
    4   0.001049000   0.000024000 	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines) : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
    4   0.012446000   0.000014000 	cal s:Render(lines, pat)

FUNCTION  <SNR>101_RemovePastBracketBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:853
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var stack: list<dict<any>> = b:vimindent.block_stack
                                  
                                      var removed: dict<any>
                                      if line_A.lnum > stack[0].endlnum
                                          removed = stack[0]
                                      endif
                                  
                                      stack->filter((_, block: dict<any>): bool => line_A.lnum <= block.endlnum)
                                      if stack->empty()
                                          unlet! b:vimindent
                                      endif
                                      return removed

FUNCTION  <SNR>167_Close()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:291
Called 2 times
Total time:   0.020163000
 Self time:   0.001775000

count     total (s)      self (s)
    2   0.000073000   0.000019000 	cal s:buffunc(0)
    2                 0.000007000 	if winnr('$') == 1
                                  		bw!
    2                 0.000002000 	el
    2                 0.000435000 		try | bun!
    2                 0.000015000 		cat | clo! | endt
    2   0.000055000   0.000016000 		cal s:unmarksigns()
    2                 0.000002000 	en
   68                 0.000169000 	for key in keys(s:glbs) | if exists('+'.key)
   34                 0.000708000 		sil! exe 'let &'.key.' = s:glb_'.key
   68                 0.000054000 	en | endfo
    2                 0.000009000 	if exists('s:glb_acd') | let &acd = s:glb_acd | en
    2                 0.000005000 	let g:ctrlp_lines = []
    2                 0.000023000 	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
    2                 0.000067000 		exe s:winres[0].s:winres[0]
    2                 0.000002000 	en
    2                 0.000023000 	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:cline s:init s:savestr s:mrbs s:did_exp
    2   0.018180000   0.000022000 	cal ctrlp#recordhist()
    2   0.000114000   0.000060000 	cal s:execextvar('exit')
    2   0.000103000   0.000020000 	cal s:log(0)
    2                 0.000016000 	let v:errmsg = s:ermsg
    2                 0.000048000 	ec

FUNCTION  <SNR>101_FirstLinePreviousCommand()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:891
Called 3 times
Total time:   0.000319000
 Self time:   0.000010000

count     total (s)      self (s)
    3                 0.000001000     var line_B: dict<any> = line
                                  
    3                 0.000002000     while line_B.lnum > 1
    2   0.000019000   0.000000000         var code_line_above: dict<any> = PrevCodeLine(line_B.lnum)
                                  
    2   0.000295000   0.000005000         if line_B.text =~ CLOSING_BRACKET_AT_SOL
                                              var n: number = MatchingOpenBracket(line_B)
                                  
                                              if n <= 0
                                                  break
                                              endif
                                  
                                              line_B.lnum = n
                                              line_B.text = getline(line_B.lnum)
                                              continue
                                  
                                          elseif line_B->IsFirstLineOfCommand(code_line_above)
    2                 0.000000000             break
                                          endif
                                  
                                          line_B = code_line_above
                                      endwhile
                                  
                                      return line_B

FUNCTION  <SNR>158_execute()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:300
Called 5 times
Total time:   0.072266000
 Self time:   0.000298000

count     total (s)      self (s)
    5                 0.000005000   try
    5   0.071223000   0.000057000     call vader#window#execute(a:block, a:lang_if)
    1                 0.000001000     return 1
    4                 0.000105000   catch
    4   0.000443000   0.000059000     call s:append(a:prefix, a:type, v:exception, 1)
    4   0.000440000   0.000022000     call s:print_throwpoint()
    4                 0.000006000     return 0
    5                 0.000007000   endtry

FUNCTION  AddTabularPattern()
    Defined: ~/.vim/bundle/tabular/plugin/Tabular.vim:172
Called 6 times
Total time:   0.000610000
 Self time:   0.000173000

count     total (s)      self (s)
    6                 0.000001000   try
    6   0.000071000   0.000023000     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                                  
    6                 0.000023000     let name = matchstr(rest, '.\{-}\ze\s*/')
    6                 0.000024000     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                                  
    6   0.000401000   0.000012000     let [ pattern, format ] = s:ParsePattern(pattern)
                                  
    6                 0.000007000     if empty(name) || empty(pattern)
                                        throw "Invalid arguments!"
    6                 0.000003000     endif
                                  
    6                 0.000005000     if !a:force && has_key(commandmap, name)
                                        throw string(name) . " is already defined, use ! to overwrite."
    6                 0.000002000     endif
                                  
    6                 0.000010000     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)
                                  
    6                 0.000005000     if !empty(format)
    6                 0.000007000       let command .=  ", " . string(format)
    6                 0.000004000     endif
                                  
    6                 0.000006000     let command .= ")"
                                  
    6                 0.000011000     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }
                                    catch
                                      echohl ErrorMsg
                                      echomsg "AddTabularPattern: " . v:exception
                                      echohl None
    6                 0.000000000   endtry

FUNCTION  ctrlp#utils#glob()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:69
Called 1 time
Total time:   0.000060000
 Self time:   0.000016000

count     total (s)      self (s)
    1   0.000047000   0.000003000 	let path = ctrlp#utils#fnesc(a:1, 'g')
    1                 0.000013000 	retu s:wig_cond ? glob(path, a:2) : glob(path)

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:136
Called 309 times
Total time:   0.033703000
 Self time:   0.021394000

count     total (s)      self (s)
  309                 0.002331000     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                                  
  309   0.011272000   0.001272000     call ale#highlight#RemoveHighlights()
                                  
  362                 0.000537000     for l:item in l:item_list
   53                 0.000066000         if l:item.type is# 'W'
                                              if get(l:item, 'sub_type', '') is# 'style'
                                                  let l:group = 'ALEStyleWarning'
                                              else
                                                  let l:group = 'ALEWarning'
                                              endif
   53                 0.000046000         elseif l:item.type is# 'I'
                                              let l:group = 'ALEInfo'
   53                 0.000084000         elseif get(l:item, 'sub_type', '') is# 'style'
                                              let l:group = 'ALEStyleError'
   53                 0.000026000         else
   53                 0.000044000             let l:group = 'ALEError'
   53                 0.000020000         endif
                                  
   53                 0.000285000         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                                  
   53   0.002495000   0.000186000         call s:highlight_range(l:item.bufnr, l:range, l:group)
  362                 0.000408000     endfor
                                  
                                      " If highlights are enabled and signs are not enabled, we should still
                                      " offer line highlights by adding a separate set of highlights.
  309                 0.000517000     if !g:ale_set_signs
                                          let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                                  
                                          for l:item in l:item_list
                                              if l:item.type is# 'W'
                                                  let l:group = 'ALEWarningLine'
                                              elseif l:item.type is# 'I'
                                                  let l:group = 'ALEInfoLine'
                                              else
                                                  let l:group = 'ALEErrorLine'
                                              endif
                                  
                                              if l:available_groups[l:group]
                                                  call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                              endif
                                          endfor
  309                 0.000201000     endif

FUNCTION  <SNR>120_on_stdout_vim()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:79
Called 219 times
Total time:   0.001558000
 Self time:   0.001558000

count     total (s)      self (s)
  219                 0.001386000   call add(self.stdoutbuffer, a:data)

FUNCTION  ale#events#FileChangedEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:87
Called 3 times
Total time:   0.006832000
 Self time:   0.000056000

count     total (s)      self (s)
    3                 0.000012000     call setbufvar(a:buffer, 'ale_file_changed', 1)
                                  
    3                 0.000007000     if bufnr('') == a:buffer
    2   0.006793000   0.000017000         call ale#events#LintOnEnter(a:buffer)
    3                 0.000001000     endif

FUNCTION  <SNR>43_InitVariable()
    Defined: ~/.vim/bundle/nerdcommenter/plugin/nerdcommenter.vim:20
Called 19 times
Total time:   0.000070000
 Self time:   0.000070000

count     total (s)      self (s)
   19                 0.000017000     if !exists(a:var)
   19                 0.000044000         execute 'let ' . a:var . ' = ' . string(a:value)
   19                 0.000004000     endif

FUNCTION  <SNR>126_ShouldOpen()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:41
Called 143 times
Total time:   0.002082000
 Self time:   0.001054000

count     total (s)      self (s)
  143   0.001384000   0.000356000     let l:val = ale#Var(a:buffer, 'open_list')
  143                 0.000292000     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                  
  143                 0.000313000     return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved

FUNCTION  UploadProfileLog()
    Defined: ~/.vimrc:361
Called 1 time
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                    :profile stop
                                    call system('curl -F "file=@' . getcwd() . '/profile.log" http://localhost:4567/upload')

FUNCTION  <SNR>167_shortest()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1328
Called 116 times
Total time:   0.000391000
 Self time:   0.000391000

count     total (s)      self (s)
  116                 0.000370000 	retu min(map(values(a:lens), 'v:val[0]'))

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:213
Called 93 times
Total time:   0.012813000
 Self time:   0.012813000

count     total (s)      self (s)
   93                 0.009765000   let p = resolve(expand('#'.a:bufnr.':p'))
   93                 0.001887000   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
   93                 0.000414000   if !empty(ml) && !empty(ml[1])
                                      return ml[1].'^'
   93                 0.000072000   endif
   93                 0.000226000   return g:gitgutter_diff_base

FUNCTION  ale#job#Start()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:221
Called 131 times
Total time:   0.361596000
 Self time:   0.352046000

count     total (s)      self (s)
  131   0.001686000   0.000807000     call ale#job#ValidateArguments(a:command, a:options)
                                  
  131                 0.000630000     let l:job_info = copy(a:options)
  131                 0.000305000     let l:job_options = {}
                                  
  131                 0.000704000     if has('nvim')
                                          if has_key(a:options, 'out_cb')
                                              let l:job_options.on_stdout = function('s:NeoVimCallback')
                                              let l:job_info.out_cb_line = ''
                                          endif
                                  
                                          if has_key(a:options, 'err_cb')
                                              let l:job_options.on_stderr = function('s:NeoVimCallback')
                                              let l:job_info.err_cb_line = ''
                                          endif
                                  
                                          if has_key(a:options, 'exit_cb')
                                              let l:job_options.on_exit = function('s:NeoVimCallback')
                                          endif
                                  
                                          let l:job_info.job = jobstart(a:command, l:job_options)
                                          let l:job_id = l:job_info.job
  131                 0.000091000     else
  131                 0.000788000         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                                  
  131                 0.000323000         if has_key(a:options, 'out_cb')
  131                 0.000701000             let l:job_options.out_cb = function('s:VimOutputCallback')
                                          else
                                              " prevent buffering of output and excessive polling in case close_cb is set
                                              let l:job_options.out_cb = {->0}
  131                 0.000091000         endif
                                  
  131                 0.000277000         if has_key(a:options, 'err_cb')
                                              let l:job_options.err_cb = function('s:VimErrorCallback')
  131                 0.000090000         else
                                              " prevent buffering of output and excessive polling in case close_cb is set
  131                 0.000540000             let l:job_options.err_cb = {->0}
  131                 0.000089000         endif
                                  
  131                 0.000290000         if has_key(a:options, 'exit_cb')
                                              " Set a close callback to which simply calls job_status()
                                              " when the channel is closed, which can trigger the exit callback
                                              " earlier on.
  131                 0.000633000             let l:job_options.close_cb = function('s:VimCloseCallback')
  131                 0.000606000             let l:job_options.exit_cb = function('s:VimExitCallback')
  131                 0.000090000         endif
                                  
                                          " Use non-blocking writes for Vim versions that support the option.
  131                 0.000657000         if has('patch-8.1.350')
  131                 0.000255000             let l:job_options.noblock = 1
  131                 0.000081000         endif
                                  
                                          " Vim 8 will read the stdin from the file's buffer.
  131                 0.330940000         let l:job_info.job = job_start(a:command, l:job_options)
  131   0.012784000   0.004113000         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
  131                 0.000377000     endif
                                  
  131                 0.000272000     if l:job_id > 0
                                          " Store the job in the map for later only if we can get the ID.
  131                 0.000574000         let s:job_map[l:job_id] = l:job_info
  131                 0.000079000     endif
                                  
  131                 0.000588000     return l:job_id

FUNCTION  <SNR>129_GetNormalBgColorCterm()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes/color.vim:22
Called 39 times
Total time:   0.001206000
 Self time:   0.001206000

count     total (s)      self (s)
                                      # Get the highlight ID for 'Normal'
   39                 0.001054000     var hlid = hlID('Normal')
                                      # Resolve any links
   39                 0.000019000     hlid = synIDtrans(hlid)
                                      # Get the background color in cterm format
   39                 0.000030000     var bg_color = synIDattr(hlid, 'ctermbg')
                                      return str2nr(bg_color)

FUNCTION  <SNR>143_GetBearerToken()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/auth.vim:48
Called 1 time
Total time:   0.000261000
 Self time:   0.000261000

count     total (s)      self (s)
    1                 0.000077000   if filereadable(device_token_file)
                                      return join(readfile(device_token_file), "\n")
                                    else
                                      var response = GetDeviceToken()
                                      var json_response = json_decode(response)
                                      var device_code = json_response.device_code
                                      var user_code = json_response.user_code
                                      var verification_uri = json_response.verification_uri
                                  
                                      echo 'Please visit ' .. verification_uri .. ' and enter the code: ' .. user_code
                                      input("Press Enter to continue...\n")
                                  
                                      var token_poll_url = 'https://github.com/login/oauth/access_token'
                                      var token_poll_data = {
                                        'client_id': 'Iv1.b507a08c87ecfe98',
                                        'device_code': device_code,
                                        'grant_type': 'urn:ietf:params:oauth:grant-type:device_code'
                                      }
                                      var token_headers = [
                                        'Accept: application/json',
                                        'User-Agent: GithubCopilot/1.155.0',
                                        'Accept-Encoding: gzip,deflate,br',
                                        'Editor-Plugin-Version: copilot.vim/1.16.0',
                                        'Editor-Version: vim/9.0.1',
                                        'Content-Type: application/json'
                                      ]
                                  
                                      var access_token_response = api.Http('POST', token_poll_url, token_headers, token_poll_data)
                                      json_response = json_decode(access_token_response)
                                      var bearer_token = json_response.access_token
                                      call writefile([bearer_token], device_token_file)
                                  
                                      return bearer_token
                                    endif

FUNCTION  ale#command#SetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:34
Called 107 times
Total time:   0.000824000
 Self time:   0.000340000

count     total (s)      self (s)
  107   0.000643000   0.000159000     call ale#command#InitData(a:buffer)
  107                 0.000136000     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  <SNR>108_IsBoolean()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:88
Called 16 times
Total time:   0.000039000
 Self time:   0.000039000

count     total (s)      self (s)
   16                 0.000038000     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  <SNR>160_read_vader()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/parser.vim:72
Called 5 times
Total time:   0.008674000
 Self time:   0.008674000

count     total (s)      self (s)
    5                 0.000618000   let remains   = readfile(a:fn)[a:line1 - 1 : a:line2 - 1]
    5                 0.000021000   let lnum      = a:line1
    5                 0.000014000   let lines     = []
    5                 0.000013000   let reserved  = 0
    5                 0.000010000   let depth     = 0 " Not a strict depth
    5                 0.000011000   let max_depth = 10
                                  
   90                 0.000355000   while len(remains) > 0
   85                 0.000332000     let line = remove(remains, 0)
   85                 0.002078000     let m = matchlist(line, '^Include\(\s*(.*)\s*\)\?:\s*\(.\{-}\)\s*$')
   85                 0.000270000     if !empty(m)
                                        let file = findfile(m[2], fnamemodify(a:fn, ':h'))
                                        if empty(file)
                                          echoerr "Cannot find ".m[2]
                                        endif
                                        if reserved > 0
                                          let depth += 1
                                          if depth >= max_depth
                                            echoerr 'Recursive inclusion limit exceeded'
                                          endif
                                          let reserved -= 1
                                        endif
                                        let included = readfile(file)
                                        let reserved += len(included)
                                        call extend(remains, included, 0)
                                        continue
   85                 0.000086000     end
                                  
   85                 0.000515000     call add(lines, [a:fn, lnum, line])
   85                 0.000240000     if reserved > 0
                                        let reserved -= 1
   85                 0.000084000     end
   85                 0.000149000     if reserved == 0
   85                 0.000165000       let depth = 0
   85                 0.000189000       let lnum += 1
   85                 0.000092000     endif
   90                 0.000118000   endwhile
                                  
    5                 0.000021000   return lines

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:504
Called 36 times
Total time:   0.064433000
 Self time:   0.002992000

count     total (s)      self (s)
   36                 0.000142000     let l:command = ''
   36                 0.000081000     let l:address = ''
   36   0.030326000   0.000439000     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                                  
   36                 0.000157000     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                          " If there's no project root, then we can't check files with LSP,
                                          " unless we are using tsserver, which doesn't use project roots.
                                          call ale#lsp_linter#AddErrorMessage(a:linter.name, "Failed to find project root, language server won't start.")
                                  
                                          return 0
   36                 0.000033000     endif
                                  
   36                 0.000336000     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                                  
   36                 0.000090000     if a:linter.lsp is# 'socket'
                                          let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                                  
                                          return s:StartWithAddress(l:options, l:address)
   36                 0.000034000     endif
                                  
   36   0.018799000   0.000347000     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                                  
   36   0.013394000   0.000292000     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  <SNR>11_SetupFullScreenTouchBar()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:1390
Called 1 time
Total time:   0.000014000
 Self time:   0.000014000

count     total (s)      self (s)
    1                 0.000001000     if &fullscreen && s:touchbar_fullscreen != 1
                                        silent! aun TouchBar.EnterFullScreen
                                        silent! tlun TouchBar.EnterFullScreen
                                        if !exists("g:macvim_default_touchbar_fullscreen") || g:macvim_default_touchbar_fullscreen
                                          an icon=NSTouchBarExitFullScreenTemplate 1.20 TouchBar.ExitFullScreen :set nofullscreen<CR>
                                          tln icon=NSTouchBarExitFullScreenTemplate 1.20 TouchBar.ExitFullScreen <C-W>:set nofullscreen<CR>
                                        endif
                                        let s:touchbar_fullscreen = 1
    1                 0.000002000     elseif !&fullscreen && s:touchbar_fullscreen != 0
                                        silent! aun TouchBar.ExitFullScreen
                                        silent! tlun TouchBar.ExitFullScreen
                                        if !exists("g:macvim_default_touchbar_fullscreen") || g:macvim_default_touchbar_fullscreen
                                          an icon=NSTouchBarEnterFullScreenTemplate 1.20 TouchBar.EnterFullScreen :set fullscreen<CR>
                                          tln icon=NSTouchBarEnterFullScreenTemplate 1.20 TouchBar.EnterFullScreen <C-W>:set fullscreen<CR>
                                        endif
                                        let s:touchbar_fullscreen = 0
    1                 0.000000000     endif

FUNCTION  gitgutter#highlight#define_highlights()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:67
Called 1 time
Total time:   0.000447000
 Self time:   0.000163000

count     total (s)      self (s)
    1   0.000070000   0.000006000   let [guibg, ctermbg] = s:get_background_colors('SignColumn')
                                  
                                    " Highlights used by the signs.
                                  
                                    " When they are invisible.
    1                 0.000014000   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1                 0.000006000   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1                 0.000006000   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1                 0.000001000   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
                                  
                                    " When they are visible.
    4                 0.000004000   for type in ["Add", "Change", "Delete"]
    3                 0.000008000     if hlexists("GitGutter".type) && s:get_foreground_colors("GitGutter".type) != ['NONE', 'NONE']
                                        if g:gitgutter_set_sign_backgrounds
                                          execute "highlight GitGutter".type." guibg=".guibg." ctermbg=".ctermbg
                                        endif
                                        continue
    3   0.000143000   0.000007000     elseif s:useful_diff_colours()
    3   0.000053000   0.000009000       let [guifg, ctermfg] = s:get_foreground_colors('Diff'.type)
                                      else
                                        let [guifg, ctermfg] = s:get_foreground_fallback_colors(type)
    3                 0.000000000     endif
    3                 0.000022000     execute "highlight GitGutter".type." guifg=".guifg." guibg=".guibg." ctermfg=".ctermfg." ctermbg=".ctermbg
    4                 0.000002000   endfor
                                  
    1                 0.000002000   if hlexists("GitGutterChangeDelete") && g:gitgutter_set_sign_backgrounds
                                      execute "highlight GitGutterChangeDelete guibg=".guibg." ctermbg=".ctermbg
    1                 0.000000000   endif
                                  
    1                 0.000002000   highlight default link GitGutterChangeDelete GitGutterChange
                                  
                                    " Highlights used for the whole line.
                                  
    1                 0.000001000   highlight default link GitGutterAddLine          DiffAdd
    1                 0.000001000   highlight default link GitGutterChangeLine       DiffChange
    1                 0.000000000   highlight default link GitGutterDeleteLine       DiffDelete
    1                 0.000001000   highlight default link GitGutterChangeDeleteLine GitGutterChangeLine
                                  
    1                 0.000001000   highlight default link GitGutterAddLineNr          CursorLineNr
    1                 0.000001000   highlight default link GitGutterChangeLineNr       CursorLineNr
    1                 0.000001000   highlight default link GitGutterDeleteLineNr       CursorLineNr
    1                 0.000002000   highlight default link GitGutterChangeDeleteLineNr CursorLineNr
                                  
                                    " Highlights used intra line.
    1                 0.000001000   highlight default GitGutterAddIntraLine    gui=reverse cterm=reverse
    1                 0.000001000   highlight default GitGutterDeleteIntraLine gui=reverse cterm=reverse
                                    " Set diff syntax colours (used in the preview window) - diffAdded,diffChanged,diffRemoved -
                                    " to match the signs, if not set aleady.
    4                 0.000004000   for [dtype,type] in [['Added','Add'], ['Changed','Change'], ['Removed','Delete']]
    3                 0.000003000     if !hlexists('diff'.dtype)
    3   0.000048000   0.000008000       let [guifg, ctermfg] = s:get_foreground_colors('GitGutter'.type)
    3                 0.000015000       execute "highlight diff".dtype." guifg=".guifg." ctermfg=".ctermfg." guibg=NONE ctermbg=NONE"
    3                 0.000000000     endif
    4                 0.000002000   endfor

FUNCTION  ale#handlers#writegood#ResetOptions()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/writegood.vim:4
Called 1 time
Total time:   0.000031000
 Self time:   0.000011000

count     total (s)      self (s)
    1   0.000012000   0.000004000     call ale#Set('writegood_options', '')
    1   0.000008000   0.000002000     call ale#Set('writegood_executable', 'write-good')
    1   0.000010000   0.000004000     call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))

FUNCTION  modes#SetVisualHighlight()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:50
Called 32 times
Total time:   0.007276000
 Self time:   0.003347000

count     total (s)      self (s)
   32   0.002606000   0.000438000   var blended = color.ComputeBlendedColor(g:modes_colors.visual.gui, gui_blend)
   32   0.001907000   0.000146000   var ctbg = color.ComputeBlendedColorCterm(g:modes_colors.visual.term, cterm_blend)
   32                 0.002409000   execute $'highlight Visual guibg={blended} ctermfg={ctbg}'

FUNCTION  <SNR>101_Is_IN_KeywordForLoop()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1117
Called 6 times
Total time:   0.000016000
 Self time:   0.000016000

count     total (s)      self (s)
                                      return line_2 =~ '^\s*for\s'
                                          && line_1 =~ '^\s*in\s'

FUNCTION  <SNR>167_PrtFocusMap()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:797
Called 53 times
Total time:   0.588925000
 Self time:   0.000238000

count     total (s)      self (s)
   53   0.588915000   0.000228000 	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])

FUNCTION  <SNR>76_restore_shell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:207
Called 1 time
Total time:   0.000032000
 Self time:   0.000026000

count     total (s)      self (s)
    1                 0.000007000   if (has('unix') || has('win32')) && exists('s:shell')
    1   0.000021000   0.000015000     let [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote] = [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote]
    1                 0.000001000   endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:21
Called 310 times
Total time:   1.068198000
 Self time:   0.038709000

count     total (s)      self (s)
                                    " NOTE a:bufnr is not necessarily the current buffer.
                                  
  310   0.008894000   0.002650000   if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
   33   0.000639000   0.000142000     call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
  310                 0.000319000   endif
                                  
  310   0.104151000   0.001919000   if gitgutter#utility#is_active(a:bufnr)
                                  
  187                 0.002148000     if has('patch-7.4.1559')
  187                 0.002018000       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                      else
                                        let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
  187                 0.000176000     endif
  187   0.024335000   0.001655000     let how = s:setup_path(a:bufnr, l:Callback)
  187                 0.000614000     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    8                 0.000003000       return
  179                 0.000189000     endif
                                  
  179   0.004134000   0.001067000     if a:force || s:has_fresh_changes(a:bufnr)
                                  
   93                 0.000177000       let diff = 'NOT SET'
   93                 0.000255000       try
   93   0.900764000   0.005995000         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                        catch /gitgutter not tracked/
                                          call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                        catch /gitgutter assume unchanged/
                                          call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                        catch /gitgutter diff failed/
                                          call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                          call gitgutter#hunk#reset(a:bufnr)
   93                 0.000139000       endtry
                                  
   93                 0.000310000       if diff != 'async' && diff != 'NOT SET'
                                          call gitgutter#diff#handler(a:bufnr, diff)
   93                 0.000118000       endif
                                  
  179                 0.000123000     endif
  302                 0.000219000   endif

FUNCTION  <SNR>152_DetectFromHashBang()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/script.vim:22
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                    var line1 = firstline
                                  
                                    # Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                                    # "#!/usr/bin/bash" to make matching easier.
                                    # Recognize only a few {options} that are commonly used.
                                    if line1 =~ '^#!\s*\S*\<env\s'
                                      line1 = substitute(line1, '\S\+=\S\+', '', 'g')
                                      line1 = substitute(line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                      line1 = substitute(line1, '\<env\s\+', '', '')
                                    endif
                                  
                                    # Get the program name.
                                    # Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                                    # If the word env is used, use the first word after the space:
                                    # "#!/usr/bin/env perl [path/args]"
                                    # If there is no path use the first word: "#!perl [path/args]".
                                    # Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                                    var name: string
                                    if line1 =~ '^#!\s*\a:[/\\]'
                                      name = substitute(line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                                    elseif line1 =~ '^#!.*\<env\>'
                                      name = substitute(line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                                    elseif line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                      name = substitute(line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                                    else
                                      name = substitute(line1, '^#!\s*\S*[/\\]\(\f\+\).*', '\1', '')
                                    endif
                                  
                                    # tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                                    # third line.  Suggested by Steven Atkinson.
                                    if getline(3) =~ '^exec wish'
                                      name = 'wish'
                                    endif
                                  
                                    var ft = Exe2filetype(name, line1)
                                    if ft != ''
                                      exe 'setl ft=' .. ft
                                    endif

FUNCTION  <SNR>122_is_removed()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 202 times
Total time:   0.000296000
 Self time:   0.000296000

count     total (s)      self (s)
  202                 0.000261000   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>167_sublist()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1704
Called 4 times
Total time:   0.000032000
 Self time:   0.000032000

count     total (s)      self (s)
    4                 0.000031000 	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:51
Called 193 times
Total time:   0.013488000
 Self time:   0.009011000

count     total (s)      self (s)
                                      " Apply pattern options if the variable is set.
  193                 0.001813000     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                          call ale#pattern_options#SetOptions(a:buffer)
  193                 0.000153000     endif
                                  
                                      " When entering a buffer, we are no longer quitting it.
  193                 0.001366000     call setbufvar(a:buffer, 'ale_quitting', 0)
  193                 0.001083000     let l:filetype = getbufvar(a:buffer, '&filetype')
  193                 0.001195000     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                                  
                                      " If the file changed outside of Vim, check it on BufEnter,BufRead
  193                 0.000682000     if getbufvar(a:buffer, 'ale_file_changed')
    1   0.004483000   0.000006000         call ale#events#LintOnEnter(a:buffer)
  193                 0.000142000     endif

FUNCTION  ctrlp#igncwd()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1504
Called 1 time
Total time:   0.000113000
 Self time:   0.000017000

count     total (s)      self (s)
    1   0.000113000   0.000017000 	retu ctrlp#utils#glob(a:cwd, 0) == '' || ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )

FUNCTION  <SNR>167_mixedsort()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1332
Called 58 times
Total time:   0.011091000
 Self time:   0.002975000

count     total (s)      self (s)
   58                 0.000069000 	if s:itemtype == 1
                                  		let pat = '[\/]\?\[\d\+\*No Name\]$'
                                  		if a:1 =~# pat && a:2 =~# pat | retu 0
                                  		elsei a:1 =~# pat | retu 1
                                  		elsei a:2 =~# pat | retu -1 | en
   58                 0.000017000 	en
   58   0.002218000   0.000362000 	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
   58                 0.000046000 	if s:ispath
   58                 0.000054000 		let ms = []
   58                 0.000054000 		if s:res_count < 21
   58   0.000883000   0.000201000 			let ms += [s:compfnlen(a:1, a:2)]
   58   0.001125000   0.000444000 			if s:itemtype !~ '^[12]$' | let ms += [s:comptime(a:1, a:2)] | en
   58   0.004489000   0.000286000 			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
   58                 0.000029000 		en
   58                 0.000168000 		if s:itemtype =~ '^[12]$'
                                  			let ms += [s:compmref(a:1, a:2)]
                                  			let cln = cml ? cln : 0
   58                 0.000033000 		en
   58                 0.000105000 		let ms += [cml, 0, 0, 0]
   58   0.000952000   0.000258000 		let mp = call('s:multipliers', ms[:3])
   58                 0.000246000 		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                                  	en
                                  	retu cln + cml * 2

FUNCTION  ctrlp#statusline()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1370
Called 55 times
Total time:   0.002916000
 Self time:   0.002651000

count     total (s)      self (s)
   55                 0.000080000 	if !exists('s:statypes')
    2                 0.000009000 		let s:statypes = [ ['files', 'fil'], ['buffers', 'buf'], ['mru files', 'mru'], ]
    2                 0.000005000 		if !empty(g:ctrlp_ext_vars)
                                  			cal map(copy(g:ctrlp_ext_vars), 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
    2                 0.000001000 		en
   55                 0.000022000 	en
   55                 0.000047000 	let tps = s:statypes
   55                 0.000086000 	let max = len(tps) - 1
   55   0.000336000   0.000196000 	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
   55   0.000278000   0.000157000 	let prv = tps[s:walker(max, s:itemtype, -1)][1]
   55                 0.000092000 	let s:ctype = tps[s:itemtype][0]
   55                 0.000073000 	let focus   = s:focus ? 'prt'  : 'win'
   55                 0.000086000 	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
   55                 0.000165000 	let marked  = s:opmul != '0' ? exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
   55                 0.000061000 	if s:status != {}
                                  		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'focus':   focus, 'byfname': byfname, 'regex':   s:regexp, 'prev':    prv, 'item':    s:ctype, 'next':    nxt, 'marked':  marked, }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
                                  		let &l:stl = call(s:status['main'], argms, s:status)
   55                 0.000020000 	el
   55                 0.000084000 		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
   55                 0.000073000 		let focus   = '%#CtrlPMode2# '.focus.' %*'
   55                 0.000074000 		let byfname = '%#CtrlPMode1# '.byfname.' %*'
   55                 0.000063000 		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
   55                 0.000125000 		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
   55                 0.000056000 		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
   55   0.000317000   0.000313000 		let &l:stl  = focus.byfname.regex.slider.marked.dir
   55                 0.000019000 	en

FUNCTION  <SNR>149_foldable()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/ruby.vim:40
Called 159 times
Total time:   0.000831000
 Self time:   0.000831000

count     total (s)      self (s)
  159                 0.000255000   if index(s:foldable_groups, 'NONE') > -1
                                      return 0
  159                 0.000075000   endif
                                  
  159                 0.000205000   if index(s:foldable_groups, 'ALL') > -1
  159                 0.000104000     return 1
                                    endif
                                  
                                    for l:i in a:000
                                      if index(s:foldable_groups, l:i) > -1
                                        return 1
                                      endif
                                    endfor
                                  
                                    return 0

FUNCTION  <SNR>167_remarksigns()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1666
Called 2 times
Total time:   0.000013000
 Self time:   0.000006000

count     total (s)      self (s)
    2   0.000012000   0.000005000 	if !s:dosigns() | retu | en
                                  	for ic in range(1, len(s:lines))
                                  		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                                  		let key = s:dictindex(s:marked, line)
                                  		if key > 0
                                  			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                                  		en
                                  	endfo

FUNCTION  ctrlp#mrufiles#bufs()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:125
Called 2 times
Total time:   0.000006000
 Self time:   0.000006000

count     total (s)      self (s)
    2                 0.000004000 	retu s:mrbs

FUNCTION  <SNR>167_dohighlight()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1635
Called 4 times
Total time:   0.000042000
 Self time:   0.000021000

count     total (s)      self (s)
    4   0.000040000   0.000019000 	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:101
Called 187 times
Total time:   0.007117000
 Self time:   0.002094000

count     total (s)      self (s)
  187   0.006947000   0.001924000   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>101_IsFirstLineOfCommand()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1093
Called 5 times
Total time:   0.000923000
 Self time:   0.000262000

count     total (s)      self (s)
    5   0.000019000   0.000006000     if line_1.text->Is_IN_KeywordForLoop(line_2.text)
                                          return false
                                      endif
                                  
    5                 0.000027000     if line_1.text =~ RANGE_AT_SOL
                                              || line_1.text =~ PLUS_MINUS_COMMAND
                                          return true
                                      endif
                                  
    5                 0.000062000     if line_2.text =~ DICT_KEY
                                              && !line_1->IsInThisBlock(line_2.lnum)
                                          return true
                                      endif
                                  
    5                 0.000157000     var line_1_is_good: bool = line_1.text !~ COMMENT
                                          && line_1.text !~ DICT_KEY
                                          && line_1.text !~ LINE_CONTINUATION_AT_SOL
                                  
    5   0.000649000   0.000001000     var line_2_is_good: bool = !line_2->EndsWithLineContinuation()
                                  
                                      return line_1_is_good && line_2_is_good

FUNCTION  ctrlp#utils#readfile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:44
Called 12 times
Total time:   0.006780000
 Self time:   0.006780000

count     total (s)      self (s)
   12                 0.000515000 	if filereadable(a:file)
   12                 0.006110000 		let data = readfile(a:file)
   12                 0.000061000 		if empty(data) || type(data) != 3
                                  			unl data
                                  			let data = []
   12                 0.000009000 		en
   12                 0.000017000 		retu data
                                  	en
                                  	retu []

FUNCTION  <SNR>77_useful_diff_colours()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:230
Called 3 times
Total time:   0.000136000
 Self time:   0.000030000

count     total (s)      self (s)
    3   0.000046000   0.000009000   let [guifg_add, ctermfg_add] = s:get_foreground_colors('DiffAdd')
    3   0.000083000   0.000014000   let [guifg_del, ctermfg_del] = s:get_foreground_colors('DiffDelete')
                                  
    3                 0.000006000   return guifg_add != guifg_del && ctermfg_add != ctermfg_del

FUNCTION  copilot_chat#api#AsyncRequest()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/api.vim:10
Called 4 times
Total time:   2.272209000
 Self time:   1.174156000

count     total (s)      self (s)
    4   1.097557000   0.000028000   var chat_token: string = auth.VerifySignin()
    4                 0.000401000   curl_output = []
    4                 0.000004000   var url: string = 'https://api.githubcopilot.com/chat/completions'
                                  
                                    # for knowledge bases its just an attachment as the content
                                    # {'content': '<attachment id="kb:Name">\n#kb:\n</attachment>', 'role': 'user'}
                                    # for files similar
    4                 0.000002000   for file in file_list
                                      var file_content: list<string> = readfile(file)
                                      var full_path: string = fnamemodify(file, ': p')
                                      # TODO: get the filetype instead of just markdown
                                      var attachment_content: string = '<attachment id="' .. file .. '">\n````markdown\n<!-- filepath: ' .. full_path .. ' -->\n' .. join(file_content, "\n") .. '\n```</attachment>'
                                      add(messages, {'content': attachment_content, 'role': 'user'})
                                    endfor
                                  
    4   1.144973000   1.144935000   var data: string = json_encode({
                                      'intent': false,
                                      'model': models.Current(),
                                      'temperature': 0,
                                      'top_p': 1,
                                      'n': 1,
                                      'stream': true,
                                      'messages': messages
                                    })
                                  
    4                 0.000012000   var tmpfile: string = tempname()
    4                 0.015698000   writefile([data], tmpfile)
                                  
    4                 0.000040000   var curl_cmd: list<string> = [
                                      'curl',
                                      '-s',
                                      '-X',
                                      'POST',
                                      '-H',
                                      'Content-Type: application/json',
                                      '-H', 'Authorization: Bearer ' .. chat_token,
                                      '-H', 'Editor-Version: vscode/1.80.1',
                                      '-d',
                                      $'@{tmpfile}',
                                      url
                                    ]
                                  
    4                 0.012697000   var job: job = job_start(curl_cmd, {
                                       'out_cb': function('HandleJobOutput'),
                                       'exit_cb': function('HandleJobClose'),
                                       'err_cb': function('HandleJobError')
                                       })
                                  
    4   0.000747000   0.000261000   _buffer.WaitingForResponse()
                                  
                                    return job

FUNCTION  <SNR>101_NextCodeLine()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:947
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var last: number = line('$')
                                      if v:lnum == last
                                          return 0
                                      endif
                                  
                                      var lnum: number = v:lnum + 1
                                      while lnum <= last
                                          var line: string = getline(lnum)
                                          if line != '' && line !~ COMMENT
                                              return lnum
                                          endif
                                          ++lnum
                                      endwhile
                                      return 0

FUNCTION  10()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:187
Called 1 time
Total time:   0.000003000
 Self time:   0.000003000

count     total (s)      self (s)
    1                 0.000002000     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))

FUNCTION  14()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:263
Called 204 times
Total time:   0.004961000
 Self time:   0.000980000

count     total (s)      self (s)
  204                 0.000292000     if self.cachedDisplayString ==# ''
   78   0.004104000   0.000123000         call self.cacheDisplayString()
  204                 0.000082000     endif
                                  
  204                 0.000183000     return self.cachedDisplayString

FUNCTION  15()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:272
Called 4 times
Total time:   0.170534000
 Self time:   0.003070000

count     total (s)      self (s)
    4   0.001121000   0.000037000     let l:bufname = self.str({'format': 'Edit'})
    4                 0.000016000     if bufname('%') !=# l:bufname
    4   0.169377000   0.002997000         exec 'edit ' . l:bufname
    4                 0.000003000     endif

FUNCTION  16()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:282
Called 125 times
Total time:   0.002820000
 Self time:   0.002133000

count     total (s)      self (s)
  125   0.001020000   0.000333000     if nerdtree#runningWindows()
                                          if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                              "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                              let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                              let self.drive = substitute(self.drive, '/', '\', 'g')
                                          else
                                              let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                          endif
  125                 0.000069000     else
  125                 0.000195000         let self.drive = ''
  125                 0.000072000     endif
                                  

FUNCTION  18()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:305
Called 12 times
Total time:   0.000188000
 Self time:   0.000106000

count     total (s)      self (s)
   12   0.000116000   0.000034000     if nerdtree#runningWindows()
                                          return " `\|\"#%&,?()\*^<>$"
   12                 0.000007000     endif
                                  
   12                 0.000021000     return " \\`\|\"#%&,?()\*^<>[]{}$"

FUNCTION  <SNR>101_IsInside()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1052
Called 9 times
Total time:   0.000063000
 Self time:   0.000063000

count     total (s)      self (s)
    9                 0.000051000     if !exists('b:vimindent')
                                              || !b:vimindent->has_key($'is_{syntax}')
                                          return false
                                      endif
                                  
                                      if syntax == 'BracketBlock'
                                          if !b:vimindent->has_key('block_stack')
                                                  || b:vimindent.block_stack->empty()
                                              return false
                                          endif
                                          return lnum <= b:vimindent.block_stack[0].endlnum
                                      endif
                                  
                                      return lnum <= b:vimindent.endlnum

FUNCTION  <SNR>40_MakeBuff()
    Defined: ~/.vim/bundle/vim-poi/plugin/poi.vim:45
Called 167 times
Total time:   0.011014000
 Self time:   0.011014000

count     total (s)      self (s)
  167                 0.000406000   let start = 1
  835                 0.001775000   while start <= g:poi_color_count
  668                 0.003250000     if !exists('b:poi_lines'.start)
  172                 0.000453000       let b:poi_lines{start} = []
  668                 0.000507000     endif
  668                 0.001332000     let start += 1
  835                 0.000826000   endwhile

FUNCTION  <SNR>167_sanstail()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1829
Called 4 times
Total time:   0.000121000
 Self time:   0.000121000

count     total (s)      self (s)
    4                 0.000046000 	let str = s:spi ? substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
    4                 0.000017000 	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
    4                 0.000004000 	unl! s:optail
    4                 0.000020000 	if str =~ '\\\@<!:'.pat
                                  		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                                  		let str = substitute(str, '\\\@<!:'.pat, '', '')
    4                 0.000002000 	en
    4                 0.000013000 	retu substitute(str, '\\\ze:', '', 'g')

FUNCTION  <SNR>101_IndentMoreInBracketBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:20
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      if get(g:, 'vim_indent', {})
                                              ->get('more_in_bracket_block', false)
                                          return shiftwidth()
                                      else
                                          return 0
                                      endif

FUNCTION  <SNR>120_job_id()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:104
Called 202 times
Total time:   0.006274000
 Self time:   0.006274000

count     total (s)      self (s)
                                    " Vim
  202                 0.004641000   return job_info(a:job).process

FUNCTION  containedinlist#GetContainedinlist()
    Defined: ~/.vim/bundle/semantic-highlight.vim/autoload/containedinlist.vim:9
Called 1 time
Total time:   0.000001000
 Self time:   0.000001000

count     total (s)      self (s)
    1                 0.000001000 	return s:containedinlist

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:58
Called 107 times
Total time:   0.001075000
 Self time:   0.000349000

count     total (s)      self (s)
  107   0.000941000   0.000215000     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                                  
  107                 0.000098000     let l:obj.output = a:output

FUNCTION  107()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:13
Called 4 times
Total time:   0.194635000
 Self time:   0.000114000

count     total (s)      self (s)
    4   0.194632000   0.000111000     call self.open(a:0 ? a:1 : {})

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:72
Called 482 times
Total time:   0.020785000
 Self time:   0.019904000

count     total (s)      self (s)
  482                 0.017088000   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
  389                 0.000689000     return a:arg
   93   0.001340000   0.000459000   elseif s:winshell()
                                      return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   93                 0.000069000   else
   93                 0.000456000     return shellescape(a:arg)
                                    endif

FUNCTION  <SNR>122_is_modified()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 202 times
Total time:   0.000390000
 Self time:   0.000390000

count     total (s)      self (s)
  202                 0.000362000   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>113_RunJob()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:436
Called 131 times
Total time:   0.624638000
 Self time:   0.019943000

count     total (s)      self (s)
  131   0.001473000   0.000627000     if ale#command#IsDeferred(a:command)
                                          let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                                  
                                          return 1
  131                 0.000096000     endif
                                  
  131                 0.000263000     let l:command = a:command
                                  
  131                 0.000318000     if empty(l:command)
                                          return 0
  131                 0.000091000     endif
                                  
  131                 0.000274000     let l:cwd = a:options.cwd
  131                 0.000293000     let l:executable = a:options.executable
  131                 0.000310000     let l:buffer = a:options.buffer
  131                 0.000294000     let l:linter = a:options.linter
  131                 0.000321000     let l:output_stream = a:options.output_stream
  131                 0.000420000     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
  131                 0.000457000     let l:info = g:ale_buffer_info[l:buffer]
                                  
  131                 0.002130000     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
  131   0.604231000   0.006111000     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                                  
                                      " Only proceed if the job is being run.
  131                 0.000348000     if empty(l:result)
                                          return 0
  131                 0.000072000     endif
                                  
  131   0.004541000   0.000837000     call ale#engine#MarkLinterActive(l:info, l:linter)
                                  
  131   0.005430000   0.003405000     silent doautocmd <nomodeline> User ALEJobStarted
                                  
  131                 0.000626000     return 1

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:29
Called 2193 times
Total time:   0.281922000
 Self time:   0.206871000

count     total (s)      self (s)
                                      " The checks are split into separate if statements to make it possible to
                                      " profile each check individually with Vim's profiling tools.
                                      "
                                      " Do nothing if ALE is disabled.
 2193                 0.015636000     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                          return 1
 2193                 0.001363000     endif
                                  
                                      " Don't perform any checks when newer NeoVim versions are exiting.
 2193                 0.010045000     if get(v:, 'exiting', v:null) isnot v:null
                                          return 1
 2193                 0.001263000     endif
                                  
 2193                 0.011015000     let l:filetype = getbufvar(a:buffer, '&filetype')
                                  
                                      " Do nothing when there's no filetype.
 2193                 0.003707000     if l:filetype is# ''
   37                 0.000035000         return 1
 2156                 0.001256000     endif
                                  
                                      " Do nothing for diff buffers.
 2156                 0.007073000     if getbufvar(a:buffer, '&diff')
                                          return 1
 2156                 0.001262000     endif
                                  
                                      " Do nothing for blacklisted files.
 2156                 0.014612000     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
  104                 0.000119000         return 1
 2052                 0.001171000     endif
                                  
                                      " Do nothing if running from command mode.
 2052                 0.010338000     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                          return 1
 2052                 0.001407000     endif
                                  
 2052                 0.011873000     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                                  
                                      " Do nothing for directories.
 2052                 0.003240000     if l:filename is# '.'
                                          return 1
 2052                 0.001220000     endif
                                  
                                      " Don't start linting and so on when an operator is pending.
 2052   0.023578000   0.011459000     if ale#util#Mode(1) is# 'no'
                                          return 1
 2052                 0.001227000     endif
                                  
                                      " Do nothing if running in the sandbox.
 2052   0.043860000   0.007002000     if ale#util#InSandbox()
                                          return 1
 2052                 0.001200000     endif
                                  
                                      " Do nothing if the file is too large.
 2052   0.033965000   0.007891000     if ale#FileTooLarge(a:buffer)
                                          return 1
 2052                 0.001258000     endif
                                  
                                      " Do nothing from CtrlP buffers with CtrlP-funky.
 2052                 0.020782000     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                          return 1
 2052                 0.001202000     endif
                                  
 2052                 0.001900000     return 0

FUNCTION  <SNR>87_LocalBrowse()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim:105
Called 1 time
Total time:   0.000004000
 Self time:   0.000004000

count     total (s)      self (s)
                                    " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                                    " Otherwise, the BufEnter event gets triggered when attempts to write to
                                    " the DBG buffer are made.
                                  
    1                 0.000001000   if !exists("s:vimentered")
                                     " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                                     " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                                  "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                                  "   call Dret("s:LocalBrowse")
    1                 0.000001000    return
                                    endif
                                  
                                  "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                                  
                                    if has("amiga")
                                     " The check against '' is made for the Amiga, where the empty
                                     " string is the current directory and not checking would break
                                     " things such as the help command.
                                  "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                                     if a:dirname != '' && isdirectory(a:dirname)
                                      sil! call netrw#LocalBrowseCheck(a:dirname)
                                      if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                       exe w:netrw_bannercnt
                                      endif
                                     endif
                                  
                                    elseif isdirectory(a:dirname)
                                  "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                                  "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                                     " Jul 13, 2021: for whatever reason, preceding the following call with
                                     " a   sil!  causes an unbalanced if-endif vim error
                                     call netrw#LocalBrowseCheck(a:dirname)
                                     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                      exe w:netrw_bannercnt
                                     endif
                                  
                                    else
                                     " not a directory, ignore it
                                  "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                                    endif
                                  
                                  "  call Dret("s:LocalBrowse")

FUNCTION  ctrlp#recordhist()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1649
Called 2 times
Total time:   0.018158000
 Self time:   0.000120000

count     total (s)      self (s)
    2                 0.000014000 	let str = join(s:prompt, '')
    2                 0.000012000 	if empty(str) || !s:maxhst | retu | en
    2                 0.000004000 	let hst = s:hstry
    2                 0.000015000 	if len(hst) > 1 && hst[1] == str | retu | en
    2                 0.000010000 	cal extend(hst, [str], 1)
    2                 0.000016000 	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
    2   0.018082000   0.000044000 	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])

FUNCTION  ctrlp#utils#fnesc()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:78
Called 25 times
Total time:   0.000931000
 Self time:   0.000931000

count     total (s)      self (s)
   25                 0.000053000 	if exists('*fnameescape')
   25                 0.000040000 		if exists('+ssl')
                                  			if a:type == 'c'
                                  				let path = escape(a:path, '%#')
                                  			elsei a:type == 'f'
                                  				let path = fnameescape(a:path)
                                  			elsei a:type == 'g'
                                  				let path = escape(a:path, '?*')
                                  			en
                                  			let path = substitute(path, '[', '[[]', 'g')
   25                 0.000013000 		el
   25                 0.000203000 			let path = fnameescape(a:path)
   25                 0.000013000 		en
                                  	el
                                  		if exists('+ssl')
                                  			if a:type == 'c'
                                  				let path = escape(a:path, '%#')
                                  			elsei a:type == 'f'
                                  				let path = escape(a:path, " \t\n%#*?|<\"")
                                  			elsei a:type == 'g'
                                  				let path = escape(a:path, '?*')
                                  			en
                                  			let path = substitute(path, '[', '[[]', 'g')
                                  		el
                                  			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                                  		en
   25                 0.000009000 	en
   25                 0.000076000 	retu a:0 ? escape(path, a:1) : path

FUNCTION  <SNR>34_ApplyCodeBlockSyntaxImpl()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:276
Called 40 times
Total time:   0.375603000
 Self time:   0.306328000

count     total (s)      self (s)
   40                 0.000163000   syntax_timer = -1
                                  
   40                 0.002631000   var lines: list<string> = getline(1, '$')
   40                 0.000008000   var in_code_block: bool = false
   40                 0.000027000   var current_lang: string = ''
   40                 0.000002000   var start_line: number = 0
   40                 0.000005000   var block_count: number = 0
                                  
   40                 0.000174000   for linenum in range(len(lines))
13905                 0.002486000     var line: string = lines[linenum]
                                  
13905                 0.040051000     if !in_code_block && line =~# '^```\s*\([a-zA-Z0-9_+-]\+\)$'
   50                 0.000013000       in_code_block = true
   50                 0.000947000       current_lang = matchstr(line, '^```\s*\zs[a-zA-Z0-9_+-]\+\ze$')
   50                 0.000036000       start_line = linenum + 1  # Start on next line
                                  
   50                 0.000003000     elseif in_code_block && line =~# '^```\s*$'
   50                 0.000013000       var end_line: number = linenum
                                  
   50                 0.000016000       if start_line < end_line
   50   0.058018000   0.000128000         HighlightCodeBlock(start_line, end_line, current_lang, block_count)
   50                 0.000020000         block_count += 1
   50                 0.000003000       endif
                                  
   50                 0.000010000       in_code_block = false
   50                 0.000019000       current_lang = ''
   50                 0.000004000     endif
13905                 0.000848000   endfor
   40                 0.265665000   redraw

FUNCTION  ale#path#FindExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:132
Called 36 times
Total time:   0.017413000
 Self time:   0.001415000

count     total (s)      self (s)
   36   0.001003000   0.000268000     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                          return ale#Var(a:buffer, a:base_var_name . '_executable')
   36                 0.000064000     endif
                                  
   36   0.014957000   0.000354000     let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                                  
   36                 0.000098000     if !empty(l:nearest)
                                          return l:nearest
   36                 0.000028000     endif
                                  
   36   0.000887000   0.000227000     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  21()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:350
Called 1491 times
Total time:   0.013162000
 Self time:   0.013162000

count     total (s)      self (s)
 1491                 0.002607000     if empty(self.pathSegments)
                                          return ''
 1491                 0.000675000     endif
 1491                 0.002585000     let toReturn = self.pathSegments[-1]
 1491                 0.001762000     if a:dirSlash && self.isDirectory
   83                 0.000116000         let toReturn = toReturn . '/'
 1491                 0.000710000     endif
 1491                 0.001276000     return toReturn

FUNCTION  22()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:363
Called 108 times
Total time:   0.008174000
 Self time:   0.005044000

count     total (s)      self (s)
  108                 0.000123000     let i = 0
  403                 0.000684000     while i < len(g:NERDTreeSortOrder)
  344   0.005839000   0.002709000         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
   49                 0.000040000             return i
  295                 0.000139000         endif
  295                 0.000319000         let i = i + 1
  354                 0.000202000     endwhile
                                  
   59                 0.000114000     return index(g:NERDTreeSortOrder, '*')

FUNCTION  24()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:393
Called 760 times
Total time:   0.048291000
 Self time:   0.039194000

count     total (s)      self (s)
  760                 0.001776000     if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                          " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
  108                 0.000110000         let metadata = []
  648                 0.000549000         for tag in g:NERDTreeSortOrder
  540                 0.001317000             if tag =~? '\[\[-\?timestamp\]\]'
                                                  let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
  540                 0.001150000             elseif tag =~? '\[\[-\?size\]\]'
                                                  let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
  540                 0.001288000             elseif tag =~? '\[\[extension\]\]'
                                                  let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
                                                  let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
  540                 0.000254000             endif
  648                 0.000387000         endfor
                                  
  108                 0.000307000         if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
                                              " Apply tags' sorting first if specified first.
                                              let self._sortKey = metadata + [self.getSortOrderIndex()]
  108                 0.000070000         else
                                              " Otherwise, do regex grouping first.
  108   0.008579000   0.000405000             let self._sortKey = [self.getSortOrderIndex()] + metadata
  108                 0.000055000         endif
                                  
  108   0.001192000   0.000269000         let path = self.getLastPathComponent(0)
  108                 0.000117000         if !g:NERDTreeSortHiddenFirst
                                              let path = substitute(path, '^[._]', '', '')
  108                 0.000060000         endif
  108                 0.000104000         if !g:NERDTreeCaseSensitiveSort
  108                 0.000198000             let path = tolower(path)
  108                 0.000057000         endif
                                  
  108                 0.000412000         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
  760                 0.000326000     endif
  760                 0.000640000     return self._sortKey

FUNCTION  26()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:451
Called 418 times
Total time:   0.004828000
 Self time:   0.001439000

count     total (s)      self (s)
  418   0.004726000   0.001337000     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  28()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:472
Called 418 times
Total time:   0.035738000
 Self time:   0.013245000

count     total (s)      self (s)
                                      "filter out the user specified paths to ignore
  418   0.001269000   0.000738000     if a:nerdtree.ui.isIgnoreFilterEnabled()
  836                 0.000791000         for i in g:NERDTreeIgnore
  418   0.015285000   0.001082000             if self._ignorePatternMatches(i)
                                                  return 1
  418                 0.000194000             endif
  836                 0.000457000         endfor
                                  
  418   0.003031000   0.000942000         for l:Callback in g:NERDTree.PathFilters()
                                              let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                              if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                                 return 1
                                              endif
  418                 0.000256000         endfor
  418                 0.000199000     endif
                                  
                                      "dont show hidden files unless instructed to
  418   0.006799000   0.001510000     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   78                 0.000051000         return 1
  340                 0.000140000     endif
                                  
  340   0.001199000   0.000818000     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                          return 1
  340                 0.000139000     endif
                                  
  340                 0.000228000     return 0

FUNCTION  29()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:503
Called 418 times
Total time:   0.014203000
 Self time:   0.010486000

count     total (s)      self (s)
  418                 0.000492000     let pat = a:pattern
  418                 0.001188000     if strpart(pat,len(pat)-8) ==# '[[path]]'
                                          let pat = strpart(pat,0, len(pat)-8)
                                          return self.str() =~# pat
  418                 0.001148000     elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                          if !self.isDirectory
                                              return 0
                                          endif
                                          let pat = strpart(pat,0, len(pat)-7)
  418                 0.001102000     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                          if self.isDirectory
                                              return 0
                                          endif
                                          let pat = strpart(pat,0, len(pat)-8)
  418                 0.000188000     endif
                                  
  418   0.005156000   0.001439000     return self.getLastPathComponent(0) =~# pat

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:181
Called 101 times
Total time:   0.024915000
 Self time:   0.001759000

count     total (s)      self (s)
  101   0.012453000   0.001004000   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
  101   0.012341000   0.000634000   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>114_TemporaryFilename()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:132
Called 131 times
Total time:   0.007951000
 Self time:   0.004015000

count     total (s)      self (s)
  131                 0.000822000     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                                  
  131                 0.000304000     if empty(l:filename)
                                          " If the buffer's filename is empty, create a dummy filename.
                                          let l:ft = getbufvar(a:buffer, '&filetype')
                                          let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
  131                 0.000095000     endif
                                  
                                      " Create a temporary filename, <temp_dir>/<original_basename>
                                      " The file itself will not be created by this function.
  131   0.005392000   0.001456000     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  113()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 113 times
Total time:   0.004010000
 Self time:   0.000428000

count     total (s)      self (s)
  113   0.003987000   0.000405000     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  114()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 153 times
Total time:   0.021611000
 Self time:   0.000720000

count     total (s)      self (s)
  153   0.021565000   0.000674000     return self.path.str() ==# a:treenode.path.str()

FUNCTION  115()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:112
Called 7 times
Total time:   0.001895000
 Self time:   0.000080000

count     total (s)      self (s)
    7   0.001874000   0.000059000     if a:path.equals(self.path)
    4                 0.000005000         return self
    3                 0.000002000     endif
    3                 0.000003000     return {}

FUNCTION  117()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 808 times
Total time:   0.000951000
 Self time:   0.000951000

count     total (s)      self (s)
  808                 0.000743000     return self._nerdtree

FUNCTION  119()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:173
Called 12 times
Total time:   0.099078000
 Self time:   0.000716000

count     total (s)      self (s)
                                  
   12                 0.000043000     try
   12   0.025517000   0.000265000         let l:path = b:NERDTree.ui.getPath(line('.'))
                                  
   12                 0.000040000         if empty(l:path)
                                              return {}
   12                 0.000011000         endif
                                  
   12   0.073301000   0.000191000         return b:NERDTree.root.findNode(l:path)
                                      catch
                                          return {}
   12                 0.000034000     endtry

FUNCTION  <SNR>167_mtype()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2180
Called 2 times
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    2                 0.000006000 	retu s:itemtype > 2 ? s:getextvar('type') : 'path'

FUNCTION  nerdtree#compareNodes()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:102
Called 380 times
Total time:   0.061077000
 Self time:   0.001132000

count     total (s)      self (s)
  380   0.061001000   0.001056000     return nerdtree#compareNodePaths(a:n1.path, a:n2.path)

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:144
Called 131 times
Total time:   0.000879000
 Self time:   0.000879000

count     total (s)      self (s)
  131                 0.000400000     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                          throw 'Invalid mode: ' . a:options.mode
  131                 0.000084000     endif

FUNCTION  modes#TrackOperator()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:25
Called 11 times
Total time:   0.003990000
 Self time:   0.002260000

count     total (s)      self (s)
   11                 0.000075000   if op ==# 'yank'
    1                 0.000003000     g:modes_pending_operator = 'yank'
    1   0.000205000   0.000031000     var ctbg = color.ComputeBlendedColorCterm(g:modes_colors.yank.term, cterm_blend)
    1   0.000077000   0.000011000     var gbg = color.ComputeBlendedColor(g:modes_colors.yank.gui, gui_blend)
    1                 0.000141000     execute $'highlight CursorLine guibg={gbg} ctermbg={ctbg}'
                                      return 'y'
                                    elseif op ==# 'delete'
    6                 0.000033000     g:modes_pending_operator = 'delete'
    6   0.001246000   0.000423000     var ctbg = color.ComputeBlendedColorCterm(g:modes_colors.delete.term, cterm_blend)
    6   0.001027000   0.000744000     execute $'highlight CursorLine guibg={color.ComputeBlendedColor(g:modes_colors.delete.gui, gui_blend)} ctermbg={ctbg}'
                                      return 'd'
                                    elseif op ==# 'replace'
    4                 0.000009000     g:modes_pending_operator = 'replace'
    4   0.000839000   0.000455000     execute $'highlight CursorLine guibg={color.ComputeBlendedColor(g:modes_colors.replace.gui, gui_blend)} cterm=underline ctermul={g:modes_colors.replace.term}'
                                      return 'r'
                                    endif
                                    return ''

FUNCTION  ag#Ag()
    Defined: ~/.vim/bundle/ag.vim/autoload/ag.vim:75
Called 1 time
Total time:   0.089931000
 Self time:   0.018044000

count     total (s)      self (s)
    1                 0.000017000   let l:ag_executable = get(split(g:ag_prg, " "), 0)
                                  
                                    " Ensure that `ag` is installed
    1                 0.000094000   if !executable(l:ag_executable)
                                      echoe "Ag command '" . l:ag_executable . "' was not found. Is the silver searcher installed and on your $PATH?"
                                      return
    1                 0.000001000   endif
                                  
                                    " If no pattern is provided, search for the word under the cursor
    1                 0.000004000   if empty(a:args)
                                      let l:grepargs = expand("<cword>")
    1                 0.000001000   else
    1                 0.000008000     let l:grepargs = a:args . join(a:000, ' ')
    1                 0.000001000   end
                                  
    1                 0.000003000   if empty(l:grepargs)
                                      echo "Usage: ':Ag {pattern}' (or just :Ag to search for the word under the cursor). See ':help :Ag' for more information."
                                      return
    1                 0.000001000   endif
                                  
                                    " Format, used to manage column jump
    1                 0.000005000   if a:cmd =~# '-g$'
                                      let s:ag_format_backup=g:ag_format
                                      let g:ag_format="%f"
    1                 0.000004000   elseif exists("s:ag_format_backup")
                                      let g:ag_format=s:ag_format_backup
    1                 0.000004000   elseif !exists("g:ag_format")
    1                 0.000002000     let g:ag_format="%f:%l:%c:%m"
    1                 0.000001000   endif
                                  
    1                 0.000005000   let l:grepprg_bak=&grepprg
    1                 0.000003000   let l:grepformat_bak=&grepformat
    1                 0.000004000   let l:t_ti_bak=&t_ti
    1                 0.000003000   let l:t_te_bak=&t_te
    1                 0.000002000   try
    1   0.000021000   0.000015000     let &grepprg=g:ag_prg
    1   0.000010000   0.000005000     let &grepformat=g:ag_format
    1   0.000026000   0.000025000     set t_ti=
    1   0.000009000   0.000008000     set t_te=
    1                 0.000004000     if g:ag_working_path_mode ==? 'r' " Try to find the projectroot for current buffer
                                        let l:cwd_back = getcwd()
                                        let l:cwd = s:guessProjectRoot()
                                        try
                                          exe "lcd ".l:cwd
                                        catch
                                          echom 'Failed to change directory to:'.l:cwd
                                        finally
                                          silent! execute a:cmd . " " . escape(l:grepargs, '|')
                                          exe "lcd ".l:cwd_back
                                        endtry
    1                 0.000001000     else " Someone chose an undefined value or 'c' so we revert to the default
    1   0.067004000   0.001002000       silent! execute a:cmd . " " . escape(l:grepargs, '|')
    1                 0.000000000     endif
    1                 0.000001000   finally
    1   0.000012000   0.000010000     let &grepprg=l:grepprg_bak
    1   0.000005000   0.000003000     let &grepformat=l:grepformat_bak
    1   0.000010000   0.000009000     let &t_ti=l:t_ti_bak
    1   0.000005000   0.000004000     let &t_te=l:t_te_bak
    1                 0.000001000   endtry
                                  
    1                 0.000002000   if a:cmd =~# '^l'
                                      let l:match_count = len(getloclist(winnr()))
    1                 0.000001000   else
    1                 0.000022000     let l:match_count = len(getqflist())
    1                 0.000001000   endif
                                  
    1                 0.000002000   if a:cmd =~# '^l' && l:match_count
                                      exe g:ag_lhandler
                                      let l:apply_mappings = g:ag_apply_lmappings
                                      let l:matches_window_prefix = 'l' " we're using the location list
    1                 0.000000000   elseif l:match_count
    1   0.006046000   0.000180000     exe g:ag_qhandler
    1                 0.000002000     let l:apply_mappings = g:ag_apply_qmappings
    1                 0.000002000     let l:matches_window_prefix = 'c' " we're using the quickfix window
    1                 0.000000000   endif
                                  
                                    " If highlighting is on, highlight the search keyword.
    1                 0.000001000   if exists('g:ag_highlight')
                                      let @/ = matchstr(a:args, "\\v(-)\@<!(\<)\@<=\\w+|['\"]\\zs.{-}\\ze['\"]")
                                      call feedkeys(":let &hlsearch=1 \| echo \<CR>", 'n')
    1                 0.000000000   end
                                  
    1                 0.016450000   redraw!
                                  
    1                 0.000002000   if l:match_count
    1                 0.000001000     if l:apply_mappings
    1                 0.000005000       nnoremap <silent> <buffer> h  <C-W><CR><C-w>K
    1                 0.000002000       nnoremap <silent> <buffer> H  <C-W><CR><C-w>K<C-w>b
    1                 0.000001000       nnoremap <silent> <buffer> o  <CR>
    1                 0.000002000       nnoremap <silent> <buffer> t  <C-w><CR><C-w>T
    1                 0.000002000       nnoremap <silent> <buffer> T  <C-w><CR><C-w>TgT<C-W><C-W>
    1                 0.000002000       nnoremap <silent> <buffer> v  <C-w><CR><C-w>H<C-W>b<C-W>J<C-W>t
                                  
    1                 0.000004000       exe 'nnoremap <silent> <buffer> e <CR><C-w><C-w>:' . l:matches_window_prefix .'close<CR>'
    1                 0.000003000       exe 'nnoremap <silent> <buffer> go <CR>:' . l:matches_window_prefix . 'open<CR>'
    1                 0.000002000       exe 'nnoremap <silent> <buffer> q  :' . l:matches_window_prefix . 'close<CR>'
                                  
    1                 0.000007000       exe 'nnoremap <silent> <buffer> gv :let b:height=winheight(0)<CR><C-w><CR><C-w>H:' . l:matches_window_prefix . 'open<CR><C-w>J:exe printf(":normal %d\<lt>c-w>_", b:height)<CR>'
                                        " Interpretation:
                                        " :let b:height=winheight(0)<CR>                      Get the height of the quickfix/location list window
                                        " <CR><C-w>                                           Open the current item in a new split
                                        " <C-w>H                                              Slam the newly opened window against the left edge
                                        " :copen<CR> -or- :lopen<CR>                          Open either the quickfix window or the location list (whichever we were using)
                                        " <C-w>J                                              Slam the quickfix/location list window against the bottom edge
                                        " :exe printf(":normal %d\<lt>c-w>_", b:height)<CR>   Restore the quickfix/location list window's height from before we opened the match
                                  
    1                 0.000001000       if g:ag_mapping_message && l:apply_mappings
    1                 0.000014000         echom "ag.vim keys: q=quit <cr>/e/t/h/v=enter/edit/tab/split/vsplit go/T/H/gv=preview versions of same"
    1                 0.000000000       endif
    1                 0.000001000     endif
                                    else " Close the split window automatically:
                                      cclose
                                      lclose
                                      echohl WarningMsg
                                      echom 'No matches for "'.a:args.'"'
                                      echohl None
    1                 0.000001000   endif

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:28
Called 131 times
Total time:   0.003704000
 Self time:   0.003704000

count     total (s)      self (s)
  131                 0.001094000     let l:found = 0
                                  
  131                 0.000641000     for l:other_linter in a:info.active_linter_list
                                          if l:other_linter.name is# a:linter.name
                                              let l:found = 1
                                              break
                                          endif
  131                 0.000167000     endfor
                                  
  131                 0.000163000     if !l:found
  131                 0.000387000         call add(a:info.active_linter_list, a:linter)
  131                 0.000077000     endif

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:37
Called 36 times
Total time:   0.011994000
 Self time:   0.011994000

count     total (s)      self (s)
   36                 0.002986000     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   36                 0.000769000     let l:buffer_filename = fnameescape(l:buffer_filename)
                                  
   36                 0.007682000     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                                  
   36                 0.000142000     if !empty(l:relative_path)
                                          return fnamemodify(l:relative_path, ':p')
   36                 0.000034000     endif
                                  
   36                 0.000058000     return ''

FUNCTION  33()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:575
Called 143 times
Total time:   0.037805000
 Self time:   0.002678000

count     total (s)      self (s)
  143   0.037739000   0.002612000     return nerdtree#pathEquals(self.str(), a:path.str())

FUNCTION  34()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:580
Called 125 times
Total time:   0.042681000
 Self time:   0.004474000

count     total (s)      self (s)
  125                 0.002615000     let l:newPath = copy(self)
                                  
  125   0.038002000   0.000783000     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                                  
  125                 0.000237000     let l:newPath.cachedDisplayString = ''
  125   0.001473000   0.000485000     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                                  
  125                 0.000137000     return l:newPath

FUNCTION  35()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:596
Called 255 times
Total time:   0.006743000
 Self time:   0.006743000

count     total (s)      self (s)
  255                 0.002877000     let tmp = resolve(a:path)
  255                 0.003724000     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  36()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:605
Called 125 times
Total time:   0.027583000
 Self time:   0.014920000

count     total (s)      self (s)
  125   0.003231000   0.000411000     call self.extractDriveLetter(a:fullpath)
                                  
  125   0.001718000   0.000464000     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                                  
  125                 0.001394000     if getftype(fullpath) ==# 'fifo'
                                          throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
  125                 0.000069000     endif
                                  
  125                 0.002289000     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                                  
  125                 0.000190000     let self.isReadOnly = 0
  125                 0.000637000     if isdirectory(a:fullpath)
   62                 0.000102000         let self.isDirectory = 1
   63                 0.002075000     elseif filereadable(a:fullpath)
   63                 0.000114000         let self.isDirectory = 0
   63                 0.001283000         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                      else
                                          throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
  125                 0.000072000     endif
                                  
  125                 0.000187000     let self.isExecutable = 0
  125                 0.000143000     if !self.isDirectory
   63                 0.000374000         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
  125                 0.000078000     endif
                                  
                                      "grab the last part of the path (minus the trailing slash)
  125   0.001969000   0.000481000     let lastPathComponent = self.getLastPathComponent(0)
                                  
                                      "get the path to the new node with the parent dir fully resolved
  125   0.004749000   0.000759000     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                                  
                                      "if  the last part of the path is a symlink then flag it as such
  125   0.003657000   0.000546000     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
  125                 0.000147000     if self.isSymLink
                                          let self.symLinkDest = s:Path.Resolve(fullpath)
                                  
                                          "if the link is a dir then slap a / on the end of its dest
                                          if isdirectory(self.symLinkDest)
                                  
                                              "we always wanna treat MS windows shortcuts as files for
                                              "simplicity
                                              if hardPath !~# '\.lnk$'
                                  
                                                  let self.symLinkDest = self.symLinkDest . '/'
                                              endif
                                          endif
  125                 0.000073000     endif

FUNCTION  modes#SetInsertModeCursorline()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:61
Called 48 times
Total time:   0.010302000
 Self time:   0.005646000

count     total (s)      self (s)
   48   0.006212000   0.001556000   var blended = color.ComputeBlendedColor(g:modes_colors.insert.gui, gui_blend)
   48                 0.003460000   execute $'highlight CursorLine guibg={blended} cterm=underline ctermul={g:modes_colors.insert.term}'

FUNCTION  <SNR>76_strip_trailing_new_line()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:249
Called 8 times
Total time:   0.000092000
 Self time:   0.000092000

count     total (s)      self (s)
    8                 0.000084000   return substitute(a:line, '[[:cntrl:]]$', '', '')

FUNCTION  ctrlp#mrufiles#cachefile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:133
Called 11 times
Total time:   0.000432000
 Self time:   0.000326000

count     total (s)      self (s)
   11                 0.000057000 	if !exists('s:cadir') || !exists('s:cafile')
    1   0.000276000   0.000171000 		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
    1   0.000003000   0.000002000 		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
   11                 0.000008000 	en
   11                 0.000015000 	retu s:cafile

FUNCTION  121()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 153 times
Total time:   0.023487000
 Self time:   0.001298000

count     total (s)      self (s)
  153   0.000718000   0.000330000     if !g:NERDTree.ExistsForBuf()
                                          throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  153                 0.000078000     endif
                                  
  153   0.022441000   0.000640000     return self.equals(self.getNerdtree().root)

FUNCTION  122()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:210
Called 108 times
Total time:   0.003000000
 Self time:   0.001542000

count     total (s)      self (s)
  108                 0.000112000     if a:path.isDirectory
   49   0.001634000   0.000176000         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
   59                 0.000040000     else
   59                 0.000643000         let newTreeNode = copy(self)
   59                 0.000108000         let newTreeNode.path = a:path
   59                 0.000108000         let newTreeNode.parent = {}
   59                 0.000091000         let newTreeNode._nerdtree = a:nerdtree
   59                 0.000061000         return newTreeNode
                                      endif

FUNCTION  123()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:223
Called 4 times
Total time:   0.194521000
 Self time:   0.000137000

count     total (s)      self (s)
    4                 0.000012000     let opts = a:0 ? a:1 : {}
    4   0.000365000   0.000050000     let opener = g:NERDTreeOpener.New(self.path, opts)
    4   0.194107000   0.000038000     call opener.open(self)

FUNCTION  128()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:262
Called 13 times
Total time:   0.006600000
 Self time:   0.000285000

count     total (s)      self (s)
   13   0.006366000   0.000051000     let ln = self.getNerdtree().ui.getLineNum(self)
   13                 0.000014000     if ln != -1
   13                 0.000010000         if a:isJump
                                              mark '
   13                 0.000005000         endif
   13                 0.000031000         call cursor(ln, col('.'))
                                      else
                                          if a:recurseUpward
                                              let node = self
                                              while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                                  let node = node.parent
                                                  call node.open()
                                              endwhile
                                              call self._nerdtree.render()
                                              call node.putCursorHere(a:isJump, 0)
                                          endif
   13                 0.000006000     endif

FUNCTION  <SNR>126_FixList()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:76
Called 175 times
Total time:   0.006454000
 Self time:   0.003610000

count     total (s)      self (s)
  175   0.002411000   0.000723000     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
  175                 0.000192000     let l:new_list = []
                                  
  213                 0.000216000     for l:item in a:list
   38                 0.000070000         let l:fixed_item = copy(l:item)
                                  
   38   0.001241000   0.000085000         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                                  
   38                 0.000027000         if l:item.bufnr == -1
                                              " If the buffer number is invalid, remove it.
                                              call remove(l:fixed_item, 'bufnr')
   38                 0.000013000         endif
                                  
   38                 0.000044000         call add(l:new_list, l:fixed_item)
  213                 0.000180000     endfor
                                  
  175                 0.000161000     return l:new_list

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:61
Called 168 times
Total time:   0.001737000
 Self time:   0.001737000

count     total (s)      self (s)
  168                 0.001278000     if !isdirectory(a:dir)
  168                 0.000203000         return
                                      endif
                                  
                                      if s:reuseWin(a:dir)
                                          return
                                      endif
                                  
                                      call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  ale#util#Writefile()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:432
Called 131 times
Total time:   0.072003000
 Self time:   0.072003000

count     total (s)      self (s)
  131                 0.001306000     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                                  
                                      " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
  131                 0.000828000     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                                  
  131                 0.069351000     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  copilot_chat#buffer#WelcomeMessage()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:195
Called 3 times
Total time:   0.000126000
 Self time:   0.000064000

count     total (s)      self (s)
    3                 0.000053000   appendbufline(g:copilot_chat_active_buffer, 0, 'Welcome to Copilot Chat! Type your message below:')
    3   0.000064000   0.000002000   AddInputSeparator()

FUNCTION  40()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:713
Called 1053 times
Total time:   0.107566000
 Self time:   0.058584000

count     total (s)      self (s)
 1053                 0.003115000     let options = a:0 ? a:1 : {}
 1053                 0.001508000     let toReturn = ''
                                  
 1053                 0.002623000     if has_key(options, 'format')
   57                 0.000122000         let format = options['format']
   57                 0.000182000         if has_key(self, '_strFor' . format)
   57   0.002202000   0.000416000             exec 'let toReturn = self._strFor' . format . '()'
                                          else
                                              throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
   57                 0.000041000         endif
  996                 0.000702000     else
  996   0.046348000   0.004501000         let toReturn = self._str()
 1053                 0.000763000     endif
                                  
 1053   0.008122000   0.003809000     if nerdtree#has_opt(options, 'escape')
                                          let toReturn = shellescape(toReturn)
 1053                 0.000703000     endif
                                  
 1053                 0.002265000     if has_key(options, 'truncateTo')
   13                 0.000020000         let limit = options['truncateTo']
   13                 0.000043000         if strdisplaywidth(toReturn) > limit-1
  312                 0.000919000             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
  299                 0.000864000                 let toReturn = substitute(toReturn, '^.', '', '')
  312                 0.000155000             endwhile
   13                 0.000073000             if len(split(toReturn, '/')) > 1
   13                 0.000089000                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                              else
                                                  let toReturn = '<' . toReturn
   13                 0.000005000             endif
   13                 0.000007000         endif
 1053                 0.000666000     endif
                                  
 1053                 0.001268000     return toReturn

FUNCTION  41()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:750
Called 41 times
Total time:   0.000553000
 Self time:   0.000553000

count     total (s)      self (s)
   41                 0.000258000     let toReturn = '/' . join(self.pathSegments, '/')
   41                 0.000090000     if self.isDirectory && toReturn !=# '/'
   41                 0.000080000         let toReturn  = toReturn . '/'
   41                 0.000028000     endif
   41                 0.000046000     return toReturn

FUNCTION  43()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:768
Called 4 times
Total time:   0.000791000
 Self time:   0.000250000

count     total (s)      self (s)
                                  
                                      " Make the path relative to the current working directory, if possible.
    4   0.000634000   0.000124000     let l:result = fnamemodify(self.str(), ':.')
                                  
                                      " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                      " back, if necessary.
    4   0.000054000   0.000023000     if nerdtree#runningWindows() && l:result[0] == nerdtree#slash()
                                          let l:result = self.drive . l:result
    4                 0.000003000     endif
                                  
    4                 0.000042000     let l:result = fnameescape(l:result)
                                  
    4                 0.000009000     if empty(l:result)
                                          let l:result = '.'
    4                 0.000001000     endif
                                  
    4                 0.000005000     return l:result

FUNCTION  44()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:789
Called 12 times
Total time:   0.001233000
 Self time:   0.000509000

count     total (s)      self (s)
   12   0.000247000   0.000039000     let lead = nerdtree#slash()
                                  
                                      "if we are running windows then slap a drive letter on the front
   12   0.000104000   0.000029000     if nerdtree#runningWindows()
                                          let lead = self.drive . '\'
   12                 0.000007000     endif
                                  
   12   0.000251000   0.000070000     let toReturn = lead . join(self.pathSegments, nerdtree#slash())
                                  
   12   0.000106000   0.000034000     if !nerdtree#runningWindows()
   12   0.000433000   0.000245000         let toReturn = escape(toReturn, self._escChars())
   12                 0.000008000     endif
   12                 0.000014000     return toReturn

FUNCTION  45()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:808
Called 996 times
Total time:   0.041847000
 Self time:   0.017928000

count     total (s)      self (s)
  996   0.021450000   0.003774000     let l:separator = nerdtree#slash()
  996                 0.001905000     let l:leader = l:separator
                                  
  996   0.008877000   0.002634000     if nerdtree#runningWindows()
                                          let l:leader = self.drive . l:separator
  996                 0.000682000     endif
                                  
  996                 0.005728000     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  46()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:821
Called 125 times
Total time:   0.000816000
 Self time:   0.000816000

count     total (s)      self (s)
  125                 0.000755000     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  47()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:829
Called 4 times
Total time:   0.002476000
 Self time:   0.002099000

count     total (s)      self (s)
    4   0.000394000   0.000017000     let str = self.str()
   16                 0.000037000     for t in range(tabpagenr('$'))
   43                 0.000080000         for b in tabpagebuflist(t+1)
   31                 0.001737000             if str ==# expand('#' . b . ':p')
                                                  return t+1
   31                 0.000022000             endif
   43                 0.000029000         endfor
   16                 0.000012000     endfor
    4                 0.000007000     return 0

FUNCTION  48()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim:848
Called 125 times
Total time:   0.001254000
 Self time:   0.000590000

count     total (s)      self (s)
  125   0.001005000   0.000341000     if !nerdtree#runningWindows()
  125                 0.000149000         return a:pathstr
                                      endif
                                  
                                      let toReturn = a:pathstr
                                  
                                      "remove the x:\ of the front
                                      let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                                  
                                      "remove the \\ network share from the front
                                      let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                                  
                                      "convert all \ chars to /
                                      let toReturn = substitute(toReturn, '\', '/', 'g')
                                  
                                      return toReturn

FUNCTION  modes#color#GetNormalBgColor()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes/color.vim:3
Called 92 times
Total time:   0.004772000
 Self time:   0.004772000

count     total (s)      self (s)
   92                 0.004061000   var hlid = hlID('Normal')
                                    # Resolve any links
   92                 0.000146000   hlid = synIDtrans(hlid)
                                    # Get the background color in #RRGGBB format
                                    return synIDattr(hlid, 'bg#')

FUNCTION  <SNR>167_GlobPath()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:372
Called 4 times
Total time:   0.072515000
 Self time:   0.051106000

count     total (s)      self (s)
    4                 0.001685000 	let entries = split(globpath(a:dirs, s:glob), "\n")
    4   0.001983000   0.000020000 	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
    4                 0.000009000 	cal extend(g:ctrlp_allfiles, dnf[1])
    4   0.000025000   0.000020000 	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
    3   0.051122000   0.000013000 		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
    3   0.000296000   0.000041000 		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
    4                 0.000001000 	en

FUNCTION  132()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 13 times
Total time:   0.072419000
 Self time:   0.000063000

count     total (s)      self (s)
   13   0.072407000   0.000051000     return self._renderToString(0, 0)

FUNCTION  133()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 217 times
Total time:   0.137662000
 Self time:   0.112562000

count     total (s)      self (s)
  217                 0.000209000     let output = ''
  217                 0.000190000     if a:drawText ==# 1
                                  
  204                 0.000408000         let treeParts = repeat('  ', a:depth - 1)
  204                 0.000583000         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                                  
  204   0.031358000   0.000613000         let line = treeParts . self.displayString()
  204                 0.000318000         let output = output . line . "\n"
  217                 0.000105000     endif
                                  
                                      " if the node is an open dir, draw its children
  217                 0.000305000     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                                  
   28   0.025389000   0.000080000         let childNodesToDraw = self.getVisibleChildren()
                                  
   28   0.009325000   0.000075000         if self.isCascadable() && a:depth > 0
                                  
                                              let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                                  
   28                 0.000055000         elseif len(childNodesToDraw) > 0
  232                 0.000155000             for i in childNodesToDraw
  204                 0.000601000                 let output = output . i._renderToString(a:depth + 1, 1)
  232                 0.000118000             endfor
   28                 0.000016000         endif
  217                 0.000078000     endif
                                  
  217                 0.000197000     return output

FUNCTION  135()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:24
Called 8 times
Total time:   0.216736000
 Self time:   0.000232000

count     total (s)      self (s)
    8                 0.000028000     let l:options = (a:0 > 0) ? a:1 : {}
                                  
    8   0.150072000   0.000061000     call self.toggleOpen(l:options)
                                  
                                      " Note that we only re-render the NERDTree for this node if we did NOT
                                      " create a new node and render it in a new window or tab.  In the latter
                                      " case, rendering the NERDTree for this node could overwrite the text of
                                      " the new NERDTree!
    8                 0.000028000     if !has_key(l:options, 'where') || empty(l:options['where'])
    8   0.060669000   0.000036000         call self.getNerdtree().render()
    8   0.005883000   0.000023000         call self.putCursorHere(0, 0)
    8                 0.000003000     endif

FUNCTION  136()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:45
Called 108 times
Total time:   0.000847000
 Self time:   0.000847000

count     total (s)      self (s)
  108                 0.000255000     call add(self.children, a:treenode)
  108                 0.000173000     let a:treenode.parent = self
                                  
  108                 0.000093000     if a:inOrder
                                          call self.sortChildren()
  108                 0.000054000     endif

FUNCTION  137()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:56
Called 1 time
Total time:   0.000620000
 Self time:   0.000013000

count     total (s)      self (s)
                                  
                                      " Close all directories in this directory node's cascade. This is
                                      " necessary to ensure consistency when cascades are rendered.
    2   0.000612000   0.000005000     for l:dirNode in self.getCascade()
    1                 0.000003000         let l:dirNode.isOpen = 0
    2                 0.000002000     endfor

FUNCTION  139()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:86
Called 108 times
Total time:   0.004991000
 Self time:   0.001010000

count     total (s)      self (s)
  108   0.003682000   0.000548000     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
  108   0.001150000   0.000303000     call self.addChild(newTreeNode, a:inOrder)
  108                 0.000098000     return newTreeNode

FUNCTION  copilot_chat#config#GetValue()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/config.vim:26
Called 7 times
Total time:   0.000019000
 Self time:   0.000019000

count     total (s)      self (s)
                                    return get(config, key, default)

FUNCTION  <SNR>152_DetectFromText()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/script.vim:243
Called 7 times
Total time:   0.002354000
 Self time:   0.002354000

count     total (s)      self (s)
    7                 0.000005000   var line2 = getline(2)
    7                 0.000003000   var line3 = getline(3)
    7                 0.000002000   var line4 = getline(4)
    7                 0.000002000   var line5 = getline(5)
                                  
                                    # Bourne-like shell scripts: sh ksh bash bash2
    7                 0.002117000   if line1 =~ '^:$'
                                      call dist#ft#SetFileTypeSH(line1)
                                  
                                    # Z shell scripts
                                    elseif line1 =~ '^#compdef\>'
                                        || line1 =~ '^#autoload\>'
                                        || "\n" .. line1 .. "\n" .. line2 .. "\n" .. line3 ..
                                  	 "\n" .. line4 .. "\n" .. line5
                                  	 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                      setl ft=zsh
                                  
                                    # ELM Mail files
                                    elseif line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                      setl ft=mail
                                  
                                    # Mason
                                    elseif line1 =~ '^<[%&].*>'
                                      setl ft=mason
                                  
                                    # Vim scripts (must have '" vim' as the first line to trigger this)
                                    elseif line1 =~ '^" *[vV]im$'
                                      setl ft=vim
                                  
                                    # libcxx and libstdc++ standard library headers like "iostream" do not have
                                    # an extension, recognize the Emacs file mode.
                                    elseif line1 =~? '-\*-.*C++.*-\*-'
                                      setl ft=cpp
                                  
                                    # MOO
                                    elseif line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                      setl ft=moo
                                  
                                      # Diff file:
                                      # - "diff" in first line (context diff)
                                      # - "Only in " in first line
                                      # - "--- " in first line and "+++ " in second line (unified diff).
                                      # - "*** " in first line and "--- " in second line (context diff).
                                      # - "# It was generated by makepatch " in the second line (makepatch diff).
                                      # - "Index: <filename>" in the first line (CVS file)
                                      # - "=== ", line of "=", "---", "+++ " (SVK diff)
                                      # - "=== ", "--- ", "+++ " (bzr diff, common case)
                                      # - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                      # - "# HG changeset patch" in first line (Mercurial export format)
                                    elseif line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                                  	 || (line1 =~ '^--- ' && line2 =~ '^+++ ')
                                  	 || (line1 =~ '^\* looking for ' && line2 =~ '^\* comparing to ')
                                  	 || (line1 =~ '^\*\*\* ' && line2 =~ '^--- ')
                                  	 || (line1 =~ '^=== ' && ((line2 =~ '^=\{66\}' && line3 =~ '^--- ' && line4 =~ '^+++') || (line2 =~ '^--- ' && line3 =~ '^+++ ')))
                                  	 || (line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                      setl ft=diff
                                  
                                      # PostScript Files (must have %!PS as the first line, like a2ps output)
                                    elseif line1 =~ '^%![ \t]*PS'
                                      setl ft=postscr
                                  
                                      # M4 scripts: Guess there is a line that starts with "dnl".
                                    elseif line1 =~ '^\s*dnl\>'
                                  	 || line2 =~ '^\s*dnl\>'
                                  	 || line3 =~ '^\s*dnl\>'
                                  	 || line4 =~ '^\s*dnl\>'
                                  	 || line5 =~ '^\s*dnl\>'
                                      setl ft=m4
                                  
                                      # AmigaDos scripts
                                    elseif $TERM == "amiga" && (line1 =~ "^;" || line1 =~? '^\.bra')
                                      setl ft=amiga
                                  
                                      # SiCAD scripts (must have procn or procd as the first line to trigger this)
                                    elseif line1 =~? '^ *proc[nd] *$'
                                      setl ft=sicad
                                  
                                      # Purify log files start with "****  Purify"
                                    elseif line1 =~ '^\*\*\*\*  Purify'
                                      setl ft=purifylog
                                  
                                      # XML
                                    elseif line1 =~ '<?\s*xml.*?>'
                                      setl ft=xml
                                  
                                      # XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                                    elseif line1 =~ '\<DTD\s\+XHTML\s'
                                      setl ft=xhtml
                                  
                                      # HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                      # Avoid "doctype html", used by slim.
                                    elseif line1 =~? '<!DOCTYPE\s\+html\>'
                                      setl ft=html
                                  
                                      # PDF
                                    elseif line1 =~ '^%PDF-'
                                      setl ft=pdf
                                  
                                      # XXD output
                                    elseif line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                      setl ft=xxd
                                  
                                      # RCS/CVS log output
                                    elseif line1 =~ '^RCS file:' || line2 =~ '^RCS file:'
                                      setl ft=rcslog
                                  
                                      # CVS commit
                                    elseif line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                      setl ft=cvs
                                  
                                      # Prescribe
                                    elseif line1 =~ '^!R!'
                                      setl ft=prescribe
                                  
                                      # Send-pr
                                    elseif line1 =~ '^SEND-PR:'
                                      setl ft=sendpr
                                  
                                      # SNNS files
                                    elseif line1 =~ '^SNNS network definition file'
                                      setl ft=snnsnet
                                    elseif line1 =~ '^SNNS pattern definition file'
                                      setl ft=snnspat
                                    elseif line1 =~ '^SNNS result file'
                                      setl ft=snnsres
                                  
                                      # Virata
                                    elseif line1 =~ '^%.\{-}[Vv]irata'
                                  	 || line2 =~ '^%.\{-}[Vv]irata'
                                  	 || line3 =~ '^%.\{-}[Vv]irata'
                                  	 || line4 =~ '^%.\{-}[Vv]irata'
                                  	 || line5 =~ '^%.\{-}[Vv]irata'
                                      setl ft=virata
                                  
                                      # Strace
                                      # inaccurate fast match first, then use accurate slow match
                                    elseif (line1 =~ 'execve(' && line1 =~ '^[0-9:. ]*execve(')
                                  	   || line1 =~ '^__libc_start_main'
                                      setl ft=strace
                                  
                                      # VSE JCL
                                    elseif line1 =~ '^\* $$ JOB\>' || line1 =~ '^// *JOB\>'
                                      setl ft=vsejcl
                                  
                                      # TAK and SINDA
                                    elseif line4 =~ 'K & K  Associates' || line2 =~ 'TAK 2000'
                                      setl ft=takout
                                    elseif line3 =~ 'S Y S T E M S   I M P R O V E D '
                                      setl ft=sindaout
                                    elseif getline(6) =~ 'Run Date: '
                                      setl ft=takcmp
                                    elseif getline(9) =~ 'Node    File  1'
                                      setl ft=sindacmp
                                  
                                      # DNS zone files
                                    elseif line1 .. line2 .. line3 .. line4 =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                      setl ft=bindzone
                                  
                                      # BAAN
                                    elseif line1 =~ '|\*\{1,80}' && line2 =~ 'VRC '
                                  	 || line2 =~ '|\*\{1,80}' && line3 =~ 'VRC '
                                      setl ft=baan
                                  
                                      # Valgrind
                                    elseif line1 =~ '^==\d\+== valgrind' || line3 =~ '^==\d\+== Using valgrind'
                                      setl ft=valgrind
                                  
                                      # Go docs
                                    elseif line1 =~ '^PACKAGE DOCUMENTATION$'
                                      setl ft=godoc
                                  
                                      # Renderman Interface Bytestream
                                    elseif line1 =~ '^##RenderMan'
                                      setl ft=rib
                                  
                                      # Scheme scripts
                                    elseif line1 =~ 'exec\s\+\S*scheme' || line2 =~ 'exec\s\+\S*scheme'
                                      setl ft=scheme
                                  
                                      # Git output
                                    elseif line1 =~ '^\(commit\|tree\|object\) \x\{40,\}\>\|^tag \S\+$'
                                      setl ft=git
                                  
                                      # Gprof (gnu profiler)
                                    elseif line1 == 'Flat profile:'
                                  	&& line2 == ''
                                  	&& line3 =~ '^Each sample counts as .* seconds.$'
                                      setl ft=gprof
                                  
                                      # Erlang terms
                                      # (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                                    elseif line1 =~? '-\*-.*erlang.*-\*-'
                                      setl ft=erlang
                                  
                                      # YAML
                                    elseif line1 =~ '^%YAML'
                                      setl ft=yaml
                                  
                                      # MikroTik RouterOS script
                                    elseif line1 =~ '^#.*by RouterOS.*$'
                                      setl ft=routeros
                                  
                                      # Sed scripts
                                      # #ncomment is allowed but most likely a false positive so require a space
                                      # before any trailing comment text
                                    elseif line1 =~ '^#n\%($\|\s\)'
                                      setl ft=sed
                                  
                                    else
    7                 0.000004000     var lnum = 1
    7                 0.000015000     while getline(lnum) =~ "^? " && lnum < line("$")
                                        lnum += 1
                                      endwhile
    7                 0.000153000     if getline(lnum) =~ '^Index:\s\+\f\+$'
                                        # CVS diff
                                        setl ft=diff
                                  
                                        # locale input files: Formal Definitions of Cultural Conventions
                                        # filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                      elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                        lnum = 1
                                        while lnum < 100 && lnum < line("$")
                                  	if getline(lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                                  	  setf fdcc
                                  	  break
                                  	endif
                                  	lnum += 1
                                        endwhile
                                      endif
    7                 0.000002000   endif

FUNCTION  <SNR>167_nocache()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2149
Called 2 times
Total time:   0.000034000
 Self time:   0.000034000

count     total (s)      self (s)
    2                 0.000004000 	if !s:caching
                                  		retu 1
    2                 0.000002000 	elsei s:caching > 1
                                  		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                                  			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                                  		elsei a:0 && filereadable(a:1)
                                  			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                                  		en
                                  		retu 1
    2                 0.000001000 	en
    2                 0.000002000 	retu 0

FUNCTION  <SNR>41_add_menu()
    Defined: ~/.vim/bundle/open-browser.vim/plugin/openbrowser.vim:62
Called 1 time
Total time:   0.000128000
 Self time:   0.000128000

count     total (s)      self (s)
    1                 0.000007000     if get(g:, 'openbrowser_menu_lang',      &langmenu isnot# '' ? &langmenu : v:lang) =~# '^ja'
                                        runtime! lang/openbrowser_menu_ja.vim
    1                 0.000001000     endif
                                  
    1                 0.000025000     nnoremenu PopUp.-OpenBrowserSep- <Nop>
    1                 0.000010000     xnoremenu PopUp.-OpenBrowserSep- <Nop>
    1                 0.000017000     nmenu <silent> PopUp.Open\ URL <Plug>(openbrowser-open)
    1                 0.000009000     xmenu <silent> PopUp.Open\ URL <Plug>(openbrowser-open)
    1                 0.000020000     nmenu <silent> PopUp.Open\ Word(s) <Plug>(openbrowser-search)
    1                 0.000010000     xmenu <silent> PopUp.Open\ Word(s) <Plug>(openbrowser-search)
    1                 0.000017000     nmenu <silent> PopUp.Open\ URL\ or\ Word(s) <Plug>(openbrowser-smart-search)
    1                 0.000010000     xmenu <silent> PopUp.Open\ URL\ or\ Word(s) <Plug>(openbrowser-smart-search)

FUNCTION  ale#linter#Define()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:260
Called 8 times
Total time:   0.001231000
 Self time:   0.000126000

count     total (s)      self (s)
                                      " This command will throw from the sandbox.
    8                 0.000015000     let &l:equalprg=&l:equalprg
                                  
    8   0.001137000   0.000032000     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                                  
    8                 0.000013000     if !has_key(s:linters, a:filetype)
    2                 0.000003000         let s:linters[a:filetype] = []
    8                 0.000002000     endif
                                  
                                      " Remove previously defined linters with the same name.
    8                 0.000031000     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
    8                 0.000017000     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  <SNR>76_use_known_shell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:194
Called 1 time
Total time:   0.000037000
 Self time:   0.000033000

count     total (s)      self (s)
    1                 0.000003000   if has('unix') && &shell !=# 'sh'
    1                 0.000006000     let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
    1   0.000015000   0.000012000     let &shell = 'sh'
    1   0.000005000   0.000004000     set shellcmdflag=-c shellredir=>%s\ 2>&1
    1                 0.000000000   endif
    1                 0.000002000   if has('win32') && (&shell =~# 'pwsh' || &shell =~# 'powershell')
                                      let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
                                      let &shell = 'cmd.exe'
                                      set shellcmdflag=/s\ /c shellredir=>%s\ 2>&1 shellpipe=>%s\ 2>&1 shellquote= shellxquote="
    1                 0.000000000   endif

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:253
Called 122 times
Total time:   0.006279000
 Self time:   0.006279000

count     total (s)      self (s)
  122                 0.000150000     let l:msg = a:format_string
  122                 0.000168000     let l:severity = g:ale_echo_msg_warning_str
  122                 0.000244000     let l:code = get(a:item, 'code', '')
  122                 0.000201000     let l:type = get(a:item, 'type', 'E')
  122                 0.000241000     let l:linter_name = get(a:item, 'linter_name', '')
  122                 0.000268000     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                                  
  122                 0.000121000     if l:type is# 'E'
  122                 0.000181000         let l:severity = g:ale_echo_msg_error_str
                                      elseif l:type is# 'I'
                                          let l:severity = g:ale_echo_msg_info_str
  122                 0.000055000     endif
                                  
                                      " Replace special markers with certain information.
                                      " \=l:variable is used to avoid escaping issues.
  122                 0.001732000     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
  122                 0.000517000     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
  122                 0.000426000     let l:msg = substitute(l:msg, '\V%type%', '\=l:type', 'g')
  122                 0.000379000     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                      " Replace %s with the text.
  122                 0.000489000     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                      " Windows may insert carriage return line endings (^M), strip these characters.
  122                 0.000354000     let l:msg = substitute(l:msg, '\r', '', 'g')
                                  
  122                 0.000089000     return l:msg

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:14
Called 16 times
Total time:   0.000788000
 Self time:   0.000423000

count     total (s)      self (s)
                                      " Remember when ALE is quitting for BufWrite, etc.
   16   0.000695000   0.000330000     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  copilot_chat#buffer#WaitingForResponse()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:127
Called 4 times
Total time:   0.000486000
 Self time:   0.000164000

count     total (s)      self (s)
    4   0.000343000   0.000021000   AppendMessage('Waiting for response')
                                    #waiting_timer = timer_start(500, { -> UpdateWaitingDots()}, {'repeat': -1})
    4                 0.000073000   waiting_timer = timer_start(500, function('UpdateWaitingDots'), {'repeat': -1})

FUNCTION  nerdtree#compareNodePaths()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:107
Called 380 times
Total time:   0.059945000
 Self time:   0.011654000

count     total (s)      self (s)
  380   0.028549000   0.000805000     let sortKey1 = a:p1.getSortKey()
  380   0.021294000   0.000747000     let sortKey2 = a:p2.getSortKey()
  380                 0.000302000     let i = 0
  672                 0.002214000     while i < min([len(sortKey1), len(sortKey2)])
                                          " Compare chunks upto common length.
                                          " If chunks have different type, the one which has
                                          " integer type is the lesser.
  672                 0.001686000         if type(sortKey1[i]) == type(sortKey2[i])
  672                 0.001112000             if sortKey1[i] <# sortKey2[i]
  171                 0.000125000                 return - 1
  501                 0.000786000             elseif sortKey1[i] ># sortKey2[i]
  209                 0.000124000                 return 1
  292                 0.000136000             endif
                                          elseif type(sortKey1[i]) == type(0)
                                              return -1
                                          elseif type(sortKey2[i]) == type(0)
                                              return 1
  292                 0.000129000         endif
  292                 0.000253000         let i += 1
  292                 0.000125000     endwhile
                                  
                                      " Keys are identical upto common length.
                                      " The key which has smaller chunks is the lesser one.
                                      if len(sortKey1) < len(sortKey2)
                                          return -1
                                      elseif len(sortKey1) > len(sortKey2)
                                          return 1
                                      else
                                          return 0
                                      endif

FUNCTION  141()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:120
Called 136 times
Total time:   0.148516000
 Self time:   0.046258000

count     total (s)      self (s)
  136   0.036769000   0.000779000     if a:path.equals(self.path)
    8                 0.000010000         return self
  128                 0.000093000     endif
  128   0.001560000   0.000390000     if nerdtree#caseSensitiveFS()
                                          if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                              return {}
                                          endif
  128                 0.000103000     else
  128   0.028192000   0.001684000         if stridx(tolower(a:path.str()), tolower(self.path.str()), 0) ==# -1
   96                 0.000145000             return {}
   32                 0.000029000         endif
   32                 0.000023000     endif
                                  
   32                 0.000131000     if self.path.isDirectory
  131                 0.000828000         for i in self.children
  131   0.002997000   0.001102000             let retVal = i.findNode(a:path)
  131                 0.000331000             if retVal !=# {}
   32                 0.000038000                 return retVal
   99                 0.000076000             endif
   99                 0.000092000         endfor
                                      endif
                                      return {}

FUNCTION  142()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:147
Called 97 times
Total time:   0.026068000
 Self time:   0.000409000

count     total (s)      self (s)
   97   0.025931000   0.000272000     if !self.isCascadable()
   97                 0.000100000         return [self]
                                      endif
                                  
                                      let vc = self.getVisibleChildren()
                                      let visChild = vc[0]
                                  
                                      return [self] + visChild.getCascade()

FUNCTION  144()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:186
Called 11 times
Total time:   0.000027000
 Self time:   0.000027000

count     total (s)      self (s)
   11                 0.000021000     return len(self.children)

FUNCTION  gitgutter#buffer_disable()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:97
Called 13 times
Total time:   0.001601000
 Self time:   0.000159000

count     total (s)      self (s)
   13                 0.000047000   let bufnr = a:0 ? a:1 : bufnr('')
   13   0.000253000   0.000052000   call gitgutter#utility#setbufvar(bufnr, 'enabled', 0)
   13   0.001289000   0.000048000   call s:clear(bufnr)

FUNCTION  ale#virtualtext#GetColumnPadding()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:128
Called 36 times
Total time:   0.000947000
 Self time:   0.000625000

count     total (s)      self (s)
   36   0.000232000   0.000070000     let l:mincol = ale#Var(a:buffer, 'virtualtext_column')
   36   0.000215000   0.000055000     let l:maxcol = ale#Var(a:buffer, 'virtualtext_maxcolumn')
   36                 0.000037000     let l:win = bufwinnr(a:buffer)
                                  
   36                 0.000050000     if l:mincol[len(l:mincol)-1] is# '%'
                                          let l:mincol = (winwidth(l:win) * l:mincol) / 100
   36                 0.000011000     endif
                                  
   36                 0.000047000     if l:maxcol[len(l:maxcol)-1] is# '%'
                                          let l:maxcol = (winwidth(l:win) * l:maxcol) / 100
   36                 0.000010000     endif
                                  
                                      " Calculate padding for virtualtext alignment
   36                 0.000036000     if l:mincol > 0 || l:maxcol > 0
                                          let l:line_width = strdisplaywidth(getline(a:line))
                                  
                                          if l:line_width < l:mincol
                                              return l:mincol - l:line_width
                                          elseif l:maxcol > 0 && l:line_width >= l:maxcol
                                              " Stop processing if virtualtext would start beyond maxcol
                                              return -1
                                          endif
   36                 0.000006000     endif
                                  
                                      " no padding.
   36                 0.000020000     return 0

FUNCTION  <SNR>101_EndsWithOpeningBracket()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1164
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      return NonCommentedMatch(line, OPENING_BRACKET_AT_EOL)

FUNCTION  ale#job#Stop()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:358
Called 24 times
Total time:   0.001212000
 Self time:   0.000884000

count     total (s)      self (s)
   24                 0.000055000     if !has_key(s:job_map, a:job_id)
                                          return
   24                 0.000007000     endif
                                  
   24                 0.000053000     if has('nvim')
                                          " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                          " which are child processes on Unix. Some work needs to be done to
                                          " kill child processes to stop long-running processes like pylint.
                                          silent! call jobstop(a:job_id)
   24                 0.000008000     else
   24                 0.000040000         let l:job = s:job_map[a:job_id].job
                                  
                                          " We must close the channel for reading the buffer if it is open
                                          " when stopping a job. Otherwise, we will get errors in the status line.
   24                 0.000062000         if ch_status(job_getchannel(l:job)) is# 'open'
   24                 0.000092000             call ch_close_in(job_getchannel(l:job))
   24                 0.000008000         endif
                                  
                                          " Ask nicely for the job to stop.
   24                 0.000298000         call job_stop(l:job)
                                  
   24   0.000406000   0.000078000         if ale#job#IsRunning(l:job)
                                              " Set a 100ms delay for killing the job with SIGKILL.
                                              let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
   24                 0.000014000         endif
   24                 0.000006000     endif

FUNCTION  <SNR>167_autocmds()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2275
Called 2 times
Total time:   0.000038000
 Self time:   0.000038000

count     total (s)      self (s)
    2                 0.000009000 	if !has('autocmd') | retu | en
    2                 0.000012000 	if exists('#CtrlPLazy')
                                  		au! CtrlPLazy
    2                 0.000001000 	en
    2                 0.000002000 	if s:lazy
                                  		aug CtrlPLazy
                                  			au!
                                  			au CursorHold ControlP cal s:ForceUpdate()
                                  		aug END
    2                 0.000001000 	en

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:82
Called 167 times
Total time:   0.003432000
 Self time:   0.003432000

count     total (s)      self (s)
  167                 0.001040000     if !has_key(g:ale_buffer_info, a:buffer)
                                          " active_linter_list will hold the list of active linter names
                                          " loclist holds the loclist items after all jobs have completed.
    8                 0.000030000         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                                  
    8                 0.000007000         return 1
  159                 0.000145000     endif
                                  
  159                 0.000203000     return 0

FUNCTION  62()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim:8
Called 12 times
Total time:   0.000034000
 Self time:   0.000034000

count     total (s)      self (s)
   12                 0.000014000     if !exists('s:menuItems')
    1                 0.000001000         let s:menuItems = []
   12                 0.000002000     endif
   12                 0.000008000     return s:menuItems

FUNCTION  64()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim:29
Called 12 times
Total time:   0.000230000
 Self time:   0.000196000

count     total (s)      self (s)
   12                 0.000021000     let newMenuItem = copy(self)
                                  
   12                 0.000011000     let newMenuItem.text = a:options['text']
   12                 0.000009000     let newMenuItem.shortcut = a:options['shortcut']
   12                 0.000007000     let newMenuItem.children = []
                                  
   12                 0.000009000     let newMenuItem.isActiveCallback = -1
   12                 0.000014000     if has_key(a:options, 'isActiveCallback')
    1                 0.000002000         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
   12                 0.000006000     endif
                                  
   12                 0.000007000     let newMenuItem.callback = -1
   12                 0.000010000     if has_key(a:options, 'callback')
   12                 0.000011000         let newMenuItem.callback = a:options['callback']
   12                 0.000004000     endif
                                  
   12                 0.000011000     if has_key(a:options, 'parent')
                                          call add(a:options['parent'].children, newMenuItem)
   12                 0.000000000     else
   12   0.000055000   0.000021000         call add(s:MenuItem.All(), newMenuItem)
   12                 0.000002000     endif
                                  
   12                 0.000004000     return newMenuItem

FUNCTION  151()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:359
Called 7 times
Total time:   0.002209000
 Self time:   0.000042000

count     total (s)      self (s)
    7   0.002194000   0.000027000     return len(self.getVisibleChildren())

FUNCTION  <SNR>77_define_sign_line_highlights()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:169
Called 1 time
Total time:   0.000007000
 Self time:   0.000007000

count     total (s)      self (s)
    1                 0.000001000   if g:gitgutter_highlight_lines
                                      sign define GitGutterLineAdded                 linehl=GitGutterAddLine
                                      sign define GitGutterLineModified              linehl=GitGutterChangeLine
                                      sign define GitGutterLineRemoved               linehl=GitGutterDeleteLine
                                      sign define GitGutterLineRemovedFirstLine      linehl=GitGutterDeleteLine
                                      sign define GitGutterLineRemovedAboveAndBelow  linehl=GitGutterDeleteLine
                                      sign define GitGutterLineModifiedRemoved       linehl=GitGutterChangeDeleteLine
    1                 0.000001000   else
    1                 0.000001000     sign define GitGutterLineAdded                 linehl=NONE
    1                 0.000000000     sign define GitGutterLineModified              linehl=NONE
    1                 0.000001000     sign define GitGutterLineRemoved               linehl=NONE
    1                 0.000000000     sign define GitGutterLineRemovedFirstLine      linehl=NONE
    1                 0.000001000     sign define GitGutterLineRemovedAboveAndBelow  linehl=NONE
    1                 0.000000000     sign define GitGutterLineModifiedRemoved       linehl=NONE
    1                 0.000000000   endif

FUNCTION  154()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:392
Called 125 times
Total time:   0.034909000
 Self time:   0.002478000

count     total (s)      self (s)
  125                 0.000159000     if g:NERDTreeCascadeSingleChildDir ==# 0
                                          return 0
  125                 0.000054000     endif
                                  
  125   0.018480000   0.000268000     if self.isRoot()
   13                 0.000007000         return 0
  112                 0.000048000     endif
                                  
  112                 0.000134000     if self.path.isSymLink
                                          return 0
  112                 0.000052000     endif
                                  
  112   0.000889000   0.000309000     for i in g:NERDTreeBookmark.Bookmarks()
                                          if i.path.equals(self.path)
                                              return 0
                                          endif
  112                 0.000069000     endfor
                                  
  112   0.013957000   0.000318000     let c = self.getVisibleChildren()
  112                 0.000233000     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  155()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:423
Called 11 times
Total time:   0.306085000
 Self time:   0.002772000

count     total (s)      self (s)
                                      "remove all the current child nodes
   11                 0.000018000     let self.children = []
                                  
   11   0.012094000   0.000148000     let files = self._glob('*', 1) + self._glob('.*', 0)
                                  
   11                 0.000045000     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                          call nerdtree#echo('Please wait, caching a large dir ...')
   11                 0.000007000     endif
                                  
   11                 0.000022000     let invalidFilesFound = 0
   11                 0.000017000     let invalidFiles = []
  119                 0.000117000     for i in files
  108                 0.000065000         try
  108   0.032678000   0.000346000             let path = g:NERDTreePath.New(i)
  108   0.005295000   0.000304000             call self.createChild(path, 0)
  108   0.004830000   0.000652000             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                          catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                              let invalidFilesFound += 1
                                              let invalidFiles += [i]
  108                 0.000083000         endtry
  119                 0.000074000     endfor
                                  
   11                 0.000045000     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
   11   0.061645000   0.000040000     call self.sortChildren()
                                  
   11   0.188293000   0.000059000     call nerdtree#echo('')
                                  
   11                 0.000015000     if invalidFilesFound
                                          call nerdtree#echoWarning(invalidFilesFound . ' Invalid file(s): ' . join(invalidFiles, ', '))
   11                 0.000009000     endif
   11   0.000067000   0.000040000     return self.getChildCount()

FUNCTION  156()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:463
Called 54 times
Total time:   0.001652000
 Self time:   0.001652000

count     total (s)      self (s)
   54                 0.000072000     if a:path.isDirectory !=# 1
                                          throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
   54                 0.000021000     endif
                                  
   54                 0.000925000     let newTreeNode = copy(self)
   54                 0.000086000     let newTreeNode.path = a:path
                                  
   54                 0.000074000     let newTreeNode.isOpen = 0
   54                 0.000071000     let newTreeNode.children = []
                                  
   54                 0.000091000     let newTreeNode.parent = {}
   54                 0.000078000     let newTreeNode._nerdtree = a:nerdtree
                                  
   54                 0.000047000     return newTreeNode

FUNCTION  157()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:484
Called 12 times
Total time:   0.312887000
 Self time:   0.000777000

count     total (s)      self (s)
   12                 0.000036000     let l:options = a:0 ? a:1 : {}
                                  
                                      " If special options were specified, process them and return.
   12                 0.000058000     if has_key(l:options, 'where') && !empty(l:options['where'])
                                          let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                          call l:opener.open(self)
                                          return 0
   12                 0.000008000     endif
                                  
                                      " Open any ancestors of this node that render within the same cascade.
   12                 0.000028000     let l:parent = self.parent
   12   0.001667000   0.000059000     while !empty(l:parent) && !l:parent.isRoot()
    5   0.004529000   0.000112000         if index(l:parent.getCascade(), self) >= 0
                                              let l:parent.isOpen = 1
                                              let l:parent = l:parent.parent
    5                 0.000005000         else
    5                 0.000008000             break
                                          endif
   12                 0.000013000     endwhile
                                  
   12                 0.000023000     let self.isOpen = 1
                                  
   12                 0.000024000     let l:numChildrenCached = 0
   12                 0.000032000     if empty(self.children)
   11   0.306156000   0.000071000         let l:numChildrenCached = self._initChildren(0)
   12                 0.000008000     endif
                                  
   12                 0.000012000     return l:numChildrenCached

FUNCTION  158()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:519
Called 7 times
Total time:   0.149179000
 Self time:   0.000214000

count     total (s)      self (s)
    7                 0.000019000     let opts = a:0 ? a:1 : {}
    7                 0.000012000     let level = 0
                                  
    7                 0.000010000     let node = self
    7                 0.000013000     while node.path.isDirectory
    7   0.146800000   0.000044000         call node.open(opts)
    7                 0.000019000         let level += 1
    7   0.002232000   0.000023000         if node.getVisibleChildCount() ==# 1
                                              let node = node.getChildByIndex(0, 1)
    7                 0.000005000         else
    7                 0.000005000             break
                                          endif
    7                 0.000005000     endwhile
    7                 0.000004000     return level

FUNCTION  <SNR>22_Setup()
    Defined: ~/.vim/bundle/ale/autoload/ale/code_action.vim:356
Called 1 time
Total time:   0.000041000
 Self time:   0.000041000

count     total (s)      self (s)
    1                 0.000001000     augroup ALECodeActionsGroup
    1                 0.000032000         autocmd!
                                  
    1                 0.000001000         if a:enabled
    1                 0.000003000             autocmd MenuPopup * :call ale#code_action#GetCodeActions({})
    1                 0.000000000         endif
    1                 0.000000000     augroup END
                                  
    1                 0.000001000     if !a:enabled
                                          silent! augroup! ALECodeActionsGroup
                                  
                                          silent! aunmenu PopUp.Rename
                                          silent! aunmenu PopUp.Refactor\.\.\.
    1                 0.000000000     endif

FUNCTION  ctrlp#setlines()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2240
Called 2 times
Total time:   0.062042000
 Self time:   0.000057000

count     total (s)      self (s)
    2                 0.000007000 	if a:0 | let s:itemtype = a:1 | en
    2   0.000158000   0.000012000 	cal s:modevar()
    2                 0.000005000 	let types = ['ctrlp#files()', 'ctrlp#buffers()', 'ctrlp#mrufiles#list()']
    2                 0.000004000 	if !empty(g:ctrlp_ext_vars)
                                  		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
    2                 0.000002000 	en
    2   0.061857000   0.000018000 	let g:ctrlp_lines = eval(types[s:itemtype])

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:21
Called 2052 times
Total time:   0.026074000
 Self time:   0.026074000

count     total (s)      self (s)
 2052                 0.012668000     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                                  
 2052                 0.010022000     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:43
Called 107 times
Total time:   0.000409000
 Self time:   0.000409000

count     total (s)      self (s)
  107                 0.000362000     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  ale#handlers#alex#CreateCommandCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/alex.vim:12
Called 1 time
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    1                 0.000008000     return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))            . ' --stdin '            . a:flags}

FUNCTION  <SNR>48_mergelists()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:29
Called 11 times
Total time:   0.012296000
 Self time:   0.005112000

count     total (s)      self (s)
   11   0.007193000   0.000130000 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
   11                 0.004346000 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
   11                 0.000564000 	let mrufs = s:mrufs + diskmrufs
   11   0.000179000   0.000058000 	retu s:chop(mrufs)

FUNCTION  73()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:30
Called 69 times
Total time:   0.000206000
 Self time:   0.000206000

count     total (s)      self (s)
   69                 0.000185000     return get(s:keyMaps, a:key . a:scope, {})

FUNCTION  74()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:35
Called 16 times
Total time:   0.037738000
 Self time:   0.005203000

count     total (s)      self (s)
  928                 0.001232000     for i in values(s:keyMaps)
  912   0.035482000   0.002947000         call i.bind()
  928                 0.000708000     endfor

FUNCTION  75()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:42
Called 912 times
Total time:   0.032535000
 Self time:   0.032535000

count     total (s)      self (s)
                                      " If the key sequence we're trying to map contains any '<>' notation, we
                                      " must replace each of the '<' characters with '<lt>' to ensure the string
                                      " is not translated into its corresponding keycode during the later part
                                      " of the map command below
                                      " :he <>
  912                 0.001912000     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  912                 0.004212000     if self.key =~# specialNotationRegex
  192                 0.001630000         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
  720                 0.000530000     else
  720                 0.001456000         let keymapInvokeString = self.key
  912                 0.000644000     endif
  912                 0.002763000     let keymapInvokeString = escape(keymapInvokeString, '\"')
                                  
  912                 0.002361000     let premap = self.key ==# '<LeftRelease>' ? ' <LeftRelease>' : ' '
                                  
  912                 0.010481000     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  77()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:68
Called 12 times
Total time:   0.414779000
 Self time:   0.000405000

count     total (s)      self (s)
   12                 0.000235000     let l:Callback = type(self.callback) ==# type(function('tr')) ? self.callback : function(self.callback)
   12                 0.000017000     if a:0
   12   0.414458000   0.000084000         call l:Callback(a:1)
                                      else
                                          call l:Callback()
   12                 0.000005000     endif

FUNCTION  78()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:87
Called 12 times
Total time:   0.515504000
 Self time:   0.001284000

count     total (s)      self (s)
                                  
                                      "required because clicking the command window below another window still
                                      "invokes the <LeftRelease> mapping - but changes the window cursor
                                      "is in first
                                      "
                                      "TODO: remove this check when the vim bug is fixed
   12   0.000435000   0.000198000     if !g:NERDTree.ExistsForBuf()
                                          return {}
   12                 0.000029000     endif
                                  
   12   0.099462000   0.000384000     let node = g:NERDTreeFileNode.GetSelected()
   12                 0.000046000     if !empty(node)
                                  
                                          "try file node
   12                 0.000026000         if !node.path.isDirectory
    4   0.000090000   0.000042000             let km = s:KeyMap.FindFor(a:key, 'FileNode')
    4                 0.000009000             if !empty(km)
    4   0.195096000   0.000046000                 return km.invoke(node)
                                              endif
    8                 0.000002000         endif
                                  
                                          "try dir node
    8                 0.000011000         if node.path.isDirectory
    8   0.000157000   0.000079000             let km = s:KeyMap.FindFor(a:key, 'DirNode')
    8                 0.000019000             if !empty(km)
    8   0.219792000   0.000063000                 return km.invoke(node)
                                              endif
                                          endif
                                  
                                          "try generic node
                                          let km = s:KeyMap.FindFor(a:key, 'Node')
                                          if !empty(km)
                                              return km.invoke(node)
                                          endif
                                  
                                      endif
                                  
                                      "try bookmark
                                      let bm = g:NERDTreeBookmark.GetSelected()
                                      if !empty(bm)
                                          let km = s:KeyMap.FindFor(a:key, 'Bookmark')
                                          if !empty(km)
                                              return km.invoke(bm)
                                          endif
                                      endif
                                  
                                      "try all
                                      let km = s:KeyMap.FindFor(a:key, 'all')
                                      if !empty(km)
                                          return km.invoke()
                                      endif

FUNCTION  79()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:142
Called 57 times
Total time:   0.000924000
 Self time:   0.000755000

count     total (s)      self (s)
   57                 0.000148000     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
                                  
                                      "dont override other mappings unless the 'override' option is given
   57   0.000259000   0.000179000     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
                                          return
   57                 0.000012000     end
                                  
   57                 0.000085000     let newKeyMap = copy(self)
   57                 0.000046000     let newKeyMap.key = opts['key']
   57                 0.000065000     let newKeyMap.quickhelpText = opts['quickhelpText']
   57                 0.000041000     let newKeyMap.callback = opts['callback']
   57                 0.000044000     let newKeyMap.scope = opts['scope']
                                  
   57   0.000140000   0.000051000     call s:KeyMap.Add(newKeyMap)

FUNCTION  <SNR>167_narrowable()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1917
Called 4 times
Total time:   0.000030000
 Self time:   0.000030000

count     total (s)      self (s)
    4                 0.000026000 	retu exists('s:act_add') && exists('s:matched') && s:matched != [] && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp] && s:matcher == {} && !exists('s:did_exp')

FUNCTION  <SNR>101_EndsWithCommaOrDictKey()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1148
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      return NonCommentedMatch(line_A, COMMA_OR_DICT_KEY_AT_EOL)

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:101
Called 453 times
Total time:   0.004912000
 Self time:   0.004912000

count     total (s)      self (s)
  453                 0.001643000     let l:info = get(g:ale_buffer_info, a:buffer, {})
                                  
  453                 0.002748000     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  <SNR>16_SynSet()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim:34
Called 55 times
Total time:   0.376545000
 Self time:   0.073432000

count     total (s)      self (s)
                                    " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   55                 0.002426000   syn clear
   55                 0.000166000   if exists("b:current_syntax")
                                      unlet b:current_syntax
   55                 0.000041000   endif
                                  
   55                 0.000184000   0verbose let s = expand("<amatch>")
   55                 0.000092000   if s == "ON"
                                      " :set syntax=ON
                                      if &filetype == ""
                                        echohl ErrorMsg
                                        echo "filetype unknown"
                                        echohl None
                                      endif
                                      let s = &filetype
   55                 0.000083000   elseif s == "OFF"
                                      let s = ""
   55                 0.000025000   endif
                                  
   55                 0.000064000   if s != ""
                                      " Load the syntax file(s).  When there are several, separated by dots,
                                      " load each in sequence.  Skip empty entries.
  100                 0.000338000     for name in split(s, '\.')
   50                 0.000106000       if !empty(name)
   50   0.371769000   0.068656000 	exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   50                 0.000042000       endif
  100                 0.000080000     endfor
   55                 0.000033000   endif

FUNCTION  168()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:679
Called 11 times
Total time:   0.061605000
 Self time:   0.000528000

count     total (s)      self (s)
   11                 0.000047000     if count(g:NERDTreeSortOrder, '*') < 1
                                          call add(g:NERDTreeSortOrder, '*')
   11                 0.000008000     endif
   11                 0.000056000     let CompareFunc = function('nerdtree#compareNodes')
   11   0.061441000   0.000364000     call sort(self.children, CompareFunc)
   11                 0.000017000     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder

FUNCTION  169()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:690
Called 8 times
Total time:   0.150011000
 Self time:   0.000212000

count     total (s)      self (s)
    8                 0.000020000     let opts = a:0 ? a:1 : {}
    8                 0.000015000     if self.isOpen ==# 1
    1   0.000639000   0.000019000         call self.close()
    7                 0.000006000     else
    7                 0.000021000         if g:NERDTreeCascadeOpenSingleChildDir ==# 0
                                              call self.open(opts)
    7                 0.000004000         else
    7   0.149231000   0.000052000             call self.openAlong(opts)
    7                 0.000006000         endif
    8                 0.000002000     endif

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:39
Called 107 times
Total time:   0.000306000
 Self time:   0.000306000

count     total (s)      self (s)
  107                 0.000118000     if has_key(s:buffer_data, a:buffer)
  107                 0.000123000         let s:buffer_data[a:buffer].cwd = v:null
  107                 0.000033000     endif

FUNCTION  ale#Var()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:194
Called 4104 times
Total time:   0.092108000
 Self time:   0.092108000

count     total (s)      self (s)
 4104                 0.016447000     let l:full_name = 'ale_' . a:variable_name
 4104                 0.040460000     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                                  
 4104                 0.027787000     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>123_reset_summary()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 106 times
Total time:   0.001468000
 Self time:   0.000408000

count     total (s)      self (s)
  106   0.001440000   0.000380000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#sign#ParseSignsWithGetPlaced()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:205
Called 143 times
Total time:   0.003338000
 Self time:   0.003338000

count     total (s)      self (s)
  143                 0.001114000     let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale_signs' : '' })[0].signs
  143                 0.000154000     let l:result = []
  143                 0.000170000     let l:is_dummy_sign_set = 0
                                  
  154                 0.000184000     for l:sign in l:signs
   11                 0.000011000         if l:sign['name'] is# 'ALEDummySign'
                                              let l:is_dummy_sign_set = 1
   11                 0.000006000         else
   11                 0.000040000             call add(l:result, [   str2nr(l:sign['lnum']),   str2nr(l:sign['id']),   l:sign['name'],])
   11                 0.000002000         endif
  154                 0.000106000     endfor
                                  
  143                 0.000229000     return [l:is_dummy_sign_set, l:result]

FUNCTION  <SNR>101_EndsWithLineContinuation()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1160
Called 6 times
Total time:   0.000779000
 Self time:   0.000008000

count     total (s)      self (s)
                                      return NonCommentedMatch(line_B, LINE_CONTINUATION_AT_EOL)

FUNCTION  vader#run()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:30
Called 5 times
Total time:   0.283936000
 Self time:   0.005770000

count     total (s)      self (s)
    5                 0.000082000   let s:error_line = 0
                                  
    5                 0.000037000   let g:vader_bang = a:bang
                                  
    5                 0.000023000   if a:lastline - a:firstline > 0
                                      if a:0 > 1
                                        echoerr "You can't apply range on multiple files"
                                        return
                                      endif
                                      let [line1, line2] = [a:firstline, a:lastline]
    5                 0.000010000   else
    5                 0.000037000     let [line1, line2] = [1, 0]
    5                 0.000007000   endif
                                  
    5                 0.000113000   let options = { 'exitfirst': index(a:000, '-x') >= 0, 'quiet': index(a:000, '-q') >= 0, }
    5                 0.000080000   let patterns = filter(copy(a:000), "index(['-x', '-q'], v:val) == -1")
    5                 0.000030000   if empty(patterns)
    5                 0.000054000     let patterns = [expand('%')]
    5                 0.000008000   endif
                                  
    5                 0.000018000   if a:bang && !options.quiet
                                      redir => ver
                                      silent version
                                      redir END
                                      call vader#print_stderr(ver . "\n\n")
    5                 0.000006000   endif
                                  
    5   0.000900000   0.000431000   call vader#assert#reset()
    5   0.000812000   0.000067000   call s:prepare()
    5                 0.000014000   try
    5                 0.000017000     let all_cases = []
    5                 0.000014000     let qfl = []
    5                 0.000031000     let st  = reltime()
    5                 0.000045000     let [success, pending, total] = [0, 0, 0]
                                  
   10                 0.000053000     for gl in patterns
    5                 0.000714000       if filereadable(gl)
    5                 0.000041000         let files = [gl]
                                        else
                                          let files = filter(split(glob(gl), "\n"), "fnamemodify(v:val, ':e') ==# 'vader'")
    5                 0.000006000       endif
   10                 0.000026000       for fn in files
    5                 0.000961000         let afn = fnamemodify(fn, ':p')
    5   0.048301000   0.000360000         let cases = vader#parser#parse(afn, line1, line2)
    5                 0.000021000         call add(all_cases, [afn, cases])
    5                 0.000024000         let total += len(cases)
   10                 0.000010000       endfor
   10                 0.000014000     endfor
    5                 0.000011000     if empty(all_cases)
                                        throw 'Vader: no tests found for patterns ('.join(patterns).')'
    5                 0.000003000     endif
                                  
    5   0.075017000   0.000366000     call vader#window#open()
    5   0.000234000   0.000055000     call vader#window#append( printf("Starting Vader: %d suite(s), %d case(s)", len(all_cases), total), 0)
                                  
   10                 0.000013000     for pair in all_cases
    5                 0.000012000       let [fn, case] = pair
    5   0.075407000   0.000077000       let [cs, cp, ct, lqfl] = s:run(fn, case, options)
    5                 0.000011000       let success += cs
    5                 0.000009000       let pending += cp
    5                 0.000018000       call extend(qfl, lqfl)
    5   0.000206000   0.000048000       call vader#window#append( printf('Success/Total: %s/%s%s',     cs, ct, cp > 0 ? (' ('.cp.' pending)') : ''), 1)
    5                 0.000014000       if options.exitfirst && (cs + cp) < ct
                                          break
    5                 0.000004000       endif
   10                 0.000009000     endfor
                                  
    5                 0.000014000     let successful = success + pending == total
    5                 0.000043000     let g:vader_result = { 'total': total, 'success': success, 'pending': pending, 'successful': successful, }
                                  
    5   0.000039000   0.000025000     let stats = vader#assert#stat()
    5   0.000207000   0.000057000     call vader#window#append(printf('Success/Total: %s/%s (%sassertions: %d/%d)', success, total, (pending > 0 ? pending . ' pending, ' : ''), stats[0], stats[1]), 0)
    5                 0.000007000     if 0 && exists('*reltimefloat')
                                        let duration = printf('%.2f', reltimefloat(reltime(st)))
    5                 0.000003000     else
    5                 0.000082000       let duration = substitute(substitute(reltimestr(reltime(st)), '^\s*', '', ''), '\.\d\d\zs.*', '', '')
    5                 0.000003000     endif
    5   0.000163000   0.000026000     call vader#window#append(printf('Elapsed time: %s sec.', duration), 0)
    5   0.016348000   0.000023000     call vader#window#cleanup()
                                  
    5                 0.000011000     if a:bang
                                        if exists('*s:output_stderr_buffer')
                                          call s:output_stderr_buffer()
                                        endif
                                        if successful
                                          qall!
                                        else
                                          cq
                                        endif
    5                 0.000003000     else
    5                 0.000057000       let g:vader_report = join(getline(1, '$'), "\n")
    5                 0.000025000       let g:vader_errors = qfl
    5   0.034851000   0.000618000       call setqflist(qfl)
                                  
    5                 0.000017000       if !empty(qfl)
    4   0.027728000   0.000017000         call vader#window#copen()
    5                 0.000003000       endif
    5                 0.000003000     endif
                                    catch
                                      let error = 'Vader error: '.v:exception.' (in '.v:throwpoint.')'
                                      if a:bang
                                        call vader#print_stderr(error)
                                        cq
                                      else
                                        echoerr error
                                      endif
    5                 0.000004000   finally
    5   0.000141000   0.000018000     call s:cleanup()
    5                 0.000004000   endtry

FUNCTION  <SNR>68_customOpenDir()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:98
Called 8 times
Total time:   0.219459000
 Self time:   0.000125000

count     total (s)      self (s)
    8   0.219452000   0.000118000     call s:activateDirNode(a:node, s:initCustomOpenArgs().dir)

FUNCTION  copilot_chat#SubmitMessage()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat.vim:49
Called 2 times
Total time:   2.258042000
 Self time:   0.000000000

count     total (s)      self (s)
    2                 0.000002000   var messages = []
    2                 0.000001000   var pattern = ' ━\+$'
    2                 0.000002000   var all_file_lists = []
    2                 0.000009000   cursor(1, 1)
                                  
    6                 0.000186000   while search(pattern, 'W') > 0
    4                 0.000007000     var header_line = getline('.')
    4                 0.000000000     var role = 'user'
                                      # Check separator icon to determine message role
                                      # Separator with  icon indicates assistant response, otherwise user message
    4                 0.000004000     if stridx(header_line, ' ') != -1
    1                 0.000000000       role = 'assistant'
    1                 0.000000000     endif
    4                 0.000134000     var end_line: number = search(pattern, 'W')
    4                 0.000001000     if end_line == 0
    2                 0.000001000       end_line = line('$')
    2                 0.000001000     else
    2                 0.000000000       end_line -= 1
    2                 0.000003000       cursor(line('.') - 1, col('.'))
    2                 0.000000000     endif
                                  
    4                 0.000006000     var lines: list<string> = getline(line('.') + 1, end_line)
    4                 0.000002000     var file_list: list<string> = []
                                  
    4                 0.000005000     for i in range(len(lines))
    8                 0.000005000       var line: string = lines[i]
    8                 0.000065000       if line =~? '^> \(\w\+\)'
                                          var text: string = matchstr(line, '^> \(\w\+\)')
                                          text = substitute(text, '^> ', '', '')
                                          if has_key(g:copilot_chat_prompts, text)
                                            lines[i] = g:copilot_chat_prompts[text]
                                          endif
                                        elseif line =~? '^#file: '
                                          var filename: string = matchstr(line, '^#file: \s*\zs.*\ze$')
                                          add(file_list, filename)
                                        endif
    8                 0.000002000     endfor
    4                 0.000010000     var message: string = join(lines, "\n")
                                  
    4                 0.000005000     add(messages, {'content': message, 'role': role})
    4                 0.000003000     add(all_file_lists, file_list)
    4                 0.000004000     cursor(line('.'), col('.') + 1)
    4                 0.000001000   endwhile
                                  
                                    # Limit message history to improve performance
                                    # Only send the most recent messages based on configuration
    2                 0.000006000   var limit: number = g:copilot_chat_message_history_limit
    2                 0.000001000   if len(messages) > limit && limit > 0
                                      var start_idx: number = len(messages) - limit
                                      messages = messages[start_idx : ]
                                      all_file_lists = all_file_lists[start_idx : ]
                                    endif
                                  
                                    # Consolidate file lists from recent messages
                                    # O(n) consolidation using dictionary for O(1) duplicate detection (improved from O(n²))
    2                 0.000000000   var consolidated_files: list<string> = []
    2                 0.000001000   var seen: dict<any> = {}
    2                 0.000001000   for files in all_file_lists
    4                 0.000001000     for file in files
                                        if !has_key(seen, file)
                                          seen[file] = 1
                                          add(consolidated_files, file)
                                        endif
                                      endfor
    4                 0.000000000   endfor
                                  
    2   2.256744000   0.000000000   api.AsyncRequest(messages, consolidated_files)

FUNCTION  <SNR>68_activateDirNode()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:136
Called 8 times
Total time:   0.218913000
 Self time:   0.000223000

count     total (s)      self (s)
                                  
    8   0.002013000   0.000059000     if a:directoryNode.isRoot() && a:directoryNode.isOpen
                                          call nerdtree#echo('cannot close tree root')
                                          return
    8                 0.000005000     endif
                                  
    8   0.216812000   0.000076000     call a:directoryNode.activate((a:0 > 0) ? a:1 : {})

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:192
Called 131 times
Total time:   0.154600000
 Self time:   0.020481000

count     total (s)      self (s)
  131                 0.000329000     let l:temporary_file = ''
  131                 0.000298000     let l:command = a:command
                                  
  131                 0.000313000     if !empty(a:cwd)
                                          let l:command = ale#command#CdString(a:cwd) . l:command
  131                 0.000100000     endif
                                  
                                      " First replace all uses of %%, used for literal percent characters,
                                      " with an ugly string.
  131                 0.001363000     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                                  
                                      " Replace %e with the escaped executable, if available.
  131                 0.000682000     if !empty(a:executable) && l:command =~# '%e'
  131   0.005727000   0.001865000         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
  131                 0.000105000     endif
                                  
                                      " Replace all %s occurrences in the string with the name of the current
                                      " file.
  131                 0.000398000     if l:command =~# '%s'
                                          let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                          let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
  131                 0.000096000     endif
                                  
  131                 0.000526000     if a:input isnot v:false && l:command =~# '%t'
                                          " Create a temporary filename, <temp_dir>/<original_basename>
                                          " The file itself will not be created by this function.
  131   0.008890000   0.000939000         let l:temporary_file = s:TemporaryFilename(a:buffer)
  131   0.009068000   0.003784000         let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
  131                 0.000101000     endif
                                  
                                      " Finish formatting so %% becomes %.
  131                 0.000987000     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                                  
  131                 0.000405000     if a:pipe_file_if_needed && empty(l:temporary_file)
                                          " If we are to send the Vim buffer to a command, we'll do it
                                          " in the shell. We'll write out the file to a temporary file,
                                          " and then read it back in, in the shell.
                                          let l:temporary_file = s:TemporaryFilename(a:buffer)
                                          let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
  131                 0.000095000     endif
                                  
  131   0.119555000   0.002533000     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                                  
  131                 0.000492000     return [l:temporary_file, l:command, l:file_created]

FUNCTION  80()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim:160
Called 57 times
Total time:   0.000089000
 Self time:   0.000089000

count     total (s)      self (s)
   57                 0.000080000     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap

FUNCTION  83()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim:35
Called 195 times
Total time:   0.000942000
 Self time:   0.000942000

count     total (s)      self (s)
  195                 0.000423000     if !exists('g:NERDTreeBookmarks')
                                          let g:NERDTreeBookmarks = []
  195                 0.000087000     endif
  195                 0.000162000     return g:NERDTreeBookmarks

FUNCTION  84()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim:45
Called 5 times
Total time:   0.000654000
 Self time:   0.000341000

count     total (s)      self (s)
    5                 0.000014000     try
    5   0.000353000   0.000040000         call s:Bookmark.BookmarkFor(a:name)
                                          return 1
    5                 0.000226000     catch /^NERDTree.BookmarkNotFoundError/
    5                 0.000015000         return 0
    5                 0.000013000     endtry

FUNCTION  85()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim:57
Called 5 times
Total time:   0.000313000
 Self time:   0.000234000

count     total (s)      self (s)
    5                 0.000018000     let l:result = {}
    5   0.000129000   0.000050000     for l:bookmark in s:Bookmark.Bookmarks()
                                          if l:bookmark.name ==# a:name
                                              let l:result = l:bookmark
                                              break
                                          endif
    5                 0.000013000     endfor
    5                 0.000025000     if empty(l:result)
    4                 3.791072000         throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                      endif
                                      return l:result

FUNCTION  87()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim:87
Called 1 time
Total time:   0.000054000
 Self time:   0.000054000

count     total (s)      self (s)
    1                 0.000015000     if filereadable(g:NERDTreeBookmarksFile)
    1                 0.000001000         let g:NERDTreeBookmarks = []
    1                 0.000001000         let g:NERDTreeInvalidBookmarks = []
    1                 0.000010000         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
    1                 0.000001000         let invalidBookmarksFound = 0
    2                 0.000001000         for i in bookmarkStrings
                                  
                                              "ignore blank lines
    1                 0.000001000             if i !=# ''
                                  
                                                  let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                                                  let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
                                                  let path = fnamemodify(path, ':p')
                                  
                                                  try
                                                      let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                                                      call add(g:NERDTreeBookmarks, bookmark)
                                                  catch /^NERDTree.InvalidArgumentsError/
                                                      call add(g:NERDTreeInvalidBookmarks, i)
                                                      let invalidBookmarksFound += 1
                                                  endtry
    1                 0.000000000             endif
    2                 0.000002000         endfor
    1                 0.000000000         if invalidBookmarksFound
                                              call s:Bookmark.Write()
                                              if !a:silent
                                                  call nerdtree#echo(invalidBookmarksFound . ' invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.')
                                              endif
    1                 0.000001000         endif
    1                 0.000000000     endif

FUNCTION  ale#job#ParseVim8ProcessID()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:140
Called 501 times
Total time:   0.012004000
 Self time:   0.012004000

count     total (s)      self (s)
  501                 0.011613000     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 195 times
Total time:   0.006849000
 Self time:   0.006849000

count     total (s)      self (s)
  195                 0.000391000   if g:gitgutter_log
                                      if s:new_log_session && gitgutter#async#available()
                                        if exists('*ch_logfile')
                                          call ch_logfile(s:channel_log, 'w')
                                        endif
                                      endif
                                  
                                      execute 'redir >> '.s:log_file
                                        if s:new_log_session
                                          let s:start = reltime()
                                          silent echo "\n==== start log session ===="
                                        endif
                                  
                                        let elapsed = reltimestr(reltime(s:start)).' '
                                        silent echo ''
                                        " callers excluding this function
                                        silent echo elapsed.expand('<sfile>')[:-22].':'
                                        silent echo elapsed.s:format_for_log(a:message)
                                        if a:0 && !empty(a:1)
                                          for msg in a:000
                                            silent echo elapsed.s:format_for_log(msg)
                                          endfor
                                        endif
                                      redir END
                                  
                                      let s:new_log_session = 0
  195                 0.000121000   endif

FUNCTION  ale#command#Run()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:333
Called 131 times
Total time:   0.591703000
 Self time:   0.040275000

count     total (s)      self (s)
  131                 0.000584000     let l:options = get(a:000, 0, {})
                                  
  131                 0.000455000     if len(a:000) > 1
                                          throw 'Too many arguments!'
  131                 0.000096000     endif
                                  
  131                 0.000514000     let l:output_stream = get(l:options, 'output_stream', 'stdout')
  131                 0.000219000     let l:line_list = []
  131                 0.000434000     let l:cwd = get(l:options, 'cwd', v:null)
                                  
  131                 0.000255000     if l:cwd is v:null
                                          " Default the working directory to whatever it was for the last
                                          " command run in the chain.
  131                 0.000830000         let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
  131                 0.000105000     endif
                                  
  131   0.157979000   0.003379000     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
  131   0.013672000   0.001060000     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
  131                 0.002866000     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                                  
  131                 0.000297000     if l:output_stream is# 'stdout'
  131                 0.001082000         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                      elseif l:output_stream is# 'stderr'
                                          let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                      elseif l:output_stream is# 'both'
                                          let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                          let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
  131                 0.000109000     endif
                                  
  131                 0.000264000     let l:status = 'failed'
                                  
  131                 0.000479000     if get(g:, 'ale_run_synchronously') == 1
                                          if get(g:, 'ale_emulate_job_failure') == 1
                                              let l:job_id = 0
                                          else
                                              " Generate a fake job ID for tests.
                                              let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                              let l:job_id = s:fake_job_id
                                          endif
  131                 0.000303000     elseif has('win32')
                                          let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
  131                 0.000082000     else
  131   0.366537000   0.004941000         let l:job_id = ale#job#Start(l:command, l:job_options)
  131                 0.000115000     endif
                                  
  131                 0.000160000     if l:job_id
  131                 0.000240000         let l:status = 'started'
  131                 0.000622000         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                                  
  131   0.003247000   0.000666000         call ale#command#InitData(a:buffer)
  131                 0.001087000         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
  131                 0.000100000     endif
                                  
  131                 0.000262000     if g:ale_history_enabled
  131   0.020918000   0.000879000         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
  131                 0.000093000     endif
                                  
  131                 0.000184000     if !l:job_id
                                          return 0
  131                 0.000087000     endif
                                  
                                      " We'll return this Dictionary. A `result_callback` can be assigned to it
                                      " later for capturing the result of a:Callback.
                                      "
                                      " The `_deferred_job_id` is used for both checking the type of object, and
                                      " for checking the job ID and status.
                                      "
                                      " The cwd is kept and used as the default value for the next command in
                                      " the chain.
                                      "
                                      " The original command here is used in tests.
  131                 0.001424000     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                                  
  131                 0.000440000     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                          if !exists('g:ale_run_synchronously_callbacks')
                                              let g:ale_run_synchronously_callbacks = []
                                          endif
                                  
                                          if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                              call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                          else
                                              " Run a command synchronously if this test option is set.
                                              call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                                  
                                              " Don't capture output when the callbacks aren't set.
                                              if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                                  let l:line_list = []
                                              endif
                                  
                                              call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                          endif
  131                 0.000103000     endif
                                  
  131                 0.000295000     return l:result

FUNCTION  <SNR>13_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim:23
Called 55 times
Total time:   0.180461000
 Self time:   0.167305000

count     total (s)      self (s)
   55                 0.000214000   if exists("b:undo_ftplugin")
                                      # We assume b:undo_ftplugin is using legacy script syntax
   11   0.000928000   0.000431000     legacy exe b:undo_ftplugin
   11                 0.000016000     unlet! b:undo_ftplugin b:did_ftplugin
   11                 0.000001000   endif
                                  
   55                 0.000052000   var s = expand("<amatch>")
   55                 0.000041000   if s != ""
   50                 0.000240000     if &cpo =~# "S" && exists("b:did_ftplugin")
                                        # In compatible mode options are reset to the global values, need to
                                        # set the local values also when a plugin was already used.
                                        unlet b:did_ftplugin
                                      endif
                                  
                                      # When there is a dot it is used to separate filetype names.  Thus for
                                      # "aaa.bbb" load "aaa" and then "bbb".
   50                 0.000135000     for name in split(s, '\.')
   50   0.178561000   0.165902000       exe 'runtime! ftplugin/' .. name .. '.vim ftplugin/' .. name .. '_*.vim ftplugin/' .. name .. '/*.vim'
   50                 0.000035000     endfor
   50                 0.000001000   endif

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:10
Called 16 times
Total time:   0.000365000
 Self time:   0.000365000

count     total (s)      self (s)
   16                 0.000326000     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#path#FindNearestExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:112
Called 36 times
Total time:   0.014603000
 Self time:   0.002101000

count     total (s)      self (s)
   72                 0.000175000     for l:path in a:path_list
   36   0.000746000   0.000238000         if ale#path#IsAbsolute(l:path)
                                              let l:executable = filereadable(l:path) ? l:path : ''
   36                 0.000038000         else
   36   0.012297000   0.000303000             let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
   36                 0.000034000         endif
                                  
   36                 0.000101000         if !empty(l:executable)
                                              return l:executable
   36                 0.000031000         endif
   72                 0.000118000     endfor
                                  
   36                 0.000044000     return ''

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:69
Called 55 times
Total time:   0.002852000
 Self time:   0.001178000

count     total (s)      self (s)
                                      " The old filetype will be set to an empty string by the BuFEnter event,
                                      " and not linting when the old filetype hasn't been set yet prevents
                                      " buffers being checked when you enter them when linting on enter is off.
   55                 0.000279000     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                                  
   55                 0.000235000     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                          " Remember what the new filetype is.
   16                 0.000063000         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                                  
   16                 0.000027000         if g:ale_lint_on_filetype_changed
   16   0.001753000   0.000079000             call ale#Queue(300, 'lint_file', a:buffer)
   16                 0.000007000         endif
   55                 0.000028000     endif

FUNCTION  172()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:42
Called 8 times
Total time:   0.016277000
 Self time:   0.000104000

count     total (s)      self (s)
    8                 0.000013000     if self._keepopen
                                          return
    8                 0.000004000     endif
                                  
    8                 0.000026000     if (a:newtab && self._where ==# 't') || !a:newtab
    4   0.016196000   0.000023000         call g:NERDTree.Close()
    8                 0.000007000     endif

FUNCTION  174()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:70
Called 4 times
Total time:   0.017492000
 Self time:   0.000198000

count     total (s)      self (s)
    4   0.000042000   0.000024000     if b:NERDTree.isWinTree()
                                          if self._where ==# 'v'
                                              call self._newVSplit()
                                          elseif self._where ==# 'h'
                                              call self._newSplit()
                                          elseif self._where ==# 't'
                                              tabnew
                                          endif
    4                 0.000003000     else
    4   0.000062000   0.000013000         call self._checkToCloseTree(1)
                                  
    4                 0.000006000         if self._where ==# 'v'
                                              call self._newVSplit()
    4                 0.000006000         elseif self._where ==# 'h'
                                              call self._newSplit()
    4                 0.000005000         elseif self._where ==# 't'
                                              tabnew
    4                 0.000005000         elseif self._where ==# 'p'
    4   0.001013000   0.000014000             call self._previousWindow()
    4                 0.000003000         endif
                                  
    4   0.016244000   0.000016000         call self._checkToCloseTree(0)
    4                 0.000002000     endif

FUNCTION  175()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:102
Called 8 times
Total time:   0.000761000
 Self time:   0.000326000

count     total (s)      self (s)
                                      "gotta split if theres only one window (i.e. the NERD tree)
    8                 0.000020000     if winnr('$') ==# 1
                                          return 0
    8                 0.000006000     endif
                                  
    8                 0.000017000     let oldwinnr = winnr()
    8   0.000335000   0.000049000     call nerdtree#exec(a:winnumber . 'wincmd p', 1)
    8                 0.000075000     let specialWindow = getbufvar('%', '&buftype') !=# '' || getwinvar('%', '&previewwindow')
    8                 0.000032000     let modified = &modified
    8   0.000183000   0.000034000     call nerdtree#exec(oldwinnr . 'wincmd p', 1)
                                  
                                      "if its a special window e.g. quickfix or another explorer plugin then we
                                      "have to split
    8                 0.000011000     if specialWindow
                                          return 0
    8                 0.000006000     endif
                                  
    8                 0.000012000     if &hidden
    8                 0.000009000         return 1
                                      endif
                                  
                                      return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  176()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:138
Called 4 times
Total time:   0.000315000
 Self time:   0.000229000

count     total (s)      self (s)
    4                 0.000087000     let l:newOpener = copy(self)
                                  
    4   0.000046000   0.000019000     let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    4                 0.000011000     let l:newOpener._nerdtree = b:NERDTree
    4                 0.000008000     let l:newOpener._path = a:path
    4                 0.000022000     let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
    4   0.000032000   0.000016000     let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
    4                 0.000019000     let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                                  
    4   0.000062000   0.000019000     call l:newOpener._saveCursorPos()
                                  
    4                 0.000006000     return l:newOpener

FUNCTION  179()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:209
Called 4 times
Total time:   0.194069000
 Self time:   0.000095000

count     total (s)      self (s)
    4                 0.000008000     if self._path.isDirectory
                                          call self._openDirectory(a:target)
                                          return
    4                 0.000003000     endif
                                  
    4   0.194027000   0.000053000     call self._openFile()

FUNCTION  <SNR>167_Open()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:269
Called 2 times
Total time:   0.003726000
 Self time:   0.002519000

count     total (s)      self (s)
    2   0.000054000   0.000010000 	cal s:log(1)
    2   0.000832000   0.000013000 	cal s:getenv()
    2   0.000022000   0.000007000 	cal s:execextvar('enter')
    2                 0.001128000 	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
    2   0.000042000   0.000015000 	cal s:buffunc(1)
    2                 0.000012000 	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
    2                 0.000009000 	let [s:focus, s:prompt] = [1, ['', '', '']]
    2                 0.000004000 	abc <buffer>
    2                 0.000004000 	if !exists('s:hstry')
    1   0.000834000   0.000621000 		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
    1                 0.000003000 		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
    2                 0.000002000 	en
   68                 0.000140000 	for [ke, va] in items(s:glbs) | if exists('+'.ke)
   34                 0.000355000 		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
   68                 0.000040000 	en | endfo
    2                 0.000010000 	if s:opmul != '0' && has('signs')
    2                 0.000092000 		sign define ctrlpmark text=+> texthl=Search
    2                 0.000002000 	en
    2   0.000101000   0.000012000 	cal s:setupblank()

FUNCTION  vader#syntax#include()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/syntax.vim:30
Called 85 times
Total time:   0.002095000
 Self time:   0.002095000

count     total (s)      self (s)
   85                 0.000999000   let lines = filter(getline(a:l1, a:l2), '!empty(v:val) && v:val[0] != " "')
   87                 0.000191000   for line in lines
    2                 0.000027000     let match = matchlist(line, '^\(Given\|Expect\|Execute\)\s\+\([^:; (]\+\)')
    2                 0.000004000     if len(match) >= 3
                                        silent! call s:load(match[2])
    2                 0.000001000     endif
   87                 0.000097000   endfor

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:15
Called 181 times
Total time:   0.004326000
 Self time:   0.004326000

count     total (s)      self (s)
  181                 0.000562000     if has('unix')
  181                 0.001406000         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                                  
  181                 0.002024000         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                      endif
                                  
                                      let l:win_path = substitute(a:path, '/', '\\', 'g')
                                  
                                      return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>101_EndsWithComma()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1144
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      return NonCommentedMatch(line, COMMA_AT_EOL)

FUNCTION  copilot_chat#OpenChat()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat.vim:8
Called 3 times
Total time:   0.861720000
 Self time:   0.000068000

count     total (s)      self (s)
    3   0.832618000   0.000011000   if auth.VerifySignin() != v:null
    3   0.000310000   0.000277000     if _buffer.HasActiveChat() && g:copilot_reuse_active_chat == 1
                                        _buffer.FocusActiveChat()
                                      else
    3   0.028562000   0.000004000       _buffer.Create()
    3                 0.000089000       normal G
    3                 0.000000000     endif
    3                 0.000000000   endif

FUNCTION  <SNR>122_save_last_seen_change()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:419
Called 93 times
Total time:   0.001152000
 Self time:   0.000314000

count     total (s)      self (s)
   93   0.001127000   0.000289000   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>108_IsCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:84
Called 7 times
Total time:   0.000023000
 Self time:   0.000023000

count     total (s)      self (s)
    7                 0.000020000     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:471
Called 632 times
Total time:   0.003970000
 Self time:   0.003970000

count     total (s)      self (s)
  632                 0.003506000     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  copilot_chat#buffer#AddInputSeparator()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:120
Called 7 times
Total time:   0.000200000
 Self time:   0.000148000

count     total (s)      self (s)
    7                 0.000109000   var width: number = winwidth(0) - 2 - getwininfo(win_getid())[0].textoff
    7                 0.000013000   var separator: string = ' ' .. repeat('━', width)
    7   0.000039000   0.000004000   AppendMessage(separator)
    7   0.000019000   0.000002000   AppendMessage('')

FUNCTION  <SNR>158_print_throwpoint()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:311
Called 4 times
Total time:   0.000418000
 Self time:   0.000121000

count     total (s)      self (s)
    4                 0.000061000   if v:throwpoint !~ 'vader#assert'
    4   0.000347000   0.000050000     Log v:throwpoint
    4                 0.000002000   endif

FUNCTION  ale#path#IsAbsolute()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:147
Called 36 times
Total time:   0.000508000
 Self time:   0.000508000

count     total (s)      self (s)
   36                 0.000128000     if has('win32')
                                          return a:filename[:0] =~# '[\\/]' || a:filename[0:2] =~? '[A-Z]:[/\\]'
   36                 0.000037000     else
   36                 0.000130000         return a:filename[:0] is# '/'
                                      endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:87
Called 93 times
Total time:   0.012198000
 Self time:   0.001142000

count     total (s)      self (s)
   93   0.012133000   0.001077000   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>126_ShouldClose()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:50
Called 143 times
Total time:   0.001870000
 Self time:   0.000983000

count     total (s)      self (s)
  143   0.001234000   0.000347000     let l:val = ale#Var(a:buffer, 'open_list')
  143                 0.000276000     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                  
  143                 0.000262000     return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))

FUNCTION  180()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:219
Called 4 times
Total time:   0.193974000
 Self time:   0.000210000

count     total (s)      self (s)
    4                 0.000015000     if !self._stay && self._keepopen && get(b:, 'NERDTreeZoomed', 0)
                                          call b:NERDTree.ui.toggleZoom()
    4                 0.000001000     endif
                                  
    4   0.005755000   0.000017000     if self._reuseWindow()
                                          return
    4                 0.000002000     endif
                                  
    4   0.017514000   0.000022000     call self._gotoTargetWin()
                                  
    4                 0.000007000     if self._stay
                                          silent call self._path.edit()
                                          call self._restoreCursorPos()
                                          return
    4                 0.000003000     endif
                                  
    4   0.170585000   0.000051000     call self._path.edit()

FUNCTION  182()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:261
Called 4 times
Total time:   0.000999000
 Self time:   0.000172000

count     total (s)      self (s)
    4   0.000535000   0.000038000     if !self._isWindowUsable(winnr('#')) && self._firstUsableWindow() ==# -1
                                          call self._newSplit()
    4                 0.000003000     else
    4                 0.000003000         try
    4   0.000282000   0.000018000             if !self._isWindowUsable(winnr('#'))
                                                  call nerdtree#exec(self._firstUsableWindow() . 'wincmd w', 1)
    4                 0.000003000             else
    4   0.000079000   0.000013000                 call nerdtree#exec('wincmd p', 1)
    4                 0.000004000             endif
                                          catch /^Vim\%((\a\+)\)\=:E37/
                                              call g:NERDTree.CursorToTreeWin()
                                              throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
                                          catch /^Vim\%((\a\+)\)\=:/
                                              echo v:exception
    4                 0.000005000         endtry
    4                 0.000002000     endif

FUNCTION  184()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:290
Called 4 times
Total time:   0.005738000
 Self time:   0.002873000

count     total (s)      self (s)
    4                 0.000020000     if empty(self._reuse)
                                          return 0
    4                 0.000002000     endif
                                  
                                      "check the current tab for the window
    4   0.003046000   0.002657000     let winnr = bufwinnr('^' . self._path.str() . '$')
    4                 0.000012000     if winnr !=# -1
                                          call nerdtree#exec(winnr . 'wincmd w', 0)
                                          call self._checkToCloseTree(0)
                                          return 1
    4                 0.000002000     endif
                                  
    4                 0.000009000     if self._reuse ==# 'currenttab'
                                          return 0
    4                 0.000002000     endif
                                  
                                      "check other tabs
    4   0.002508000   0.000032000     let tabnr = self._path.tabnr()
    4                 0.000005000     if tabnr
                                          call self._checkToCloseTree(1)
                                          call nerdtree#exec(tabnr . 'tabnext', 1)
                                          let winnr = bufwinnr('^' . self._path.str() . '$')
                                          call nerdtree#exec(winnr . 'wincmd w', 0)
                                          return 1
    4                 0.000003000     endif
                                  
    4                 0.000004000     return 0

FUNCTION  185()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/opener.vim:321
Called 4 times
Total time:   0.000043000
 Self time:   0.000043000

count     total (s)      self (s)
    4                 0.000022000     let self._bufnr = bufnr('')
    4                 0.000017000     let self._tabnr = tabpagenr()

FUNCTION  186()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:15
Called 16 times
Total time:   0.038815000
 Self time:   0.001077000

count     total (s)      self (s)
   16   0.037878000   0.000140000     call g:NERDTreeKeyMap.BindAll()
                                  
   16                 0.000148000     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
   16                 0.000137000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
   16                 0.000091000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
   16                 0.000087000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
   16                 0.000110000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
   16                 0.000089000     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
   16                 0.000099000     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
   16                 0.000064000     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
   16                 0.000050000     command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()

FUNCTION  187()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:30
Called 5 times
Total time:   0.000021000
 Self time:   0.000021000

count     total (s)      self (s)
    5                 0.000014000     if exists('#User#NERDTreeInit')
                                          doautocmd User NERDTreeInit
    5                 0.000002000     endif

FUNCTION  188()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:37
Called 7 times
Total time:   0.000026000
 Self time:   0.000026000

count     total (s)      self (s)
    7                 0.000023000     return 'NERD_tree_'

FUNCTION  vader#window#prepare()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:113
Called 5 times
Total time:   0.000793000
 Self time:   0.000211000

count     total (s)      self (s)
    5   0.000148000   0.000025000   call s:switch_to_workbench()
    5   0.000505000   0.000048000   execute 'setlocal modifiable filetype='.a:type
                                  
    5                 0.000018000   silent %d _
    5                 0.000008000   for line in a:lines
                                      call append(line('$') - 1, line)
    5                 0.000005000   endfor
    5                 0.000005000   silent d _
    5                 0.000047000   execute "normal! \<c-\>\<c-n>gg0"
                                  
    5   0.000034000   0.000032000   let &undolevels = &undolevels " Break undo block

FUNCTION  <SNR>108_GetAliasedFiletype()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:303
Called 203 times
Total time:   0.018173000
 Self time:   0.018173000

count     total (s)      self (s)
  203                 0.002179000     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                                  
                                      " b:ale_linter_aliases can be set to a List or String.
  203                 0.002286000     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                          return l:buffer_aliases
  203                 0.000359000     endif
                                  
                                      " Check for aliased filetypes first in a buffer variable,
                                      " then the global variable,
                                      " then in the default mapping,
                                      " otherwise use the original filetype.
  776                 0.002865000     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
  609                 0.002986000         if has_key(l:dict, a:original_filetype)
   36                 0.000186000             return l:dict[a:original_filetype]
  573                 0.000523000         endif
  740                 0.001007000     endfor
                                  
  167                 0.000383000     return a:original_filetype

FUNCTION  152()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:368
Called 147 times
Total time:   0.041115000
 Self time:   0.004914000

count     total (s)      self (s)
  147                 0.000153000     let toReturn = []
  565                 0.000628000     for i in self.children
  418   0.038219000   0.002018000         if i.path.ignore(self.getNerdtree()) ==# 0
  340                 0.000590000             call add(toReturn, i)
  418                 0.000203000         endif
  565                 0.000302000     endfor
  147                 0.000113000     return toReturn

FUNCTION  <SNR>129_RGBToCterm()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes/color.vim:57
Called 39 times
Total time:   0.000392000
 Self time:   0.000392000

count     total (s)      self (s)
                                      # Try to match to the 6x6x6 color cube for best results
   39                 0.000046000     var ri = float2nr(round(r / 51.0))
   39                 0.000014000     var gi = float2nr(round(g / 51.0))
   39                 0.000014000     var bi = float2nr(round(b / 51.0))
                                  
                                      # Clamp to valid range
   39                 0.000113000     ri = min([max([ri, 0]), 5])
   39                 0.000031000     gi = min([max([gi, 0]), 5])
   39                 0.000025000     bi = min([max([bi, 0]), 5])
                                  
                                      return 16 + ri * 36 + gi * 6 + bi

FUNCTION  <SNR>43_CreateMaps()
    Defined: ~/.vim/bundle/nerdcommenter/plugin/nerdcommenter.vim:52
Called 18 times
Total time:   0.000878000
 Self time:   0.000878000

count     total (s)      self (s)
                                      " Build up a map command like
                                      " 'noremap <silent> <Plug>NERDCommenterComment :call nerdcommenter#Comment("n", "Comment")'
   18                 0.000016000     let plug = '<Plug>NERDCommenter' . a:target
   18                 0.000025000     let plug_start = 'noremap <silent> ' . plug . ' :call nerdcommenter#Comment("'
   18                 0.000017000     let plug_end = '", "' . a:target . '")<CR>'
                                      " Build up a menu command like
                                      " 'menu <silent> comment.Comment<Tab>\\cc <Plug>NERDCommenterComment'
   18                 0.000042000     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment', '&Plugin.Nerd\ &Commenter'], g:NERDMenuMode, '')
   18                 0.000033000     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
   18                 0.000015000     if strlen(a:combo)
   13                 0.000015000         let leader = exists('g:mapleader') ? g:mapleader : '\'
   13                 0.000022000         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
   18                 0.000007000     endif
   18                 0.000027000     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
                                      " Execute the commands built above for each requested mode.
   46                 0.000049000     for mode in (a:modes ==# '') ? [''] : split(a:modes, '\zs')
   28                 0.000022000         if strlen(a:combo)
   23                 0.000104000             execute mode . plug_start . mode . plug_end
   23                 0.000100000             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
   23                 0.000086000                 execute mode . 'map <leader>' . a:combo . ' ' . plug
   23                 0.000008000             endif
   28                 0.000005000         endif
                                          " Check if the user wants the menu to be displayed.
   28                 0.000015000         if g:NERDMenuMode !=# 0
   28                 0.000094000             execute mode . menu_command
   28                 0.000010000         endif
   46                 0.000016000     endfor

FUNCTION  <SNR>167_matchlens()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1314
Called 116 times
Total time:   0.000434000
 Self time:   0.000434000

count     total (s)      self (s)
  116                 0.000398000 	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
                                  	let st   = a:0 ? a:1 : 0
                                  	let lens = a:0 >= 2 ? a:2 : {}
                                  	let nr   = a:0 >= 3 ? a:3 : 0
                                  	if nr > 20 | retu {} | en
                                  	if match(a:str, a:pat, st) >= 0
                                  		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
                                  		let lens = extend(lens, { nr : [strlen(mst), mst] })
                                  		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
                                  	en
                                  	retu lens

FUNCTION  <SNR>167_getinput()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1923
Called 55 times
Total time:   0.001627000
 Self time:   0.001627000

count     total (s)      self (s)
   55                 0.000128000 	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
   55                 0.000080000 	if s:abbrev != {}
                                  		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                                  		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                                  		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                                  			retu join(prt, '')
                                  		en
                                  		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                                  		for dict in s:abbrev['abbrevs']
                                  			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                                  			let pat = escape(dict['pattern'], '~')
                                  			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 ) || dmd =~ '['.spi.']' ) && str =~ pat
                                  				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                                  			en
                                  		endfo
                                  		if gmd =~ 't' && !a:0
                                  			let prt[0] = str
                                  		el
                                  			retu str
                                  		en
   55                 0.000024000 	en
   55                 0.000155000 	retu spi == 'c' ? prt[0] : join(prt, '')

FUNCTION  nerdtree#ui_glue#setupCommands()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:658
Called 1 time
Total time:   0.000019000
 Self time:   0.000019000

count     total (s)      self (s)
    1                 0.000003000     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
    1                 0.000003000     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
    1                 0.000002000     command! -n=? -complete=dir -bar NERDTreeExplore :call g:NERDTreeCreator.CreateExploreTree('<args>')
    1                 0.000001000     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
    1                 0.000003000     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
    1                 0.000001000     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
    1                 0.000002000     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
    1                 0.000001000     command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
    1                 0.000001000     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
    1                 0.000001000     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 93 times
Total time:   0.001017000
 Self time:   0.000402000

count     total (s)      self (s)
   93   0.001003000   0.000388000   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>14_LoadIndent()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/indent.vim:16
Called 55 times
Total time:   0.033331000
 Self time:   0.028589000

count     total (s)      self (s)
   55                 0.000226000   if exists("b:undo_indent")
    4                 0.000045000     legacy exe b:undo_indent
    4                 0.000006000     unlet! b:undo_indent b:did_indent
    4                 0.000000000   endif
   55                 0.000049000   var s = expand("<amatch>")
   55                 0.000021000   if s != ""
   50                 0.000068000     if exists("b:did_indent")
                                        unlet b:did_indent
                                      endif
                                  
                                      # When there is a dot it is used to separate filetype names.  Thus for
                                      # "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   50                 0.000109000     for name in split(s, '\.')
   50   0.032606000   0.027864000       exe 'runtime! indent/' .. name .. '.vim'
   50                 0.000013000     endfor
   50                 0.000003000   endif

FUNCTION  ale#handlers#alex#DefineLinter()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/alex.vim:44
Called 1 time
Total time:   0.000276000
 Self time:   0.000030000

count     total (s)      self (s)
    1   0.000021000   0.000006000     call ale#Set('alex_executable', 'alex')
    1   0.000016000   0.000006000     call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                                  
    1   0.000239000   0.000018000     call ale#linter#Define(a:filetype, {   'name': 'alex',   'executable': function('ale#handlers#alex#GetExecutable'),   'command': ale#handlers#alex#CreateCommandCallback(a:flags),   'output_stream': 'stderr',   'callback': 'ale#handlers#alex#Handle',})

FUNCTION  <SNR>75_on_bufenter()
    Defined: ~/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim:236
Called 167 times
Total time:   0.222887000
 Self time:   0.009958000

count     total (s)      self (s)
  167   0.021210000   0.001052000   call gitgutter#setup_maps()
                                  
                                    " To keep vim's start-up fast, do not process the buffer when vim is starting.
                                    " Instead process it a short time later.  Normally we would rely on our
                                    " CursorHold autocommand to handle this but it turns out CursorHold is not
                                    " guaranteed to fire if the user has not typed anything yet; so set up a
                                    " timer instead.  The disadvantage is that if CursorHold does fire, the
                                    " plugin will do a round of unnecessary work; but since there will not have
                                    " been any changes to the buffer since the first round, the second round
                                    " will be cheap.
  167                 0.001344000   if has('vim_starting') && !$VIM_GITGUTTER_TEST
    1                 0.000002000     if exists('*timer_start') && has('lambda')
    1   0.000033000   0.000028000       call s:next_tick("call gitgutter#process_buffer(+".bufnr('').", 0)")
                                      else
                                        call gitgutter#process_buffer(bufnr(''), 0)
    1                 0.000000000     endif
    1                 0.000001000     return
  166                 0.000110000   endif
                                  
  166                 0.000772000   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
   41                 0.000100000     let t:gitgutter_didtabenter = 0
   41   0.099418000   0.000417000     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
  125                 0.000099000   else
  125   0.095064000   0.001299000     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
  166                 0.000134000   endif

FUNCTION  <SNR>167_compfnlen()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1307
Called 58 times
Total time:   0.000682000
 Self time:   0.000682000

count     total (s)      self (s)
                                  	" By filename length
   58                 0.000279000 	let len1 = strlen(split(a:1, s:lash)[-1])
   58                 0.000254000 	let len2 = strlen(split(a:2, s:lash)[-1])
   58                 0.000109000 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  191()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:72
Called 5 times
Total time:   0.288232000
 Self time:   0.000255000

count     total (s)      self (s)
    5   0.004403000   0.000050000     let l:path = self._pathForString(a:name)
                                  
                                      " Abort if an exception was thrown (i.e., if the bookmark or directory
                                      " does not exist).
    5                 0.000011000     if empty(l:path)
                                          return
    5                 0.000002000     endif
                                  
                                      " Obey the user's preferences for changing the working directory.
    5                 0.000018000     if g:NERDTreeChDirMode != 0
                                          call l:path.changeToDir()
    5                 0.000002000     endif
                                  
    5   0.000042000   0.000014000     if g:NERDTree.ExistsForTab()
                                          call g:NERDTree.Close()
                                          call self._removeTreeBufForTab()
    5                 0.000005000     endif
                                  
    5   0.097983000   0.000023000     call self._createTreeWin()
    5   0.166717000   0.000021000     call self._createNERDTree(l:path, 'tab')
    5   0.018192000   0.000013000     call b:NERDTree.render()
    5   0.000755000   0.000015000     call b:NERDTree.root.putCursorHere(0, 0)
                                  
    5   0.000028000   0.000007000     call self._broadcastInitEvent()

FUNCTION  194()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:133
Called 5 times
Total time:   0.166696000
 Self time:   0.000079000

count     total (s)      self (s)
    5   0.000524000   0.000038000     let b:NERDTree = g:NERDTree.New(a:path, a:type)
                                  
                                      " TODO: This assignment is kept for compatibility reasons.  Many other
                                      " plugins use b:NERDTreeRoot instead of b:NERDTree.root.  Remove this
                                      " assignment in the future.
    5                 0.000011000     let b:NERDTreeRoot = b:NERDTree.root
                                  
    5   0.166148000   0.000017000     call b:NERDTree.root.open()

FUNCTION  <SNR>76_not_git_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:58
Called 187 times
Total time:   0.042641000
 Self time:   0.005605000

count     total (s)      self (s)
  187   0.042489000   0.005453000   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  199()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:242
Called 26 times
Total time:   0.001034000
 Self time:   0.001034000

count     total (s)      self (s)
   26                 0.000889000     let newCreator = copy(self)
   26                 0.000091000     return newCreator

FUNCTION  modes#SetNormalHighlight()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:56
Called 32 times
Total time:   0.003045000
 Self time:   0.003045000

count     total (s)      self (s)
   32                 0.001892000   highlight CursorLine guibg=NONE
   32                 0.000871000   highlight LineNr guibg=NONE

FUNCTION  <SNR>34_UpdateWaitingDots()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:134
Called 6276 times
Total time:   0.300124000
 Self time:   0.300124000

count     total (s)      self (s)
 6276                 0.053640000   if !bufexists(g:copilot_chat_active_buffer)
                                      timer_stop(waiting_timer)
                                      return 0
                                    endif
                                  
 6276                 0.039211000   var lines: list<string> = getbufline(g:copilot_chat_active_buffer, '$')
 6276                 0.009681000   if empty(lines)
                                      timer_stop(waiting_timer)
                                      return 0
                                    endif
                                  
 6276                 0.007398000   var current_text = lines[0]
 6276                 0.116074000   if current_text =~? '^Waiting for response'
   32                 0.000521000       var dots = len(matchstr(current_text, '\..*$'))
   32                 0.000044000       var new_dots = (dots % 3) + 1
   32                 0.000541000       setbufline(g:copilot_chat_active_buffer, '$', $'Waiting for response{repeat('.', new_dots)}')
   32                 0.000117000     color_index = (color_index + 1) % len(colors_gui)
   32                 0.003428000     execute 'highlight CopilotWaiting guifg=' .. colors_gui[color_index] .. ' ctermfg=' .. colors_cterm[color_index]
   32                 0.000007000   endif
                                    return 1

FUNCTION  <SNR>79_extend()
    Defined: ~/.vim/bundle/vim-test/autoload/test.vim:231
Called 1 time
Total time:   0.000084000
 Self time:   0.000084000

count     total (s)      self (s)
    1                 0.000001000   let result = {}
    1                 0.000002000   for [key, value] in items(a:source)
                                      let result[key] = value
    1                 0.000000000   endfor
   30                 0.000022000   for [key, value] in items(a:dict)
   29                 0.000048000     let result[key] = get(result, key, []) + value
   30                 0.000007000   endfor
    1                 0.000001000   return result

FUNCTION  ale#util#LocItemCompareWithText()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:209
Called 75 times
Total time:   0.001074000
 Self time:   0.000255000

count     total (s)      self (s)
   75   0.000952000   0.000133000     let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                                  
   75                 0.000033000     if l:cmp_value
   69                 0.000040000         return l:cmp_value
    6                 0.000001000     endif
                                  
    6                 0.000005000     if a:left.text < a:right.text
    6                 0.000004000         return -1
                                      endif
                                  
                                      if a:left.text > a:right.text
                                          return 1
                                      endif
                                  
                                      return 0

FUNCTION  nerdtree#echo()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:277
Called 11 times
Total time:   0.188234000
 Self time:   0.188234000

count     total (s)      self (s)
   11                 0.188137000     redraw
   11                 0.000086000     echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)

FUNCTION  ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:52
Called 1 time
Total time:   0.000064000
 Self time:   0.000062000

count     total (s)      self (s)
    1                 0.000001000     let l:verbose = &verbose
    1   0.000005000   0.000004000     set verbose=0
    1                 0.000008000     let l:output = execute('highlight SignColumn', 'silent')
    1   0.000002000   0.000001000     let &verbose = l:verbose
                                  
    1                 0.000015000     let l:highlight_syntax = join(split(l:output)[2:])
    1                 0.000005000     let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                                  
    1                 0.000001000     if !empty(l:match)
                                          execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
    1                 0.000001000     elseif l:highlight_syntax isnot# 'cleared'
    1                 0.000024000         execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
    1                 0.000000000     endif

FUNCTION  <SNR>161_move()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:187
Called 1 time
Total time:   0.032673000
 Self time:   0.029834000

count     total (s)      self (s)
    1                 0.000068000   let lno = matchstr(getline('.'), '(#[0-9]\+)')[2:-2]
    1                 0.000006000   let wq = winnr()
    1                 0.000009000   let wc = bufwinnr(s:console_bfr)
    1                 0.000004000   if wc >= 0
    1   0.001953000   0.000033000     execute wc . 'wincmd w'
    1                 0.000004000     let scrolloff = &scrolloff
    1   0.000025000   0.000023000     set scrolloff=0
    1                 0.000008000     execute lno
    1                 0.000050000     normal! zt
    1                 0.029546000     redraw
    1   0.000033000   0.000027000     let &scrolloff = scrolloff
    1   0.000958000   0.000047000     execute wq . 'wincmd w'
    1                 0.000000000   endif

FUNCTION  <SNR>167_ispathitem()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1500
Called 2 times
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    2                 0.000007000 	retu s:itemtype < 3 || ( s:itemtype > 2 && s:getextvar('type') == 'path' )

FUNCTION  <SNR>76_abs_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:222
Called 696 times
Total time:   0.087673000
 Self time:   0.087673000

count     total (s)      self (s)
  696                 0.058903000   let p = resolve(expand('#'.a:bufnr.':p'))
                                  
                                    " Remove extra parts from fugitive's filepaths
  696                 0.023981000   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                                  
  696                 0.002732000   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#virtualtext#SetTexts()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:303
Called 143 times
Total time:   0.013506000
 Self time:   0.004303000

count     total (s)      self (s)
  143                 0.000527000     if !has('nvim') && s:emulate_virt
                                          return
  143                 0.000045000     endif
                                  
  143   0.004008000   0.000398000     call ale#virtualtext#Clear(a:buffer)
                                  
  143                 0.000449000     let l:buffer_list = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
                                  
  143   0.001408000   0.000308000     if ale#Var(a:buffer,'virtualtext_single')
                                          " If we want a single problem per line, sort items on each line by
                                          " highest severity and then lowest column position, then de-duplicate
                                          " the items by line.
  143   0.001505000   0.001310000         call uniq(   sort(l:buffer_list, function('ale#virtualtext#CompareSeverityPerLine')),   {a, b -> a.lnum - b.lnum})
  143                 0.000065000     endif
                                  
  179                 0.000189000     for l:item in l:buffer_list
   36   0.004384000   0.000086000         call ale#virtualtext#ShowMessage(a:buffer, l:item)
  179                 0.000081000     endfor

FUNCTION  <SNR>107_ApplyPartialTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:447
Called 101 times
Total time:   0.029724000
 Self time:   0.001537000

count     total (s)      self (s)
  101                 0.000353000     if has_key(s:partial_timers, a:timer_id)
  101                 0.000469000         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
  101   0.028760000   0.000573000         call call(l:Callback, [a:timer_id] + l:args)
  101                 0.000042000     endif

FUNCTION  <SNR>158_append()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:425
Called 9 times
Total time:   0.000611000
 Self time:   0.000244000

count     total (s)      self (s)
    9                 0.000053000   let error = get(a:, 1, 0)
    9                 0.000029000   let message = (error ? '(X) ' : '') . a:message
    9   0.000468000   0.000101000   let line = vader#window#append(printf("%s [%7s] %s", a:prefix, toupper(a:type), message), 2)
    9                 0.000010000   if error
    4                 0.000008000     let s:error_line = line
    9                 0.000005000   endif
    9                 0.000007000   return line

FUNCTION  <SNR>9_DetectCoffee()
    Defined: ~/.vim/bundle/vim-coffee-script/ftdetect/coffee.vim:12
Called 31 times
Total time:   0.000303000
 Self time:   0.000303000

count     total (s)      self (s)
   31                 0.000207000     if getline(1) =~ '^#!.*\<coffee\>'
                                          set filetype=coffee
   31                 0.000022000     endif

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 202 times
Total time:   0.005413000
 Self time:   0.001326000

count     total (s)      self (s)
  202   0.002800000   0.000454000   let summary = gitgutter#hunk#summary(a:bufnr)
  202                 0.000276000   let summary[1] += a:count
  202   0.002245000   0.000504000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#Queue()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:137
Called 289 times
Total time:   0.644368000
 Self time:   0.018528000

count     total (s)      self (s)
  289                 0.000758000     if a:0 > 2
                                          throw 'too many arguments!'
  289                 0.000237000     endif
                                  
  289                 0.001501000     let l:buffer = get(a:000, 1, v:null)
                                  
  289                 0.000732000     if l:buffer is v:null
  105                 0.000298000         let l:buffer = bufnr('')
  289                 0.000212000     endif
                                  
  289                 0.001129000     if type(l:buffer) isnot v:t_number
                                          throw 'buffer_number must be a Number'
  289                 0.000202000     endif
                                  
  289   0.042764000   0.001876000     if ale#ShouldDoNothing(l:buffer)
   81                 0.000054000         return
  208                 0.000157000     endif
                                  
                                      " Default linting_flag to ''
  208                 0.000929000     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                                  
  208                 0.000468000     if s:lint_timer != -1
   91                 0.000399000         call timer_stop(s:lint_timer)
   91                 0.000327000         let s:lint_timer = -1
  208                 0.000236000     endif
                                  
  208                 0.000348000     if a:delay > 0
   92                 0.001414000         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
  116                 0.000184000     else
  116   0.586297000   0.001345000         call s:Lint(l:buffer, l:should_lint_file, 0)
  208                 0.000154000     endif

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 9 times
Total time:   0.000272000
 Self time:   0.000074000

count     total (s)      self (s)
    9   0.000155000   0.000036000   let summary = gitgutter#hunk#summary(a:bufnr)
    9                 0.000014000   let summary[0] += a:count
    9   0.000098000   0.000019000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>125_PriorityCmd()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:154
Called 46 times
Total time:   0.000086000
 Self time:   0.000086000

count     total (s)      self (s)
   46                 0.000028000     if s:supports_sign_groups
   46                 0.000047000         return ' priority=' . g:ale_sign_priority . ' '
                                      else
                                          return ''
                                      endif

FUNCTION  copilot_chat#history#Get()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/history.vim:118
Called 2 times
Total time:   0.000552000
 Self time:   0.000552000

count     total (s)      self (s)
    2                 0.000028000   if !isdirectory(history_dir)
                                      mkdir(history_dir, 'p')
                                      return []
                                    endif
                                  
                                    return map(glob(history_dir .. '/*.json', 0, 1), 'fnamemodify(v:val, ":t:r")')

FUNCTION  copilot_chat#history#List()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/history.vim:131
Called 2 times
Total time:   0.000799000
 Self time:   0.000247000

count     total (s)      self (s)
    2   0.000564000   0.000012000   var histories = Get()
                                  
    2                 0.000002000   if empty(histories)
                                      echo 'No saved chat histories'
                                      return
                                    endif
                                  
    2                 0.000121000   echo 'Available chat historie '
    2                 0.000001000   for history in histories
    4                 0.000041000     echo '- ' .. history
    4                 0.000001000   endfor

FUNCTION  <SNR>11_BMCanAdd()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:798
Called 53 times
Total time:   0.000761000
 Self time:   0.000761000

count     total (s)      self (s)
                                    # no directory or unlisted buffer
   53                 0.000176000   if isdirectory(name) || !buflisted(num)
                                      return false
                                    endif
                                  
                                    # no name with control characters
   50                 0.000294000   if name =~ '[\x01-\x1f]'
                                      return false
                                    endif
                                  
                                    # no special buffer, such as terminal or popup
   50                 0.000087000   var buftype = getbufvar(num, '&buftype')
   50                 0.000028000   if buftype != '' && buftype != 'nofile' && buftype != 'nowrite'
                                      return false
                                    endif
                                  
                                    # only existing buffers
                                    return bufexists(num)

FUNCTION  <SNR>122_process_hunk()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:244
Called 211 times
Total time:   0.018382000
 Self time:   0.008428000

count     total (s)      self (s)
  211                 0.000245000   let modifications = []
  211                 0.000285000   let from_line  = a:hunk[0]
  211                 0.000241000   let from_count = a:hunk[1]
  211                 0.000228000   let to_line    = a:hunk[2]
  211                 0.000237000   let to_count   = a:hunk[3]
                                  
  211   0.000885000   0.000500000   if s:is_added(from_count, to_count)
    9   0.000274000   0.000037000     call s:process_added(modifications, from_count, to_count, to_line)
    9   0.000305000   0.000033000     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                                  
  202   0.000684000   0.000388000   elseif s:is_removed(from_count, to_count)
                                      call s:process_removed(modifications, from_count, to_count, to_line)
                                      call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                                  
  202   0.000776000   0.000386000   elseif s:is_modified(from_count, to_count)
  202   0.003575000   0.000614000     call s:process_modified(modifications, from_count, to_count, to_line)
  202   0.006010000   0.000597000     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                  
                                    elseif s:is_modified_and_added(from_count, to_count)
                                      call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                      call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                      call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                                  
                                    elseif s:is_modified_and_removed(from_count, to_count)
                                      call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                      call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                      call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                                  
  211                 0.000080000   endif
  211                 0.000153000   return modifications

FUNCTION  ctrlp#hicheck()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2225
Called 16 times
Total time:   0.000211000
 Self time:   0.000211000

count     total (s)      self (s)
   16                 0.000071000 	if !hlexists(a:grp)
    8                 0.000110000 		exe 'hi link' a:grp a:defgrp
   16                 0.000009000 	en

FUNCTION  <SNR>101_AlsoClosesBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1127
Called 2 times
Total time:   0.001426000
 Self time:   0.000012000

count     total (s)      self (s)
                                      # We know that `line_B` opens a block.
                                      # Let's see if it also closes that block.
    2   0.000016000   0.000001000     var kwd: string = BlockStartKeyword(line_B.text)
    2                 0.000002000     if !START_MIDDLE_END->has_key(kwd)
                                          return false
                                      endif
                                  
    1                 0.000006000     var [start: string, middle: string, end: string] = START_MIDDLE_END[kwd]
    1                 0.000001000     var pos: list<number> = getcurpos()
    1                 0.000000000     cursor(line_B.lnum, 1)
    1   0.001400000   0.000001000     var block_end: number = SearchPairEnd(start, middle, end, line_B.lnum)
    1                 0.000001000     setpos('.', pos)
                                  
                                      return block_end > 0

FUNCTION  ctrlp#utils#mkdir()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:56
Called 14 times
Total time:   0.000262000
 Self time:   0.000262000

count     total (s)      self (s)
   14                 0.000191000 	if exists('*mkdir') && !isdirectory(a:dir)
                                  		sil! cal mkdir(a:dir, 'p')
   14                 0.000009000 	en
   14                 0.000018000 	retu a:dir

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:53
Called 167 times
Total time:   0.015005000
 Self time:   0.012846000

count     total (s)      self (s)
  167                 0.000473000     if empty(a:executable)
                                          " Don't log the executable check if the executable string is empty.
                                          return 0
  167                 0.000122000     endif
                                  
                                      " Check for a cached executable() check.
  167                 0.001008000     let l:result = get(s:executable_cache_map, a:executable, v:null)
                                  
  167                 0.000416000     if l:result isnot v:null
  130                 0.000177000         return l:result
   37                 0.000026000     endif
                                  
                                      " Check if the file is executable, and convert -1 to 1.
   37                 0.008281000     let l:result = executable(a:executable) isnot 0
                                  
                                      " Cache the executable check if we found it, or if the option to cache
                                      " failing checks is on.
   37                 0.000188000     if l:result || get(g:, 'ale_cache_executable_check_failures')
    1                 0.000001000         let s:executable_cache_map[a:executable] = l:result
   37                 0.000029000     endif
                                  
   37                 0.000080000     if g:ale_history_enabled
   37   0.002670000   0.000511000         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
   37                 0.000034000     endif
                                  
   37                 0.000059000     return l:result

FUNCTION  <SNR>118_has_fresh_changes()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:175
Called 130 times
Total time:   0.003067000
 Self time:   0.001360000

count     total (s)      self (s)
  130   0.002877000   0.001170000   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  ale#handlers#cspell#DefineLinter()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/cspell.vim:67
Called 1 time
Total time:   0.000235000
 Self time:   0.000020000

count     total (s)      self (s)
    1   0.000012000   0.000004000     call ale#Set('cspell_executable', 'cspell')
    1   0.000010000   0.000002000     call ale#Set('cspell_options', '')
    1   0.000010000   0.000003000     call ale#Set('cspell_use_global', get(g:, 'ale_use_global_executables', 0))
                                  
    1   0.000203000   0.000011000     call ale#linter#Define(a:filetype, {   'name': 'cspell',   'executable': function('ale#handlers#cspell#GetExecutable'),   'command': function('ale#handlers#cspell#GetCommand'),   'callback': 'ale#handlers#cspell#Handle',})

FUNCTION  ale#Escape()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:233
Called 262 times
Total time:   0.006337000
 Self time:   0.006337000

count     total (s)      self (s)
  262                 0.002056000     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                          " If the string contains spaces, it will be surrounded by quotes.
                                          " Otherwise, special characters will be escaped with carets (^).
                                          return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
  262                 0.000210000     endif
                                  
  262                 0.001281000     return shellescape (a:str)

FUNCTION  <SNR>167_dosigns()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1677
Called 8 times
Total time:   0.000045000
 Self time:   0.000045000

count     total (s)      self (s)
    8                 0.000041000 	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:202
Called 2675 times
Total time:   0.017178000
 Self time:   0.017178000

count     total (s)      self (s)
 2675                 0.016169000     return has('win16') || has('win32') || has('win64')

FUNCTION  gitgutter#all()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:3
Called 87 times
Total time:   0.554095000
 Self time:   0.071514000

count     total (s)      self (s)
   87                 0.001020000   let visible = tabpagebuflist()
                                  
 1698                 0.003833000   for bufnr in range(1, bufnr('$') + 1)
 1611                 0.004131000     if buflisted(bufnr)
  460                 0.032261000       let file = expand('#'.bufnr.':p')
  460                 0.002021000       if !empty(file)
  431                 0.001517000         if index(visible, bufnr) != -1
   81   0.479731000   0.002098000           call gitgutter#process_buffer(bufnr, a:force)
  350                 0.000502000         elseif a:force
   81   0.005804000   0.000856000           call s:reset_tick(bufnr)
  431                 0.000337000         endif
  460                 0.000300000       endif
 1611                 0.001311000     endif
 1698                 0.001661000   endfor

FUNCTION  <lambda>453()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:981
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                  return InCommentOrString()

FUNCTION  vader#log()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:237
Called 4 times
Total time:   0.000297000
 Self time:   0.000066000

count     total (s)      self (s)
    4                 0.000025000   let msg = type(a:msg) == 1 ? a:msg : string(a:msg)
    4   0.000257000   0.000026000   call vader#window#append('> ' . msg, s:indent)

FUNCTION  vader#syntax#reset()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/syntax.vim:26
Called 2 times
Total time:   0.000004000
 Self time:   0.000004000

count     total (s)      self (s)
    2                 0.000003000   let b:vader_types = {}

FUNCTION  <lambda>454()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1124
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                  return synIDattr(id, 'name') =~ '\ccomment\|string\|heredoc'

FUNCTION  gitgutter#buffer_enable()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:103
Called 13 times
Total time:   0.001523000
 Self time:   0.000192000

count     total (s)      self (s)
   13                 0.000072000   let bufnr = a:0 ? a:1 : bufnr('')
   13   0.000238000   0.000051000   call gitgutter#utility#setbufvar(bufnr, 'enabled', 1)
   13   0.001192000   0.000048000   call gitgutter#process_buffer(bufnr, 1)

FUNCTION  <SNR>167_lsCmd()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:412
Called 1 time
Total time:   0.000006000
 Self time:   0.000006000

count     total (s)      self (s)
    1                 0.000001000 	let cmd = s:usrcmd
    1                 0.000002000 	if type(cmd) == 1
    1                 0.000001000 		retu cmd
                                  	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                                  		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                                  			retu len(cmd) == 3 ? cmd[2] : ''
                                  		en
                                  		let s:vcscmd = s:lash == '\'
                                  		retu cmd[1]
                                  	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                                  		let fndroot = []
                                  		if has_key(cmd, 'types') && cmd['types'] != {}
                                  			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                                  			for pair in cmdtypes
                                  				cal add(markrs, pair[0])
                                  			endfo
                                  			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                                  		en
                                  		if fndroot == []
                                  			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                                  		en
                                  		for pair in cmdtypes
                                  			if pair[0] == fndroot[0] | brea | en
                                  		endfo
                                  		let s:vcscmd = s:lash == '\'
                                  		retu pair[1]
                                  	en

FUNCTION  ctrlp#utils#cachefile()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:38
Called 3 times
Total time:   0.000213000
 Self time:   0.000191000

count     total (s)      self (s)
    3                 0.000112000 	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
    3                 0.000058000 	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
    3   0.000041000   0.000019000 	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file

FUNCTION  <SNR>114_GatherOutput()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:281
Called 108 times
Total time:   0.000475000
 Self time:   0.000475000

count     total (s)      self (s)
  108                 0.000433000     call add(a:line_list, a:line)

FUNCTION  <SNR>101_Indent()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:870
Called 3 times
Total time:   0.000004000
 Self time:   0.000004000

count     total (s)      self (s)
    3                 0.000000000     if lnum <= 0
                                          # Don't  return `-1`.  It could cause `Expr()` to return a non-multiple of `'shiftwidth'`.{{{
                                          #
                                          # It would be  OK if we were always returning  `Indent()` directly.  But
                                          # we  don't.  Most  of  the  time, we  include  it  in some  computation
                                          # like  `Indent(...) + shiftwidth()`.   If  `'shiftwidth'` is  `4`,  and
                                          # `Indent()` returns `-1`, `Expr()` will end up returning `3`.
                                          #}}}
                                          return 0
                                      endif
                                      return indent(lnum)

FUNCTION  <SNR>104_InCommentOrString()
    Defined: ~/.vim/bundle/vim9-syntax/import/vim9SyntaxUtil.vim:133
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      return synstack(lnum, col)
                                          ->indexof((_, id: number): bool =>
                                              synIDattr(id, 'name') =~ '\ccomment\|string\|heredoc') >= 0

FUNCTION  ale#balloon#Enable()
    Defined: ~/.vim/bundle/ale/autoload/ale/balloon.vim:64
Called 1 time
Total time:   0.000010000
 Self time:   0.000010000

count     total (s)      self (s)
    1                 0.000002000     if has('balloon_eval')
    1                 0.000001000         set ballooneval
    1                 0.000002000         set balloonexpr=ale#balloon#Expr()
    1                 0.000000000     endif
                                  
    1                 0.000001000     if has('balloon_eval_term')
    1                 0.000001000         set balloonevalterm
    1                 0.000001000         set balloonexpr=ale#balloon#Expr()
    1                 0.000000000     endif

FUNCTION  <SNR>113_GetLintFileSlots()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:626
Called 167 times
Total time:   0.007156000
 Self time:   0.007156000

count     total (s)      self (s)
  167                 0.000430000     let l:linter_slots = []
                                  
  334                 0.000648000     for l:linter in a:linters
  167                 0.000511000         let l:LintFile = l:linter.lint_file
                                  
  167                 0.000640000         if type(l:LintFile) is v:t_func
                                              let l:LintFile = l:LintFile(a:buffer)
  167                 0.000160000         endif
                                  
  167                 0.000794000         call add(l:linter_slots, [l:LintFile, l:linter])
  334                 0.000386000     endfor
                                  
  167                 0.000302000     return l:linter_slots

FUNCTION  ale#handlers#writegood#DefineLinter()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/writegood.vim:64
Called 1 time
Total time:   0.000201000
 Self time:   0.000011000

count     total (s)      self (s)
    1   0.000200000   0.000010000     call ale#linter#Define(a:filetype, {   'name': 'writegood',   'aliases': ['write-good'],   'executable': function('ale#handlers#writegood#GetExecutable'),   'command': function('ale#handlers#writegood#GetCommand'),   'callback': 'ale#handlers#writegood#Handle',})

FUNCTION  ctrlp#utils#globpath()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:74
Called 12 times
Total time:   0.000191000
 Self time:   0.000191000

count     total (s)      self (s)
   12                 0.000188000 	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])

FUNCTION  <SNR>81_init()
    Defined: ~/.vim/bundle/markdown-preview.nvim/plugin/mkdp.vim:135
Called 1 time
Total time:   0.000025000
 Self time:   0.000025000

count     total (s)      self (s)
    1                 0.000001000   augroup mkdp_init
    1                 0.000014000     autocmd!
    1                 0.000001000     if g:mkdp_command_for_global
                                        autocmd BufEnter * :call s:init_command()
    1                 0.000001000     else
    1                 0.000002000       autocmd BufEnter,FileType * if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
    1                 0.000000000     endif
    1                 0.000001000     if g:mkdp_auto_start
                                        execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#open_preview_page()'
    1                 0.000000000     endif
    1                 0.000001000     if g:mkdp_combine_preview && g:mkdp_combine_preview_auto_refresh
                                        execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#combine_preview_refresh()'
    1                 0.000000000     endif
    1                 0.000001000   augroup END

FUNCTION  <SNR>106_Lint()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:96
Called 203 times
Total time:   1.033988000
 Self time:   0.038274000

count     total (s)      self (s)
                                      " Use the filetype from the buffer
  203                 0.004278000     let l:filetype = getbufvar(a:buffer, '&filetype')
  203   0.129911000   0.003491000     let l:linters = ale#linter#Get(l:filetype)
                                  
  203   0.006163000   0.001613000     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
  203   0.004582000   0.001132000     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                                  
                                      " Load code to ignore linters only if we need to.
  203                 0.003069000     if (   !empty(l:ignore_config)   || l:disable_lsp is 1   || l:disable_lsp is v:true   || (l:disable_lsp is# 'auto' && get(g:, 'lspconfig', 0)))
                                          let l:linters = ale#engine#ignore#Exclude(   l:filetype,   l:linters,   l:ignore_config,   l:disable_lsp,)
  203                 0.000189000     endif
                                  
                                      " Tell other sources that they can start checking the buffer now.
  203                 0.001353000     let g:ale_want_results_buffer = a:buffer
  203   0.005941000   0.005568000     silent doautocmd <nomodeline> User ALEWantResults
  203                 0.000813000     unlet! g:ale_want_results_buffer
                                  
                                      " Don't set up buffer data and so on if there are no linters to run.
  203                 0.001537000     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
   36                 0.000056000         return
  167                 0.000153000     endif
                                  
                                      " Clear lint_file linters, or only run them if the file exists.
  167                 0.006109000     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                                  
  167   0.864165000   0.003244000     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:438
Called 131 times
Total time:   0.001108000
 Self time:   0.001108000

count     total (s)      self (s)
  131                 0.000320000     let l:Command = a:linter.command
                                  
  131                 0.000641000     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  copilot_chat#buffer#ApplyCodeBlockSyntax()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:268
Called 205 times
Total time:   0.004577000
 Self time:   0.004577000

count     total (s)      self (s)
                                    # Debounce syntax highlighting to avoid excessive recalculations
  205                 0.000663000   if syntax_timer != -1
  165                 0.000554000     timer_stop(syntax_timer)
  165                 0.000038000   endif
  205                 0.001979000   syntax_timer = timer_start(g:copilot_chat_syntax_debounce_ms, function('ApplyCodeBlockSyntaxImpl'))

FUNCTION  gitgutter#sign#clear_signs()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:38
Called 13 times
Total time:   0.000120000
 Self time:   0.000120000

count     total (s)      self (s)
   13                 0.000031000   if exists('*sign_unplace')
   13                 0.000062000     call sign_unplace('gitgutter', {'buffer': a:bufnr})
   13                 0.000010000     return
                                    endif
                                  
                                  
                                    call s:find_current_signs(a:bufnr)
                                  
                                    let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                                    call s:remove_signs(a:bufnr, sign_ids, 1)
                                    call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})

FUNCTION  vader#window#cleanup()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:127
Called 5 times
Total time:   0.016325000
 Self time:   0.000821000

count     total (s)      self (s)
    5   0.008110000   0.000618000   execute 'silent! bd' s:workbench_bfr
    5   0.008033000   0.000030000   call s:switch_to_console()
    5   0.000048000   0.000039000   setlocal nomodifiable
    5                 0.000042000   nnoremap <silent> <buffer> q :call <SID>quit()<CR><CR>
    5                 0.000084000   normal! Gzb

FUNCTION  ctrlp#utils#opts()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:16
Called 3 times
Total time:   0.000208000
 Self time:   0.000153000

count     total (s)      self (s)
    3   0.000022000   0.000012000 	let s:lash = ctrlp#utils#lash()
    3   0.000040000   0.000017000 	let usrhome = $HOME . s:lash( $HOME )
    3                 0.000015000 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    3   0.000090000   0.000068000 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    3                 0.000006000 	if exists('g:ctrlp_cache_dir')
                                  		let cadir = expand(g:ctrlp_cache_dir, 1)
                                  		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                                  			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                                  		en
    3                 0.000002000 	en
    3                 0.000005000 	let s:cache_dir = cadir

FUNCTION  ctrlp#utils#lash()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:8
Called 7 times
Total time:   0.000027000
 Self time:   0.000027000

count     total (s)      self (s)
    7                 0.000026000 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  <SNR>76_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:231
Called 288 times
Total time:   0.048743000
 Self time:   0.003479000

count     total (s)      self (s)
  288   0.048556000   0.003292000   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  ale_linters#vim#vimls#GetProjectRoot()
    Defined: ~/.vim/bundle/ale/ale_linters/vim/vimls.vim:8
Called 36 times
Total time:   0.026381000
 Self time:   0.014897000

count     total (s)      self (s)
   36                 0.000267000     let l:trigger_file_candidates = [   '.vimrc',   'init.vim',]
                                  
  108                 0.000275000     for l:candidate in l:trigger_file_candidates
   72                 0.000635000         let l:trigger_file = fnamemodify(bufname(a:buffer), ':t')
                                  
   72                 0.000256000         if l:trigger_file is# l:candidate
                                              return fnamemodify(   bufname(a:buffer),   ':h',)
   72                 0.000070000         endif
  108                 0.000132000     endfor
                                  
   36                 0.000210000     let l:trigger_dir_candidates = [   'autoload',   'plugin',   '.git',]
                                  
   36   0.015752000   0.007159000     let l:path_upwards = ale#path#Upwards(fnamemodify(bufname(a:buffer), ':p:h'))
                                  
   72                 0.000180000     for l:path in l:path_upwards
  180                 0.000392000         for l:candidate in l:trigger_dir_candidates
  144   0.003953000   0.001062000             let l:trigger_dir = ale#path#Simplify(   l:path . '/' . l:candidate,)
                                  
  144                 0.001642000             if isdirectory(l:trigger_dir)
   36                 0.000366000                 return fnamemodify(   l:trigger_dir,   ':p:h:h',)
  108                 0.000107000             endif
  144                 0.000147000         endfor
   36                 0.000030000     endfor
                                  
                                      return ''

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 101 times
Total time:   0.000345000
 Self time:   0.000345000

count     total (s)      self (s)
  101                 0.000256000   return s:available

FUNCTION  <SNR>101_AtStartOf()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1002
Called 12 times
Total time:   0.015033000
 Self time:   0.000556000

count     total (s)      self (s)
   12                 0.000018000     if syntax == 'BracketBlock'
                                          return AtStartOfBracketBlock(line_A)
                                      endif
                                  
    9                 0.000039000     var pat: string = {
                                          HereDoc: ASSIGNS_HEREDOC,
                                          FuncHeader: STARTS_FUNCTION
                                      }[syntax]
                                      return line_A.text =~ pat
                                          && (!exists('b:vimindent') || !b:vimindent->has_key('is_HereDoc'))

FUNCTION  copilot_chat#models#Current()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/models.vim:82
Called 4 times
Total time:   0.000038000
 Self time:   0.000028000

count     total (s)      self (s)
                                    return config.GetValue(model_key, default_model)

FUNCTION  <SNR>76_winshell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:67
Called 93 times
Total time:   0.000881000
 Self time:   0.000881000

count     total (s)      self (s)
   93                 0.000812000   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:220
Called 211 times
Total time:   0.005588000
 Self time:   0.005588000

count     total (s)      self (s)
  211                 0.002864000   let matches = matchlist(a:line, s:hunk_re)
  211                 0.000320000   if len(matches) > 0
  211                 0.000446000     let from_line  = str2nr(matches[1])
  211                 0.000553000     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
  211                 0.000323000     let to_line    = str2nr(matches[3])
  211                 0.000458000     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
  211                 0.000389000     return [from_line, from_count, to_line, to_count]
                                    else
                                      return []
                                    end

FUNCTION  copilot_chat#buffer#HasActiveChat()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:61
Called 3 times
Total time:   0.000033000
 Self time:   0.000033000

count     total (s)      self (s)
    3                 0.000012000   if g:copilot_chat_active_buffer == -1
                                      return 0
                                    endif
                                  
    2                 0.000002000   if !bufexists(g:copilot_chat_active_buffer)
                                      return 0
                                    endif
                                  
    2                 0.000012000   var buf: list<dict<any>> = getbufinfo(g:copilot_chat_active_buffer)
    2                 0.000000000   if empty(buf)
                                      return 0
                                    endif
                                  
                                    return 1

FUNCTION  copilot_chat#buffer#AppendMessage()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:191
Called 28 times
Total time:   0.000548000
 Self time:   0.000548000

count     total (s)      self (s)
   28                 0.000510000   appendbufline(g:copilot_chat_active_buffer, '$', message)

FUNCTION  <SNR>167_usrign()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1534
Called 35 times
Total time:   0.001158000
 Self time:   0.001158000

count     total (s)      self (s)
   35                 0.001150000 	retu s:igntype == 1 ? a:item =~ s:usrign : s:igntype == 4 && has_key(s:usrign, a:type) && s:usrign[a:type] != '' ? a:item =~ s:usrign[a:type] : 0

FUNCTION  <SNR>156_StartIfExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:484
Called 36 times
Total time:   0.013102000
 Self time:   0.000944000

count     total (s)      self (s)
   36   0.000389000   0.000177000     if ale#command#IsDeferred(a:executable)
                                          let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                                  
                                          return 1
   36                 0.000026000     endif
                                  
   36   0.012242000   0.000296000     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
   36                 0.000045000         return 0
                                      endif
                                  
                                      let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                                  
                                      return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  nerdtree#loadClassFiles()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:175
Called 1 time
Total time:   0.003006000
 Self time:   0.001596000

count     total (s)      self (s)
    1   0.000385000   0.000120000     runtime lib/nerdtree/path.vim
    1   0.000187000   0.000119000     runtime lib/nerdtree/menu_controller.vim
    1   0.000157000   0.000111000     runtime lib/nerdtree/menu_item.vim
    1   0.000164000   0.000111000     runtime lib/nerdtree/key_map.vim
    1   0.000228000   0.000110000     runtime lib/nerdtree/bookmark.vim
    1   0.000226000   0.000115000     runtime lib/nerdtree/tree_file_node.vim
    1   0.000333000   0.000115000     runtime lib/nerdtree/tree_dir_node.vim
    1   0.000207000   0.000109000     runtime lib/nerdtree/opener.vim
    1   0.000240000   0.000110000     runtime lib/nerdtree/creator.vim
    1   0.000141000   0.000111000     runtime lib/nerdtree/flag_set.vim
    1   0.000182000   0.000111000     runtime lib/nerdtree/nerdtree.vim
    1   0.000275000   0.000107000     runtime lib/nerdtree/ui.vim
    1   0.000146000   0.000134000     runtime lib/nerdtree/event.vim
    1   0.000134000   0.000112000     runtime lib/nerdtree/notifier.vim

FUNCTION  copilot_chat#buffer#Create()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:37
Called 3 times
Total time:   0.027872000
 Self time:   0.026566000

count     total (s)      self (s)
    3   0.001181000   0.000001000   WindowSplit()
                                  
    3                 0.006310000   enew
                                  
    3                 0.000039000   setlocal buftype=nofile
    3                 0.000011000   setlocal bufhidden=hide
    3                 0.000026000   setlocal noswapfile
    3                 0.018296000   setlocal filetype=copilot_chat
    3                 0.000004000   if copilot_list_chat_buffer == 0
    3                 0.000400000     setlocal nobuflisted
    3                 0.000000000   endif
                                  
                                    # Set buffer name
    3                 0.001454000   execute 'file CopilotChat-' .. chat_count
    3                 0.000005000   chat_count += 1
                                  
                                    # Save buffer number for reference
    3                 0.000005000   g:copilot_chat_active_buffer = bufnr('%')
    3                 0.000006000   b:added_syntaxes = []
    3   0.000127000   0.000001000   WelcomeMessage()
                                    return g:copilot_chat_active_buffer

FUNCTION  <SNR>158_cleanup()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:282
Called 5 times
Total time:   0.000123000
 Self time:   0.000123000

count     total (s)      self (s)
    5                 0.000019000   let s:register = {}
    5                 0.000013000   let s:register_undefined = []
    5                 0.000023000   delcommand Log
    5                 0.000007000   delcommand Save
    5                 0.000006000   delcommand Restore
    5                 0.000006000   delcommand Assert
    5                 0.000010000   delcommand AssertEqual
    5                 0.000007000   delcommand AssertNotEqual
    5                 0.000007000   delcommand AssertThrows
    5                 0.000006000   unlet g:SyntaxAt
    5                 0.000011000   unlet g:SyntaxOf

FUNCTION  tabular#ElementFormatPattern()
    Defined: ~/.vim/bundle/tabular/autoload/tabular.vim:220
Called 6 times
Total time:   0.000006000
 Self time:   0.000006000

count     total (s)      self (s)
    6                 0.000006000   return s:formatelempat

FUNCTION  <SNR>167_MatchedItems()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:475
Called 4 times
Total time:   0.001025000
 Self time:   0.000115000

count     total (s)      self (s)
    4                 0.000011000 	let exc = exists('s:crfilerel') ? s:crfilerel : ''
    4   0.000049000   0.000019000 	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
    4                 0.000005000 	if s:matcher != {}
                                  		let argms = has_key(s:matcher, 'arg_type') && s:matcher['arg_type'] == 'dict' ? [{ 'items':  items, 'str':    a:pat, 'limit':  a:limit, 'mmode':  s:mmode(), 'ispath': s:ispath, 'crfile': exc, 'regex':  s:regexp, }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                                  		let lines = call(s:matcher['match'], argms, s:matcher)
    4                 0.000001000 	el
    4   0.000902000   0.000022000 		let lines = s:MatchIt(items, a:pat, a:limit, exc)
    4                 0.000002000 	en
    4                 0.000007000 	let s:matches = len(lines)
    4                 0.000003000 	unl! s:did_exp
    4                 0.000002000 	retu lines

FUNCTION  vader#helper#syntax_at()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/helper.vim:1
Called 7 times
Total time:   0.000515000
 Self time:   0.000515000

count     total (s)      self (s)
    7                 0.000011000   syntax sync fromstart
    7                 0.000010000   if a:0 < 2
                                      let l:pos = getpos('.')
                                      let l:cur_lnum = pos[1]
                                      let l:cur_col = pos[2]
                                      if a:0 == 0
                                        let l:lnum = l:cur_lnum
                                        let l:col = l:cur_col
                                      else
                                        let l:lnum = l:cur_lnum
                                        let l:col = a:1
                                      endif
    7                 0.000004000   else
    7                 0.000010000     let l:lnum = a:1
    7                 0.000007000     let l:col = a:2
    7                 0.000006000   endif
    7                 0.000248000   call map(synstack(l:lnum, l:col), 'synIDattr(v:val, "name")')
    7                 0.000139000   return synIDattr(synID(l:lnum, l:col, 1), 'name')

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 93 times
Total time:   0.007754000
 Self time:   0.004801000

count     total (s)      self (s)
   93                 0.000189000   if exists('*sign_unplace')
                                      " Vim is (hopefully) now quick enough to remove all signs then place new ones.
   93                 0.000448000     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                                  
   93   0.001102000   0.000313000     let modified_lines = s:handle_double_hunk(a:modified_lines)
   93   0.005014000   0.002850000     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                                  
   93                 0.000155000     if exists('*sign_placelist')
   93                 0.000423000       call sign_placelist(signs)
   93                 0.000044000       return
                                      endif
                                  
                                      for sign in signs
                                        call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                      endfor
                                      return
                                    endif
                                  
                                  
                                    " Derive a delta between the current signs and the ones we want.
                                    " Remove signs from lines that no longer need a sign.
                                    " Upsert the remaining signs.
                                  
                                    call s:find_current_signs(a:bufnr)
                                  
                                    let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                                    let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                                  
                                    call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                                    call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>167_formatline()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1433
Called 20 times
Total time:   0.000547000
 Self time:   0.000452000

count     total (s)      self (s)
   20                 0.000028000 	let str = a:str
   20                 0.000017000 	if s:itemtype == 1
                                  		let filpath = fnamemodify(str, ':p')
                                  		let bufnr = s:nonamecond(str, filpath) ? str2nr(matchstr(str, '[\/]\?\[\zs\d\+\ze\*No Name\]$')) : bufnr('^'.filpath.'$')
                                  		let idc = ( bufnr == bufnr('#') ? '#' : '' ) . ( getbufvar(bufnr, '&ma') ? '' : '-' ) . ( getbufvar(bufnr, '&ro') ? '=' : '' ) . ( getbufvar(bufnr, '&mod') ? '+' : '' )
                                  		let str .= idc != '' ? ' '.idc : ''
   20                 0.000007000 	en
   20   0.000170000   0.000075000 	let cond = s:ispath && ( s:winw - 4 ) < s:strwidth(str)
   20                 0.000054000 	retu '> '.( cond ? s:pathshorten(str) : str )

FUNCTION  <SNR>167_mfunc()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2119
Called 2 times
Total time:   0.000043000
 Self time:   0.000039000

count     total (s)      self (s)
    2                 0.000002000 	let mfunc = 'match'
    2   0.000014000   0.000010000 	if s:byfname()
                                  		let mfunc = 's:matchfname'
    2                 0.000003000 	elsei s:itemtype > 2
                                  		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                                  		if has_key(matchtypes, s:matchtype)
                                  			let mfunc = matchtypes[s:matchtype]
                                  		en
    2                 0.000000000 	en
    2                 0.000002000 	retu mfunc

FUNCTION  <SNR>124_handle_double_hunk()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 93 times
Total time:   0.000789000
 Self time:   0.000789000

count     total (s)      self (s)
   93                 0.000357000   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                      return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
   93                 0.000037000   endif
                                  
   93                 0.000081000   return a:modified_lines

FUNCTION  <SNR>167_getenv()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2009
Called 2 times
Total time:   0.000819000
 Self time:   0.000527000

count     total (s)      self (s)
    2                 0.000161000 	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
    2                 0.000024000 	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
    2                 0.000019000 	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
    2                 0.000013000 	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
    2   0.000312000   0.000026000 	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
    2                 0.000176000 	let s:crfile = bufname('%') == '' ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
    2                 0.000090000 	let s:crfpath = expand('%:p:h', 1)
    2   0.000018000   0.000012000 	let s:mrbs = ctrlp#mrufiles#bufs()

FUNCTION  ale#balloon#Expr()
    Defined: ~/.vim/bundle/ale/autoload/ale/balloon.vim:48
Called 23 times
Total time:   0.004731000
 Self time:   0.001309000

count     total (s)      self (s)
   23   0.004593000   0.001171000     return ale#balloon#MessageForPos(v:beval_bufnr, v:beval_lnum, v:beval_col)

FUNCTION  <SNR>11_SetupCompilers()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:711
Called 1 time
Total time:   0.016147000
 Self time:   0.016147000

count     total (s)      self (s)
    1                 0.000003000   if s:did_setup_compilers
                                      return
                                    endif
    1                 0.000002000   s:did_setup_compilers = 1
                                  
    1                 0.009145000   var names = globpath(&runtimepath, "compiler/*.vim", 1, 1)
    1                 0.000000000   var idx = 100
    1                 0.000002000   for name in names
                                      # Ignore case for VMS and windows
  120                 0.003688000     var cname = substitute(name, '\c.*[/\\:\]]\([^/\\:]*\)\.vim', '\1', '')
  120                 0.003223000     exe "an 30.440." .. idx .. ' &Tools.Se&t\ Compiler.' .. cname .. " :compiler " .. cname .. "<CR>"
  120                 0.000007000     idx += 10
  120                 0.000021000   endfor
    1                 0.000022000   silent! aunmenu &Tools.Show\ Compiler\ Se&ttings\ in\ Menu

FUNCTION  ctrlp#utils#cachedir()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:34
Called 7 times
Total time:   0.000017000
 Self time:   0.000017000

count     total (s)      self (s)
    7                 0.000014000 	retu s:cache_dir

FUNCTION  ctrlp#complen()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1264
Called 157 times
Total time:   0.000688000
 Self time:   0.000688000

count     total (s)      self (s)
                                  	" By length
  157                 0.000354000 	let [len1, len2] = [strlen(a:1), strlen(a:2)]
  157                 0.000260000 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  <SNR>113_RunIfExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:562
Called 131 times
Total time:   0.643202000
 Self time:   0.012306000

count     total (s)      self (s)
  131   0.001405000   0.000685000     if ale#command#IsDeferred(a:executable)
                                          let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                                  
                                          return 1
  131                 0.000093000     endif
                                  
  131   0.003855000   0.000796000     if ale#engine#IsExecutable(a:buffer, a:executable)
                                          " Use different job types for file or linter jobs.
  131                 0.000385000         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
  131                 0.000917000         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                                  
                                          " Get the cwd for the linter and set it before we call GetCommand.
                                          " This will ensure that ale#command#Run uses it by default.
  131   0.002154000   0.000783000         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                                  
  131                 0.000373000         if l:cwd isnot v:null
                                              call ale#command#SetCwd(a:buffer, l:cwd)
  131                 0.000110000         endif
                                  
  131   0.001858000   0.000750000         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                  
  131                 0.000249000         if l:cwd isnot v:null
                                              call ale#command#ResetCwd(a:buffer)
  131                 0.000096000         endif
                                  
  131                 0.001843000         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                                  
  131   0.626316000   0.001678000         return s:RunJob(l:command, l:options)
                                      endif
                                  
                                      return 0

FUNCTION  vader#assert#equal()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/assert.vim:72
Called 9 times
Total time:   0.000413000
 Self time:   0.000265000

count     total (s)      self (s)
    9                 0.000028000   let [Exp, Got] = a:000[0:1]
    9                 0.000024000   let s:assertions[1] += 1
                                  
    9   0.000184000   0.000036000   call s:check_types(Exp, Got)
    9                 0.000012000   if Exp !=# Got
                                      let type = type(Exp)
                                      let type_name = get(s:type_names, type)
                                      let type_name_plural = type_name ==# 'Dictionary' ? 'Dictionaries' : type_name.'s'
                                      let msg = (type == type({}) || type == type([])) ? printf("Unequal %s\n      %%s should be equal to\n      %%s", type_name_plural) : '%s should be equal to %s'
                                      throw get(a:000, 2, printf(msg, string(Got), string(Exp)))
    9                 0.000005000   endif
    9                 0.000017000   let s:assertions[0] += 1
    9                 0.000006000   return 1

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:232
Called 1737 times
Total time:   0.026819000
 Self time:   0.026819000

count     total (s)      self (s)
 1737                 0.002971000     let l:min = 0
 1737                 0.005731000     let l:max = len(a:loclist) - 1
                                  
 1775                 0.003620000     while 1
 1775                 0.003151000         if l:max < l:min
 1689                 0.001999000             return -1
   86                 0.000103000         endif
                                  
   86                 0.000229000         let l:mid = (l:min + l:max) / 2
   86                 0.000260000         let l:item = a:loclist[l:mid]
                                  
                                          " Binary search for equal buffers, equal lines, then near columns.
   86                 0.000183000         if l:item.bufnr < a:buffer
                                              let l:min = l:mid + 1
   86                 0.000179000         elseif l:item.bufnr > a:buffer
                                              let l:max = l:mid - 1
   86                 0.000160000         elseif l:item.lnum < a:line
   27                 0.000053000             let l:min = l:mid + 1
   59                 0.000080000         elseif l:item.lnum > a:line
   11                 0.000013000             let l:max = l:mid - 1
   48                 0.000036000         else
                                              " This part is a small sequential search.
   48                 0.000079000             let l:index = l:mid
                                  
                                              " Search backwards to find the first problem on the line.
   51                 0.000219000             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
    3                 0.000007000                 let l:index -= 1
   51                 0.000064000             endwhile
                                  
                                              " Find the last problem on or before this column.
   55                 0.000259000             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
    7                 0.000013000                 let l:index += 1
   55                 0.000029000             endwhile
                                  
                                              " Scan forwards to find the last item on the column for the item
                                              " we found, which will have the most serious problem.
   48                 0.000153000             let l:item_column = a:loclist[l:index].col
                                  
   48                 0.000214000             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                                  let l:index += 1
   48                 0.000029000             endwhile
                                  
   48                 0.000055000             return l:index
   38                 0.000035000         endif
   38                 0.000043000     endwhile

FUNCTION  ale#virtualtext#Clear()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:83
Called 143 times
Total time:   0.003610000
 Self time:   0.003610000

count     total (s)      self (s)
  143                 0.000600000     if !s:has_virt_text || !bufexists(str2nr(a:buffer))
                                          return
  143                 0.000056000     endif
                                  
  143                 0.000318000     if has('nvim')
                                          call nvim_buf_clear_namespace(a:buffer, s:ns_id, 0, -1)
  143                 0.000051000     else
  143                 0.000177000         if s:emulate_virt && s:last_virt != -1
                                              call prop_remove({'type': 'ale'})
                                              call popup_close(s:last_virt)
                                              let s:last_virt = -1
  143                 0.000227000         elseif !empty(s:hl_list)
   95                 0.000896000             call prop_remove({   'types': s:hl_list,   'all': 1,   'bufnr': a:buffer,})
  143                 0.000067000         endif
  143                 0.000063000     endif

FUNCTION  vader#syntax#_head()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/syntax.vim:40
Called 22 times
Total time:   0.000058000
 Self time:   0.000058000

count     total (s)      self (s)
   22                 0.000051000   return '\(\(^\(Given\|Expect\|Do\|Execute\|Then\|Before\|After\)\(\s\+[^:;(]\+\)\?\s*\((.*)\)\?\s*[:;]\s*$\)\|\(^Include\(\s*(.*)\)\?\s*:\)\)\@='

FUNCTION  nerdtree#runningMac()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:212
Called 2 times
Total time:   0.000006000
 Self time:   0.000006000

count     total (s)      self (s)
    2                 0.000005000     return has('gui_mac') || has('gui_macvim') || has('mac') || has('osx')

FUNCTION  <SNR>167_walker()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1986
Called 110 times
Total time:   0.000261000
 Self time:   0.000261000

count     total (s)      self (s)
  110                 0.000234000 	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:25
Called 42 times
Total time:   0.229196000
 Self time:   0.002960000

count     total (s)      self (s)
   42   0.002038000   0.000675000     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                                  
   42                 0.000104000     if l:should_lint
   42                 0.000342000         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
   42                 0.000063000     endif
                                  
   42   0.000830000   0.000243000     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                          let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                          let l:should_lint = l:should_lint && !l:will_fix
   42                 0.000031000     endif
                                  
   42   0.000779000   0.000234000     if l:should_lint && !ale#events#QuitRecently(a:buffer)
   42   0.224304000   0.000563000         call ale#Queue(0, 'lint_file', a:buffer)
   42                 0.000025000     endif

FUNCTION  modes#SetNormalModeCursorline()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:71
Called 254 times
Total time:   0.027411000
 Self time:   0.027411000

count     total (s)      self (s)
  254                 0.019167000   highlight CursorLine guibg=NONE ctermbg=NONE cterm=NONE
  254                 0.005909000   highlight LineNr guibg=NONE ctermbg=NONE

FUNCTION  blacklist#GetBlacklist()
    Defined: ~/.vim/bundle/semantic-highlight.vim/autoload/blacklist.vim:639
Called 1 time
Total time:   0.000001000
 Self time:   0.000001000

count     total (s)      self (s)
    1                 0.000001000 	return s:blacklist

FUNCTION  <SNR>126_Deduplicate()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:57
Called 143 times
Total time:   0.002280000
 Self time:   0.001206000

count     total (s)      self (s)
  143                 0.000175000     let l:list = a:list
                                  
  143   0.001195000   0.000457000     call sort(l:list, function('ale#util#LocItemCompareWithText'))
  143   0.000664000   0.000328000     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                                  
  143                 0.000112000     return l:list

FUNCTION  ale#cursor#Echom()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:14
Called 48 times
Total time:   0.007986000
 Self time:   0.004203000

count     total (s)      self (s)
   48                 0.000121000     if mode() is# 'n'
                                          " no-custom-checks
   48   0.007746000   0.003963000         exec "norm! :echom a:message\n"
   48                 0.000051000     endif

FUNCTION  copilot_chat#buffer#CheckForMacro()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:337
Called 184 times
Total time:   0.003004000
 Self time:   0.003004000

count     total (s)      self (s)
  184                 0.000335000   var current_line: string = getline('.')
  184                 0.000113000   var cursor_pos: number = col('.')
  184                 0.000193000   var before_cursor: string = strpart(current_line, 0, cursor_pos)
  184                 0.001691000   if current_line =~# '/tab all'
                                      # Get the position where the pattern starts
                                      var pattern_start: number = match(before_cursor, '/tab all')
                                  
                                      # Delete the pattern
                                      cursor(line('.'), pattern_start + 1)
                                      exec 'normal d' .. len('/tab all') .. 'l'
                                  
                                      # Generate list of tabs with #file: prefix, excluding current buffer
                                      var tab_list: list<string> = []
                                      for i in range(1, tabpagenr('$'))
                                        var buffers: list<number> = tabpagebuflist(i)
                                        for buf in buffers
                                          var filename: string = bufname(buf)
                                          # Only add if it's not the current buffer and has a filename
                                          if filename !=# '' && filename !~# 'CopilotChat'
                                            # Use the relative path format instead of just the base filename
                                            add(tab_list, $'#file: {filename}')
                                          endif
                                        endfor
                                        #let winnr = tabpagewinnr(i)
                                        #let buf_nr = buflist[winnr - 1]
                                        #let filename = bufname(buf_nr)
                                  
                                      endfor
                                  
                                      # Insert the tab list at cursor position, one per line
                                      if len(tab_list) > 0
                                        # Add a newline at the end of the text to be inserted
                                        var tabs_text: string = join(tab_list, "\n") .. "\n"
                                        exec 'normal i' .. tabs_text
                                      else
                                        exec "normal iNo other tabs found\n"
                                      endif
                                  
                                      # Position cursor on the empty line
                                      cursor(line('.'), 1)
                                    elseif current_line =~# '#file: '
                                      if completion_active == 1 && !pumvisible()
                                        completion_active = 0
                                      endif
                                      if completion_active == 0
                                        # TODO: should be resetting this after we do this
                                        # let saved_completeopt = &completeopt
                                        # timer_start(0, {-> execute('let &completeopt = "' . saved_completeopt . '"')})
                                        set completeopt=menu,menuone,noinsert,noselect
                                        var line: string = getline('.')
                                        var start: number = match(line, '#file: ') + 6
                                        var typed: string = strpart(line, start, col('.') - start - 1)
                                        if typed !=# '' && filereadable(typed) && !isdirectory(typed)
                                          return
                                        endif
                                  
                                        # Cache file list to avoid repeated git/glob calls
                                        var current_time: number = localtime()
                                        var cache_expired: bool = file_list_cache_time == 0 || (current_time - file_list_cache_time) > g:copilot_chat_file_cache_timeout
                                        if empty(file_list_cache) || cache_expired
                                          system('git rev-parse --is-inside-work-tree 2>/dev/null')
                                  
                                          if v:shell_error == 0  # We are in a git repo
                                            file_list_cache = systemlist('git ls-files --cached --others --exclude-standard')
                                          else
                                            file_list_cache = glob('**/*', 0, 1)
                                          endif
                                          file_list_cache_time = current_time
                                        endif
                                  
                                        # Filter out directories and prepare completion items
                                        var matches: list<string> = []
                                        for file in file_list_cache
                                          if !isdirectory(file) && file =~? typed
                                            add(matches, file)
                                          endif
                                        endfor
                                  
                                        # Show the completion menu
                                        complete(start + 1, matches)
                                        completion_active = 1
                                      endif
                                    endif

FUNCTION  <SNR>101_CacheBracketBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:803
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var pos: list<number> = getcurpos()
                                      var opening: string = line_A.text->matchstr(CHARACTER_UNDER_CURSOR)
                                      var closing: string = {'[': ']', '{': '}', '(': ')'}[opening]
                                      var endlnum: number = SearchPair(opening, '', closing, 'nW')
                                      setpos('.', pos)
                                      if endlnum <= line_A.lnum
                                          return
                                      endif
                                  
                                      if !exists('b:vimindent')
                                          b:vimindent = {
                                              is_BracketBlock: true,
                                              is_on_named_block_line: line_A.text =~ STARTS_NAMED_BLOCK,
                                              block_stack: [],
                                          }
                                      endif
                                  
                                      var is_dict: bool
                                      var is_curly_block: bool
                                      if opening == '{'
                                          if line_A.text =~ STARTS_CURLY_BLOCK
                                              [is_dict, is_curly_block] = [false, true]
                                          else
                                              [is_dict, is_curly_block] = [true, false]
                                          endif
                                      endif
                                      b:vimindent.block_stack->insert({
                                          is_dict: is_dict,
                                          is_curly_block: is_curly_block,
                                          startline: line_A.text,
                                          startlnum: line_A.lnum,
                                          endlnum: endlnum,
                                      })
                                  
                                      RegisterCacheInvalidation()

FUNCTION  <SNR>11_BMAdd()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:767
Called 53 times
Total time:   0.014567000
 Self time:   0.001771000

count     total (s)      self (s)
   53                 0.000084000   if s:bmenu_wait == 0
                                      # when adding too many buffers, redraw in short format
   53                 0.000088000     if s:bmenu_count == &menuitems && s:bmenu_short == 0
                                        s:BMShow()
                                      else
   53                 0.000764000       var name = expand("<afile>")
   53                 0.000109000       var num = str2nr(expand("<abuf>"))
   53   0.000868000   0.000107000       if s:BMCanAdd(name, num)
   47   0.012069000   0.000034000 	s:BMFilename(name, num)
   47                 0.000042000 	s:bmenu_count += 1
   47                 0.000005000       endif
   53                 0.000002000     endif
   53                 0.000003000   endif

FUNCTION  <SNR>76_unc_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:186
Called 101 times
Total time:   0.010584000
 Self time:   0.000851000

count     total (s)      self (s)
  101   0.010524000   0.000791000   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>101_InCommentOrString()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1122
Called 9 times
Total time:   0.015021000
 Self time:   0.015021000

count     total (s)      self (s)
                                      return synstack('.', col('.'))
                                          ->indexof((_, id: number): bool => synIDattr(id, 'name') =~ '\ccomment\|string\|heredoc') >= 0

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:129
Called 66 times
Total time:   0.000564000
 Self time:   0.000564000

count     total (s)      self (s)
   66                 0.000058000     if a:item.type is# 'I'
                                          return g:ale#util#info_priority
   66                 0.000019000     endif
                                  
   66                 0.000039000     if a:item.type is# 'W'
                                          if get(a:item, 'sub_type', '') is# 'style'
                                              return g:ale#util#style_warning_priority
                                          endif
                                  
                                          return g:ale#util#warning_priority
   66                 0.000015000     endif
                                  
   66                 0.000076000     if get(a:item, 'sub_type', '') is# 'style'
                                          return g:ale#util#style_error_priority
   66                 0.000011000     endif
                                  
   66                 0.000046000     return g:ale#util#error_priority

FUNCTION  ale#cursor#TruncatedEcho()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:21
Called 48 times
Total time:   0.011812000
 Self time:   0.003776000

count     total (s)      self (s)
   48                 0.000103000     let l:message = a:original_message
                                      " Change tabs to spaces.
   48                 0.000208000     let l:message = substitute(l:message, "\t", ' ', 'g')
                                      " Remove any newlines in the message.
   48                 0.000163000     let l:message = substitute(l:message, "\n", ' ', 'g')
                                      " Convert indentation groups into single spaces for better legibility when
                                      " put on a single line
   48                 0.000449000     let l:message = substitute(l:message, ' \+', ' ', 'g')
                                  
                                      " We need to remember the setting for shortmess and reset it again.
   48                 0.000157000     let l:shortmess_options = &l:shortmess
                                  
   48                 0.000040000     try
   48                 0.000139000         let l:cursor_position = getpos('.')
                                  
                                          " The message is truncated and saved to the history.
   48   0.000411000   0.000385000         silent! setlocal shortmess+=T
                                  
   48                 0.000034000         try
   48   0.008246000   0.000260000             call ale#cursor#Echom(l:message)
                                          catch /^Vim\%((\a\+)\)\=:E523/
                                              " Fallback into manual truncate (#1987)
                                              let l:winwidth = winwidth(0)
                                  
                                              if l:winwidth < strdisplaywidth(l:message)
                                                  " Truncate message longer than window width with trailing '...'
                                                  let l:message = l:message[:l:winwidth - 4] . '...'
                                              endif
                                  
                                              exec 'echomsg l:message'
                                          catch /E481/
                                              " Do nothing if running from a visual selection.
   48                 0.000045000         endtry
                                  
                                          " Reset the cursor position if we moved off the end of the line.
                                          " Using :norm and :echomsg can move the cursor off the end of the
                                          " line.
   48                 0.000166000         if l:cursor_position != getpos('.')
                                              call setpos('.', l:cursor_position)
   48                 0.000027000         endif
   48                 0.000069000     finally
   48   0.000257000   0.000233000         let &l:shortmess = l:shortmess_options
   48                 0.000043000     endtry

FUNCTION  nerdtree#postSourceActions()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:193
Called 1 time
Total time:   0.002412000
 Self time:   0.000629000

count     total (s)      self (s)
    1   0.000057000   0.000003000     call g:NERDTreeBookmark.CacheBookmarks(1)
    1   0.001168000   0.000004000     call nerdtree#ui_glue#createDefaultBindings()
                                  
                                      "load all nerdtree plugins
    1   0.001186000   0.000621000     runtime! nerdtree_plugin/**/*.vim

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:714
Called 167 times
Total time:   0.860619000
 Self time:   0.011431000

count     total (s)      self (s)
                                      " Initialise the buffer information if needed.
  167   0.004884000   0.001452000     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                                  
  167   0.854408000   0.008652000     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 741 times
Total time:   0.011332000
 Self time:   0.011332000

count     total (s)      self (s)
  741                 0.001278000   let buffer = +a:buffer
                                    " Default value for getbufvar() was introduced in Vim 7.3.831.
  741                 0.002339000   let ggvars = getbufvar(buffer, 'gitgutter')
  741                 0.001460000   if type(ggvars) == type('')
   44                 0.000087000     unlet ggvars
   44                 0.000073000     let ggvars = {}
   44                 0.000152000     call setbufvar(buffer, 'gitgutter', ggvars)
  741                 0.000351000   endif
  741                 0.001908000   let ggvars[a:varname] = a:val

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:170
Called 1061 times
Total time:   0.004356000
 Self time:   0.004356000

count     total (s)      self (s)
 1061                 0.003950000     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>48_record()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:57
Called 402 times
Total time:   0.277435000
 Self time:   0.021628000

count     total (s)      self (s)
  402                 0.002510000 	if s:locked | retu | en
  402                 0.001845000 	let bufnr = a:bufnr + 0
  402                 0.001761000 	let bufname = bufname(bufnr)
  402                 0.001708000 	if bufnr > 0 && !empty(bufname)
  326                 0.007855000 		cal filter(s:mrbs, 'v:val != bufnr')
  326                 0.001452000 		cal insert(s:mrbs, bufnr)
  326   0.258239000   0.002432000 		cal s:addtomrufs(bufname)
  402                 0.000331000 	en

FUNCTION  <SNR>159_check_types()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/assert.vim:63
Called 9 times
Total time:   0.000148000
 Self time:   0.000148000

count     total (s)      self (s)
    9                 0.000020000   let [Exp, Got] = a:000[0:1]
    9                 0.000024000   if type(Exp) !=# type(Got)
                                      throw get(a:000, 2, printf("type mismatch: %s (%s) should be equal to %s (%s)", string(Got), get(s:type_names, type(Got), type(Got)), string(Exp), get(s:type_names, type(Exp), type(Exp))))
    9                 0.000005000   endif

FUNCTION  <SNR>101_IsInCurlyBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1075
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      return b:vimindent.block_stack
                                          ->indexof((_, block: dict<any>): bool => block.is_curly_block) >= 0

FUNCTION  <SNR>11_BMHash2()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:892
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                    var nm = substitute(name, ".", '\L\0', "")
                                    if nm[0] < 'a' || nm[0] > 'z'
                                      return '&others.'
                                    elseif nm[0] <= 'd'
                                      return '&abcd.'
                                    elseif nm[0] <= 'h'
                                      return '&efgh.'
                                    elseif nm[0] <= 'l'
                                      return '&ijkl.'
                                    elseif nm[0] <= 'p'
                                      return '&mnop.'
                                    elseif nm[0] <= 't'
                                      return '&qrst.'
                                    else
                                      return '&u-z.'
                                    endif

FUNCTION  <SNR>167_MapSpecs()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:874
Called 2 times
Total time:   0.001610000
 Self time:   0.001610000

count     total (s)      self (s)
    2                 0.000007000 	if !( exists('s:smapped') && s:smapped == s:bufnr )
                                  		" Correct arrow keys in terminal
    1                 0.000019000 		if ( has('termresponse') && v:termresponse =~ "\<ESC>" ) || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi'
                                  			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
                                  				exe s:lcmap.' <esc>['.each
                                  			endfo
    1                 0.000001000 		en
    2                 0.000002000 	en
  242                 0.000260000 	for [ke, va] in items(s:prtmaps) | for kp in va
  106                 0.001013000 		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
  242                 0.000149000 	endfo | endfo
    2                 0.000004000 	let s:smapped = s:bufnr

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:299
Called 36 times
Total time:   0.029887000
 Self time:   0.003506000

count     total (s)      self (s)
   36                 0.000355000     let l:buffer_ale_root = getbufvar(a:buffer, 'ale_root', {})
                                  
   36                 0.000174000     if type(l:buffer_ale_root) is v:t_string
                                          return l:buffer_ale_root
   36                 0.000044000     endif
                                  
                                      " Try to get a buffer-local setting for the root
   36                 0.000173000     if has_key(l:buffer_ale_root, a:linter.name)
                                          let l:Root = l:buffer_ale_root[a:linter.name]
                                  
                                          if type(l:Root) is v:t_func
                                              return l:Root(a:buffer)
                                          else
                                              return l:Root
                                          endif
   36                 0.000034000     endif
                                  
                                      " Try to get a global setting for the root
   36                 0.000208000     if has_key(g:ale_root, a:linter.name)
                                          let l:Root = g:ale_root[a:linter.name]
                                  
                                          if type(l:Root) is v:t_func
                                              return l:Root(a:buffer)
                                          else
                                              return l:Root
                                          endif
   36                 0.000049000     endif
                                  
                                      " Fall back to the linter-specific configuration
   36                 0.000127000     if has_key(a:linter, 'project_root')
   36                 0.000277000         let l:Root = a:linter.project_root
                                  
   36   0.026983000   0.000602000         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                      endif
                                  
                                      return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  <SNR>167_SetDefTxt()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:619
Called 2 times
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    2                 0.000006000 	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                                  	let txt = s:deftxt
                                  	if !type(txt)
                                  		let path = s:crfpath.s:lash(s:crfpath)
                                  		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                                  	en
                                  	let s:prompt[0] = txt

FUNCTION  <SNR>113_StopCurrentJobs()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:484
Called 167 times
Total time:   0.020740000
 Self time:   0.010147000

count     total (s)      self (s)
  167                 0.001374000     let l:info = get(g:ale_buffer_info, a:buffer, {})
  167   0.010748000   0.001476000     call ale#command#StopJobs(a:buffer, 'linter')
                                  
                                      " Update the active linter list, clearing out anything not running.
  167                 0.000327000     if a:clear_lint_file_jobs
   63   0.001567000   0.000246000         call ale#command#StopJobs(a:buffer, 'file_linter')
   63                 0.000228000         let l:info.active_linter_list = []
  104                 0.000116000     else
  104                 0.000378000         let l:lint_file_map = {}
                                  
                                          " Use a previously computed map of `lint_file` values to find
                                          " linters that are used for linting files.
  208                 0.000566000         for [l:lint_file, l:linter] in a:linter_slots
  104                 0.000244000             if l:lint_file is 1
                                                  let l:lint_file_map[l:linter.name] = 1
  104                 0.000106000             endif
  208                 0.000237000         endfor
                                  
                                          " Keep jobs for linting files when we're only linting buffers.
  104                 0.001167000         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
  167                 0.000157000     endif

FUNCTION  ale#virtualtext#CompareSeverityPerLine()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:277
Called 51 times
Total time:   0.000186000
 Self time:   0.000125000

count     total (s)      self (s)
                                      " Compare lines
   51                 0.000038000     if a:left.lnum < a:right.lnum
   37                 0.000014000         return -1
   14                 0.000004000     endif
                                  
   14                 0.000007000     if a:left.lnum > a:right.lnum
   10                 0.000006000         return 1
    4                 0.000001000     endif
                                  
    4   0.000037000   0.000006000     let l:left_priority = ale#util#GetItemPriority(a:left)
    4   0.000037000   0.000007000     let l:right_priority = ale#util#GetItemPriority(a:right)
                                  
                                      " Put highest priority items first.
    4                 0.000003000     if l:left_priority > l:right_priority
                                          return -1
    4                 0.000002000     endif
                                  
    4                 0.000003000     if l:left_priority < l:right_priority
                                          return 1
    4                 0.000002000     endif
                                  
                                      " Put the first seen problem first.
    4                 0.000003000     return a:left.col - a:right.col

FUNCTION  modes#SetReplaceHighlight()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:66
Called 1 time
Total time:   0.000296000
 Self time:   0.000182000

count     total (s)      self (s)
    1   0.000125000   0.000011000   var blended = color.ComputeBlendedColor(g:modes_colors.replace.gui, gui_blend)
    1                 0.000092000   execute $'highlight CursorLine guibg={blended} cterm=underline ctermul={g:modes_colors.replace.term}'

FUNCTION  ctrlp#mrufiles#init()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:141
Called 1 time
Total time:   0.000025000
 Self time:   0.000025000

count     total (s)      self (s)
    1                 0.000003000 	if !has('autocmd') | retu | en
    1                 0.000001000 	let s:locked = 0
    1                 0.000000000 	aug CtrlPMRUF
    1                 0.000013000 		au!
    1                 0.000004000 		au BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
    1                 0.000001000 		au QuickFixCmdPre  *vimgrep* let s:locked = 1
    1                 0.000002000 		au QuickFixCmdPost *vimgrep* let s:locked = 0
    1                 0.000001000 		au VimLeavePre * cal s:savetofile(s:mergelists())
    1                 0.000000000 	aug END

FUNCTION  ale#history#Add()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:12
Called 168 times
Total time:   0.022074000
 Self time:   0.022074000

count     total (s)      self (s)
  168                 0.001173000     if g:ale_max_buffer_history_size <= 0
                                          " Don't save anything if the history isn't a positive number.
                                          call setbufvar(a:buffer, 'ale_history', [])
                                  
                                          return
  168                 0.000101000     endif
                                  
  168                 0.001433000     let l:history = getbufvar(a:buffer, 'ale_history', [])
                                  
                                      " Remove the first item if we hit the max history size.
  168                 0.000605000     if len(l:history) >= g:ale_max_buffer_history_size
  111                 0.007415000         let l:history = l:history[1:]
  168                 0.000140000     endif
                                  
  168                 0.001512000     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                                  
  168                 0.007864000     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  nerdtree#closeTreeOnOpen()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:34
Called 12 times
Total time:   0.000063000
 Self time:   0.000063000

count     total (s)      self (s)
   12                 0.000043000     return g:NERDTreeQuitOnOpen == 1 || g:NERDTreeQuitOnOpen == 3

FUNCTION  <SNR>167_iscmdwin()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1794
Called 2 times
Total time:   0.000074000
 Self time:   0.000074000

count     total (s)      self (s)
    2                 0.000008000 	let ermsg = v:errmsg
    2                 0.000023000 	sil! noa winc p
    2                 0.000012000 	sil! noa winc p
    2                 0.000010000 	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
    2                 0.000016000 	retu ermsg =~ '^E11:'

FUNCTION  <SNR>125_GroupLoclistItems()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:261
Called 143 times
Total time:   0.002514000
 Self time:   0.002514000

count     total (s)      self (s)
  143                 0.000179000     let l:grouped_items = []
  143                 0.000130000     let l:last_lnum = -1
                                  
  181                 0.000145000     for l:obj in a:loclist
   38                 0.000025000         if l:obj.bufnr != a:buffer
                                              continue
   38                 0.000011000         endif
                                  
                                          " Create a new sub-List when we hit a new line.
   38                 0.000025000         if l:obj.lnum != l:last_lnum
   36                 0.000035000             call add(l:grouped_items, [])
   38                 0.000006000         endif
                                  
   38                 0.000052000         call add(l:grouped_items[-1], l:obj)
   38                 0.000025000         let l:last_lnum = l:obj.lnum
  181                 0.000130000     endfor
                                  
  143                 0.000138000     return l:grouped_items

FUNCTION  <SNR>101_IsInInterface()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1089
Called 1 time
Total time:   0.000120000
 Self time:   0.000001000

count     total (s)      self (s)
                                      return SearchPair('interface', '', 'endinterface', 'nW') > 0

FUNCTION  gitgutter#hunk#reset()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:14
Called 13 times
Total time:   0.000533000
 Self time:   0.000108000

count     total (s)      self (s)
   13   0.000228000   0.000047000   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
   13   0.000293000   0.000049000   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>101_HereDocIndent()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:642
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      # at the end of a heredoc
                                      if line_A =~ $'^\s*{b:vimindent.endmarker}$'
                                          # `END` must be at the very start of the line if the heredoc is not trimmed
                                          if !b:vimindent.is_trimmed
                                              # We can't invalidate the cache just yet.
                                              # The indent of `END` is meaningless;  it's always 0.  The next line
                                              # will need to be indented relative to the start of the heredoc.  It
                                              # must know where it starts; it needs the cache.
                                              return 0
                                          else
                                              var ind: number = b:vimindent.startindent
                                              # invalidate the cache so that it's not used for the next heredoc
                                              unlet! b:vimindent
                                              return ind
                                          endif
                                      endif
                                  
                                      # In a non-trimmed heredoc, all of leading whitespace is semantic.
                                      # Leave it alone.
                                      if !b:vimindent.is_trimmed
                                          # But do save the indent of the assignment line.
                                          if !b:vimindent->has_key('startindent')
                                              b:vimindent.startindent = b:vimindent.startlnum->Indent()
                                          endif
                                          return -1
                                      endif
                                  
                                      # In a trimmed heredoc, *some* of the leading whitespace is semantic.
                                      # We want to preserve  it, so we can't just indent  relative to the assignment
                                      # line.  That's because we're dealing with data, not with code.
                                      # Instead, we need  to compute by how  much the indent of  the assignment line
                                      # was increased  or decreased.   Then, we  need to apply  that same  change to
                                      # every line inside the body.
                                      var offset: number
                                      if !b:vimindent->has_key('offset')
                                          var old_startindent: number = b:vimindent.startindent
                                          var new_startindent: number = b:vimindent.startlnum->Indent()
                                          offset = new_startindent - old_startindent
                                  
                                          # If all the non-empty lines in  the body have a higher indentation relative
                                          # to the assignment, there is no need to indent them more.
                                          # But if  at least one of  them does have  the same indentation level  (or a
                                          # lower one), then we want to indent it further (and the whole block with it).
                                          # This way,  we can clearly distinguish  the heredoc block from  the rest of
                                          # the code.
                                          var end: number = search($'^\s*{b:vimindent.endmarker}$', 'nW')
                                          var should_indent_more: bool = range(v:lnum, end - 1)
                                              ->indexof((_, lnum: number): bool => Indent(lnum) <= old_startindent && getline(lnum) != '') >= 0
                                          if should_indent_more
                                              offset += shiftwidth()
                                          endif
                                  
                                          b:vimindent.offset = offset
                                          b:vimindent.startindent = new_startindent
                                      endif
                                  
                                      return [0, Indent(v:lnum) + b:vimindent.offset]->max()

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:157
Called 137 times
Total time:   0.065700000
 Self time:   0.024667000

count     total (s)      self (s)
  137                 0.000351000     let old_ei = &eventignore
  137                 0.000206000     if a:ignoreAll
  109                 0.000491000         set eventignore=all
  137                 0.000103000     endif
  137                 0.000128000     try
  137   0.023620000   0.019156000         exec a:cmd
  137                 0.000171000     finally
  137   0.000591000   0.000523000         let &eventignore = old_ei
  137                 0.000168000     endtry

FUNCTION  <SNR>115_FindHistoryItem()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:36
Called 214 times
Total time:   0.002475000
 Self time:   0.001460000

count     total (s)      self (s)
                                      " Search backwards to find a matching job ID. IDs might be recycled,
                                      " so finding the last one should be good enough.
  214   0.001806000   0.000791000     for l:obj in reverse(ale#history#Get(a:buffer))
  214                 0.000188000         if l:obj.job_id == a:job_id
  214                 0.000125000             return l:obj
                                          endif
                                      endfor
                                  
                                      return {}

FUNCTION  <SNR>167_match_window_opts()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:245
Called 2 times
Total time:   0.000146000
 Self time:   0.000146000

count     total (s)      self (s)
    2                 0.000025000 	let s:mw_pos = s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') : exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' ) : 'bottom'
    2                 0.000024000 	let s:mw_order = s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') : exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' ) : 'btt'
    2                 0.000029000 	let s:mw_max = s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) : exists('g:ctrlp_max_height') ? s:mxheight : 10
    2                 0.000012000 	let s:mw_min = s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
    2                 0.000014000 	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
    2                 0.000006000 	let s:mw_min = min([s:mw_min, s:mw_max])
    2                 0.000019000 	let s:mw_res = s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+')) : min([s:mw_max, &lines])
    2                 0.000006000 	let s:mw_res = max([s:mw_res, 1])

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:72
Called 358 times
Total time:   0.012019000
 Self time:   0.012019000

count     total (s)      self (s)
  358                 0.000721000     if s:has_nvim_highlight
                                          call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
  358                 0.000259000     else
  634                 0.002283000         for l:match in getmatches()
  276                 0.003551000             if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
   48                 0.000215000                 call matchdelete(l:match.id)
  276                 0.000184000             endif
  634                 0.000542000         endfor
  358                 0.000195000     endif

FUNCTION  <SNR>101_IsInThisBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1080
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var pos: list<number> = getcurpos()
                                      cursor(lnum, [lnum, '$']->col())
                                      var end: number = SearchPairEnd('{', '', '}')
                                      setpos('.', pos)
                                  
                                      return line_A.lnum <= end

FUNCTION  <SNR>68_SID()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:672
Called 1 time
Total time:   0.000011000
 Self time:   0.000011000

count     total (s)      self (s)
    1                 0.000001000     if !exists('s:sid')
    1                 0.000009000         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
    1                 0.000000000     endif
    1                 0.000000000     return s:sid

FUNCTION  ale#virtualtext#GetGroup()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:105
Called 36 times
Total time:   0.000213000
 Self time:   0.000213000

count     total (s)      self (s)
   36                 0.000050000     let l:type = get(a:item, 'type', 'E')
   36                 0.000040000     let l:sub_type = get(a:item, 'sub_type', '')
                                  
   36                 0.000025000     if l:type is# 'E'
   36                 0.000022000         if l:sub_type is# 'style'
                                              return 'ALEVirtualTextStyleError'
   36                 0.000008000         endif
                                  
   36                 0.000018000         return 'ALEVirtualTextError'
                                      endif
                                  
                                      if l:type is# 'W'
                                          if l:sub_type is# 'style'
                                              return 'ALEVirtualTextStyleWarning'
                                          endif
                                  
                                          return 'ALEVirtualTextWarning'
                                      endif
                                  
                                      return 'ALEVirtualTextInfo'

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:460
Called 101 times
Total time:   0.001085000
 Self time:   0.001085000

count     total (s)      self (s)
  101                 0.000551000     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
  101                 0.000362000     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                                  
  101                 0.000081000     return l:timer_id

FUNCTION  <SNR>76_is_file_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:62
Called 310 times
Total time:   0.002516000
 Self time:   0.002516000

count     total (s)      self (s)
  310                 0.002251000   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  ale#command#InitData()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:22
Called 369 times
Total time:   0.004591000
 Self time:   0.004591000

count     total (s)      self (s)
  369                 0.002037000     if !has_key(s:buffer_data, a:buffer)
  114                 0.000302000         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
  369                 0.000220000     endif

FUNCTION  <SNR>167_writecache()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2142
Called 1 time
Total time:   0.005705000
 Self time:   0.000014000

count     total (s)      self (s)
    1   0.000019000   0.000008000 	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
    1   0.005682000   0.000002000 		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
    1                 0.000002000 		let g:ctrlp_newcache = 0
    1                 0.000001000 	en

FUNCTION  <SNR>167_comparent()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1295
Called 58 times
Total time:   0.004203000
 Self time:   0.001153000

count     total (s)      self (s)
                                  	" By same parent dir
   58                 0.000125000 	if !stridx(s:crfpath, s:dyncwd)
   58   0.001037000   0.000327000 		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
   58   0.002643000   0.000303000 		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
   58                 0.000176000 		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
   50                 0.000145000 		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
   46                 0.000027000 		retu 0
                                  	en
                                  	retu 0

FUNCTION  <SNR>167_findroot()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1563
Called 4 times
Total time:   0.002092000
 Self time:   0.000570000

count     total (s)      self (s)
    4                 0.000011000 	let [depth, fnd] = [a:depth + 1, 0]
    4                 0.000006000 	if type(a:mark) == 1
                                  		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
    4                 0.000007000 	elsei type(a:mark) == 3
   14                 0.000018000 		for markr in a:mark
   12   0.000930000   0.000089000 			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
    2                 0.000002000 				let fnd = 1
    2                 0.000002000 				brea
   10                 0.000005000 			en
   14                 0.000014000 		endfo
    4                 0.000002000 	en
    4                 0.000004000 	if fnd
    2   0.000362000   0.000015000 		if !a:type | cal ctrlp#setdir(a:curr) | en
    2                 0.000008000 		retu [exists('markr') ? markr : a:mark, a:curr]
    2                 0.000004000 	elsei depth > s:maxdepth
                                  		cal ctrlp#setdir(s:cwd)
    2                 0.000001000 	el
    2   0.000074000   0.000012000 		let parent = s:getparent(a:curr)
    2                 0.000003000 		if parent != a:curr
    2                 0.000007000 			retu s:findroot(parent, a:mark, depth, a:type)
                                  		en
                                  	en
                                  	retu []

FUNCTION  ale#util#LocItemCompare()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:151
Called 126 times
Total time:   0.001380000
 Self time:   0.001212000

count     total (s)      self (s)
  126                 0.000092000     if a:left.bufnr < a:right.bufnr
                                          return -1
  126                 0.000034000     endif
                                  
  126                 0.000085000     if a:left.bufnr > a:right.bufnr
                                          return 1
  126                 0.000044000     endif
                                  
  126                 0.000060000     if a:left.bufnr == -1
                                          if a:left.filename < a:right.filename
                                              return -1
                                          endif
                                  
                                          if a:left.filename > a:right.filename
                                              return 1
                                          endif
  126                 0.000040000     endif
                                  
  126                 0.000072000     if a:left.lnum < a:right.lnum
   96                 0.000048000         return -1
   30                 0.000006000     endif
                                  
   30                 0.000021000     if a:left.lnum > a:right.lnum
   20                 0.000007000         return 1
   10                 0.000006000     endif
                                  
   10                 0.000008000     if a:left.col < a:right.col
                                          return -1
   10                 0.000002000     endif
                                  
   10                 0.000008000     if a:left.col > a:right.col
                                          return 1
   10                 0.000006000     endif
                                  
                                      " When either of the items lacks a problem type, then the two items should
                                      " be considered equal. This is important for loclist jumping.
   10                 0.000019000     if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                          return 0
   10                 0.000004000     endif
                                  
   10   0.000107000   0.000017000     let l:left_priority = ale#util#GetItemPriority(a:left)
   10   0.000093000   0.000015000     let l:right_priority = ale#util#GetItemPriority(a:right)
                                  
   10                 0.000008000     if l:left_priority < l:right_priority
                                          return -1
   10                 0.000003000     endif
                                  
   10                 0.000007000     if l:left_priority > l:right_priority
                                          return 1
   10                 0.000002000     endif
                                  
   10                 0.000004000     return 0

FUNCTION  <SNR>167_maxf()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1974
Called 3 times
Total time:   0.000005000
 Self time:   0.000005000

count     total (s)      self (s)
    3                 0.000004000 	retu s:maxfiles && a:len > s:maxfiles

FUNCTION  <SNR>119_StopCursorTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:67
Called 1817 times
Total time:   0.035220000
 Self time:   0.035220000

count     total (s)      self (s)
 1817                 0.008014000     if s:cursor_timer != -1
 1623                 0.011066000         call timer_stop(s:cursor_timer)
 1623                 0.005913000         let s:cursor_timer = -1
 1817                 0.002113000     endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 559 times
Total time:   0.018924000
 Self time:   0.007977000

count     total (s)      self (s)
  559   0.010911000   0.003191000   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
  559   0.007620000   0.004393000   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:49
Called 107 times
Total time:   0.002527000
 Self time:   0.000778000

count     total (s)      self (s)
  107   0.002131000   0.000382000     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                                  
                                      " If we find a match, then set the code and status.
  107                 0.000116000     let l:obj.exit_code = a:exit_code
  107                 0.000086000     let l:obj.status = 'finished'

FUNCTION  <SNR>167_Reset()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:331
Called 2 times
Total time:   0.001548000
 Self time:   0.000066000

count     total (s)      self (s)
    2                 0.000012000 	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
    2   0.001274000   0.000018000 	cal call('s:opts', opts)
    2   0.000050000   0.000012000 	cal s:autocmds()
    2   0.000177000   0.000007000 	cal ctrlp#utils#opts()
    2   0.000032000   0.000014000 	cal s:execextvar('opts')

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:48
Called 53 times
Total time:   0.000272000
 Self time:   0.000272000

count     total (s)      self (s)
   53                 0.000074000     if a:line >= a:end_line
                                          " For single lines, just return the one position.
   53                 0.000132000         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                      endif
                                  
                                      " Get positions from the first line at the first column, up to a large
                                      " integer for highlighting up to the end of the line, followed by
                                      " the lines in-between, for highlighting entire lines, and
                                      " a highlight for the last line, up to the end column.
                                      let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                                  
                                      return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  ctrlp#init()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2250
Called 2 times
Total time:   0.156106000
 Self time:   0.000201000

count     total (s)      self (s)
    2   0.000103000   0.000029000 	if exists('s:init') || s:iscmdwin() | retu | en
    2                 0.000009000 	let [s:ermsg, v:errmsg] = [v:errmsg, '']
    2                 0.000008000 	let [s:matches, s:init] = [1, 1]
    2   0.001565000   0.000017000 	cal s:Reset(a:0 ? a:1 : {})
    2   0.003750000   0.000024000 	noa cal s:Open()
    2   0.001827000   0.000017000 	cal s:SetWD(a:0 ? a:1 : {})
    2   0.001041000   0.000014000 	cal s:MapNorms()
    2   0.001622000   0.000012000 	cal s:MapSpecs()
    2   0.000528000   0.000015000 	cal ctrlp#syntax()
    2   0.062073000   0.000022000 	cal ctrlp#setlines(s:settype(a:type))
    2   0.000017000   0.000009000 	cal s:SetDefTxt()
    2   0.083551000   0.000013000 	cal s:BuildPrompt(1)
    2                 0.000005000 	if s:keyloop | cal s:KeyLoop() | en

FUNCTION  <SNR>149_run_syntax_fold()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/syntax/ruby.vim:58
Called 157 times
Total time:   0.006739000
 Self time:   0.005919000

count     total (s)      self (s)
  157                 0.003263000   let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
  157   0.001515000   0.000695000   if call('s:foldable', split(groups))
  157                 0.000174000     let cmd .= ' fold'
  157                 0.000060000   endif
  157                 0.001637000   exe cmd

FUNCTION  ale#events#Init()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:164
Called 1 time
Total time:   0.000077000
 Self time:   0.000077000

count     total (s)      self (s)
                                      " This value used to be a Boolean as a Number, and is now a String.
    1                 0.000002000     let l:text_changed = '' . g:ale_lint_on_text_changed
                                  
    1                 0.000001000     augroup ALEEvents
    1                 0.000012000         autocmd!
                                  
                                          " These events always need to be set up.
    1                 0.000002000         autocmd BufEnter,BufRead * call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
    1                 0.000002000         autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))
                                  
    1                 0.000000000         if g:ale_enabled
    1                 0.000002000             if l:text_changed is? 'always'|| l:text_changed is# '1'|| g:ale_lint_on_text_changed is v:true
                                                  autocmd TextChanged,TextChangedI * call ale#Queue(ale#Var(str2nr(expand('<abuf>')), 'lint_delay'))
    1                 0.000001000             elseif l:text_changed is? 'normal'
    1                 0.000002000                 autocmd TextChanged * call ale#Queue(ale#Var(str2nr(expand('<abuf>')), 'lint_delay'))
                                              elseif l:text_changed is? 'insert'
                                                  autocmd TextChangedI * call ale#Queue(ale#Var(str2nr(expand('<abuf>')), 'lint_delay'))
    1                 0.000000000             endif
                                  
    1                 0.000001000             if g:ale_lint_on_enter
    1                 0.000001000                 autocmd BufWinEnter * call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
                                                  " Track when the file is changed outside of Vim.
    1                 0.000002000                 autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))
    1                 0.000000000             endif
                                  
    1                 0.000001000             if g:ale_lint_on_filetype_changed
                                                  " Only start linting if the FileType actually changes after
                                                  " opening a buffer. The FileType will fire when buffers are opened.
    1                 0.000002000                 autocmd FileType * call ale#events#FileTypeEvent(   str2nr(expand('<abuf>')),   expand('<amatch>'))
    1                 0.000000000             endif
                                  
                                              " Add an InsertEnter event if we need to close the preview window
                                              " on entering insert mode, or if we want to run ALE on leaving
                                              " insert mode and <C-c> is not the same as <Esc>.
                                              "
                                              " We will emulate leaving insert mode for users that might not
                                              " trigger InsertLeave.
                                              "
                                              " If the ModeChanged event is available, this timer will not
                                              " be used.
    1                 0.000005000             if g:ale_close_preview_on_insert|| (g:ale_lint_on_insert_leave && maparg("\<C-c>", 'i') isnot# '<Esc>' && !s:mode_changed_exists)
                                                  autocmd InsertEnter * call ale#events#InsertEnterEvent(str2nr(expand('<abuf>')))
    1                 0.000000000             endif
                                  
    1                 0.000001000             let l:add_insert_leave_event = g:ale_lint_on_insert_leave
                                  
    1                 0.000000000             if g:ale_echo_cursor || g:ale_cursor_detail
                                                  " We need to make the message display on InsertLeave
    1                 0.000001000                 let l:add_insert_leave_event = 1
                                  
    1                 0.000002000                 autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
    1                 0.000000000             endif
                                  
    1                 0.000002000             if g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor is# 1 || g:ale_virtualtext_cursor is# '1'
                                                  " We need to make the message display on InsertLeave
                                                  let l:add_insert_leave_event = 1
                                  
                                                  autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarningWithDelay() | endif
    1                 0.000001000             endif
                                  
    1                 0.000000000             if l:add_insert_leave_event
    1                 0.000001000                 if s:mode_changed_exists
                                                      " If the ModeChanged event is available, handle any
                                                      " transition from the Insert mode to any other mode.
    1                 0.000002000                     autocmd ModeChanged i*:* call ale#events#InsertLeaveEvent(str2nr(expand('<abuf>')))
                                                  else
                                                      " If ModeChanged is not available, handle InsertLeave events.
                                                      autocmd InsertLeave * call ale#events#InsertLeaveEvent(str2nr(expand('<abuf>')))
    1                 0.000000000                 endif
    1                 0.000000000             endif
                                  
    1                 0.000000000             if g:ale_hover_cursor
    1                 0.000001000                 autocmd CursorHold * if exists('*ale#lsp#Send') | call ale#hover#ShowTruncatedMessageAtCursor() | endif
    1                 0.000000000             endif
    1                 0.000000000         endif
    1                 0.000000000     augroup END
                                  
    1                 0.000001000     augroup AleURISchemes
    1                 0.000012000         autocmd!
                                  
    1                 0.000003000         autocmd BufNewFile,BufReadPre jdt://** call ale#uri#jdt#ReadJDTLink(expand('<amatch>'))
    1                 0.000000000     augroup END

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:50
Called 131 times
Total time:   0.003304000
 Self time:   0.001778000

count     total (s)      self (s)
  131   0.002294000   0.000768000     call ale#command#InitData(a:buffer)
  131                 0.000813000     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  <SNR>167_setupblank()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1772
Called 2 times
Total time:   0.000089000
 Self time:   0.000089000

count     total (s)      self (s)
    2                 0.000040000 	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
    2                 0.000029000 	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
    2                 0.000004000 	if v:version > 702
    2                 0.000011000 		setl nornu noudf cc=0
    2                 0.000000000 	en

FUNCTION  <SNR>11_BMFilename()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:912
Called 47 times
Total time:   0.012035000
 Self time:   0.002988000

count     total (s)      self (s)
   47   0.008421000   0.000063000   var munge = s:BMMunge(name, num)
   47   0.000709000   0.000020000   var hash = s:BMHash(munge)
   47                 0.000047000   var cmd: string
   47                 0.000016000   if s:bmenu_short == 0
   47                 0.000102000     s:bmenu_items[num] = munge
   47                 0.000139000     cmd = 'an ' .. g:bmenu_priority .. '.' .. hash .. ' &Buffers.' .. munge
   47                 0.000010000   else
                                      var menu_name = s:BMHash2(munge) .. munge
                                      s:bmenu_items[num] = menu_name
                                      cmd = 'an ' .. g:bmenu_priority .. '.' .. hash .. '.' .. hash .. ' &Buffers.' .. menu_name
                                    endif
   47                 0.002520000   exe cmd .. ' :confirm b' .. num .. '<CR>'

FUNCTION  <SNR>49_setup_keymaps()
    Defined: ~/.vim/bundle/tagbar/plugin/tagbar.vim:147
Called 1 time
Total time:   0.000161000
 Self time:   0.000076000

count     total (s)      self (s)
    1                 0.000010000     let keymaps = [ ['jump',          '<CR>'], ['preview',       'p'], ['previewwin',    'P'], ['nexttag',       '<C-N>'], ['prevtag',       '<C-P>'], ['showproto',     '<Space>'], ['hidenonpublic', 'v'], ['openfold',      ['+', '<kPlus>', 'zo']], ['closefold',     ['-', '<kMinus>', 'zc']], ['togglefold',    ['o', 'za']], ['openallfolds',  ['*', '<kMultiply>', 'zR']], ['closeallfolds', ['=', 'zM']], ['incrementfolds',  ['zr']], ['decrementfolds',  ['zm']], ['nextfold',      'zj'], ['prevfold',      'zk'], ['togglesort',            's'], ['togglecaseinsensitive', 'i'], ['toggleautoclose',       'c'], ['togglepause',           't'], ['zoomwin',               'x'], ['close',                 'q'], ['help',                  ['<F1>', '?']], ]
                                  
   24                 0.000013000     for [map, key] in keymaps
   23   0.000117000   0.000032000         call s:init_var('map_' . map, key)
   23                 0.000010000         unlet key
   24                 0.000006000     endfor

FUNCTION  <SNR>167_fnesc()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1599
Called 24 times
Total time:   0.000986000
 Self time:   0.000099000

count     total (s)      self (s)
   24   0.000980000   0.000093000 	retu call('ctrlp#utils#fnesc', a:000)

FUNCTION  <SNR>77_define_sign_text()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:138
Called 1 time
Total time:   0.000013000
 Self time:   0.000013000

count     total (s)      self (s)
    1                 0.000003000   execute "sign define GitGutterLineAdded                 text=" . g:gitgutter_sign_added
    1                 0.000002000   execute "sign define GitGutterLineModified              text=" . g:gitgutter_sign_modified
    1                 0.000002000   execute "sign define GitGutterLineRemoved               text=" . g:gitgutter_sign_removed
    1                 0.000002000   execute "sign define GitGutterLineRemovedFirstLine      text=" . g:gitgutter_sign_removed_first_line
    1                 0.000002000   execute "sign define GitGutterLineRemovedAboveAndBelow  text=" . g:gitgutter_sign_removed_above_and_below
    1                 0.000002000   execute "sign define GitGutterLineModifiedRemoved       text=" . g:gitgutter_sign_modified_removed

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:253
Called 103 times
Total time:   0.000872000
 Self time:   0.000872000

count     total (s)      self (s)
  103                 0.000815000   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 211 times
Total time:   0.002465000
 Self time:   0.001184000

count     total (s)      self (s)
  211   0.002415000   0.001134000   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:280
Called 203 times
Total time:   0.031463000
 Self time:   0.021885000

count     total (s)      self (s)
                                      " Don't return linters in the sandbox.
                                      " Otherwise a sandboxed script could modify them.
  203   0.005938000   0.001465000     if ale#util#InSandbox()
                                          return []
  203                 0.000163000     endif
                                  
  203                 0.000592000     let l:combined_linters = []
                                  
  442                 0.001009000     for l:filetype in a:filetypes
                                          " Load linters from runtimepath if we haven't done that yet.
  239                 0.001395000         if !has_key(s:runtime_loaded_map, l:filetype)
    5   0.011262000   0.006157000             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                                  
    5                 0.000033000             let s:runtime_loaded_map[l:filetype] = 1
  239                 0.000216000         endif
                                  
  239                 0.003367000         call extend(l:combined_linters, get(s:linters, l:filetype, []))
  442                 0.000596000     endfor
                                  
  203                 0.000426000     return l:combined_linters

FUNCTION  <SNR>167_SplitPattern()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:498
Called 4 times
Total time:   0.000212000
 Self time:   0.000198000

count     total (s)      self (s)
    4                 0.000005000 	let str = a:str
    4                 0.000007000 	if s:migemo && s:regexp && len(str) > 0 && executable('cmigemo')
                                  		let str = s:migemo(str)
    4                 0.000002000 	en
    4                 0.000006000 	let s:savestr = str
    4                 0.000002000 	if s:regexp
                                  		let pat = s:regexfilter(str)
    4                 0.000001000 	el
    4                 0.000011000 		let lst = split(str, '\zs')
    4                 0.000006000 		if exists('+ssl') && !&ssl
                                  			cal map(lst, 'escape(v:val, ''\'')')
    4                 0.000001000 		en
   16                 0.000014000 		for each in ['^', '$', '.']
   12                 0.000024000 			cal map(lst, 'escape(v:val, each)')
   16                 0.000009000 		endfo
    4                 0.000003000 	en
    4                 0.000005000 	if exists('lst')
    4                 0.000003000 		let pat = ''
    4                 0.000004000 		if !empty(lst)
    2   0.000006000   0.000005000 			if s:byfname() && index(lst, ';') > 0
                                  				let fbar = index(lst, ';')
                                  				let lst_1 = s:sublist(lst, 0, fbar - 1)
                                  				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                                  				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
    2                 0.000000000 			el
    2   0.000020000   0.000007000 				let pat = s:buildpat(lst)
    2                 0.000001000 			en
    4                 0.000002000 		en
    4                 0.000002000 	en
    4                 0.000006000 	retu escape(pat, '~')

FUNCTION  <SNR>161_switch_to_workbench()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:39
Called 5 times
Total time:   0.000123000
 Self time:   0.000123000

count     total (s)      self (s)
    5                 0.000098000   execute 'normal! '.s:workbench_tab.'gt'
    5                 0.000021000   execute 'b!' s:workbench_bfr

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:485
Called 1737 times
Total time:   0.077601000
 Self time:   0.050782000

count     total (s)      self (s)
 1737                 0.011707000     let l:info = get(g:ale_buffer_info, a:buffer, {})
 1737                 0.005664000     let l:loclist = get(l:info, 'loclist', [])
 1737                 0.005575000     let l:pos = getpos('.')
 1737   0.041219000   0.014400000     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
 1737                 0.006156000     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                                  
 1737                 0.003419000     return [l:info, l:loc]

FUNCTION  <SNR>113_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:512
Called 167 times
Total time:   0.005124000
 Self time:   0.005124000

count     total (s)      self (s)
                                      " Figure out which linters are still enabled, and remove
                                      " problems for linters which are no longer enabled.
                                      " Problems from other sources will be kept.
  167                 0.000396000     let l:name_map = {}
                                  
  334                 0.000602000     for l:linter in a:linters
  167                 0.000749000         let l:name_map[l:linter.name] = 1
  334                 0.000325000     endfor
                                  
  167                 0.001828000     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>101_EndsWithLambdaArrow()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1156
Called 3 times
Total time:   0.000242000
 Self time:   0.000003000

count     total (s)      self (s)
                                      return NonCommentedMatch(line_A, LAMBDA_ARROW_AT_EOL)

FUNCTION  <SNR>167_SetWD()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:954
Called 2 times
Total time:   0.001810000
 Self time:   0.000274000

count     total (s)      self (s)
    2                 0.000010000 	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0 && exists('s:dyncwd')
                                  		cal ctrlp#setdir(s:dyncwd) | retu
    2                 0.000000000 	en
    2                 0.000006000 	if has_key(a:args, 'dir') && a:args['dir'] != ''
                                  		cal ctrlp#setdir(a:args['dir']) | retu
    2                 0.000001000 	en
    2                 0.000008000 	let pmode = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
    2                 0.000101000 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
    2                 0.000034000 	if s:crfile =~ '^.\+://' | retu | en
    2                 0.000020000 	if pmode =~ 'c' || ( pmode =~ 'a' && stridx(s:crfpath, s:cwd) < 0 ) || ( !type(pmode) && pmode )
                                  		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                                  		cal ctrlp#setdir(s:crfpath)
    2                 0.000002000 	en
    2                 0.000006000 	if pmode =~ 'r' || pmode == 2
    2                 0.000004000 		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
    2                 0.000009000 		let spath = pmode =~ 'd' ? s:dyncwd : pmode =~ 'w' ? s:cwd : s:crfpath
    2                 0.000006000 		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                                  			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu | en
                                  			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
    2                 0.000001000 		en
    2   0.001554000   0.000018000 		cal s:findroot(spath, markers, 0, 0)
    2                 0.000002000 	en

FUNCTION  <SNR>101_MatchingOpenBracket()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:884
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var end: string = line.text->matchstr(CLOSING_BRACKET)
                                      var start: string = {']': '[', '}': '{', ')': '('}[end]
                                      cursor(line.lnum, 1)
                                      return SearchPairStart(start, '', end)

FUNCTION  ctrlp#progress()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1419
Called 3 times
Total time:   0.051109000
 Self time:   0.051106000

count     total (s)      self (s)
    3                 0.004049000 	if has('macunix') || has('mac') | sl 1m | en
    3                 0.000009000 	let txt = a:0 ? '(press ctrl-c to abort)' : ''
    3                 0.000010000 	if s:status != {}
                                  		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'str': a:enum }] : [a:enum]
                                  		let &l:stl = call(s:status['prog'], argms, s:status)
    3                 0.000002000 	el
    3   0.000025000   0.000022000 		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
    3                 0.000002000 	en
    3                 0.046994000 	redraws

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:329
Called 203 times
Total time:   0.022708000
 Self time:   0.004535000

count     total (s)      self (s)
  203   0.020704000   0.002531000     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                                  
  203                 0.000789000     if type(l:filetype) isnot v:t_list
  167                 0.000418000         return [l:filetype]
   36                 0.000045000     endif
                                  
   36                 0.000079000     return l:filetype

FUNCTION  <SNR>125_EscapeSignText()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:73
Called 5 times
Total time:   0.000019000
 Self time:   0.000019000

count     total (s)      self (s)
    5                 0.000018000     return substitute(substitute(a:sign_text, ' *$', '', ''), '\\\| ', '\\\0', 'g')

FUNCTION  copilot_chat#buffer#Resize()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:243
Called 107 times
Total time:   0.452201000
 Self time:   0.031035000

count     total (s)      self (s)
  107                 0.000199000   if g:copilot_chat_active_buffer == -1
                                      return
                                    endif
                                  
   64                 0.000157000   for tabnr in range(1, tabpagenr('$'))
  197   0.316400000   0.006419000     exec 'normal ' tabnr .. 'gt'
                                  
  197                 0.000162000     for winnr in range(1, winnr('$'))
  455                 0.002801000       exec $':{winnr}wincmd w'
  455                 0.000362000       if &filetype !=# 'copilot_chat'
  396                 0.000066000         continue
                                        endif
   59                 0.002464000       var width: number = winwidth(0) - 2 - getwininfo(win_getid())[0].textoff
   59   0.011329000   0.010809000       exec ':%s/^ ━\+/ ' .. repeat('━', width) .. '/ge'
   59                 0.006469000       exec ':%s/^ ━\+/ ' .. repeat('━', width) .. '/ge'
   59                 0.000213000       setpos('.', getcurpos())
   59                 0.000030000     endfor
                                  
  197                 0.000423000     exec ':' .. winnr() .. 'wincmd w'
  197                 0.000028000   endfor
                                  
   64   0.110343000   0.000876000   exec 'normal ' .. tabpagenr() .. 'gt'

FUNCTION  197()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:207
Called 16 times
Total time:   0.229574000
 Self time:   0.008865000

count     total (s)      self (s)
   16                 0.000131000     let l:splitLocation = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'top' ? 'topleft ' : 'botright '
   16                 0.000085000     let l:splitDirection = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'right' ? 'vertical' : ''
   16                 0.000059000     let l:splitSize = g:NERDTreeWinSize
                                  
   16   0.001982000   0.000066000     if !g:NERDTree.ExistsForTab()
    5   0.000276000   0.000044000         let t:NERDTreeBufName = self._nextBufferName('tab')
    5   0.029991000   0.001249000         silent! execute l:splitLocation . l:splitDirection . ' ' . l:splitSize . ' new'
    5   0.027132000   0.003232000         silent! execute 'edit ' . t:NERDTreeBufName
    5                 0.000045000         silent! execute l:splitDirection . ' resize '. l:splitSize
   11                 0.000020000     else
   11   0.003378000   0.000952000         silent! execute l:splitLocation . l:splitDirection . ' ' . l:splitSize . ' split'
   11   0.029464000   0.002245000         silent! execute 'buffer ' . t:NERDTreeBufName
   16                 0.000015000     endif
                                  
   16   0.000211000   0.000164000     setlocal winfixwidth
                                  
   16   0.136320000   0.000093000     call self._setCommonBufOptions()
                                  
   16                 0.000072000     if has('patch-7.4.1925')
   16                 0.000031000         clearjumps
   16                 0.000012000     endif
                                  

FUNCTION  <SNR>46_ChooseCommandMap()
    Defined: ~/.vim/bundle/tabular/plugin/Tabular.vim:77
Called 10 times
Total time:   0.000082000
 Self time:   0.000082000

count     total (s)      self (s)
   10                 0.000009000   let map = s:TabularCommands
   10                 0.000007000   let cmd = a:commandline
                                  
   10                 0.000017000   if cmd =~# '^<buffer>\s\+'
                                      if !exists('b:TabularCommands')
                                        let b:TabularCommands = {}
                                      endif
                                      let map = b:TabularCommands
                                      let cmd = substitute(cmd, '^<buffer>\s\+', '', '')
   10                 0.000003000   endif
                                  
   10                 0.000008000   return [ map, cmd ]

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:5
Called 2052 times
Total time:   0.011704000
 Self time:   0.011704000

count     total (s)      self (s)
 2052                 0.009696000     return call('mode', a:000)

FUNCTION  200()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:250
Called 5 times
Total time:   0.000232000
 Self time:   0.000137000

count     total (s)      self (s)
    5                 0.000009000     if a:0 > 0
    5                 0.000011000         let type = a:1
                                      else
                                          let type = ''
    5                 0.000003000     end
    5   0.000047000   0.000022000     let name = s:Creator.BufNamePrefix()
    5                 0.000010000     if type ==# 'tab'
    5                 0.000009000         let name = name . 'tab_'
                                      elseif type ==# 'win'
                                          let name = name . 'win_'
    5                 0.000004000     endif
    5   0.000096000   0.000026000     let name = name . self._nextBufferNumber()
    5                 0.000008000     return name

FUNCTION  201()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:268
Called 5 times
Total time:   0.000070000
 Self time:   0.000070000

count     total (s)      self (s)
    5                 0.000019000     if !exists('s:Creator._NextBufNum')
    1                 0.000006000         let s:Creator._NextBufNum = 1
    4                 0.000003000     else
    4                 0.000013000         let s:Creator._NextBufNum += 1
    5                 0.000004000     endif
                                  
    5                 0.000008000     return s:Creator._NextBufNum

FUNCTION  202()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:280
Called 5 times
Total time:   0.004353000
 Self time:   0.001170000

count     total (s)      self (s)
    5                 0.000035000     let path = {}
    5   0.000718000   0.000064000     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                          let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    5                 0.000007000     else
    5                 0.000724000         let dir = a:str ==# '' ? getcwd() : a:str
                                  
                                          "hack to get an absolute path if a relative path is given
    5                 0.000047000         if dir =~# '^\.'
                                              let dir = getcwd() . nerdtree#slash() . dir
    5                 0.000006000         endif
                                  
                                          "hack to prevent removing slash if dir is the root of the file system.
    5                 0.000009000         if dir !=# '/'
    5   0.000523000   0.000065000             let dir = g:NERDTreePath.Resolve(dir)
    5                 0.000006000         endif
                                  
    5                 0.000005000         try
    5   0.002106000   0.000035000             let path = g:NERDTreePath.New(dir)
                                          catch /^NERDTree.InvalidArgumentsError/
                                              call nerdtree#echo('No bookmark or directory found for: ' . a:str)
                                              return {}
    5                 0.000006000         endtry
    5                 0.000004000     endif
    5                 0.000009000     if !path.isDirectory
                                          let path = path.getParent()
    5                 0.000004000     endif
                                  
    5                 0.000006000     return path

FUNCTION  204()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:329
Called 16 times
Total time:   0.136227000
 Self time:   0.001403000

count     total (s)      self (s)
                                  
                                      " Options for a non-file/control buffer.
   16   0.000133000   0.000118000     setlocal bufhidden=hide
   16   0.000065000   0.000057000     setlocal buftype=nofile
   16   0.000076000   0.000067000     setlocal noswapfile
                                  
                                      " Options for controlling buffer/window appearance.
   16   0.000151000   0.000130000     setlocal foldcolumn=0
   16   0.000067000   0.000052000     setlocal foldmethod=manual
   16   0.000514000   0.000056000     setlocal nobuflisted
   16   0.000057000   0.000043000     setlocal nofoldenable
   16   0.000061000   0.000056000     setlocal nolist
   16   0.000049000   0.000044000     setlocal nospell
   16   0.000049000   0.000044000     setlocal nowrap
                                  
   16                 0.000039000     if g:NERDTreeShowLineNumbers
                                          setlocal number
   16                 0.000016000     else
   16   0.000056000   0.000051000         setlocal nonumber
   16                 0.000036000         if v:version >= 703
   16   0.000059000   0.000050000             setlocal norelativenumber
   16                 0.000015000         endif
   16                 0.000011000     endif
                                  
   16                 0.000039000     iabc <buffer>
                                  
   16                 0.000032000     if g:NERDTreeHighlightCursorline
   16   0.000066000   0.000064000         setlocal cursorline
   16                 0.000010000     endif
                                  
   16   0.000283000   0.000068000     call self._setupStatusline()
   16   0.038878000   0.000063000     call self._bindMappings()
                                  
   16   0.095306000   0.000083000     setlocal filetype=nerdtree

FUNCTION  205()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:367
Called 16 times
Total time:   0.000215000
 Self time:   0.000210000

count     total (s)      self (s)
   16                 0.000048000     if g:NERDTreeStatusline != -1
   16   0.000136000   0.000131000         let &l:statusline = g:NERDTreeStatusline
   16                 0.000012000     endif

FUNCTION  207()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:395
Called 26 times
Total time:   0.486789000
 Self time:   0.000609000

count     total (s)      self (s)
   26   0.001423000   0.000389000     let creator = s:Creator.New()
   26   0.485302000   0.000156000     call creator.toggleTabTree(a:dir)

FUNCTION  208()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim:408
Called 26 times
Total time:   0.485146000
 Self time:   0.001406000

count     total (s)      self (s)
   26   0.005074000   0.000278000     if g:NERDTree.ExistsForTab()
   21   0.003766000   0.000158000         if !g:NERDTree.IsOpen()
   11   0.131684000   0.000070000             call self._createTreeWin()
   11                 0.000050000             if !empty(a:dir) && a:dir !=# b:NERDTree.root.path.str()
                                                  call self.createTabTree(a:dir)
   11                 0.000023000             elseif !&hidden
                                                  call b:NERDTree.render()
   11                 0.000011000             endif
   11   0.000917000   0.000082000             call b:NERDTree.ui.restoreScreenState()
   10                 0.000009000         else
   10   0.054724000   0.000069000             call g:NERDTree.Close()
   21                 0.000019000         endif
    5                 0.000006000     else
    5   0.288261000   0.000029000         call self.createTabTree(a:dir)
   26                 0.000015000     endif

FUNCTION  <SNR>77_get_hl()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:210
Called 26 times
Total time:   0.000191000
 Self time:   0.000191000

count     total (s)      self (s)
   26                 0.000093000   let r = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
   26                 0.000054000   if empty(r) || r == -1
   12                 0.000007000     return 'NONE'
   14                 0.000014000   endif
   14                 0.000007000   return r

FUNCTION  <SNR>11_BMShow()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:820
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                    s:bmenu_wait = 1
                                    s:bmenu_short = 1
                                    s:bmenu_count = 0
                                    s:bmenu_items = {}
                                  
                                    # Remove old menu, if it exists; keep one entry to avoid a torn off menu to
                                    # disappear.  Use try/catch to avoid setting v:errmsg
                                    try 
                                      unmenu &Buffers 
                                    catch 
                                    endtry
                                    exe 'noremenu ' .. g:bmenu_priority .. ".1 &Buffers.Dummy l"
                                    try 
                                      unmenu! &Buffers 
                                    catch 
                                    endtry
                                  
                                    # create new menu
                                    exe 'an <silent> ' .. g:bmenu_priority .. ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
                                    exe 'an ' .. g:bmenu_priority .. ".4 &Buffers.&Delete :confirm bd<CR>"
                                    exe 'an ' .. g:bmenu_priority .. ".6 &Buffers.&Alternate :confirm b #<CR>"
                                    exe 'an ' .. g:bmenu_priority .. ".7 &Buffers.&Next :confirm bnext<CR>"
                                    exe 'an ' .. g:bmenu_priority .. ".8 &Buffers.&Previous :confirm bprev<CR>"
                                    exe 'an ' .. g:bmenu_priority .. ".9 &Buffers.-SEP- :"
                                    unmenu &Buffers.Dummy
                                  
                                    # figure out how many buffers there are
                                    var buf = 1
                                    while buf <= bufnr('$')
                                      if s:BMCanAdd(bufname(buf), buf)
                                        s:bmenu_count = s:bmenu_count + 1
                                      endif
                                      buf += 1
                                    endwhile
                                    if s:bmenu_count <= &menuitems
                                      s:bmenu_short = 0
                                    endif
                                  
                                    # iterate through buffer list, adding each buffer to the menu:
                                    buf = 1
                                    while buf <= bufnr('$')
                                      var name = bufname(buf)
                                      if s:BMCanAdd(name, buf)
                                        call s:BMFilename(name, buf)
                                      endif
                                      buf += 1
                                    endwhile
                                    s:bmenu_wait = 0
                                    aug buffer_list
                                      au!
                                      au BufCreate,BufFilePost * call s:BMAdd()
                                      au BufDelete,BufFilePre * call s:BMRemove()
                                    aug END

FUNCTION  <SNR>167_MatchIt()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:459
Called 4 times
Total time:   0.000880000
 Self time:   0.000841000

count     total (s)      self (s)
    4                 0.000010000 	let [lines, id] = [[], 0]
    4   0.000022000   0.000015000 	let pat = s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val') : s:martcs.a:pat
   72                 0.000043000 	for item in a:items
   70                 0.000056000 		let id += 1
  136                 0.000269000 		try | if !( s:ispath && item == a:exc ) && call(s:mfunc, [item, pat]) >= 0
   20                 0.000031000 			cal add(lines, item)
  136                 0.000062000 		en | cat | brea | endt
  136                 0.000140000 		if a:limit > 0 && len(lines) >= a:limit | brea | en
   72                 0.000022000 	endfo
    4   0.000057000   0.000025000 	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
    4                 0.000003000 	retu lines

FUNCTION  ctrlp#rmbasedir()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1546
Called 1 time
Total time:   0.000029000
 Self time:   0.000025000

count     total (s)      self (s)
    1   0.000007000   0.000003000 	let cwd = s:dyncwd.s:lash()
    1                 0.000002000 	if a:items != [] && !stridx(a:items[0], cwd)
    1                 0.000002000 		let idx = strlen(cwd)
    1                 0.000018000 		retu map(a:items, 'strpart(v:val, idx)')
                                  	en
                                  	retu a:items

FUNCTION  <SNR>101_SearchPair()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:970
Called 5 times
Total time:   0.015929000
 Self time:   0.015929000

count     total (s)      self (s)
                                  
    5                 0.000002000     var s: string = start
    5                 0.000001000     var e: string = end
    5                 0.000003000     if start == '[' || start == ']'
                                          s = s->escape('[]')
                                      endif
    5                 0.000006000     if end == '[' || end == ']'
                                          e = e->escape('[]')
                                      endif
                                      return searchpair('\C' .. s, (middle == '' ? '' : '\C' .. middle), '\C' .. e,
                                          flags, (): bool => InCommentOrString(), stopline, TIMEOUT)

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:207
Called 143 times
Total time:   0.014955000
 Self time:   0.002347000

count     total (s)      self (s)
  143                 0.000657000     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                          " Update lists immediately if running a test synchronously, or if the
                                          " buffer was saved.
                                          "
                                          " The lists need to be updated immediately when saving a buffer so
                                          " that we can reliably close window automatically, if so configured.
   42   0.011710000   0.000187000         call s:SetListsImpl(-1, a:buffer, a:loclist)
  101                 0.000052000     else
  101   0.001759000   0.000674000         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
  143                 0.000061000     endif

FUNCTION  vader#parser#parse()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/parser.vim:24
Called 5 times
Total time:   0.047509000
 Self time:   0.000212000

count     total (s)      self (s)
    5   0.047502000   0.000205000   return s:parse_vader(s:read_vader(a:fn, a:line1, a:line2), a:line1)

FUNCTION  dist#vimindent#Expr()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:417
Called 3 times
Total time:   0.020708000
 Self time:   0.002166000

count     total (s)      self (s)
                                      # line which is indented
    3                 0.000021000     var line_A: dict<any> = {text: getline(lnum), lnum: lnum}
                                      # line above, on which we'll base the indent of line A
    3                 0.000001000     var line_B: dict<any>
                                  
    3   0.000545000   0.000027000     if line_A->AtStartOf('HereDoc')
                                          line_A->CacheHeredoc()
                                      elseif line_A.lnum->IsInside('HereDoc')
                                          return line_A.text->HereDocIndent()
                                      elseif line_A.lnum->IsRightBelow('HereDoc')
                                          var ind: number = b:vimindent.startindent
                                          unlet! b:vimindent
                                          return ind
                                      endif
                                  
                                      # Don't move this block after the function header one.
                                      # Otherwise, we  might clear the cache  too early if the  line following the
                                      # header is a comment.
    3                 0.000043000     if line_A.text =~ COMMENT
                                          return CommentIndent()
                                      endif
                                  
    3   0.000090000   0.000005000     line_B = PrevCodeLine(line_A.lnum)
    3                 0.000031000     if line_A.text =~ BACKSLASH_AT_SOL
                                          if line_B.text =~ BACKSLASH_AT_SOL
                                              return Indent(line_B.lnum)
                                          else
                                              return Indent(line_B.lnum) + IndentMoreLineContinuation()
                                          endif
                                      endif
                                  
    3   0.000077000   0.000010000     if line_A->AtStartOf('FuncHeader')
                                              && !IsInInterface()
                                          line_A.lnum->CacheFuncHeader()
                                      elseif line_A.lnum->IsInside('FuncHeader')
                                          return b:vimindent.startindent + 2 * shiftwidth()
                                      elseif line_A.lnum->IsRightBelow('FuncHeader')
                                          var startindent: number = b:vimindent.startindent
                                          unlet! b:vimindent
                                          if line_A.text =~ ENDS_FUNCTION
                                              return startindent
                                          else
                                              return startindent + shiftwidth()
                                          endif
                                      endif
                                  
    3                 0.000001000     var past_bracket_block: dict<any>
    3                 0.000005000     if exists('b:vimindent')
                                              && b:vimindent->has_key('is_BracketBlock')
                                          past_bracket_block = RemovePastBracketBlock(line_A)
                                      endif
    3   0.014485000   0.000003000     if line_A->AtStartOf('BracketBlock')
                                          line_A->CacheBracketBlock()
                                      endif
    3   0.000013000   0.000001000     if line_A.lnum->IsInside('BracketBlock')
                                          var is_in_curly_block: bool = IsInCurlyBlock()
                                          for block: dict<any> in b:vimindent.block_stack
                                              if line_A.lnum <= block.startlnum
                                                  continue
                                              endif
                                              if !block->has_key('startindent')
                                                  block.startindent = Indent(block.startlnum)
                                              endif
                                              if !is_in_curly_block
                                                  return BracketBlockIndent(line_A, block)
                                              endif
                                          endfor
                                      endif
    3   0.000006000   0.000002000     if line_A.text->ContinuesBelowBracketBlock(line_B, past_bracket_block)
                                              && line_A.text !~ CLOSING_BRACKET_AT_SOL
                                          return past_bracket_block.startindent
                                              + (past_bracket_block.startline =~ STARTS_NAMED_BLOCK ? 2 * shiftwidth() : 0)
                                      endif
                                  
                                      # Problem: If we press `==` on the line right below the start of a multiline
                                      # lambda (split after its arrow `=>`), the indent is not correct.
                                      # Solution: Indent relative to the line above.
    3   0.000245000   0.000003000     if line_B->EndsWithLambdaArrow()
                                          return Indent(line_B.lnum) + shiftwidth() + IndentMoreInBracketBlock()
                                      endif
                                      # FIXME: Similar issue here:
                                      #
                                      #     var x = []
                                      #         ->filter((_, _) =>
                                      #             true)
                                      #         ->items()
                                      #
                                      # Press `==` on last line.
                                      # Expected: The `->items()` line is indented like `->filter(...)`.
                                      # Actual: It's indented like `true)`.
                                      # Is it worth fixing? `=ip` gives  the correct indentation, because then the
                                      # cache is used.
                                  
                                      # Don't move this block before the heredoc one.{{{
                                      #
                                      # A heredoc might be assigned on the very first line.
                                      # And if it is, we need to cache some info.
                                      #}}}
                                      # Don't move it before the function header and bracket block ones either.{{{
                                      #
                                      # You could, because these blocks of code deal with construct which can only
                                      # appear  in a  Vim9  script.  And  in  a  Vim9 script,  the  first line  is
                                      # `vim9script`.  Or  maybe some legacy code/comment  (see `:help vim9-mix`).
                                      # But you  can't find a  Vim9 function header or  Vim9 bracket block  on the
                                      # first line.
                                      #
                                      # Anyway, even if you could, don't.  First, it would be inconsistent.
                                      # Second, it  could give unexpected results  while we're trying to  fix some
                                      # failing test.
                                      #}}}
    3                 0.000003000     if line_A.lnum == 1
                                          return 0
                                      endif
                                  
                                      # Don't do that:
                                      #     if line_A.text !~ '\S'
                                      #         return -1
                                      #     endif
                                      # It would prevent  a line from being automatically indented  when using the
                                      # normal command `o`.
                                      # TODO: Can we write a test for this?
                                  
    3                 0.000274000     if line_B.text =~ STARTS_CURLY_BLOCK
                                          return Indent(line_B.lnum) + shiftwidth() + IndentMoreInBracketBlock()
                                  
                                      elseif line_A.text =~ CLOSING_BRACKET_AT_SOL
                                          var start: number = MatchingOpenBracket(line_A)
                                          if start <= 0
                                              return -1
                                          endif
                                          return Indent(start) + IndentMoreInBracketBlock()
                                  
                                      elseif line_A.text =~ ENDS_BLOCK_OR_CLAUSE
                                              && !line_B->EndsWithLineContinuation()
                                          var kwd: string = BlockStartKeyword(line_A.text)
                                          if !START_MIDDLE_END->has_key(kwd)
                                              return -1
                                          endif
                                  
                                          # If the cursor  is after the match  for the end pattern,  we won't find
                                          # the start of the block.  Let's make sure that doesn't happen.
                                          cursor(line_A.lnum, 1)
                                  
                                          var [start: string, middle: string, end: string] = START_MIDDLE_END[kwd]
                                          var block_start: number = SearchPairStart(start, middle, end)
                                          if block_start > 0
                                              return Indent(block_start)
                                          else
                                              return -1
                                          endif
                                      endif
                                  
    3                 0.000000000     var base_ind: number
    3   0.000635000   0.000002000     if line_A->IsFirstLineOfCommand(line_B)
    3                 0.000004000         line_A.isfirst = true
    3   0.000320000   0.000001000         line_B = line_B->FirstLinePreviousCommand()
    3   0.000005000   0.000001000         base_ind = Indent(line_B.lnum)
                                  
    3   0.000268000   0.000004000         if line_B->EndsWithCurlyBlock()
                                                  && !line_A->IsInThisBlock(line_B.lnum)
                                              return base_ind
                                          endif
                                  
    3                 0.000000000     else
                                          line_A.isfirst = false
                                          base_ind = Indent(line_B.lnum)
                                  
                                          var line_C: dict<any> = PrevCodeLine(line_B.lnum)
                                          if !line_B->IsFirstLineOfCommand(line_C) || line_C.lnum <= 0
                                              return base_ind
                                          endif
                                      endif
                                  
    3   0.001920000   0.000008000     var ind: number = base_ind + Offset(line_A, line_B)
                                      return [ind, 0]->max()

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:290
Called 2469 times
Total time:   0.043430000
 Self time:   0.039559000

count     total (s)      self (s)
 2469                 0.003459000     try
 2469   0.021281000   0.017410000         let &l:equalprg=&l:equalprg
                                      catch /E48/
                                          " E48 is the sandbox error.
                                          return 1
 2469                 0.004337000     endtry
                                  
 2469                 0.002397000     return 0

FUNCTION  ctrlp#syntax()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1609
Called 2 times
Total time:   0.000513000
 Self time:   0.000286000

count     total (s)      self (s)
    2   0.000030000   0.000014000 	if ctrlp#nosy() | retu | en
   48   0.000311000   0.000100000 	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
    2                 0.000086000 	if synIDattr(synIDtrans(hlID('Normal')), 'bg') !~ '^-1$\|^$'
    2                 0.000037000 		sil! exe 'hi CtrlPLinePre '.( has("gui_running") ? 'gui' : 'cterm' ).'fg=bg'
    2                 0.000001000 	en
    2                 0.000020000 	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
    2                 0.000005000 	if hlexists('CtrlPLinePre')
    2                 0.000007000 		sy match CtrlPLinePre '^>'
    2                 0.000000000 	en

FUNCTION  213()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim:28
Called 125 times
Total time:   0.000988000
 Self time:   0.000988000

count     total (s)      self (s)
  125                 0.000512000     let newObj = copy(self)
  125                 0.000263000     let newObj._flags = {}
  125                 0.000128000     return newObj

FUNCTION  215()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim:45
Called 204 times
Total time:   0.001521000
 Self time:   0.001521000

count     total (s)      self (s)
  204                 0.000206000     let flagstring = ''
  204                 0.000367000     for i in values(self._flags)
                                          let flagstring .= join(i)
  204                 0.000115000     endfor
                                  
  204                 0.000286000     if len(flagstring) == 0
  204                 0.000134000         return ''
                                      endif
                                  
                                      return '[' . flagstring . ']'

FUNCTION  218()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:37
Called 14 times
Total time:   0.070828000
 Self time:   0.001233000

count     total (s)      self (s)
   14   0.002185000   0.000089000     if !s:NERDTree.IsOpen()
                                          return
   14                 0.000013000     endif
                                  
   14                 0.000062000     if winnr('$') !=# 1
                                          " Use the window ID to identify the currently active window or fall
                                          " back on the buffer ID if win_getid/win_gotoid are not available, in
                                          " which case we'll focus an arbitrary window showing the buffer.
   14                 0.000102000         let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
                                  
   14   0.002014000   0.000064000         if winnr() ==# s:NERDTree.GetWinNum()
                                              call nerdtree#exec('wincmd p', 1)
                                              let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
                                              call nerdtree#exec('wincmd p', 1)
   14                 0.000014000         else
   14                 0.000082000             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
   14                 0.000015000         endif
                                  
   14   0.002638000   0.000169000         call nerdtree#exec(s:NERDTree.GetWinNum() . ' wincmd w', 1)
   14   0.058359000   0.000090000         call nerdtree#exec('close', 0)
   14                 0.000026000         if l:useWinId
   14   0.004908000   0.000097000             call nerdtree#exec('call win_gotoid(' . l:activeBufOrWin . ')', 0)
                                          else
                                              call nerdtree#exec(bufwinnr(l:activeBufOrWin) . ' wincmd w', 0)
   14                 0.000008000         endif
                                      else
                                          close
   14                 0.000009000     endif

FUNCTION  <SNR>104_Derive()
    Defined: ~/.vim/bundle/vim9-syntax/import/vim9SyntaxUtil.vim:8
Called 4 times
Total time:   0.000080000
 Self time:   0.000080000

count     total (s)      self (s)
                                  # Purpose:{{{
                                  #
                                  # Derive  a  new syntax  group  (`new_group`)  from  an existing  one  (`from`),
                                  # overriding some attributes (`new_attrs`).
                                  #}}}
                                  # Usage Examples:{{{
                                  #
                                  # To define `CommentUnderlined` with the same attributes as `Comment`, resetting
                                  # the `term`, `cterm`, and `gui` attributes with the value `underline`:
                                  #
                                  #     Derive('CommentUnderlined', 'Comment', {gui: {bold: true}, term: {bold: true}, cterm: {bold: true}})
                                  #
                                  # To define `PopupSign` with the  same attributes as `WarningMsg`, resetting the
                                  # `guibg` or `ctermbg` attributes with the colors of the `Normal` HG:
                                  #
                                  #     Derive('PopupSign', 'WarningMsg', {bg: 'Normal'})
                                  #}}}
                                  
    4                 0.000015000     var from_def: dict<any> = hlget(from, true)->get(0,  {})
    4                 0.000000000     if from_def->get('cleared')
                                          return
                                      endif
    4                 0.000005000     highlights->add(from_def->extend({name: new_group, default: true})->extend(new_attrs))
    4                 0.000030000     highlights->hlset()
                                  
                                      # Make sure  the derived highlight groups  persist even if the  color scheme
                                      # changes, and the Vim syntax plugin is not re-sourced.
    4                 0.000009000     autocmd_add([{
                                          cmd: 'highlights->hlset()',
                                          event: 'ColorScheme',
                                          group: 'DeriveHighlightGroups',
                                          once: true,
                                          pattern: '*',
                                          replace: true,
                                      }])

FUNCTION  <SNR>167_nosort()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1908
Called 2 times
Total time:   0.000021000
 Self time:   0.000021000

count     total (s)      self (s)
    2                 0.000019000 	retu s:matcher != {} || s:nolim == 1 || ( s:itemtype == 2 && s:mrudef ) || ( s:itemtype =~ '\v^(1|2)$' && s:prompt == ['', '', ''] ) || !s:dosort

FUNCTION  ale#path#Upwards()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:229
Called 36 times
Total time:   0.008268000
 Self time:   0.006844000

count     total (s)      self (s)
   36                 0.000440000     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
   36                 0.000164000     let l:sep = has('win32') ? '\' : '/'
   36   0.002351000   0.000927000     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
   36                 0.000102000     let l:path_list = []
                                  
  252                 0.000693000     while !empty(l:parts)
  216                 0.001415000         call add(l:path_list, join(l:parts, l:sep))
  216                 0.000980000         let l:parts = l:parts[:-2]
  252                 0.000299000     endwhile
                                  
   36                 0.000128000     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                          " Add \ to C: for C:\, etc.
                                          let l:path_list[-1] .= '\'
   36                 0.000140000     elseif a:path[0] is# '/'
                                          " If the path starts with /, even on Windows, add / and / to all paths.
   36                 0.000552000         call map(l:path_list, '''/'' . v:val')
   36                 0.000104000         call add(l:path_list, '/')
   36                 0.000036000     endif
                                  
   36                 0.000067000     return l:path_list

FUNCTION  <SNR>11_SetupColorSchemes()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:448
Called 1 time
Total time:   0.010658000
 Self time:   0.010658000

count     total (s)      self (s)
    1                 0.000005000   if s:did_setup_color_schemes
                                      return
                                    endif
    1                 0.000003000   s:did_setup_color_schemes = 1
                                  
    1                 0.005899000   var n = globpath(&runtimepath, "colors/*.vim", 1, 1)
    1                 0.000207000   n += globpath(&packpath, "pack/*/start/*/colors/*.vim", 1, 1)
    1                 0.002050000   n += globpath(&packpath, "pack/*/opt/*/colors/*.vim", 1, 1)
                                  
                                    # Ignore case for VMS and windows, sort on name
    1                 0.001242000   var names = sort(map(n, 'substitute(v:val, "\\c.*[/\\\\:\\]]\\([^/\\\\:]*\\)\\.vim", "\\1", "")'), 'i')
                                  
                                    # define all the submenu entries
    1                 0.000001000   var idx = 100
    1                 0.000001000   for name in names
   29                 0.001178000     exe "an 20.450." .. idx .. ' &Edit.C&olor\ Scheme.' .. name .. " :colors " .. name .. "<CR>"
   29                 0.000005000     idx += 10
   29                 0.000010000   endfor
    1                 0.000041000   silent! aunmenu &Edit.Show\ C&olor\ Schemes\ in\ Menu

FUNCTION  <SNR>26_vader()
    Defined: ~/.vim/bundle/vader.vim/plugin/vader.vim:35
Called 5 times
Total time:   0.291784000
 Self time:   0.002549000

count     total (s)      self (s)
    5                 0.000140000     if a:lastline - a:firstline > 0 && a:0 > 1
                                        echoerr 'Range and file arguments are mutually exclusive'
                                        return
    5                 0.000020000     endif
    5   0.291534000   0.002299000     execute printf("%d,%dcall vader#run(%s)", a:firstline, a:lastline, string(a:000)[1:-2])

FUNCTION  copilot_chat#buffer#OnDelete()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:225
Called 3 times
Total time:   0.000090000
 Self time:   0.000090000

count     total (s)      self (s)
    3                 0.000002000   var bufnr: number = str2nr(bufnr_string)
    3                 0.000003000   if g:copilot_chat_zombie_buffer != -1
                                      var bufinfo = getbufinfo(g:copilot_chat_zombie_buffer)
                                      if !empty(bufinfo) # Check if the buffer wasn't wiped out by the user
                                        execute 'bwipeout' .. g:copilot_chat_zombie_buffer
                                      endif
                                      g:copilot_chat_zombie_buffer = -1
                                    endif
                                  
    3                 0.000001000   if g:copilot_chat_active_buffer != bufnr
                                      return
                                    endif
                                    # Unset the active chat buffer
                                    g:copilot_chat_zombie_buffer = g:copilot_chat_active_buffer
                                    g:copilot_chat_active_buffer = -1

FUNCTION  <SNR>101_BracketBlockIndent()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:731
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var ind: number = block.startindent
                                  
                                      if line_A.text =~ CLOSING_BRACKET_AT_SOL
                                          if b:vimindent.is_on_named_block_line
                                              ind += 2 * shiftwidth()
                                          endif
                                          return ind + IndentMoreInBracketBlock()
                                      endif
                                  
                                      var startline: dict<any> = {
                                          text: block.startline,
                                          lnum: block.startlnum
                                      }
                                      if startline->EndsWithComma()
                                              || startline->EndsWithLambdaArrow()
                                              || (startline->EndsWithOpeningBracket()
                                              # TODO: Is that reliable?
                                              && block.startline !~
                                              $'^\s*{NON_BRACKET}\+{LIST_OR_DICT_CLOSING_BRACKET},\s\+{LIST_OR_DICT_OPENING_BRACKET}')
                                          ind += shiftwidth() + IndentMoreInBracketBlock()
                                      endif
                                  
                                      if b:vimindent.is_on_named_block_line
                                          ind += shiftwidth()
                                      endif
                                  
                                      if block.is_dict
                                              && line_A.text !~ DICT_KEY
                                          ind += shiftwidth()
                                      endif
                                  
                                      return ind

FUNCTION  <SNR>113_RunLinter()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:614
Called 167 times
Total time:   0.716737000
 Self time:   0.006317000

count     total (s)      self (s)
  167                 0.000549000     if !empty(a:linter.lsp)
   36   0.066340000   0.000505000         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
  131                 0.000120000     else
  131   0.002347000   0.000964000         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                                  
  131   0.645973000   0.002771000         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                      endif
                                  
                                      return 0

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:84
Called 107 times
Total time:   0.001706000
 Self time:   0.001706000

count     total (s)      self (s)
  107                 0.001684000     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 93 times
Total time:   0.830309000
 Self time:   0.028936000

count     total (s)      self (s)
   93   0.003016000   0.001091000   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                      throw 'gitgutter path not set'
   93                 0.000073000   endif
                                  
   93   0.004783000   0.000374000   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                      throw 'gitgutter not tracked'
   93                 0.000059000   endif
                                  
   93   0.002156000   0.000361000   if gitgutter#utility#repo_path(a:bufnr, 0) == -3
                                      throw 'gitgutter assume unchanged'
   93                 0.000063000   endif
                                  
                                    " Wrap compound commands in parentheses to make Windows happy.
                                    " bash doesn't mind the parentheses.
   93                 0.000145000   let cmd = '('
                                  
                                    " Append buffer number to temp filenames to avoid race conditions between
                                    " writing and reading the files when asynchronously processing multiple
                                    " buffers.
                                  
                                    " Without the buffer number, buff_file would have a race between the
                                    " second gitgutter#process_buffer() writing the file (synchronously, below)
                                    " and the first gitgutter#process_buffer()'s async job reading it (with
                                    " git-diff).
   93                 0.000515000   let buff_file = s:temp_buffer.'.'.a:bufnr
                                  
                                    " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                    " Use a modulus greater than a maximum reasonable number of visible buffers.
   93                 0.000505000   let s:counter = (s:counter + 1) % 20
   93                 0.000415000   let buff_file .= '.'.s:counter
                                  
   93   0.012830000   0.000632000   let extension = gitgutter#utility#extension(a:bufnr)
   93                 0.000271000   if !empty(extension)
   93                 0.000279000     let buff_file .= '.'.extension
   93                 0.000080000   endif
                                  
                                    " Write buffer to temporary file.
                                    " Note: this is synchronous.
   93   0.504477000   0.002098000   call s:write_buffer(a:bufnr, buff_file)
                                  
   93                 0.000413000   if a:from ==# 'index'
                                      " Without the buffer number, from_file would have a race in the shell
                                      " between the second process writing it (with git-show) and the first
                                      " reading it (with git-diff).
   93                 0.000837000     let from_file = s:temp_from.'.'.a:bufnr
                                  
                                      " Add a counter to avoid a similar race with two quick writes of the same buffer.
   93                 0.000445000     let from_file .= '.'.s:counter
                                  
   93                 0.000306000     if !empty(extension)
   93                 0.000239000       let from_file .= '.'.extension
   93                 0.000072000     endif
                                  
                                      " Write file from index to temporary file.
   93   0.020055000   0.001470000     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
   93                 0.000906000     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                                  
                                    elseif a:from ==# 'working_tree'
                                      let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
   93                 0.000066000   endif
                                  
                                    " Call git-diff.
   93                 0.000443000   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
   93                 0.000150000   if s:c_flag
   93                 0.000520000     let cmd .= ' -c "diff.autorefreshindex=0"'
   93                 0.000304000     let cmd .= ' -c "diff.noprefix=false"'
   93                 0.000291000     let cmd .= ' -c "core.safecrlf=false"'
   93                 0.000061000   endif
   93                 0.000592000   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                                  
                                    " Pipe git-diff output into grep.
   93                 0.000329000   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   93   0.004471000   0.000697000     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   93                 0.000061000   endif
                                  
                                    " grep exits with 1 when no matches are found; git-diff exits with 1 when
                                    " differences are found.  However we want to treat non-matches and
                                    " differences as non-erroneous behaviour; so we OR the command with one
                                    " which always exits with success (0).
   93                 0.000318000   let cmd .= ' || exit 0'
                                  
   93                 0.000199000   let cmd .= ')'
                                  
   93   0.024588000   0.000550000   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                                  
   93   0.000820000   0.000496000   if g:gitgutter_async && gitgutter#async#available()
   93   0.237170000   0.005224000     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   93                 0.000290000     return 'async'
                                  
                                    else
                                      let diff = gitgutter#utility#system(cmd)
                                  
                                      if v:shell_error
                                        call gitgutter#debug#log(diff)
                                        throw 'gitgutter diff failed'
                                      endif
                                  
                                      return diff
                                    endif

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:288
Called 107 times
Total time:   0.014412000
 Self time:   0.009955000

count     total (s)      self (s)
  107   0.002457000   0.000309000     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                                  
  107                 0.000103000     if !empty(l:mappings)
                                          " We need to apply reverse filename mapping here.
                                          let l:mappings = ale#filename_mapping#Invert(l:mappings)
  107                 0.000031000     endif
                                  
  107                 0.000075000     let l:bufnr_map = {}
  107                 0.000076000     let l:new_loclist = []
                                  
                                      " Some errors have line numbers beyond the end of the file,
                                      " so we need to adjust them so they set the error at the last line
                                      " of the file instead.
  107   0.001941000   0.000235000     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                                  
  145                 0.000115000     for l:old_item in a:loclist
                                          " Copy the loclist item with some default values and corrections.
                                          "
                                          " line and column numbers will be converted to numbers.
                                          " The buffer will default to the buffer being checked.
                                          " The vcol setting will default to 0, a byte index.
                                          " The error type will default to 'E' for errors.
                                          " The error number will default to -1.
                                          "
                                          " The line number and text are the only required keys.
                                          "
                                          " The linter_name will be set on the errors so it can be used in
                                          " output, filtering, etc..
   38                 0.000249000         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                                  
   38                 0.000027000         if a:from_other_source
                                              let l:item.from_other_source = 1
   38                 0.000013000         endif
                                  
   38                 0.000036000         if has_key(l:old_item, 'code')
   38                 0.000033000             let l:item.code = l:old_item.code
   38                 0.000019000         endif
                                  
   38                 0.000042000         let l:old_name = get(l:old_item, 'filename', '')
                                  
                                          " Map parsed from output to local filesystem files.
   38                 0.000044000         if !empty(l:old_name) && !empty(l:mappings)
                                              let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
   38                 0.000009000         endif
                                  
   38                 0.000051000         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                              " Use the filename given.
                                              " Temporary files are assumed to be for this buffer,
                                              " and the filename is not included then, because it looks bad
                                              " in the loclist window.
                                              let l:filename = l:old_name
                                              let l:item.filename = l:filename
                                  
                                              if has_key(l:old_item, 'bufnr')
                                                  " If a buffer number is also given, include that too.
                                                  " If Vim detects that he buffer number is valid, it will
                                                  " be used instead of the filename.
                                                  let l:item.bufnr = l:old_item.bufnr
                                              elseif has_key(l:bufnr_map, l:filename)
                                                  " Get the buffer number from the map, which can be faster.
                                                  let l:item.bufnr = l:bufnr_map[l:filename]
                                              else
                                                  " Look up the buffer number.
                                                  let l:item.bufnr = bufnr(l:filename)
                                                  let l:bufnr_map[l:filename] = l:item.bufnr
                                              endif
   38                 0.000029000         elseif has_key(l:old_item, 'bufnr')
                                              let l:item.bufnr = l:old_item.bufnr
   38                 0.000006000         endif
                                  
   38                 0.000033000         if has_key(l:old_item, 'detail')
                                              let l:item.detail = l:old_item.detail
   38                 0.000010000         endif
                                  
                                          " Pass on a end_col key if set, used for highlights.
   38                 0.000032000         if has_key(l:old_item, 'end_col')
   38                 0.000047000             let l:item.end_col = str2nr(l:old_item.end_col)
   38                 0.000011000         endif
                                  
   38                 0.000034000         if has_key(l:old_item, 'end_lnum')
                                              let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                  
                                              " When the error ends after the end of the file, put it at the
                                              " end. This is only done for the current buffer.
                                              if l:item.bufnr == a:buffer && l:item.end_lnum > l:last_line_number
                                                  let l:item.end_lnum = l:last_line_number
                                              endif
   38                 0.000008000         endif
                                  
   38                 0.000033000         if has_key(l:old_item, 'sub_type')
                                              let l:item.sub_type = l:old_item.sub_type
   38                 0.000008000         endif
                                  
   38                 0.000027000         if l:item.lnum < 1
                                              " When errors appear before line 1, put them at line 1.
                                              let l:item.lnum = 1
   38                 0.000046000         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                              " When errors go beyond the end of the file, put them at the end.
                                              " This is only done for the current buffer.
                                              let l:item.lnum = l:last_line_number
   38                 0.000038000         elseif get(l:old_item, 'vcol', 0)
                                              " Convert virtual column positions to byte positions.
                                              " The positions will be off if the buffer has changed recently.
                                              let l:line = getbufline(a:buffer, l:item.lnum)[0]
                                  
                                              let l:item.col = ale#util#Col(l:line, l:item.col)
                                  
                                              if has_key(l:item, 'end_col')
                                                  let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                                  
                                                  let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                              endif
   38                 0.000010000         endif
                                  
   38                 0.000042000         call add(l:new_loclist, l:item)
  145                 0.000262000     endfor
                                  
  107   0.000888000   0.000285000     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                                  
  107                 0.000102000     if !empty(l:type_map)
                                          call s:RemapItemTypes(l:type_map, l:new_loclist)
  107                 0.000030000     endif
                                  
  107                 0.000064000     return l:new_loclist

FUNCTION  <SNR>101_CacheFuncHeader()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:783
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var pos: list<number> = getcurpos()
                                      cursor(startlnum, 1)
                                      if search('(', 'W', startlnum) <= 0
                                          return
                                      endif
                                      var endlnum: number = SearchPair('(', '', ')', 'nW')
                                      setpos('.', pos)
                                      if endlnum == startlnum
                                          return
                                      endif
                                  
                                      b:vimindent = {
                                          is_FuncHeader: true,
                                          startindent: startlnum->Indent(),
                                          endlnum: endlnum,
                                      }
                                      RegisterCacheInvalidation()

FUNCTION  nerdtree#osDefaultCaseSensitiveFS()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:217
Called 271 times
Total time:   0.000629000
 Self time:   0.000629000

count     total (s)      self (s)
  271                 0.000531000     return s:osDefaultCaseSensitiveFS

FUNCTION  <SNR>11_BMMunge()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:952
Called 47 times
Total time:   0.008358000
 Self time:   0.001463000

count     total (s)      self (s)
   47                 0.000011000   var name = fname
   47                 0.000012000   if name == ''
   22                 0.000039000     if !exists("g:menutrans_no_file")
    1                 0.000002000       g:menutrans_no_file = "[No Name]"
    1                 0.000000000     endif
   22                 0.000024000     name = g:menutrans_no_file
   22                 0.000000000   else
   25                 0.000650000     name = fnamemodify(name, ':p:~')
   25                 0.000005000   endif
                                    # detach file name and separate it out:
   47                 0.000046000   var name2 = fnamemodify(name, ':t')
   47                 0.000020000   if bnum >= 0
   47                 0.000114000     name2 = name2 .. ' (' .. bnum .. ')'
   47                 0.000003000   endif
   47   0.006998000   0.000103000   name = name2 .. "\t" .. s:BMTruncName(fnamemodify(name, ':h'))
   47                 0.000132000   name = escape(name, "\\. \t|")
   47                 0.000159000   name = substitute(name, "&", "&&", "g")
   47                 0.000054000   name = substitute(name, "\n", "^@", "g")
                                    return name

FUNCTION  220()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 32 times
Total time:   0.010028000
 Self time:   0.000472000

count     total (s)      self (s)
   32   0.004807000   0.000118000     call g:NERDTree.MustBeOpen()
   32   0.005190000   0.000323000     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  221()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 165 times
Total time:   0.000625000
 Self time:   0.000625000

count     total (s)      self (s)
  165                 0.000542000     return exists('b:NERDTree')

FUNCTION  222()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:106
Called 47 times
Total time:   0.006740000
 Self time:   0.006740000

count     total (s)      self (s)
   47                 0.000300000     if !exists('t:NERDTreeBufName')
   15                 0.000018000         return
   32                 0.000058000     end
                                  
                                      "check b:NERDTree is still there and hasn't been e.g. :bdeleted
   32                 0.006163000     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  226()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 159 times
Total time:   0.021923000
 Self time:   0.021923000

count     total (s)      self (s)
  159                 0.000594000     if exists('t:NERDTreeBufName')
  159                 0.021190000         return bufwinnr(t:NERDTreeBufName)
                                      endif
                                  
                                      " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                      for w in range(1,winnr('$'))
                                          if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'win_\d\+$'
                                              return w
                                          endif
                                      endfor
                                  
                                      return -1

FUNCTION  227()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 99 times
Total time:   0.014563000
 Self time:   0.000605000

count     total (s)      self (s)
   99   0.014512000   0.000554000     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  229()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:166
Called 4 times
Total time:   0.000018000
 Self time:   0.000018000

count     total (s)      self (s)
    4                 0.000011000     return self._type ==# 'window'

FUNCTION  nerdtree#ui_glue#createDefaultBindings()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:7
Called 1 time
Total time:   0.001164000
 Self time:   0.000146000

count     total (s)      self (s)
    1   0.000014000   0.000003000     let s = '<SNR>' . s:SID() . '_'
                                  
    1   0.000030000   0.000005000     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
    1   0.000021000   0.000002000     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': 'all', 'callback': s.'handleLeftClick' })
    1   0.000020000   0.000002000     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'DirNode', 'callback': s.'activateDirNode' })
    1   0.000020000   0.000003000     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'FileNode', 'callback': s.'activateFileNode' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'all', 'callback': s.'activateAll' })
                                  
    1   0.000020000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'FileNode', 'callback': s.'customOpenFile'})
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'DirNode', 'callback': s.'customOpenDir'})
    1   0.000020000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'Bookmark', 'callback': s.'customOpenBookmark'})
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'all', 'callback': s.'activateAll' })
                                  
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'DirNode', 'callback': s.'activateDirNode' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'FileNode', 'callback': s.'activateFileNode' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'Bookmark', 'callback': s.'activateBookmark' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'Bookmark', 'callback': s.'previewBookmark' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'all', 'callback': s.'activateAll' })
                                  
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'FileNode', 'callback': s.'openHSplit' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'Bookmark', 'callback': s.'openHSplitBookmark' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'FileNode', 'callback': s.'openVSplit' })
    1   0.000032000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'Bookmark', 'callback': s.'openVSplitBookmark' })
                                  
    1   0.000021000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'FileNode', 'callback': s.'previewNodeCurrent' })
    1   0.000021000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'FileNode', 'callback': s.'previewNodeHSplit' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeHSplitBookmark' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'FileNode', 'callback': s.'previewNodeVSplit' })
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeVSplitBookmark' })
                                  
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': 'DirNode', 'callback': s.'openNodeRecursively' })
                                  
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
                                  
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': 'Node', 'callback': s.'chCwd' })
                                  
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': 'all', 'callback': s.'closeTreeWindow' })
                                  
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd' })
                                  
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': 'all', 'callback': s.'refreshRoot' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': 'Node', 'callback': s.'refreshCurrent' })
                                  
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': 'all', 'callback': s.'displayHelp' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': 'all', 'callback': s.'toggleZoom' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': 'all', 'callback': s.'toggleShowHidden' })
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': 'all', 'callback': s.'toggleIgnoreFilter' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': 'all', 'callback': s.'toggleShowFiles' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': 'all', 'callback': s.'toggleShowBookmarks' })
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFileLines, 'scope': 'all', 'callback': s.'toggleShowFileLines' })
                                  
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': 'Node', 'callback': s.'closeCurrentDir' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': 'DirNode', 'callback': s.'closeChildren' })
                                  
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': 'Node', 'callback': s.'showMenu' })
                                  
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': 'Node', 'callback': s.'jumpToParent' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': 'Node', 'callback': s.'jumpToFirstChild' })
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': 'Node', 'callback': s.'jumpToLastChild' })
    1   0.000018000   0.000001000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': 'all', 'callback': s.'jumpToRoot' })
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': 'Node', 'callback': s.'jumpToNextSibling' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': 'Node', 'callback': s.'jumpToPrevSibling' })
    1   0.000019000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpBookmarks, 'scope': 'all', 'callback': s.'jumpToBookmarks' })
                                  
    1   0.000018000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
    1   0.000033000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
    1   0.000026000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
    1   0.000025000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
                                  
    1   0.000026000   0.000004000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'DirNode', 'callback': s.'openExplorer' })
    1   0.000022000   0.000003000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'FileNode', 'callback': s.'openExplorer' })
                                  
    1   0.000019000   0.000002000     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': 'Bookmark', 'callback': s.'deleteBookmark' })

FUNCTION  <SNR>125_GroupCmd()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:162
Called 67 times
Total time:   0.000096000
 Self time:   0.000096000

count     total (s)      self (s)
   67                 0.000054000     if s:supports_sign_groups
   67                 0.000033000         return ' group=ale_signs '
                                      else
                                          return ' '
                                      endif

FUNCTION  ale#highlight#BufferHidden()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:193
Called 49 times
Total time:   0.002632000
 Self time:   0.000613000

count     total (s)      self (s)
                                      " Remove highlights right away when buffers are hidden.
                                      " They will be restored later when buffers are entered.
   49   0.002414000   0.000395000     call ale#highlight#RemoveHighlights()

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:205
Called 143 times
Total time:   0.016314000
 Self time:   0.003194000

count     total (s)      self (s)
  143                 0.000873000     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                                  
                                      " Set the list in the buffer variable.
  143                 0.000684000     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                                  
  143   0.001527000   0.000392000     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                                  
  143                 0.000195000     if !empty(l:exclude_list)
                                          call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
  143                 0.000056000     endif
                                  
                                      " Update highlights for the current buffer, which may or may not
                                      " be the buffer we just set highlights for.
  143   0.012339000   0.000354000     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>101_CommentIndent()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:702
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var line_B: dict<any>
                                      line_B.lnum = prevnonblank(v:lnum - 1)
                                      line_B.text = getline(line_B.lnum)
                                      if line_B.text =~ COMMENT
                                          return Indent(line_B.lnum)
                                      endif
                                  
                                      var next: number = NextCodeLine()
                                      if next == 0
                                          return 0
                                      endif
                                      var vimindent_save: dict<any> = get(b:, 'vimindent', {})->deepcopy()
                                      var ind: number = next->Expr()
                                      # The previous `Expr()` might have set or deleted `b:vimindent`.
                                      # This could  cause issues (e.g.  when indenting  2 commented lines  above a
                                      # heredoc).  Let's make sure the state of the variable is not altered.
                                      if vimindent_save->empty()
                                          unlet! b:vimindent
                                      else
                                          b:vimindent = vimindent_save
                                      endif
                                      if getline(next) =~ ENDS_BLOCK
                                          return ind + shiftwidth()
                                      else
                                          return ind
                                      endif

FUNCTION  <SNR>11_SetupKeymaps()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:481
Called 1 time
Total time:   0.008179000
 Self time:   0.008179000

count     total (s)      self (s)
    1                 0.000002000     if s:did_setup_keymaps
                                        return
                                      endif
    1                 0.000000000     s:did_setup_keymaps = 1
                                  
    1                 0.003739000     var names = globpath(&runtimepath, "keymap/*.vim", 1, 1)
    1                 0.000002000     if !empty(names)
    1                 0.000000000       var idx = 100
    1                 0.000044000       an 20.460.90 &Edit.&Keymap.None :set keymap=<CR>
    1                 0.000001000       for name in names
                                  	# Ignore case for VMS and windows
   82                 0.002917000 	var mapname = substitute(name, '\c.*[/\\:\]]\([^/\\:_]*\)\(_[0-9a-zA-Z-]*\)\=\.vim', '\1', '')
   82                 0.001420000 	exe "an 20.460." .. idx .. ' &Edit.&Keymap.' .. mapname .. " :set keymap=" .. mapname .. "<CR>"
   82                 0.000004000 	idx += 10
   82                 0.000009000       endfor
    1                 0.000000000     endif
    1                 0.000018000     silent! aunmenu &Edit.Show\ &Keymaps\ in\ Menu

FUNCTION  ale#code_action#EnablePopUpMenu()
    Defined: ~/.vim/bundle/ale/autoload/ale/code_action.vim:373
Called 1 time
Total time:   0.000046000
 Self time:   0.000005000

count     total (s)      self (s)
    1   0.000046000   0.000005000     call s:Setup(1)

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:190
Called 143 times
Total time:   0.133637000
 Self time:   0.011649000

count     total (s)      self (s)
  143   0.001811000   0.000648000     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                                  
  143                 0.000218000     if g:ale_use_neovim_diagnostics_api
                                          call ale#engine#SendResultsToNeovimDiagnostics(a:buffer, a:loclist)
  143                 0.000056000     endif
                                  
                                      " Set signs first. This could potentially fix some line numbers.
                                      " The List could be sorted again here by SetSigns.
  143                 0.000261000     if !g:ale_use_neovim_diagnostics_api && g:ale_set_signs
  143   0.034709000   0.001080000         call ale#sign#SetSigns(a:buffer, a:loclist)
  143                 0.000067000     endif
                                  
  143                 0.000203000     if g:ale_set_quickfix || g:ale_set_loclist
  143   0.015765000   0.000572000         call ale#list#SetLists(a:buffer, a:loclist)
  143                 0.000055000     endif
                                  
  143                 0.000283000     if exists('*ale#statusline#Update')
                                          " Don't load/run if not already loaded.
                                          call ale#statusline#Update(a:buffer, a:loclist)
  143                 0.000052000     endif
                                  
  143                 0.000205000     if !g:ale_use_neovim_diagnostics_api && g:ale_set_highlights
  143   0.017215000   0.000650000         call ale#highlight#SetHighlights(a:buffer, a:loclist)
  143                 0.000050000     endif
                                  
  143                 0.000381000     if !g:ale_use_neovim_diagnostics_api&& (g:ale_virtualtext_cursor is# 'all' || g:ale_virtualtext_cursor == 2)
  143   0.014368000   0.000573000         call ale#virtualtext#SetTexts(a:buffer, a:loclist)
  143                 0.000055000     endif
                                  
  143                 0.000134000     if l:linting_is_done
  143                 0.000124000         if g:ale_echo_cursor
                                              " Try and echo the warning now.
                                              " This will only do something meaningful if we're in normal mode.
  143   0.020356000   0.000457000             call ale#cursor#EchoCursorWarning()
  143                 0.000065000         endif
                                  
  143                 0.000350000         if !g:ale_use_neovim_diagnostics_api&& (g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor == 1)
                                              " Try and show the warning now.
                                              " This will only do something meaningful if we're in normal mode.
                                              call ale#virtualtext#ShowCursorWarning()
  143                 0.000075000         endif
                                  
                                          " Reset the save event marker, used for opening windows, etc.
  143                 0.000356000         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                          " Set a marker showing how many times a buffer has been checked.
  143                 0.000471000         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                                  
                                          " Automatically remove all managed temporary files and directories
                                          " now that all jobs have completed.
  143   0.022274000   0.000632000         call ale#command#RemoveManagedFiles(a:buffer)
                                  
                                          " Call user autocommands. This allows users to hook into ALE's lint cycle.
  143   0.001391000   0.001289000         silent doautocmd <nomodeline> User ALELintPost
  143                 0.000058000     endif

FUNCTION  <SNR>167_gethistdata()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1645
Called 1 time
Total time:   0.000183000
 Self time:   0.000008000

count     total (s)      self (s)
    1   0.000183000   0.000008000 	retu ctrlp#utils#readfile(s:gethistloc()[1])

FUNCTION  <SNR>45_CSVDoBufLoadAutocmd()
    Defined: ~/.vim/bundle/csv.vim/plugin/csv.vim:11
Called 1 time
Total time:   0.000022000
 Self time:   0.000022000

count     total (s)      self (s)
                                      " Visually arrange columns when opening a csv file
                                      " do not check filetype here, it might be too late, rather use the
                                      " filepattern from the ftdetect script
    1                 0.000000000     aug CSV_Edit
    1                 0.000013000         au!
    1                 0.000005000         au BufReadPost,BufWritePost *.csv,*.dat,*.tsv,*.tab call s:CSVArrange(1)
    1                 0.000002000         au BufWritePre *.csv,*.dat,*.tsv,*.tab call s:CSVArrange(0)
    1                 0.000001000     aug end

FUNCTION  <SNR>158_prepare()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:270
Called 5 times
Total time:   0.000745000
 Self time:   0.000745000

count     total (s)      self (s)
    5                 0.000191000   command! -nargs=+ Log            :call vader#log(<args>)
    5                 0.000063000   command! -nargs=+ Save           :call vader#save(<q-args>)
    5                 0.000077000   command! -nargs=* Restore        :call vader#restore(<q-args>)
    5                 0.000063000   command! -nargs=+ Assert         :call vader#assert#true(<args>)
    5                 0.000060000   command! -nargs=+ AssertEqual    :call vader#assert#equal(<args>)
    5                 0.000057000   command! -nargs=+ AssertNotEqual :call vader#assert#not_equal(<args>)
    5                 0.000040000   command! -nargs=+ AssertThrows   :call vader#assert#throws(<q-args>)
    5                 0.000079000   let g:SyntaxAt = function('vader#helper#syntax_at')
    5                 0.000078000   let g:SyntaxOf = function('vader#helper#syntax_of')

FUNCTION  <SNR>11_SetupLazyloadMenus()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/menu.vim:736
Called 1 time
Total time:   0.035429000
 Self time:   0.000445000

count     total (s)      self (s)
    1   0.010665000   0.000007000     s:SetupColorSchemes()
    1   0.016163000   0.000016000     s:SetupCompilers()
    1                 0.000000000     if has("keymap")
    1   0.008186000   0.000007000       s:SetupKeymaps()
    1                 0.000000000     endif

FUNCTION  230()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 32 times
Total time:   0.004689000
 Self time:   0.000257000

count     total (s)      self (s)
   32   0.004547000   0.000115000     if !s:NERDTree.IsOpen()
                                          throw 'NERDTree.TreeNotOpen'
   32                 0.000028000     endif

FUNCTION  231()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:178
Called 5 times
Total time:   0.000486000
 Self time:   0.000140000

count     total (s)      self (s)
    5                 0.000049000     let newObj = copy(self)
    5   0.000177000   0.000025000     let newObj.ui = g:NERDTreeUI.New(newObj)
    5   0.000245000   0.000051000     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
    5                 0.000009000     let newObj._type = a:type
    5                 0.000004000     return newObj

FUNCTION  232()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 418 times
Total time:   0.002089000
 Self time:   0.002089000

count     total (s)      self (s)
  418                 0.000918000     if !exists('s:NERDTree._PathFilters')
    1                 0.000005000         let s:NERDTree._PathFilters = []
  418                 0.000193000     endif
  418                 0.000419000     return s:NERDTree._PathFilters

FUNCTION  235()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 13 times
Total time:   0.078803000
 Self time:   0.000042000

count     total (s)      self (s)
   13   0.078799000   0.000038000     call self.ui.render()

FUNCTION  237()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:25
Called 13 times
Total time:   0.001678000
 Self time:   0.001641000

count     total (s)      self (s)
   13   0.000052000   0.000035000     if self.getShowHelp()
                                          let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                          let help .= "\" ============================\n"
                                          let help .= "\" File node mappings~\n"
                                          let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                          if self.nerdtree.isTabTree()
                                              let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                          else
                                              let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                          endif
                                          if self.nerdtree.isTabTree()
                                              let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                          endif
                                          let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                          let help .= "\" middle-click,\n"
                                          let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                          let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                          let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                          let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                          let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Directory node mappings~\n"
                                          let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                          let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                          let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                          let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                          let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                          let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                          let help .= "\"    current node recursively\n"
                                          let help .= "\" middle-click,\n"
                                          let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Bookmark table mappings~\n"
                                          let help .= "\" double-click,\n"
                                          let help .= '" '. g:NERDTreeMapJumpBookmarks .": jump to bookmark table\n"
                                          let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                          let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                          let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                          let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                          let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                          let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                          let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                          let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                          let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Tree navigation mappings~\n"
                                          let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                          let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                          let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                          let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                          let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                          let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Filesystem mappings~\n"
                                          let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                          let help .= "\"    selected dir\n"
                                          let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                          let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                          let help .= "\"    but leave old root open\n"
                                          let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                          let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                          let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                          let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                          let help .= "\"    selected dir\n"
                                          let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Tree filtering mappings~\n"
                                          let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleFileLines .': files lines (' . (self.getShowFileLines() ? 'on' : 'off') . ")\n"
                                  
                                          " add quickhelp entries for each custom key map
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Custom mappings~\n"
                                          for i in g:NERDTreeKeyMap.All()
                                              if !empty(i.quickhelpText)
                                                  let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                              endif
                                          endfor
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Other mappings~\n"
                                          let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                          let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                          let help .= "\"    the NERDTree window\n"
                                          let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Bookmark commands~\n"
                                          let help .= "\" :Bookmark [<name>]\n"
                                          let help .= "\" :BookmarkToRoot <name>\n"
                                          let help .= "\" :RevealBookmark <name>\n"
                                          let help .= "\" :OpenBookmark <name>\n"
                                          let help .= "\" :ClearBookmarks [<names>]\n"
                                          let help .= "\" :ClearAllBookmarks\n"
                                          let help .= "\" :ReadBookmarks\n"
                                          let help .= "\" :WriteBookmarks\n"
                                          let help .= "\" :EditBookmarks\n"
                                          silent! put =help
   13   0.000060000   0.000040000     elseif !self.isMinimal()
   13                 0.000033000         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
   13                 0.000107000         silent! put =help
   13                 0.000008000     endif

FUNCTION  238()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:144
Called 5 times
Total time:   0.000152000
 Self time:   0.000152000

count     total (s)      self (s)
    5                 0.000078000     let newObj = copy(self)
    5                 0.000009000     let newObj.nerdtree = a:nerdtree
    5                 0.000007000     let newObj._showHelp = 0
    5                 0.000007000     let newObj._ignoreEnabled = 1
    5                 0.000006000     let newObj._showFiles = g:NERDTreeShowFiles
    5                 0.000009000     let newObj._showHidden = g:NERDTreeShowHidden
    5                 0.000010000     let newObj._showBookmarks = g:NERDTreeShowBookmarks
    5                 0.000008000     let newObj._showFileLines = g:NERDTreeFileLines
                                  
    5                 0.000005000     return newObj

FUNCTION  239()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:162
Called 12 times
Total time:   0.025252000
 Self time:   0.006965000

count     total (s)      self (s)
   12                 0.000139000     let line = getline(a:ln)
                                  
   12   0.001311000   0.000125000     let rootLine = self.getRootLineNum()
                                  
   12                 0.000038000     if a:ln ==# rootLine
                                          return self.nerdtree.root.path
   12                 0.000016000     endif
                                  
   12   0.000173000   0.000126000     if line ==# s:UI.UpDirLine()
                                          return self.nerdtree.root.path.getParent()
   12                 0.000015000     endif
                                  
   12                 0.000033000     if a:ln < rootLine
                                          return {}
   12                 0.000010000     endif
                                  
   12   0.001249000   0.000141000     let indent = self._indentLevelFor(line)
                                  
                                      " remove the tree parts and the leading space
   12   0.000537000   0.000123000     let curFile = self._stripMarkup(line)
                                  
   12                 0.000031000     let dir = ''
   12                 0.000037000     let lnum = a:ln
   95                 0.000323000     while lnum > 0
   95                 0.000244000         let lnum = lnum - 1
   95                 0.000367000         let curLine = getline(lnum)
   95   0.002604000   0.000580000         let curLineStripped = self._stripMarkup(curLine)
                                  
                                          " have we reached the top of the tree?
   95                 0.000228000         if lnum ==# rootLine
   12   0.001985000   0.000306000             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
   12                 0.000015000             break
   83                 0.000092000         endif
   83                 0.000494000         if curLineStripped =~# '/$'
   80   0.004051000   0.000500000             let lpindent = self._indentLevelFor(curLine)
   80                 0.000202000             if lpindent < indent
   20                 0.000059000                 let indent = indent - 1
                                  
   20                 0.000190000                 let dir = substitute (curLineStripped,'^\\', '', '') . dir
   20                 0.000054000                 continue
   60                 0.000065000             endif
   63                 0.000156000         endif
   75                 0.000100000     endwhile
   12                 0.000080000     let curFile = self.nerdtree.root.path.drive . dir . curFile
   12   0.008445000   0.000167000     let toReturn = g:NERDTreePath.New(curFile)
   12                 0.000022000     return toReturn

FUNCTION  <SNR>118_reset_tick()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:179
Called 94 times
Total time:   0.005170000
 Self time:   0.001480000

count     total (s)      self (s)
   94   0.005077000   0.001387000   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 101 times
Total time:   0.243607000
 Self time:   0.233624000

count     total (s)      self (s)
  101   0.005264000   0.000850000   call gitgutter#debug#log('[async] '.a:cmd)
                                  
  101                 0.000517000   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
  101   0.001125000   0.000520000   let command = s:build_command(a:cmd)
                                  
  101                 0.000320000   if has('nvim')
                                      call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
  101                 0.000065000   else
  101                 0.224005000     let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
  101   0.009493000   0.004529000     let s:jobs[s:job_id(job)] = 1
  101                 0.000374000   endif

FUNCTION  <SNR>113_AddProblemsFromOtherBuffers()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:528
Called 7 times
Total time:   0.001388000
 Self time:   0.001388000

count     total (s)      self (s)
    7                 0.000211000     let l:filename = expand('#' . a:buffer . ':p')
    7                 0.000008000     let l:loclist = []
    7                 0.000007000     let l:name_map = {}
                                  
                                      " Build a map of the active linters.
   14                 0.000014000     for l:linter in a:linters
    7                 0.000011000         let l:name_map[l:linter.name] = 1
   14                 0.000004000     endfor
                                  
                                      " Find the items from other buffers, for the linters that are enabled.
   39                 0.000101000     for l:info in values(g:ale_buffer_info)
  120                 0.000152000         for l:item in l:info.loclist
   88                 0.000193000             if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                                  " Copy the items and set the buffer numbers to this one.
                                                  let l:new_item = copy(l:item)
                                                  let l:new_item.bufnr = a:buffer
                                                  call add(l:loclist, l:new_item)
   88                 0.000039000             endif
  120                 0.000068000         endfor
   39                 0.000017000     endfor
                                  
    7                 0.000007000     if !empty(l:loclist)
                                          call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                          call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                                  
                                          " Set the loclist variable, used by some parts of ALE.
                                          let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                          call ale#engine#SetResults(a:buffer, l:loclist)
    7                 0.000003000     endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:177
Called 93 times
Total time:   0.050997000
 Self time:   0.005194000

count     total (s)      self (s)
   93   0.002973000   0.000465000   call gitgutter#debug#log(a:diff)
                                  
   93                 0.000207000   if !bufexists(a:bufnr)
                                      return
   93                 0.000030000   endif
                                  
   93   0.014011000   0.000907000   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   93   0.021605000   0.000547000   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                                  
   93                 0.000139000   let signs_count = len(modified_lines)
   93                 0.000187000   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                      call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                      call gitgutter#sign#clear_signs(a:bufnr)
                                  
   93                 0.000042000   else
   93                 0.000179000     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
   93   0.008571000   0.000590000       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   93                 0.000044000     endif
   93                 0.000033000   endif
                                  
   93   0.001398000   0.000246000   call s:save_last_seen_change(a:bufnr)
   93                 0.000323000   if exists('#User#GitGutter')
                                      let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                      execute 'doautocmd' s:nomodeline 'User GitGutter'
                                      unlet g:gitgutter_hook_context
   93                 0.000030000   endif

FUNCTION  <SNR>101_IndentMoreLineContinuation()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:29
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      var n: any = get(g:, 'vim_indent', {})
                                          # We inspect `g:vim_indent_cont` to stay backward compatible.
                                          ->get('line_continuation', get(g:, 'vim_indent_cont', shiftwidth() * 3))
                                  
                                      if n->typename() == 'string'
                                          return n->eval()
                                      else
                                          return n
                                      endif

FUNCTION  <SNR>167_gethistloc()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1639
Called 6 times
Total time:   0.000235000
 Self time:   0.000103000

count     total (s)      self (s)
    6   0.000042000   0.000026000 	let utilcadir = ctrlp#utils#cachedir()
    6   0.000113000   0.000042000 	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
    6   0.000077000   0.000032000 	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']

FUNCTION  <SNR>167_highlight()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1621
Called 2 times
Total time:   0.000044000
 Self time:   0.000044000

count     total (s)      self (s)
    2                 0.000008000 	if s:matcher != {} | retu | en
    2                 0.000004000 	cal clearmatches()
    2                 0.000004000 	if !empty(a:pat) && s:ispath
                                  		let pat = s:regexp ? substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g') : a:pat
                                  		if s:byfname
                                  			let pat = substitute(pat, '\[\^\(.\{-}\)\]\\{-}', '[^\\/\1]\\{-}', 'g')
                                  			let pat = substitute(pat, '\$\@<!$', '\\ze[^\\/]*$', 'g')
                                  		en
                                  		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
                                  		cal matchadd('CtrlPLinePre', '^>')
    2                 0.000001000 	en

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:120
Called 167 times
Total time:   0.020053000
 Self time:   0.015900000

count     total (s)      self (s)
  167                 0.000548000   if !g:gitgutter_map_keys
                                      return
  167                 0.000126000   endif
                                  
                                    " Note hasmapto() and maparg() operate on the current buffer.
                                  
  167                 0.000483000   let bufnr = bufnr('')
                                  
  167   0.004519000   0.001256000   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
  124                 0.000118000     return
   43                 0.000025000   endif
                                  
   43                 0.001801000   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
   43                 0.000279000     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
   43                 0.000024000   endif
   43                 0.000862000   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
   43                 0.000170000     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
   43                 0.000023000   endif
                                  
   43                 0.000783000   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
   43                 0.000256000     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
   43                 0.000022000   endif
   43                 0.000819000   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
   43                 0.000221000     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
   43                 0.000025000   endif
   43                 0.000814000   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
   43                 0.000220000     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
   43                 0.000020000   endif
   43                 0.000825000   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
   43                 0.000222000     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
   43                 0.000024000   endif
                                  
   43                 0.000964000   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
   43                 0.000206000     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
   43                 0.000026000   endif
   43                 0.000863000   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
   43                 0.000197000     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
   43                 0.000025000   endif
   43                 0.000851000   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
   43                 0.000197000     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
   43                 0.000078000   endif
   43                 0.000813000   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
   43                 0.000190000     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
   43                 0.000025000   endif
                                  
   43   0.001172000   0.000282000   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>101_SearchPairStart()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:988
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      return SearchPair(start, middle, end, 'bnW')

FUNCTION  <SNR>127_matchaddpos()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:89
Called 53 times
Total time:   0.001507000
 Self time:   0.001507000

count     total (s)      self (s)
   53                 0.000067000     if s:has_nvim_highlight
                                          for l:pos in a:pos_list
                                              let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                                  
                                              if type(l:pos) == v:t_number || len(l:pos) == 1
                                                  let l:col_start = 0
                                                  let l:col_end = s:MAX_COL_SIZE
                                              else
                                                  let l:col_start = l:pos[1] - 1
                                                  let l:col_end = l:col_start + get(l:pos, 2, 1)
                                              endif
                                  
                                              call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
                                          endfor
   53                 0.000021000     else
   53                 0.000577000         call matchaddpos(a:group, a:pos_list)
   53                 0.000018000     endif

FUNCTION  <SNR>158_run()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:317
Called 5 times
Total time:   0.075330000
 Self time:   0.001864000

count     total (s)      self (s)
    5                 0.000006000   let given = []
    5                 0.000005000   let before = []
    5                 0.000006000   let after = []
    5                 0.000006000   let then = []
    5                 0.000016000   let comment = { 'given': '', 'before': '', 'after': '' }
    5                 0.000011000   let total = len(a:cases)
    5                 0.000015000   let just  = len(string(total))
    5                 0.000005000   let cnt = 0
    5                 0.000005000   let pending = 0
    5                 0.000004000   let success = 0
    5                 0.000013000   let exitfirst = get(a:options, 'exitfirst', 0)
    5                 0.000005000   let qfl = []
    5                 0.000010000   let g:vader_file = a:filename
                                  
    5   0.000175000   0.000018000   call vader#window#append("Starting Vader: ". a:filename, 1)
                                  
   10                 0.000014000   for case in a:cases
    5                 0.000008000     let cnt += 1
    5                 0.000004000     let ok = 1
    5                 0.000032000     let prefix = printf('(%'.just.'d/%'.just.'d)', cnt, total)
                                  
   25                 0.000033000     for label in ['given', 'before', 'after', 'then']
   20                 0.000038000       if has_key(case, label)
                                          execute 'let '.label.' = case[label]'
                                          let comment[label] = get(case.comment, label, '')
   20                 0.000010000       endif
   25                 0.000011000     endfor
                                  
    5                 0.000007000     if !empty(given)
                                        call s:append(prefix, 'given', comment.given)
    5                 0.000001000     endif
    5   0.000828000   0.000035000     call vader#window#prepare(given, get(case, 'type', ''))
                                  
    5                 0.000007000     if !empty(before)
                                        let s:indent = 2
                                        let ok = ok && s:execute(prefix, 'before', before, '')
    5                 0.000027000     endif
                                  
    5                 0.000007000     let s:indent = 3
    5                 0.000010000     if has_key(case, 'execute')
    5   0.000297000   0.000047000       call s:append(prefix, 'execute', s:comment(case, 'execute'))
    5   0.072312000   0.000046000       let ok = ok && s:execute(prefix, 'execute', case.execute, get(case, 'lang_if', ''))
                                      elseif has_key(case, 'do')
                                        call s:append(prefix, 'do', s:comment(case, 'do'))
                                        try
                                          call vader#window#replay(case.do)
                                        catch
                                          call s:append(prefix, 'do', v:exception, 1)
                                          call s:print_throwpoint()
                                          let ok = 0
                                        endtry
    5                 0.000003000     endif
                                  
    5                 0.000020000     if has_key(case, 'then')
                                        call s:append(prefix, 'then', s:comment(case, 'then'))
                                        let ok = ok && s:execute(prefix, 'then', then, '')
    5                 0.000003000     endif
                                  
    5                 0.000007000     if has_key(case, 'expect')
                                        let result = vader#window#result()
                                        let match = case.expect ==# result
                                        if match
                                          call s:append(prefix, 'expect', s:comment(case, 'expect'))
                                        else
                                          let begin = s:append(prefix, 'expect', s:comment(case, 'expect'), 1)
                                          let ok = 0
                                          let data = { 'type': get(case, 'type', ''), 'got': result, 'expect': case.expect }
                                          call vader#window#append('- Expected:', 3)
                                          for line in case.expect
                                            call vader#window#append(line, 5, 0)
                                          endfor
                                          let end = vader#window#append('- Got:', 3)
                                          for line in result
                                            let end = vader#window#append(line, 5, 0)
                                          endfor
                                          call vader#window#set_data(begin, end, data)
                                        endif
    5                 0.000002000     endif
                                  
    5                 0.000011000     if !empty(after)
                                        let s:indent = 2
                                        let g:vader_case_ok = ok
                                        let ok = s:execute(prefix, 'after', after, '') && ok
    5                 0.000006000     endif
                                  
    5                 0.000004000     if ok
    1                 0.000002000       let success += 1
    4                 0.000003000     else
    4                 0.000012000       let pending += case.pending
    4                 0.000105000       let description = join(filter([ comment.given, get(case.comment, 'do', get(case.comment, 'execute', '')), get(case.comment, 'then', ''), get(case.comment, 'expect', '')], '!empty(v:val)'), ' / ') . ' (#'.s:error_line.')'
    4                 0.000031000       call add(qfl, { 'type': 'E', 'filename': a:filename, 'lnum': case.lnum, 'text': description })
    4                 0.000007000       if exitfirst && !case.pending
                                          call vader#window#append('Stopping after first failure.', 2)
                                          break
    4                 0.000002000       endif
    5                 0.000005000     endif
   10                 0.000019000   endfor
                                  
    5                 0.000013000   unlet g:vader_file
    5                 0.000012000   return [success, pending, total, qfl]

FUNCTION  240()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:214
Called 13 times
Total time:   0.006301000
 Self time:   0.002026000

count     total (s)      self (s)
                                  
   13   0.001734000   0.000021000     if a:node.isRoot()
    5   0.000108000   0.000007000         return self.getRootLineNum()
    8                 0.000003000     endif
                                  
    8   0.000492000   0.000097000     let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
    8                 0.000012000     let l:currentPathComponent = 1
                                  
    8   0.000417000   0.000033000     let l:fullPath = a:node.path.str({'format': 'UI'})
                                  
   56   0.000306000   0.000085000     for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
   56                 0.000107000         let l:currentLine = getline(l:lineNumber)
   56   0.001151000   0.000165000         let l:indentLevel = self._indentLevelFor(l:currentLine)
                                  
   56                 0.000088000         if l:indentLevel !=# l:currentPathComponent
                                              continue
   56                 0.000028000         endif
                                  
   56   0.000620000   0.000145000         let l:currentLine = self._stripMarkup(l:currentLine)
   56                 0.000171000         let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                                  
                                          " Directories: If the current path 'starts with' the full path, then
                                          " either the paths are equal or the line is a cascade containing the
                                          " full path.
   56                 0.000177000         if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
    8                 0.000008000             return l:lineNumber
   48                 0.000019000         endif
                                  
                                          " Files: The paths must exactly match.
   48                 0.000061000         if l:fullPath ==# l:currentPath
                                              return l:lineNumber
   48                 0.000018000         endif
                                  
                                          " Otherwise: If the full path starts with the current path and the
                                          " current path is a directory, we add a new path component.
   48                 0.000126000         if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
    8                 0.000031000             let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
    8                 0.000018000             call add(l:pathComponents, l:currentLine)
    8                 0.000014000             let l:currentPathComponent += 1
   48                 0.000021000         endif
   48                 0.000035000     endfor
                                  
                                      return -1

FUNCTION  241()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:262
Called 25 times
Total time:   0.001508000
 Self time:   0.001508000

count     total (s)      self (s)
   25                 0.000092000     let rootLine = 1
  100                 0.000936000     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
   75                 0.000184000         let rootLine = rootLine + 1
  100                 0.000120000     endwhile
   25                 0.000038000     return rootLine

FUNCTION  242()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:271
Called 13 times
Total time:   0.000017000
 Self time:   0.000017000

count     total (s)      self (s)
   13                 0.000014000     return self._showBookmarks

FUNCTION  243()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:276
Called 340 times
Total time:   0.000381000
 Self time:   0.000381000

count     total (s)      self (s)
  340                 0.000276000     return self._showFiles

FUNCTION  244()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:281
Called 13 times
Total time:   0.000017000
 Self time:   0.000017000

count     total (s)      self (s)
   13                 0.000013000     return self._showHelp

FUNCTION  245()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:286
Called 418 times
Total time:   0.000461000
 Self time:   0.000461000

count     total (s)      self (s)
  418                 0.000363000     return self._showHidden

FUNCTION  246()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:291
Called 44 times
Total time:   0.000044000
 Self time:   0.000044000

count     total (s)      self (s)
   44                 0.000037000     return self._showFileLines

FUNCTION  247()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:296
Called 148 times
Total time:   0.005645000
 Self time:   0.005336000

count     total (s)      self (s)
                                      " Replace multi-character DirArrows with a single space so the
                                      " indentation calculation doesn't get messed up.
  148                 0.000368000     if g:NERDTreeDirArrowExpandable ==# ''
                                          let l:line = '  '.a:line
  148                 0.000154000     else
  148                 0.002056000         let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
  148                 0.000159000     endif
  148                 0.001104000     let leadChars = match(l:line, '\M\[^ ]')
  148   0.001121000   0.000812000     return leadChars / s:UI.IndentWid()

FUNCTION  248()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:309
Called 148 times
Total time:   0.000309000
 Self time:   0.000309000

count     total (s)      self (s)
  148                 0.000222000     return 2

FUNCTION  249()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:314
Called 418 times
Total time:   0.000531000
 Self time:   0.000531000

count     total (s)      self (s)
  418                 0.000434000     return self._ignoreEnabled ==# 1

FUNCTION  <SNR>101_Offset()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:606
Called 3 times
Total time:   0.001912000
 Self time:   0.000155000

count     total (s)      self (s)
                                  
    3   0.000318000   0.000121000     if line_B->AtStartOf('FuncHeader')
                                              && IsInInterface()
                                          return 0
                                  
                                      # increase indentation inside a block
                                      elseif line_B.text =~ STARTS_NAMED_BLOCK
                                              || line_B->EndsWithCurlyBlock()
                                          # But don't indent if the line starting the block also closes it.
    2   0.001592000   0.000032000         if line_B->AlsoClosesBlock()
                                              return 0
                                          # Indent twice for  a line continuation in the block  header itself, so that
                                          # we can easily  distinguish the end of  the block header from  the start of
                                          # the block body.
                                          elseif (line_B->EndsWithLineContinuation()
                                                  && !line_A.isfirst)
                                                  || (line_A.text =~ LINE_CONTINUATION_AT_SOL
                                                  && line_A.text !~ PLUS_MINUS_COMMAND)
                                                  || line_A.text->Is_IN_KeywordForLoop(line_B.text)
                                              return 2 * shiftwidth()
                                          else
                                              return shiftwidth()
                                          endif
                                  
                                      # increase indentation of  a line if it's the continuation  of a command which
                                      # started on a previous line
                                      elseif !line_A.isfirst
                                              && (line_B->EndsWithLineContinuation()
                                              || line_A.text =~ LINE_CONTINUATION_AT_SOL)
                                          return shiftwidth()
                                      endif
                                  
                                      return 0

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:110
Called 131 times
Total time:   0.117022000
 Self time:   0.041715000

count     total (s)      self (s)
  131                 0.000367000     if empty(a:temporary_file)
                                          " There is no file, so we didn't create anything.
                                          return 0
  131                 0.000084000     endif
                                  
                                      " Use an existing list of lines of input if we have it, or get the lines
                                      " from the file.
  131                 0.005065000     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                                  
  131                 0.000824000     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                      " Create the temporary directory for the file, unreadable by 'other'
                                      " users.
  131                 0.031412000     call mkdir(l:temporary_directory, '', 0750)
                                      " Automatically delete the directory later.
  131   0.004604000   0.001300000     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                      " Write the buffer out to a file.
  131   0.072988000   0.000985000     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                                  
  131                 0.000324000     return 1

FUNCTION  <SNR>161_switch_to_console()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:30
Called 5 times
Total time:   0.008003000
 Self time:   0.000406000

count     total (s)      self (s)
    5   0.007801000   0.000204000   execute 'normal! '.s:console_tab.'gt'
    5                 0.000012000   if tabpagenr() != s:console_tab
                                      call vader#window#append(printf('Vader warning: could not change to console tab (%d)', s:console_tab), 0)
    5                 0.000003000   endif
    5                 0.000142000   call append(line('$') - 1, s:console_buffered)
    5                 0.000016000   let s:console_buffered = []

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:74
Called 1811 times
Total time:   0.466578000
 Self time:   0.137161000

count     total (s)      self (s)
 1811                 0.021336000     let l:buffer = bufnr('')
                                  
 1811                 0.005717000     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                          return
 1811                 0.002364000     endif
                                  
                                      " Only echo the warnings in normal mode, otherwise we will get problems.
 1811                 0.007674000     if mode(1) isnot# 'n'
   14                 0.000013000         return
 1797                 0.001149000     endif
                                  
 1797   0.245270000   0.010033000     if ale#ShouldDoNothing(l:buffer)
   60                 0.000049000         return
 1737                 0.000963000     endif
                                  
 1737   0.088961000   0.011360000     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                                  
 1737                 0.002558000     if g:ale_echo_cursor
 1737                 0.003732000         if !empty(l:loc)
   48   0.000958000   0.000262000             let l:format = ale#Var(l:buffer, 'echo_msg_format')
   48   0.004332000   0.000261000             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                  
   48   0.012105000   0.000293000             call ale#cursor#TruncatedEcho(l:msg)
   48                 0.000127000             let l:info.echoed = 1
 1689                 0.004393000         elseif get(l:info, 'echoed')
                                              " We'll only clear the echoed message when moving off errors once,
                                              " so we don't continually clear the echo line.
                                              "
                                              " no-custom-checks
   11                 0.000109000             echo
   11                 0.000048000             let l:info.echoed = 0
 1737                 0.001231000         endif
 1737                 0.001194000     endif
                                  
 1737                 0.002719000     if g:ale_cursor_detail
                                          if !empty(l:loc)
                                              call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                          else
                                              call ale#preview#CloseIfTypeMatches('ale-preview')
                                          endif
 1737                 0.001210000     endif

FUNCTION  <lambda>7()
    Defined: ~/.vim/bundle/vim9-syntax/import/vim9SyntaxUtil.vim:76
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                  return line->matchstr(pat)

FUNCTION  <lambda>8()
    Defined: ~/.vim/bundle/vim9-syntax/import/vim9SyntaxUtil.vim:77
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                  return type != ''

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:108
Called 107 times
Total time:   0.106078000
 Self time:   0.002576000

count     total (s)      self (s)
  107                 0.000199000     let l:info = get(g:ale_buffer_info, a:buffer, {})
                                  
  107                 0.000084000     if empty(l:info)
                                          return
  107                 0.000039000     endif
                                  
  107                 0.000076000     if !a:from_other_source
                                          " Remove this linter from the list of active linters.
                                          " This may have already been done when the job exits.
  107                 0.000163000         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
  107                 0.000029000     endif
                                  
                                      " Make some adjustments to the loclists to fix common problems, and also
                                      " to set default values for loclist items.
  107   0.014823000   0.000411000     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                                  
                                      " Remove previous items for this linter.
  107                 0.000185000     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                                  
                                      " We don't need to add items or sort the list when this list is empty.
  107                 0.000103000     if !empty(l:linter_loclist)
                                          " Add the new items.
   14                 0.000024000         call extend(l:info.loclist, l:linter_loclist)
                                  
                                          " Sort the loclist again.
                                          " We need a sorted list so we can run a binary search against it
                                          " for efficient lookup of the messages in the cursor handler.
   14   0.000616000   0.000055000         call sort(l:info.loclist, 'ale#util#LocItemCompare')
  107                 0.000027000     endif
                                  
  107   0.005996000   0.000199000     if ale#ShouldDoNothing(a:buffer)
                                          return
  107                 0.000026000     endif
                                  
  107   0.082961000   0.000229000     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>33_HandleJobOutput()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/api.vim:64
Called 1264 times
Total time:   0.005010000
 Self time:   0.005010000

count     total (s)      self (s)
 1264                 0.000704000   if type(msg) == v:t_list
                                      for data in msg
                                        if data =~? '^data: {'
                                          add(curl_output, data)
                                        endif
                                      endfor
                                    else
 1264                 0.001772000     add(curl_output, msg)
 1264                 0.000118000   endif

FUNCTION  <SNR>114_FormatFilename()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:156
Called 131 times
Total time:   0.005284000
 Self time:   0.002809000

count     total (s)      self (s)
  131                 0.000373000     let l:filename = a:filename
                                  
  131                 0.000311000     if !empty(a:mappings)
                                          let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
  131                 0.000094000     endif
                                  
  131                 0.000277000     if !empty(a:modifiers)
                                          let l:filename = fnamemodify(l:filename, a:modifiers)
  131                 0.000088000     endif
                                  
  131   0.002977000   0.000502000     return ale#Escape(l:filename)

FUNCTION  250()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:319
Called 39 times
Total time:   0.000048000
 Self time:   0.000048000

count     total (s)      self (s)
   39                 0.000042000     return g:NERDTreeMinimalUI

FUNCTION  253()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:355
Called 11 times
Total time:   0.000835000
 Self time:   0.000555000

count     total (s)      self (s)
   11                 0.000046000     if !has_key(self, '_screenState')
                                          return
   11                 0.000005000     endif
   11   0.000353000   0.000091000     call nerdtree#exec('silent vertical resize ' . self._screenState['oldWindowSize'], 1)
                                  
   11                 0.000025000     let old_scrolloff=&scrolloff
   11   0.000055000   0.000046000     let &scrolloff=0
   11                 0.000054000     call cursor(self._screenState['oldTopLine'], 0)
   11                 0.000152000     normal! zt
   11                 0.000052000     call setpos('.', self._screenState['oldPos'])
   11   0.000054000   0.000045000     let &scrolloff=old_scrolloff

FUNCTION  254()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:372
Called 32 times
Total time:   0.011873000
 Self time:   0.001309000

count     total (s)      self (s)
   32                 0.000110000     let win = winnr()
   32                 0.000168000     let self._screenState = {}
   32                 0.000034000     try
   32   0.010141000   0.000113000         call g:NERDTree.CursorToTreeWin()
   32                 0.000182000         let self._screenState['oldPos'] = getpos('.')
   32                 0.000155000         let self._screenState['oldTopLine'] = line('w0')
   32                 0.000208000         let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
   32   0.000701000   0.000165000         call nerdtree#exec(win . 'wincmd w', 1)
                                      catch
   32                 0.000031000     endtry

FUNCTION  256()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:395
Called 163 times
Total time:   0.002913000
 Self time:   0.002913000

count     total (s)      self (s)
  163                 0.001716000     let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
  163                 0.001060000     return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')

FUNCTION  257()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:401
Called 13 times
Total time:   0.078761000
 Self time:   0.001757000

count     total (s)      self (s)
   13   0.000132000   0.000114000     setlocal noreadonly modifiable
                                  
                                      " remember the top line of the buffer and the current line so we can
                                      " restore the view exactly how it was
   13                 0.000030000     let curLine = line('.')
   13                 0.000033000     let curCol = col('.')
   13                 0.000020000     let topLine = line('w0')
                                  
                                      " delete all lines in the buffer (being careful not to clobber a register)
   13                 0.000255000     silent 1,$delete _
                                  
   13   0.001714000   0.000036000     call self._dumpHelp()
                                  
                                      " delete the blank line before the help and add one after it
   13   0.000034000   0.000018000     if !self.isMinimal()
   13                 0.000084000         call setline(line('.')+1, '')
   13                 0.000045000         call cursor(line('.')+1, col('.'))
   13                 0.000008000     endif
                                  
   13   0.000044000   0.000027000     if self.getShowBookmarks()
                                          call self._renderBookmarks()
   13                 0.000006000     endif
                                  
                                      " add the 'up a dir' line
   13   0.000032000   0.000020000     if !self.isMinimal()
   13   0.000086000   0.000072000         call setline(line('.')+1, s:UI.UpDirLine())
   13                 0.000031000         call cursor(line('.')+1, col('.'))
   13                 0.000006000     endif
                                  
                                      " draw the header line
   13   0.002900000   0.000098000     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   13                 0.000058000     call setline(line('.')+1, header)
   13                 0.000034000     call cursor(line('.')+1, col('.'))
                                  
                                      " draw the tree
   13   0.072605000   0.000186000     silent put =self.nerdtree.root.renderToString()
                                  
                                      " delete the blank line at the top of the buffer
   13                 0.000050000     silent 1,1delete _
                                  
                                      " restore the view
   13                 0.000026000     let old_scrolloff=&scrolloff
   13   0.000079000   0.000067000     let &scrolloff=0
   13                 0.000028000     call cursor(topLine, 1)
   13                 0.000134000     normal! zt
   13                 0.000025000     call cursor(curLine, curCol)
   13   0.000045000   0.000039000     let &scrolloff = old_scrolloff
                                  
   13   0.000054000   0.000044000     setlocal readonly nomodifiable

FUNCTION  <SNR>116_VimCloseCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:88
Called 131 times
Total time:   0.133954000
 Self time:   0.005046000

count     total (s)      self (s)
  131                 0.000923000     let l:job = ch_getjob(a:channel)
  131   0.001832000   0.000726000     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
  131                 0.000505000     let l:info = get(s:job_map, l:job_id, {})
                                  
  131                 0.000199000     if empty(l:info)
    1                 0.000000000         return
  130                 0.000053000     endif
                                  
                                      " job_status() can trigger the exit handler.
                                      " The channel can close before the job has exited.
  130   0.127929000   0.000751000     if job_status(l:job) is# 'dead'
  130                 0.000053000         try
  130                 0.000204000             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                                  " We have to remove the callback, so we don't call it twice.
   24   0.000847000   0.000223000                 call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
  130                 0.000047000             endif
  130                 0.000050000         finally
                                              " Automatically forget about the job after it's done.
  130                 0.000139000             if has_key(s:job_map, l:job_id)
   24                 0.000031000                 call remove(s:job_map, l:job_id)
  130                 0.000039000             endif
  130                 0.000033000         endtry
  130                 0.000043000     endif

FUNCTION  ale#engine#Cleanup()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:737
Called 27 times
Total time:   0.000582000
 Self time:   0.000582000

count     total (s)      self (s)
                                      " Don't bother with cleanup code when newer NeoVim versions are exiting.
   27                 0.000141000     if get(v:, 'exiting', v:null) isnot v:null
                                          return
   27                 0.000019000     endif
                                  
   27                 0.000091000     if exists('*ale#lsp#CloseDocument')
                                          call ale#lsp#CloseDocument(a:buffer)
   27                 0.000018000     endif
                                  
   27                 0.000110000     if !has_key(g:ale_buffer_info, a:buffer)
   27                 0.000020000         return
                                      endif
                                  
                                      call ale#engine#RunLinters(a:buffer, [], 1)
                                  
                                      call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>125_UpdateLineNumbers()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:282
Called 143 times
Total time:   0.003103000
 Self time:   0.003103000

count     total (s)      self (s)
  143                 0.000200000     let l:line_map = {}
  143                 0.000178000     let l:line_numbers_changed = 0
                                  
  154                 0.000225000     for [l:line, l:sign_id, l:name] in a:current_sign_list
   11                 0.000015000         let l:line_map[l:sign_id] = l:line
  154                 0.000077000     endfor
                                  
  181                 0.000155000     for l:item in a:loclist
   38                 0.000028000         if l:item.bufnr == a:buffer
   38                 0.000064000             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                                  
   38                 0.000031000             if l:lnum && l:item.lnum != l:lnum
                                                  let l:item.lnum = l:lnum
                                                  let l:line_numbers_changed = 1
   38                 0.000011000             endif
   38                 0.000006000         endif
  181                 0.000116000     endfor
                                  
                                      " When the line numbers change, sort the list again
  143                 0.000148000     if l:line_numbers_changed
                                          call sort(a:loclist, 'ale#util#LocItemCompare')
  143                 0.000058000     endif

FUNCTION  <SNR>126_WinFindBuf()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:96
Called 143 times
Total time:   0.000832000
 Self time:   0.000832000

count     total (s)      self (s)
  143                 0.000783000     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  gitgutter#utility#supports_overscore_sign()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:1
Called 1 time
Total time:   0.000009000
 Self time:   0.000005000

count     total (s)      self (s)
    1   0.000006000   0.000002000   if gitgutter#utility#windows()
                                      return &encoding ==? 'utf-8'
    1                 0.000000000   else
    1                 0.000002000     return &termencoding ==? &encoding || &termencoding == ''
                                    endif

FUNCTION  <SNR>68_initCustomOpenArgs()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:113
Called 12 times
Total time:   0.000613000
 Self time:   0.000550000

count     total (s)      self (s)
   12   0.000222000   0.000159000     let l:defaultOpenArgs = {'file': {'reuse': 'all', 'where': 'p', 'keepopen':!nerdtree#closeTreeOnOpen()}, 'dir': {}}
   12                 0.000014000     try
   12                 0.000077000         let g:NERDTreeCustomOpenArgs = get(g:, 'NERDTreeCustomOpenArgs', {})
   12                 0.000088000         call  extend(g:NERDTreeCustomOpenArgs, l:defaultOpenArgs, 'keep')
                                      catch /^Vim(\a\+):E712:/
                                          call nerdtree#echoWarning('g:NERDTreeCustomOpenArgs is not set properly. Using default value.')
                                          let g:NERDTreeCustomOpenArgs = l:defaultOpenArgs
   12                 0.000035000     finally
   12                 0.000024000         return g:NERDTreeCustomOpenArgs
                                      endtry

FUNCTION  <SNR>167_log()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2033
Called 4 times
Total time:   0.000127000
 Self time:   0.000127000

count     total (s)      self (s)
    4                 0.000031000 	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                                  		let cadir = ctrlp#utils#cachedir()
                                  		let apd = g:ctrlp_log > 1 ? '>' : ''
                                  		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                                  	el
                                  		sil! redi END
    4                 0.000008000 	en | en

FUNCTION  ale#Set()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:204
Called 15 times
Total time:   0.000104000
 Self time:   0.000104000

count     total (s)      self (s)
   15                 0.000031000     let l:full_name = 'ale_' . a:variable_name
                                  
   15                 0.000027000     if !has_key(g:, l:full_name)
   15                 0.000029000         let g:[l:full_name] = a:default
   15                 0.000004000     endif

FUNCTION  ale#history#Get()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:8
Called 214 times
Total time:   0.001015000
 Self time:   0.001015000

count     total (s)      self (s)
  214                 0.000955000     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>167_PrtExit()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:831
Called 2 times
Total time:   0.020356000
 Self time:   0.000193000

count     total (s)      self (s)
    2                 0.000046000 	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
    2   0.020199000   0.000036000 		noa cal s:Close()
    2                 0.000101000 		noa winc p
    2                 0.000003000 	en

FUNCTION  <SNR>120_on_exit_vim()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:87
Called 101 times
Total time:   0.164279000
 Self time:   0.004848000

count     total (s)      self (s)
  101                 0.000880000   let job = ch_getjob(a:channel)
  101   0.001891000   0.000581000   let jobid = s:job_id(job)
  101                 0.000705000   if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
  101                 0.000251000   while 1
  101                 0.000259000     if job_status(job) == 'dead'
  101                 0.000343000       let exit_code = job_info(job).exitval
  101                 0.000067000       break
                                      endif
                                      sleep 5m
  101                 0.000084000   endwhile
                                  
  101                 0.000087000   if !exit_code
  101   0.158954000   0.000833000     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
  101                 0.000041000   endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 310 times
Total time:   0.102232000
 Self time:   0.007669000

count     total (s)      self (s)
  310   0.101467000   0.006904000   return gitgutter#utility#getbufvar(a:bufnr, 'enabled') && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  267()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim:554
Called 25 times
Total time:   0.000061000
 Self time:   0.000061000

count     total (s)      self (s)
   25                 0.000042000     return '.. (up a dir)'

FUNCTION  268()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/event.vim:6
Called 108 times
Total time:   0.001129000
 Self time:   0.001129000

count     total (s)      self (s)
  108                 0.000307000     let newObj = copy(self)
  108                 0.000154000     let newObj.nerdtree = a:nerdtree
  108                 0.000155000     let newObj.subject = a:subject
  108                 0.000160000     let newObj.action = a:action
  108                 0.000149000     let newObj.params = a:params
  108                 0.000085000     return newObj

FUNCTION  <SNR>124_highlight_name_for_change()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 346 times
Total time:   0.002164000
 Self time:   0.002164000

count     total (s)      self (s)
  346                 0.000403000   if a:text ==# 'added'
   33                 0.000024000     return 'GitGutterLineAdded'
  313                 0.000259000   elseif a:text ==# 'removed'
                                      return 'GitGutterLineRemoved'
  313                 0.000275000   elseif a:text ==# 'removed_first_line'
                                      return 'GitGutterLineRemovedFirstLine'
  313                 0.000247000   elseif a:text ==# 'modified'
  313                 0.000221000     return 'GitGutterLineModified'
                                    elseif a:text ==# 'modified_removed'
                                      return 'GitGutterLineModifiedRemoved'
                                    elseif a:text ==# 'removed_above_and_below'
                                      return 'GitGutterLineRemovedAboveAndBelow'
                                    endif

FUNCTION  vader#assert#stat()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/assert.vim:41
Called 5 times
Total time:   0.000014000
 Self time:   0.000014000

count     total (s)      self (s)
    5                 0.000012000   return s:assertions

FUNCTION  AddTabularPipeline()
    Defined: ~/.vim/bundle/tabular/plugin/Tabular.vim:226
Called 4 times
Total time:   0.000712000
 Self time:   0.000157000

count     total (s)      self (s)
    4                 0.000002000   try
    4   0.000043000   0.000009000     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                                  
    4                 0.000015000     let name = matchstr(rest, '.\{-}\ze\s*/')
    4                 0.000019000     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                                  
    4                 0.000042000     let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')
    4                 0.000016000     let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')
                                  
    4                 0.000005000     if empty(name) || empty(pattern)
                                        throw "Invalid arguments!"
    4                 0.000002000     endif
                                  
    4                 0.000004000     if !a:force && has_key(commandmap, name)
                                        throw string(name) . " is already defined, use ! to overwrite."
    4                 0.000001000     endif
                                  
    4   0.000530000   0.000009000     let commandlist = s:SplitCommands(commands)
                                  
    4                 0.000003000     if empty(commandlist)
                                        throw "Must provide a list of functions!"
    4                 0.000001000     endif
                                  
    4                 0.000007000     let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }
                                    catch
                                      echohl ErrorMsg
                                      echomsg "AddTabularPipeline: " . v:exception
                                      echohl None
    4                 0.000001000   endtry

FUNCTION  <SNR>167_settype()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2090
Called 2 times
Total time:   0.000009000
 Self time:   0.000009000

count     total (s)      self (s)
    2                 0.000008000 	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type

FUNCTION  <SNR>167_lastvisual()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2021
Called 2 times
Total time:   0.000286000
 Self time:   0.000240000

count     total (s)      self (s)
    2                 0.000008000 	let cview = winsaveview()
    2                 0.000014000 	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
    2                 0.000008000 	let [oureg, outype] = [getreg('"'), getregtype('"')]
    2                 0.000131000 	sil! norm! gv"vy
    2   0.000067000   0.000021000 	let selected = s:regisfilter('v')
    2                 0.000013000 	cal setreg('v', ovreg, ovtype)
    2                 0.000006000 	cal setreg('"', oureg, outype)
    2                 0.000030000 	cal winrestview(cview)
    2                 0.000002000 	retu selected

FUNCTION  vader#window#open()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:44
Called 5 times
Total time:   0.074185000
 Self time:   0.004502000

count     total (s)      self (s)
    5   0.002302000   0.001478000   execute 'silent! bd' s:console_bfr
    5                 0.000092000   execute 'silent! bd' s:workbench_bfr
    5                 0.000024000   if bufexists(s:quickfix_bfr)
    5                 0.000212000     execute "silent! bd ".s:quickfix_bfr
    5                 0.000005000   endif
                                  
    5                 0.000036000   let s:prev_winid = exists('*win_getid') ? win_getid() : 0
    5   0.013208000   0.000876000   tabnew
    5   0.000113000   0.000097000   setlocal buftype=nofile noswapfile nospell
    5   0.042634000   0.000024000   setf vader-result
    5   0.002923000   0.000675000   silent f \[Vader\]
    5                 0.000017000   let s:console_tab = tabpagenr()
    5                 0.000009000   let s:console_bfr = bufnr('')
    5                 0.000011000   let s:console_buffered = []
    5                 0.000008000   let b:vader_data = {}
    5                 0.000036000   nnoremap <silent> <buffer> <CR> :call <SID>action(line('.'))<CR>
                                  
    5   0.010264000   0.000403000   tabnew
    5   0.000025000   0.000022000   setlocal buftype=nofile
    5   0.000018000   0.000015000   setlocal noswapfile
    5   0.002191000   0.000405000   silent f \[Vader-workbench\]
    5                 0.000014000   let s:workbench_tab = tabpagenr()
    5                 0.000009000   let s:workbench_bfr = bufnr('')

FUNCTION  <SNR>167_PrtAdd()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:637
Called 53 times
Total time:   0.588687000
 Self time:   0.000623000

count     total (s)      self (s)
   53                 0.000039000 	unl! s:hstgot
   53                 0.000079000 	let s:act_add = 1
   53                 0.000106000 	let s:prompt[0] .= a:char
   53   0.588393000   0.000329000 	cal s:BuildPrompt(1)
   53                 0.000038000 	unl s:act_add

FUNCTION  ale#linter#PreProcess()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:92
Called 8 times
Total time:   0.001105000
 Self time:   0.001043000

count     total (s)      self (s)
    8                 0.000016000     if type(a:linter) isnot v:t_dict
                                          throw 'The linter object must be a Dictionary'
    8                 0.000002000     endif
                                  
    8                 0.000028000     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                                  
    8                 0.000013000     if type(l:obj.name) isnot v:t_string
                                          throw '`name` must be defined to name the linter'
    8                 0.000004000     endif
                                  
    8                 0.000013000     let l:needs_address = l:obj.lsp is# 'socket'
    8                 0.000011000     let l:needs_executable = l:obj.lsp isnot# 'socket'
    8                 0.000010000     let l:needs_command = l:obj.lsp isnot# 'socket'
    8                 0.000015000     let l:needs_lsp_details = !empty(l:obj.lsp)
                                  
    8                 0.000010000     if empty(l:obj.lsp)
    7                 0.000015000         let l:obj.callback = get(a:linter, 'callback')
                                  
    7   0.000042000   0.000019000         if !s:IsCallback(l:obj.callback)
                                              throw '`callback` must be defined with a callback to accept output'
    7                 0.000002000         endif
    8                 0.000003000     endif
                                  
    8                 0.000020000     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                          throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
    8                 0.000003000     endif
                                  
    8                 0.000008000     if !l:needs_executable
                                          if has_key(a:linter, 'executable')
                                              throw '`executable` cannot be used when lsp == ''socket'''
                                          endif
    8                 0.000012000     elseif has_key(a:linter, 'executable')
    8                 0.000012000         let l:obj.executable = a:linter.executable
                                  
    8                 0.000020000         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                              throw '`executable` must be a String or Function if defined'
    8                 0.000004000         endif
                                      else
                                          throw '`executable` must be defined'
    8                 0.000004000     endif
                                  
    8                 0.000007000     if !l:needs_command
                                          if has_key(a:linter, 'command')
                                              throw '`command` cannot be used when lsp == ''socket'''
                                          endif
    8                 0.000010000     elseif has_key(a:linter, 'command')
    8                 0.000012000         let l:obj.command = a:linter.command
                                  
    8                 0.000019000         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                              throw '`command` must be a String or Function if defined'
    8                 0.000005000         endif
                                      else
                                          throw '`command` must be defined'
    8                 0.000004000     endif
                                  
    8                 0.000005000     if !l:needs_address
    8                 0.000007000         if has_key(a:linter, 'address')
                                              throw '`address` cannot be used when lsp != ''socket'''
    8                 0.000003000         endif
                                      elseif has_key(a:linter, 'address')
                                          if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                              throw '`address` must be a String or Function if defined'
                                          endif
                                  
                                          let l:obj.address = a:linter.address
                                  
                                          if has_key(a:linter, 'cwd')
                                              throw '`cwd` makes no sense for socket LSP connections'
                                          endif
                                      else
                                          throw '`address` must be defined for getting the LSP address'
    8                 0.000004000     endif
                                  
    8                 0.000010000     if has_key(a:linter, 'cwd')
    1                 0.000001000         let l:obj.cwd = a:linter.cwd
                                  
    1                 0.000002000         if type(l:obj.cwd) isnot v:t_string&& type(l:obj.cwd) isnot v:t_func
                                              throw '`cwd` must be a String or Function if defined'
    1                 0.000000000         endif
    8                 0.000002000     endif
                                  
    8                 0.000007000     if l:needs_lsp_details
                                          " Default to using the filetype as the language.
    1                 0.000002000         let l:obj.language = get(a:linter, 'language', a:filetype)
                                  
    1                 0.000001000         if type(l:obj.language) isnot v:t_string&& type(l:obj.language) isnot v:t_func
                                              throw '`language` must be a String or Function if defined'
    1                 0.000000000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'project_root')
    1                 0.000001000             let l:obj.project_root = a:linter.project_root
                                  
    1                 0.000001000             if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                                  throw '`project_root` must be a String or Function'
    1                 0.000000000             endif
                                          else
                                              throw '`project_root` must be defined for LSP linters'
    1                 0.000000000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'completion_filter')
                                              let l:obj.completion_filter = a:linter.completion_filter
                                  
                                              if !s:IsCallback(l:obj.completion_filter)
                                                  throw '`completion_filter` must be a callback'
                                              endif
    1                 0.000001000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'initialization_options')
                                              let l:obj.initialization_options = a:linter.initialization_options
                                  
                                              if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                                  throw '`initialization_options` must be a Dictionary or Function if defined'
                                              endif
    1                 0.000001000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'lsp_config')
    1                 0.000001000             if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                                  throw '`lsp_config` must be a Dictionary or Function if defined'
    1                 0.000000000             endif
                                  
    1                 0.000001000             let l:obj.lsp_config = a:linter.lsp_config
    1                 0.000001000         endif
    8                 0.000003000     endif
                                  
    8                 0.000019000     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                                  
    8                 0.000025000     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                          throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
    8                 0.000002000     endif
                                  
                                      " An option indicating that this linter should only be run against the
                                      " file on disk.
    8                 0.000016000     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                                  
    8   0.000043000   0.000023000     if !s:IsBoolean(l:obj.lint_file) && type(l:obj.lint_file) isnot v:t_func
                                          throw '`lint_file` must be `0`, `1`, or a Function'
    8                 0.000004000     endif
                                  
                                      " An option indicating that the buffer should be read.
    8                 0.000017000     let l:obj.read_buffer = get(a:linter, 'read_buffer', 1)
                                  
    8   0.000033000   0.000014000     if !s:IsBoolean(l:obj.read_buffer)
                                          throw '`read_buffer` must be `0` or `1`'
    8                 0.000002000     endif
                                  
    8                 0.000013000     let l:obj.aliases = get(a:linter, 'aliases', [])
                                  
    8                 0.000042000     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                          throw '`aliases` must be a List of String values'
    8                 0.000002000     endif
                                  
    8                 0.000004000     return l:obj

FUNCTION  <SNR>101_PrevCodeLine()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:918
Called 5 times
Total time:   0.000104000
 Self time:   0.000104000

count     total (s)      self (s)
    5                 0.000004000     var line: string = getline(lnum)
    5                 0.000030000     if line =~ '^\s*[A-Z]\+$'
                                          var endmarker: string = line->matchstr('[A-Z]\+')
                                          var pos: list<number> = getcurpos()
                                          cursor(lnum, 1)
                                          var n: number = search(ASSIGNS_HEREDOC, 'bnW')
                                          setpos('.', pos)
                                          if n > 0
                                              line = getline(n)
                                              if line =~ $'{HEREDOC_OPERATOR}\s\+{endmarker}'
                                                  return {lnum: n, text: line}
                                              endif
                                          endif
                                      endif
                                  
    5                 0.000024000     var n: number = prevnonblank(lnum - 1)
    5                 0.000002000     line = getline(n)
    5                 0.000025000     while line =~ COMMENT && n > 1
                                          n = prevnonblank(n - 1)
                                          line = getline(n)
                                      endwhile
                                      # If we get back to the first line, we return 1 no matter what; even if it's a
                                      # commented line.   That should not  cause an issue  though.  We just  want to
                                      # avoid a  commented line above which  there is a  line of code which  is more
                                      # relevant.  There is nothing above the first line.
                                      return {lnum: n, text: line}

FUNCTION  <SNR>126_CloseWindowIfNeeded()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:242
Called 143 times
Total time:   0.003709000
 Self time:   0.000821000

count     total (s)      self (s)
  143   0.003508000   0.000620000     if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
  143                 0.000083000         return
                                      endif
                                  
                                      let l:did_close_any_list = 0
                                  
                                      try
                                          " Only close windows if the quickfix list or loclist is completely empty,
                                          " including errors set through other means.
                                          if g:ale_set_quickfix
                                              if empty(getqflist())
                                                  cclose
                                                  let l:did_close_any_list = 1
                                              endif
                                          else
                                              let l:win_ids = s:WinFindBuf(a:buffer)
                                  
                                              for l:win_id in l:win_ids
                                                  if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                      lclose
                                                      let l:did_close_any_list = 1
                                                  endif
                                              endfor
                                          endif
                                      " Ignore 'Cannot close last window' errors.
                                      catch /E444/
                                      endtry
                                  
                                      if l:did_close_any_list
                                          call s:RestoreViewIfNeeded(a:buffer)
                                      endif

FUNCTION  <SNR>167_execextvar()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2184
Called 6 times
Total time:   0.000087000
 Self time:   0.000087000

count     total (s)      self (s)
    6                 0.000035000 	if !empty(g:ctrlp_ext_vars)
                                  		cal map(filter(copy(g:ctrlp_ext_vars), 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
    6                 0.000007000 	en

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:284
Called 238 times
Total time:   0.008565000
 Self time:   0.005007000

count     total (s)      self (s)
  238   0.004828000   0.001270000     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                                  
  238                 0.000559000     if type(l:linter_mappings) is v:t_list
                                          return l:linter_mappings
  238                 0.000134000     endif
                                  
  238                 0.000322000     let l:name = a:name
                                  
  238                 0.000573000     if !has_key(l:linter_mappings, l:name)
                                          " Use * as a default setting for all tools.
  238                 0.000289000         let l:name = '*'
  238                 0.000125000     endif
                                  
  238                 0.000551000     return get(l:linter_mappings, l:name, [])

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:209
Called 93 times
Total time:   0.009048000
 Self time:   0.003460000

count     total (s)      self (s)
   93                 0.000190000   let hunks = []
  304                 0.001210000   for line in split(a:diff, '\n')
  211   0.006255000   0.000667000     let hunk_info = gitgutter#diff#parse_hunk(line)
  211                 0.000247000     if len(hunk_info) == 4
  211                 0.000309000       call add(hunks, hunk_info)
  211                 0.000094000     endif
  304                 0.000136000   endfor
   93                 0.000070000   return hunks

FUNCTION  <SNR>167_strwidth()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1965
Called 20 times
Total time:   0.000095000
 Self time:   0.000095000

count     total (s)      self (s)
   20                 0.000090000 	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)

FUNCTION  <SNR>126_SetListsImpl()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:100
Called 143 times
Total time:   0.039710000
 Self time:   0.023304000

count     total (s)      self (s)
  143                 0.008179000     let l:title = expand('#' . a:buffer . ':p')
                                  
  143                 0.000179000     if g:ale_set_quickfix
                                          let l:quickfix_list = ale#list#GetCombinedList()
                                  
                                          if has('nvim')
                                              call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                          else
                                              call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                              call setqflist([], 'r', {'title': l:title})
                                          endif
  143                 0.000127000     elseif g:ale_set_loclist
                                          " If windows support is off, win_findbuf() may not exist.
                                          " We'll set result in the current window, which might not be correct,
                                          " but it's better than nothing.
  143   0.001321000   0.000489000         let l:ids = s:WinFindBuf(a:buffer)
                                  
  143   0.002714000   0.000434000         let l:loclist = s:Deduplicate(a:loclist)
                                  
  318                 0.000332000         for l:id in l:ids
  175                 0.000497000             if has('nvim')
                                                  call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
  175                 0.000096000             else
  175   0.007915000   0.001461000                 call setloclist(l:id, s:FixList(a:buffer, l:loclist))
  175                 0.000808000                 call setloclist(l:id, [], 'r', {'title': l:title})
  175                 0.000105000             endif
  318                 0.000181000         endfor
  143                 0.000064000     endif
                                  
                                      " Save the current view before opening/closing any window
  143                 0.000837000     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                                  
                                      " Open a window to show the problems if we need to.
                                      "
                                      " ShouldOpen() checks if the current buffer has enough problems to be
                                      " opened.
  143   0.002604000   0.000522000     if s:ShouldOpen(a:buffer, len(a:loclist))
                                          let l:winnr = winnr()
                                          let l:mode = mode()
                                  
                                          " open windows vertically instead of default horizontally
                                          let l:open_type = ''
                                  
                                          if ale#Var(a:buffer, 'list_vertical') == 1
                                              let l:open_type = 'vert rightbelow '
                                          endif
                                  
                                          if g:ale_set_quickfix
                                              if !ale#list#IsQuickfixOpen()
                                                  silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                              endif
                                          elseif g:ale_set_loclist
                                              silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                          endif
                                  
                                          " If focus changed, restore it (jump to the last window).
                                          if l:winnr isnot# winnr()
                                              wincmd p
                                          endif
                                  
                                          " Return to original mode when applicable
                                          if mode() != l:mode
                                              if l:mode is? 'v' || l:mode is# "\<c-v>"
                                                  " Reset our last visual selection
                                                  normal! gv
                                              elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                                  " Reset our last character selection
                                                  normal! "\<c-g>"
                                              endif
                                          endif
                                  
                                          call s:RestoreViewIfNeeded(a:buffer)
  143                 0.000071000     endif
                                  
                                      " If ALE isn't currently checking for more problems, close the window if
                                      " needed now. This check happens inside of this timer function, so
                                      " the window can be closed reliably.
  143   0.001356000   0.000307000     if !ale#engine#IsCheckingBuffer(a:buffer)
  143   0.004106000   0.000397000         call s:CloseWindowIfNeeded(a:buffer)
  143                 0.000061000     endif

FUNCTION  270()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim:14
Called 108 times
Total time:   0.004037000
 Self time:   0.001642000

count     total (s)      self (s)
  108   0.001624000   0.000495000     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                                  
  108   0.001654000   0.000388000     for Listener in s:Notifier.GetListenersForEvent(a:event)
                                          let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
                                          call l:Callback(event)
  108                 0.000084000     endfor

FUNCTION  271()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim:23
Called 108 times
Total time:   0.000641000
 Self time:   0.000641000

count     total (s)      self (s)
  108                 0.000285000     if !exists('s:refreshListenersMap')
    1                 0.000002000         let s:refreshListenersMap = {}
  108                 0.000055000     endif
  108                 0.000128000     return s:refreshListenersMap

FUNCTION  272()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim:30
Called 108 times
Total time:   0.001266000
 Self time:   0.000625000

count     total (s)      self (s)
  108   0.000972000   0.000331000     let listenersMap = s:Notifier.GetListenersMap()
  108                 0.000257000     return get(listenersMap, a:name, [])

FUNCTION  273()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:120
Called 8 times
Total time:   0.107124000
 Self time:   0.000572000

count     total (s)      self (s)
    8   0.000125000   0.000033000   let listing = s:strip_trailing_new_line(a:listing)
    8                 0.000025000   let [status, path] = [listing[0], listing[2:]]
    8                 0.000030000   if status =~# '[a-z]'
                                      call gitgutter#utility#setbufvar(a:buffer, 'path', -3)
    8                 0.000003000   else
    8   0.000109000   0.000024000     call gitgutter#utility#setbufvar(a:buffer, 'path', path)
    8                 0.000003000   endif
                                  
    8                 0.000027000   if type(self.continuation) == type(function('tr'))
    8   0.106643000   0.000268000     call self.continuation()
                                    else
                                      call call(self.continuation.function, self.continuation.arguments)
    8                 0.000001000   endif

FUNCTION  <SNR>101_IsRightBelow()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1069
Called 6 times
Total time:   0.000013000
 Self time:   0.000013000

count     total (s)      self (s)
                                      return exists('b:vimindent')
                                          && b:vimindent->has_key($'is_{syntax}')
                                          && lnum > b:vimindent.endlnum

FUNCTION  <SNR>167_multipliers()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1358
Called 58 times
Total time:   0.000694000
 Self time:   0.000694000

count     total (s)      self (s)
   58                 0.000086000 	let mp0 = !a:1 ? 0 : 2
   58                 0.000206000 	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
   58                 0.000146000 	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
   58                 0.000135000 	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
   58                 0.000092000 	retu [mp0, mp1, mp2, mp3]

FUNCTION  <SNR>143_GetDeviceToken()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/auth.vim:85
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                    var token_url = 'https://github.com/login/device/code'
                                    var headers = [
                                      'Accept: application/json',
                                      'User-Agent: GithubCopilot/1.155.0',
                                      'Accept-Encoding: gzip, deflate, br',
                                      'Editor-Plugin-Version: copilot.vim/1.16.0',
                                      'Editor-Version: Neovim/0.6.1',
                                      'Content-Type: application/json',
                                    ]
                                    var data = {
                                      'client_id': 'Iv1.b507a08c87ecfe98',
                                      'scope': 'read: user'
                                    }
                                  
                                    return api.Http('POST', token_url, headers, data)

FUNCTION  <SNR>122_process_modified()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:314
Called 202 times
Total time:   0.002961000
 Self time:   0.002961000

count     total (s)      self (s)
  202                 0.000227000   let offset = 0
  515                 0.000467000   while offset < a:to_count
  313                 0.000388000     let line_number = a:to_line + offset
  313                 0.000581000     call add(a:modifications, [line_number, 'modified'])
  313                 0.000277000     let offset += 1
  515                 0.000238000   endwhile

FUNCTION  ale#virtualtext#ShowMessage()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:157
Called 36 times
Total time:   0.004298000
 Self time:   0.001650000

count     total (s)      self (s)
   36                 0.000075000     if !s:has_virt_text || !bufexists(str2nr(a:buffer))
                                          return
   36                 0.000011000     endif
                                  
   36                 0.000057000     let l:line = max([1, a:item.lnum])
   36   0.000277000   0.000064000     let l:hl_group = ale#virtualtext#GetGroup(a:item)
                                  
                                      " Get a language-appropriate comment character, or default to '#'.
   36   0.000337000   0.000073000     let l:comment = ale#virtualtext#GetComment(a:buffer)
   36   0.000231000   0.000059000     let l:prefix = ale#Var(a:buffer, 'virtualtext_prefix')
   36   0.001129000   0.000077000     let l:prefix = ale#GetLocItemMessage(a:item, l:prefix)
   36                 0.000093000     let l:prefix = substitute(l:prefix, '\V%comment%', '\=l:comment', 'g')
   36                 0.000070000     let l:msg = l:prefix . substitute(a:item.text, '\n', ' ', 'g')
   36   0.001022000   0.000075000     let l:col_pad = ale#virtualtext#GetColumnPadding(a:buffer, l:line)
                                  
                                      " Store the last message we're going to set so we can read it in tests.
   36                 0.000041000     let s:last_message = l:msg
                                  
                                      " Discard virtualtext if padding is negative.
   36                 0.000027000     if l:col_pad < 0
                                          return
   36                 0.000008000     endif
                                  
   36                 0.000050000     if has('nvim')
                                          call nvim_buf_set_virtual_text(   a:buffer,   s:ns_id, l:line - 1,   [[l:msg, l:hl_group]],   {})
   36                 0.000019000     elseif s:emulate_virt
                                          let l:left_pad = col('$')
                                          call prop_add(l:line, l:left_pad, {'type': 'ale'})
                                          let s:last_virt = popup_create(l:msg, {   'line': -1,   'padding': [0, 0, 0, 1],   'mask': [[1, 1, 1, 1]],   'textprop': 'ale',   'highlight': l:hl_group,   'fixed': 1,   'wrap': 0,   'zindex': 2})
   36                 0.000010000     else
   36                 0.000054000         let l:type = prop_type_get(l:hl_group)
                                  
   36                 0.000027000         if l:type == {}
    1                 0.000005000             call prop_type_add(l:hl_group, {'highlight': l:hl_group})
   36                 0.000014000         endif
                                  
                                          " Add highlight groups to the list so we can clear them later.
   36                 0.000040000         if index(s:hl_list, l:hl_group) == -1
    1                 0.000001000             call add(s:hl_list, l:hl_group)
   36                 0.000007000         endif
                                  
                                          " We ignore all errors from prop_add.
   36                 0.000199000         silent! call prop_add(l:line, 0, {   'type': l:hl_group,   'text': ' ' . l:msg,   'bufnr': a:buffer,   'text_padding_left': l:col_pad,})
   36                 0.000008000     endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:423
Called 167 times
Total time:   0.019835000
 Self time:   0.002067000

count     total (s)      self (s)
  167                 0.000577000     let l:Executable = a:linter.executable
                                  
  167   0.018928000   0.001160000     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>167_byfname()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1913
Called 67 times
Total time:   0.000101000
 Self time:   0.000101000

count     total (s)      self (s)
   67                 0.000076000 	retu s:ispath && s:byfname

FUNCTION  <SNR>72_readCache()
    Defined: ~/.vim/bundle/semantic-highlight.vim/plugin/semhl.vim:48
Called 1 time
Total time:   0.000026000
 Self time:   0.000026000

count     total (s)      self (s)
    1                 0.000008000 	if !filereadable(g:semanticPersistCacheLocation)
                                  		return []
    1                 0.000001000 	endif
                                  
    1                 0.000001000 	let l:localCache = {}
    1                 0.000009000 	let s:cacheList = readfile(g:semanticPersistCacheLocation)
    1                 0.000001000 	for s:cacheListItem in s:cacheList
                                  		let s:cacheListItemList = eval(s:cacheListItem)
                                  		let l:localCache[s:cacheListItemList[0]] = s:cacheListItemList[1]
    1                 0.000001000 	endfor
                                  
    1                 0.000001000 	if exists("s:cacheListItem")
                                  		unlet s:cacheListItem s:cacheList
    1                 0.000000000 	endif
                                  
    1                 0.000000000 	return l:localCache

FUNCTION  <SNR>77_define_sign_linenr_highlights()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:187
Called 1 time
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    1                 0.000001000   if has('nvim-0.3.2')
                                      try
                                        if g:gitgutter_highlight_linenrs
                                          sign define GitGutterLineAdded                 numhl=GitGutterAddLineNr
                                          sign define GitGutterLineModified              numhl=GitGutterChangeLineNr
                                          sign define GitGutterLineRemoved               numhl=GitGutterDeleteLineNr
                                          sign define GitGutterLineRemovedFirstLine      numhl=GitGutterDeleteLineNr
                                          sign define GitGutterLineRemovedAboveAndBelow  numhl=GitGutterDeleteLineNr
                                          sign define GitGutterLineModifiedRemoved       numhl=GitGutterChangeDeleteLineNr
                                        else
                                          sign define GitGutterLineAdded                 numhl=NONE
                                          sign define GitGutterLineModified              numhl=NONE
                                          sign define GitGutterLineRemoved               numhl=NONE
                                          sign define GitGutterLineRemovedFirstLine      numhl=NONE
                                          sign define GitGutterLineRemovedAboveAndBelow  numhl=NONE
                                          sign define GitGutterLineModifiedRemoved       numhl=NONE
                                        endif
                                      catch /E475/
                                      endtry
    1                 0.000000000   endif

FUNCTION  <SNR>167_buffunc()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:2043
Called 4 times
Total time:   0.000081000
 Self time:   0.000081000

count     total (s)      self (s)
    4                 0.000015000 	if a:e && has_key(s:buffunc, 'enter')
                                  		cal call(s:buffunc['enter'], [], s:buffunc)
    4                 0.000022000 	elsei !a:e && has_key(s:buffunc, 'exit')
                                  		cal call(s:buffunc['exit'], [], s:buffunc)
    4                 0.000004000 	en

FUNCTION  <SNR>113_RunLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:673
Called 167 times
Total time:   0.816015000
 Self time:   0.018289000

count     total (s)      self (s)
  167   0.022483000   0.001743000     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
  167   0.006791000   0.001667000     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                                  
                                      " We can only clear the results if we aren't checking the buffer.
  167   0.003940000   0.001240000     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                                  
  167   0.001709000   0.001577000     silent doautocmd <nomodeline> User ALELintPre
                                  
  334                 0.000920000     for [l:lint_file, l:linter] in a:slots
                                          " Only run lint_file linters if we should.
  167                 0.000463000         if !l:lint_file || a:should_lint_file
  167   0.719055000   0.002318000             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                                  " If a single linter ran, we shouldn't clear everything.
  131                 0.000328000                 let l:can_clear_results = 0
  167                 0.000376000             endif
                                          else
                                              " If we skipped running a lint_file linter still in the list,
                                              " we shouldn't clear everything.
                                              let l:can_clear_results = 0
  167                 0.000108000         endif
  334                 0.000372000     endfor
                                  
                                      " Clear the results if we can. This needs to be done when linters are
                                      " disabled, or ALE itself is disabled.
  167                 0.000259000     if l:can_clear_results
   36   0.051196000   0.000291000         call ale#engine#SetResults(a:buffer, [])
  131                 0.000184000     elseif a:new_buffer
    7   0.001439000   0.000051000         call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
  167                 0.000104000     endif

FUNCTION  <SNR>167_compmatlen()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1270
Called 58 times
Total time:   0.001483000
 Self time:   0.000658000

count     total (s)      self (s)
                                  	" By match length
   58   0.000709000   0.000270000 	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
   58   0.000633000   0.000247000 	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
   58                 0.000098000 	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:175
Called 131 times
Total time:   0.012381000
 Self time:   0.010271000

count     total (s)      self (s)
  131   0.002800000   0.000690000     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                                  
                                      " The command will be executed in a subshell. This fixes a number of
                                      " issues, including reading the PATH variables correctly, %PATHEXT%
                                      " expansion on Windows, etc.
                                      "
                                      " NeoVim handles this issue automatically if the command is a String,
                                      " but we'll do this explicitly, so we use the same exact command for both
                                      " versions.
  131                 0.000846000     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                                  
                                      " If a custom shell is specified, use that.
  131                 0.000461000     if exists('b:ale_shell')
                                          let l:ale_shell = b:ale_shell
  131                 0.000421000     elseif exists('g:ale_shell')
                                          let l:ale_shell = g:ale_shell
  131                 0.000102000     endif
                                  
  131                 0.000283000     if exists('l:ale_shell')
                                          let l:shell_arguments = get(b:, 'ale_shell_arguments', get(g:, 'ale_shell_arguments', &shellcmdflag))
                                  
                                          return split(l:ale_shell) + split(l:shell_arguments) + [l:command]
  131                 0.000088000     endif
                                  
  131                 0.000313000     if has('win32')
                                          return 'cmd /s/c "' . l:command . '"'
  131                 0.000077000     endif
                                  
  131                 0.001345000     if &shell =~? 'fish$\|pwsh$'
                                          return ['/bin/sh', '-c', l:command]
  131                 0.000083000     endif
                                  
  131                 0.002365000     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  vader#window#append()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:96
Called 38 times
Total time:   0.001379000
 Self time:   0.001379000

count     total (s)      self (s)
   38                 0.000149000   let message = repeat('  ', a:indent) . a:message
   38                 0.000083000   if get(a:, 1, 1)
   38                 0.000440000     let message = substitute(message, '\s*$', '', '')
   38                 0.000024000   endif
   38                 0.000100000   if !exists('s:console_buffered')
                                      call vader#print_stderr(printf("Vader: got message before startup: %s\n", message))
                                      return 0
   38                 0.000019000   endif
   38                 0.000082000   if get(g:, 'vader_bang', 0)
                                      call vader#print_stderr(message."\n")
                                      return 0
   38                 0.000019000   endif
   38                 0.000097000   call add(s:console_buffered, message)
   38                 0.000071000   return len(s:console_buffered)

FUNCTION  <SNR>117_lash()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim:12
Called 9 times
Total time:   0.000067000
 Self time:   0.000067000

count     total (s)      self (s)
    9                 0.000062000 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:88
Called 346 times
Total time:   0.001745000
 Self time:   0.001745000

count     total (s)      self (s)
  346                 0.000667000     if type(a:string_or_ref) is v:t_string
  107                 0.000145000         return function(a:string_or_ref)
  239                 0.000131000     endif
                                  
  239                 0.000161000     return a:string_or_ref

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:301
Called 132 times
Total time:   0.003952000
 Self time:   0.003952000

count     total (s)      self (s)
  132                 0.000327000     let l:clear_tempdir = 0
                                  
  132                 0.000646000     if exists('$TMPDIR') && empty($TMPDIR)
                                          let l:clear_tempdir = 1
                                          let $TMPDIR = '/tmp'
  132                 0.000087000     endif
                                  
  132                 0.000117000     try
  132                 0.000773000         let l:name = tempname() " no-custom-checks
  132                 0.000303000     finally
  132                 0.000204000         if l:clear_tempdir
                                              let $TMPDIR = ''
  132                 0.000095000         endif
  132                 0.000186000     endtry
                                  
  132                 0.000183000     return l:name

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:589
Called 36 times
Total time:   0.065325000
 Self time:   0.000892000

count     total (s)      self (s)
   36   0.065265000   0.000832000     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  ale#virtualtext#GetComment()
    Defined: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim:76
Called 36 times
Total time:   0.000264000
 Self time:   0.000264000

count     total (s)      self (s)
   36                 0.000070000     let l:filetype = getbufvar(a:buffer, '&filetype')
   36                 0.000100000     let l:split = split(getbufvar(a:buffer, '&commentstring'), '%s')
                                  
   36                 0.000068000     return !empty(l:split) ? trim(l:split[0]) : '#'

FUNCTION  <SNR>101_EndsWithCurlyBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1152
Called 4 times
Total time:   0.000311000
 Self time:   0.000001000

count     total (s)      self (s)
                                      return NonCommentedMatch(line_B, STARTS_CURLY_BLOCK)

FUNCTION  vader#window#copen()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:135
Called 4 times
Total time:   0.027711000
 Self time:   0.000580000

count     total (s)      self (s)
    4   0.021454000   0.000413000   copen
    4                 0.000009000   let s:quickfix_bfr = bufnr('')
    4   0.003133000   0.000017000   1wincmd w
    4                 0.000083000   normal! Gzb
    4   0.002988000   0.000014000   2wincmd w
    4                 0.000019000   nnoremap <silent> <buffer> q :call <SID>quit()<CR><CR>
    4                 0.000013000   nnoremap <silent> <buffer> <CR> :call <SID>move()<CR><CR>

FUNCTION  <SNR>158_comment()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader.vim:296
Called 5 times
Total time:   0.000023000
 Self time:   0.000023000

count     total (s)      self (s)
    5                 0.000017000   return get(a:case.comment, a:label, '')

FUNCTION  <SNR>101_ContinuesBelowBracketBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1045
Called 3 times
Total time:   0.000004000
 Self time:   0.000004000

count     total (s)      self (s)
                                  
                                      return !block->empty()
                                          && (line_A =~ LINE_CONTINUATION_AT_SOL
                                          || line_B->EndsWithLineContinuation())

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim:410
Called 12 times
Total time:   0.515812000
 Self time:   0.000308000

count     total (s)      self (s)
   12   0.515755000   0.000251000     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>113_GetLintFileValues()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:642
Called 167 times
Total time:   0.838600000
 Self time:   0.017574000

count     total (s)      self (s)
  167                 0.000523000     let l:deferred_list = []
  167                 0.000349000     let l:new_slots = []
                                  
  334                 0.000877000     for [l:lint_file, l:linter] in a:slots
  167   0.003251000   0.001607000         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                              " If we've already computed the return value, use it.
                                              let l:lint_file = l:lint_file.value
  167                 0.000198000         endwhile
                                  
  167   0.001466000   0.000654000         if ale#command#IsDeferred(l:lint_file)
                                              " If we are going to return the result later, wait for it.
                                              call add(l:deferred_list, l:lint_file)
  167                 0.000173000         else
                                              " If we have the value now, coerce it to 0 or 1.
  167                 0.000458000             let l:lint_file = l:lint_file is 1
  167                 0.000144000         endif
                                  
  167                 0.000734000         call add(l:new_slots, [l:lint_file, l:linter])
  334                 0.000408000     endfor
                                  
  167                 0.000542000     if !empty(l:deferred_list)
                                          for l:deferred in l:deferred_list
                                              let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                          endfor
  167                 0.000151000     else
  167   0.821192000   0.002622000         call a:Callback(l:new_slots)
  167                 0.000123000     endif

FUNCTION  <SNR>114_ExitCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:285
Called 131 times
Total time:   0.123427000
 Self time:   0.004556000

count     total (s)      self (s)
  131                 0.000386000     if !has_key(s:buffer_data, a:buffer)
                                          return
  131                 0.000039000     endif
                                  
  131                 0.000244000     let l:jobs = s:buffer_data[a:buffer].jobs
                                  
  131                 0.000173000     if !has_key(l:jobs, a:data.job_id)
   24                 0.000012000         return
  107                 0.000030000     endif
                                  
  107                 0.000168000     let l:job_type = remove(l:jobs, a:data.job_id)
                                  
  107                 0.000093000     if g:ale_history_enabled
  107   0.002866000   0.000339000         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                                  
                                          " Log the output of the command for ALEInfo if we should.
  107                 0.000134000         if g:ale_history_log_output && a:data.log_output is 1
  107   0.001406000   0.000331000             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
  107                 0.000046000         endif
  107                 0.000032000     endif
                                  
                                      " If the callback starts any new jobs, use the same job type for them.
  107                 0.000257000     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
  107   0.114757000   0.000618000     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                                  
  107                 0.000106000     let l:result = a:data.result
  107                 0.000108000     let l:result.value = l:value
                                  
                                      " Set the default cwd for this buffer in this call stack.
  107   0.001062000   0.000238000     call ale#command#SetCwd(a:buffer, l:result.cwd)
                                  
  107                 0.000035000     try
  107                 0.000176000         if get(l:result, 'result_callback', v:null) isnot v:null
                                              call call(l:result.result_callback, [l:value])
  107                 0.000035000         endif
  107                 0.000064000     finally
  107   0.000467000   0.000161000         call ale#command#ResetCwd(a:buffer)
  107                 0.000044000     endtry

FUNCTION  NERDTreeAddMenuItem()
    Defined: ~/.vim/bundle/nerdtree/plugin/NERD_tree.vim:176
Called 12 times
Total time:   0.000247000
 Self time:   0.000017000

count     total (s)      self (s)
   12   0.000245000   0.000015000     call g:NERDTreeMenuItem.Create(a:options)

FUNCTION  <SNR>127_highlight_range()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:122
Called 53 times
Total time:   0.002309000
 Self time:   0.000530000

count     total (s)      self (s)
                                      " Set all of the positions, which are chunked into Lists which
                                      " are as large as will be accepted by matchaddpos.
   53   0.002242000   0.000463000     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  <SNR>167_glbpath()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1595
Called 12 times
Total time:   0.000248000
 Self time:   0.000057000

count     total (s)      self (s)
   12   0.000243000   0.000052000 	retu call('ctrlp#utils#globpath', a:000)

FUNCTION  modes#OnOperatorComplete()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes.vim:45
Called 11 times
Total time:   0.000944000
 Self time:   0.000944000

count     total (s)      self (s)
   11                 0.000027000   g:modes_pending_operator = ''
   11                 0.000778000   highlight clear CursorLine

FUNCTION  <SNR>129_CtermToRGB()
    Defined: ~/.vim/bundle/modes.vim/autoload/modes/color.vim:32
Called 78 times
Total time:   0.000569000
 Self time:   0.000569000

count     total (s)      self (s)
                                      # Standard 256-color palette conversion
   78                 0.000068000     if cterm < 16
                                          # Standard 16 colors
   39                 0.000280000         var colors = [ [0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0], [0, 0, 128], [128, 0, 128], [0, 128, 128], [192, 192, 192], [128, 128, 128], [255, 0, 0], [0, 255, 0], [255, 255, 0], [0, 0, 255], [255, 0, 255], [0, 255, 255], [255, 255, 255] ]
                                          return colors[cterm]
                                      elseif cterm < 232
                                          # 216 color cube (6x6x6)
   39                 0.000008000         var idx = cterm - 16
   39                 0.000012000         var r = (idx / 36) * 51
   39                 0.000015000         var g = ((idx % 36) / 6) * 51
   39                 0.000012000         var b = (idx % 6) * 51
                                          return [r, g, b]
                                      else
                                          # Grayscale (24 shades)
                                          var gray = 8 + (cterm - 232) * 10
                                          return [gray, gray, gray]
                                      endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 1780 times
Total time:   0.025097000
 Self time:   0.025097000

count     total (s)      self (s)
 1780                 0.007680000   let ggvars = getbufvar(a:buffer, 'gitgutter')
 1780                 0.011320000   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
 1688                 0.003652000     return ggvars[a:varname]
   92                 0.000045000   endif
   92                 0.000084000   if a:0
   84                 0.000083000     return a:1
    8                 0.000005000   endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:83
Called 143 times
Total time:   0.021642000
 Self time:   0.021217000

count     total (s)      self (s)
  143                 0.000394000     let l:info = get(s:buffer_data, a:buffer, {})
                                  
  143                 0.000263000     if !empty(l:info) && empty(l:info.jobs)
                                          " We can't delete anything in a sandbox, so wait until we escape from
                                          " it to delete temporary files and directories.
  107   0.000544000   0.000119000         if ale#util#InSandbox()
                                              return
  107                 0.000026000         endif
                                  
                                          " Delete files with a call akin to a plan `rm` command.
  107                 0.000095000         for l:filename in l:info.file_list
                                              call delete(l:filename)
  107                 0.000042000         endfor
                                  
                                          " Delete directories like `rm -rf`.
                                          " Directories are handled differently from files, so paths that are
                                          " intended to be single files can be set up for automatic deletion
                                          " without accidentally deleting entire directories.
  238                 0.000196000         for l:directory in l:info.directory_list
  131                 0.018036000             call delete(l:directory, 'rf')
  238                 0.000149000         endfor
                                  
  107                 0.000223000         call remove(s:buffer_data, a:buffer)
  143                 0.000083000     endif

FUNCTION  <SNR>48_addtomrufs()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:68
Called 326 times
Total time:   0.255807000
 Self time:   0.155481000

count     total (s)      self (s)
  326                 0.033965000 	let fn = fnamemodify(a:fname, ':p')
  326                 0.003071000 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
  326                 0.110877000 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
  181                 0.000183000 	en
  181                 0.001762000 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
  181                 0.000234000 	if idx
   50                 0.001038000 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
   50                 0.000180000 		cal insert(s:mrufs, fn)
   50                 0.000201000 		if {s:soup} && idx < 0
   11   0.100837000   0.000511000 			cal s:savetofile(s:mergelists())
   50                 0.000046000 		en
  181                 0.000147000 	en

FUNCTION  ale#balloon#MessageForPos()
    Defined: ~/.vim/bundle/ale/autoload/ale/balloon.vim:4
Called 23 times
Total time:   0.003422000
 Self time:   0.001803000

count     total (s)      self (s)
   23   0.002298000   0.000679000     let l:set_balloons = ale#Var(a:bufnr, 'set_balloons')
   23                 0.000097000     let l:show_problems = 0
   23                 0.000056000     let l:show_hover = 0
                                  
   23                 0.000154000     if l:set_balloons is 1
                                          let l:show_problems = 1
                                          let l:show_hover = 1
   23                 0.000119000     elseif l:set_balloons is# 'hover'
                                          let l:show_hover = 1
   23                 0.000078000     endif
                                  
                                      " Don't show balloons if they are disabled, or linting is disabled.
   23                 0.000181000     if !(l:show_problems || l:show_hover)|| !g:ale_enabled|| !getbufvar(a:bufnr, 'ale_enabled', 1)
   23                 0.000057000         return ''
                                      endif
                                  
                                      if l:show_problems
                                          let l:loclist = get(g:ale_buffer_info, a:bufnr, {'loclist': []}).loclist
                                          let l:index = ale#util#BinarySearch(l:loclist, a:bufnr, a:lnum, a:col)
                                      endif
                                  
                                      " Show the diagnostics message if found, 'Hover' output otherwise
                                      if l:show_problems && l:index >= 0
                                          return l:loclist[l:index].text
                                      elseif l:show_hover && (   exists('*balloon_show')   || getbufvar(       a:bufnr,       'ale_set_balloons_legacy_echo',       get(g:, 'ale_set_balloons_legacy_echo', 0)   ))
                                          " Request LSP/tsserver hover information, but only if this version of
                                          " Vim supports the balloon_show function, or if we turned a legacy
                                          " setting on.
                                          call ale#hover#Show(a:bufnr, a:lnum, a:col, {'called_from_balloonexpr': 1})
                                      endif
                                  
                                      return ''

FUNCTION  gitgutter#highlight#define_sign_text_highlights()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/highlight.vim:147
Called 1 time
Total time:   0.000009000
 Self time:   0.000009000

count     total (s)      self (s)
                                    " Once a sign's text attribute has been defined, it cannot be undefined or
                                    " set to an empty value.  So to make signs' text disappear (when toggling
                                    " off or disabling) we make them invisible by setting their foreground colours
                                    " to the background's.
    1                 0.000001000   if g:gitgutter_signs
    1                 0.000001000     sign define GitGutterLineAdded                 texthl=GitGutterAdd
    1                 0.000001000     sign define GitGutterLineModified              texthl=GitGutterChange
    1                 0.000000000     sign define GitGutterLineRemoved               texthl=GitGutterDelete
    1                 0.000001000     sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
    1                 0.000001000     sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
    1                 0.000000000     sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
                                    else
                                      sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
                                      sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
                                      sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
                                      sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
                                      sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
                                      sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
    1                 0.000000000   endif

FUNCTION  copilot_chat#api#FetchModels()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/api.vim:136
Called 5 times
Total time:   2.583967000
 Self time:   0.003870000

count     total (s)      self (s)
    5                 0.000013000   var chat_headers = [
                                      'Content-Type: application/json',
                                      $'Authorization: Bearer {chat_token}',
                                      'Editor-Version: vscode/1.80.1'
                                    ]
                                  
    5   2.579191000   0.000127000   var response = Http('GET', 'https://api.githubcopilot.com/models', chat_headers, {})
    5                 0.000010000   var model_list = []
    4                 0.004074000   var json_response = json_decode(response)
    4                 0.000029000   for item in json_response.data
  132                 0.000220000     if has_key(item, 'id')
  132                 0.000112000       add(model_list, item.id)
  132                 0.000007000     endif
  132                 0.000014000   endfor
                                    return model_list

FUNCTION  <SNR>75_next_tick()
    Defined: ~/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim:264
Called 4 times
Total time:   0.000040000
 Self time:   0.000040000

count     total (s)      self (s)
    4                 0.000032000   call timer_start(1, {-> execute(a:cmd)})

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:431
Called 131 times
Total time:   0.001371000
 Self time:   0.001371000

count     total (s)      self (s)
  131                 0.000564000     let l:Cwd = get(a:linter, 'cwd', v:null)
                                  
  131                 0.000606000     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  ale#events#InsertLeaveEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim:136
Called 48 times
Total time:   0.329040000
 Self time:   0.005349000

count     total (s)      self (s)
                                      " Kill the InsertLeave emulation if the event fired.
                                      " If the ModeChanged event is available, it will be used instead of
                                      " a timer.
   48                 0.000519000     if !s:mode_changed_exists
                                          call timer_stop(s:insert_leave_timer)
   48                 0.000166000     endif
                                  
   48   0.003460000   0.000748000     if ale#Var(a:buffer, 'lint_on_insert_leave')
   48   0.306218000   0.000987000         call ale#Queue(0, '', a:buffer)
   48                 0.000037000     endif
                                  
                                      " Look for a warning to echo as soon as we leave Insert mode.
                                      " The script's position variable used when moving the cursor will
                                      " not be changed here.
                                      "
                                      " We don't echo this message in emulated insert leave mode, as the user
                                      " may want less work to happen on pressing <C-c> versus <Esc>
   48                 0.000273000     if exists('*ale#engine#Cleanup')
   48   0.016241000   0.000493000         call ale#cursor#EchoCursorWarning()
                                  
   48                 0.000250000         if g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor is# 1 || g:ale_virtualtext_cursor is# '1'
                                              " Show a virtualtext message if enabled.
                                              call ale#virtualtext#ShowCursorWarning()
   48                 0.000045000         endif
   48                 0.000040000     endif

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:376
Called 143 times
Total time:   0.007339000
 Self time:   0.007157000

count     total (s)      self (s)
  143                 0.000194000     let l:command_list = []
  143                 0.000205000     let l:is_dummy_sign_set = a:was_sign_set
                                  
                                      " Set the dummy sign if we need to.
                                      " The dummy sign is needed to keep the sign column open while we add
                                      " and remove signs.
  143                 0.000432000     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
   16   0.000163000   0.000097000         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
   16                 0.000010000         let l:is_dummy_sign_set = 1
  143                 0.000064000     endif
                                  
                                      " Place new items first.
  184                 0.000361000     for [l:line_str, l:info] in items(a:sign_map)
   41                 0.000025000         if l:info.new_id
                                              " Save the sign IDs we are setting back on our loclist objects.
                                              " These IDs will be used to preserve items which are set many times.
   74                 0.000043000             for l:item in l:info.items
   38                 0.000028000                 let l:item.sign_id = l:info.new_id
   74                 0.000023000             endfor
                                  
   36                 0.000041000             if index(l:info.current_id_list, l:info.new_id) < 0
   30   0.000221000   0.000132000                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
   36                 0.000021000             endif
   41                 0.000002000         endif
  184                 0.000131000     endfor
                                  
                                      " Remove signs without new IDs.
  184                 0.000289000     for l:info in values(a:sign_map)
   52                 0.000028000         for l:current_id in l:info.current_id_list
   11                 0.000010000             if l:current_id isnot l:info.new_id
    5   0.000021000   0.000015000                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
   11                 0.000006000             endif
   52                 0.000022000         endfor
  184                 0.000092000     endfor
                                  
                                      " Remove the dummy sign to close the sign column if we need to.
  143                 0.000199000     if l:is_dummy_sign_set && !g:ale_sign_column_always
   16   0.000069000   0.000048000         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
  143                 0.000062000     endif
                                  
  143                 0.000129000     return l:command_list

FUNCTION  140()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 91 times
Total time:   0.026735000
 Self time:   0.002791000

count     total (s)      self (s)
   91                 0.000094000     let l:result = ''
                                  
                                      " Build a label that identifies this TreeDirNode.
   91                 0.000087000     let l:label = ''
   91   0.021267000   0.000223000     let l:cascade = self.getCascade()
  182                 0.000182000     for l:dirNode in l:cascade
   91   0.002443000   0.000283000         let l:next = l:dirNode.path.displayString()
   91                 0.000288000         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
  182                 0.000100000     endfor
                                  
                                      " Select the appropriate open/closed status indicator symbol.
   91                 0.000326000     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
   91                 0.000194000     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
   91   0.001033000   0.000293000     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                                  
   91                 0.000150000     return l:symbol . l:flags . l:label

FUNCTION  <SNR>160_flush_buffer()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/parser.vim:28
Called 10 times
Total time:   0.001506000
 Self time:   0.001506000

count     total (s)      self (s)
   10                 0.000100000   let is_validation = index(['then', 'expect'], a:newlabel) >= 0
   10                 0.000053000   let fpos = a:fn.':'.a:lnum
                                  
   10                 0.000029000   if empty(a:label)
    5                 0.000011000     if is_validation
                                        echoerr 'Expect/Then should not appear before Do/Execute ('.fpos.')'
    5                 0.000006000     endif
    5                 0.000004000   else
    5                 0.000060000     let rev = reverse(copy(a:buffer))
    5                 0.000033000     while len(rev) > 0 && empty(rev[0])
                                        call remove(rev, 0)
    5                 0.000004000     endwhile
                                  
    5                 0.000178000     let data = map(reverse(rev), (a:case.raw ? 'v:val' : 'strpart(v:val, 2)'))
    5                 0.000018000     let a:case[a:label] = data
    5                 0.000012000     if !empty(a:buffer)
    5                 0.000026000       call remove(a:buffer, 0, -1)
    5                 0.000003000     endif
                                  
    5                 0.000030000     let fulfilled = has_key(a:case, 'do') || has_key(a:case, 'execute')
    5                 0.000007000     if is_validation
                                        if !fulfilled
                                          echoerr 'Expect/Then should not appear before Do/Execute ('.fpos.')'
                                        endif
                                        if has_key(a:case, a:newlabel)
                                          echoerr 'Expect/Then should appear only once for each Do/Execute ('.fpos.')'
                                        endif
    5                 0.000003000     endif
                                  
    5                 0.000023000     if a:final || a:newlabel == 'given' || index(['before', 'after', 'do', 'execute'], a:newlabel) >= 0 && fulfilled
    5                 0.000047000       call add(a:cases, deepcopy(a:case))
    5                 0.000032000       let new = { 'comment': {}, 'lnum': a:lnum, 'pending': 0 }
    5                 0.000026000       if !empty(get(a:case, 'type', ''))
                                          let new.type = a:case.type " To reuse Given block with type
    5                 0.000003000       endif
    5                 0.000054000       call extend(filter(a:case, '0'), new)
    5                 0.000004000     endif
   10                 0.000016000   endif
   10                 0.000051000   let a:case.raw = a:raw

FUNCTION  <SNR>167_modevar()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1899
Called 2 times
Total time:   0.000146000
 Self time:   0.000057000

count     total (s)      self (s)
    2   0.000018000   0.000010000 	let s:matchtype = s:mtype()
    2   0.000019000   0.000011000 	let s:ispath = s:ispathitem()
    2   0.000053000   0.000010000 	let s:mfunc = s:mfunc()
    2   0.000028000   0.000011000 	let s:nolim = s:getextvar('nolim')
    2   0.000020000   0.000007000 	let s:dosort = s:getextvar('sort')
    2                 0.000006000 	let s:spi = !s:itemtype || s:getextvar('specinput') > 0

FUNCTION  <SNR>48_chop()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:36
Called 11 times
Total time:   0.000121000
 Self time:   0.000121000

count     total (s)      self (s)
   11                 0.000099000 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
   11                 0.000013000 	retu a:mrufs

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:261
Called 230 times
Total time:   0.010593000
 Self time:   0.009381000

count     total (s)      self (s)
  230                 0.002022000     let l:info = get(s:buffer_data, a:buffer, {})
                                  
  230                 0.000572000     if !empty(l:info)
  165                 0.000346000         let l:new_map = {}
                                  
  189                 0.000852000         for [l:job_id, l:job_type] in items(l:info.jobs)
   24                 0.000037000             let l:job_id = str2nr(l:job_id)
                                  
   24                 0.000034000             if a:job_type is# 'all' || a:job_type is# l:job_type
   24   0.001271000   0.000059000                 call ale#job#Stop(l:job_id)
                                              else
                                                  let l:new_map[l:job_id] = l:job_type
   24                 0.000004000             endif
  189                 0.000198000         endfor
                                  
  165                 0.000823000         let l:info.jobs = l:new_map
  230                 0.000209000     endif

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:442
Called 143 times
Total time:   0.033161000
 Self time:   0.006473000

count     total (s)      self (s)
  143                 0.000552000     if !bufexists(str2nr(a:buffer))
                                          " Stop immediately when attempting to set signs for a buffer which
                                          " does not exist.
                                          return
  143                 0.000076000     endif
                                  
                                      " Find the current markers
  143   0.004927000   0.000655000     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                                  
                                      " Update the line numbers for items from before which may have moved.
  143   0.003753000   0.000650000     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                                  
                                      " Group items after updating the line numbers.
  143   0.003069000   0.000555000     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                                  
                                      " Build a map of current and new signs, with the lines as the keys.
  143   0.010098000   0.000638000     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                                  
  143   0.007996000   0.000657000     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                                  
                                      " Change the sign column color if the option is on.
  143                 0.000257000     if g:ale_change_sign_column_color && !empty(a:loclist)
                                          highlight clear SignColumn
                                          highlight link SignColumn ALESignColumnWithErrors
  143                 0.000057000     endif
                                  
  210                 0.000204000     for l:command in l:command_list
   67                 0.000171000         silent! execute l:command
  210                 0.000088000     endfor
                                  
                                      " Reset the sign column color when there are no more errors.
  143                 0.000206000     if g:ale_change_sign_column_color && empty(a:loclist)
                                          highlight clear SignColumn
                                          highlight link SignColumn ALESignColumnWithoutErrors
  143                 0.000048000     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:118
Called 1856 times
Total time:   0.320906000
 Self time:   0.228221000

count     total (s)      self (s)
 1856                 0.025301000     let l:buffer = bufnr('')
                                  
 1856                 0.010035000     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                          return
 1856                 0.004871000     endif
                                  
                                      " Only echo the warnings in normal mode, otherwise we will get problems.
 1856                 0.015758000     if mode(1) isnot# 'n'
   39                 0.000106000         return
 1817                 0.001817000     endif
                                  
 1817   0.056386000   0.021166000     call s:StopCursorTimer()
                                  
 1817                 0.027293000     let l:pos = getpos('.')[0:2]
                                  
 1817                 0.011114000     if !exists('w:last_pos')
   39                 0.000098000         let w:last_pos = [0, 0, 0]
 1817                 0.001950000     endif
                                  
                                      " Check the current buffer, line, and column number against the last
                                      " recorded position. If the position has actually changed, *then*
                                      " we should echo something. Otherwise we can end up doing processing
                                      " the echo message far too frequently.
 1817                 0.009072000     if l:pos != w:last_pos
 1623   0.075538000   0.018073000         let l:delay = ale#Var(l:buffer, 'echo_delay')
                                  
 1623                 0.006881000         let w:last_pos = l:pos
 1623                 0.019595000         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
 1817                 0.002138000     endif

FUNCTION  ctrlp#files()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:339
Called 2 times
Total time:   0.061839000
 Self time:   0.000288000

count     total (s)      self (s)
    2   0.000195000   0.000013000 	let cafile = ctrlp#utils#cachefile()
    2   0.000096000   0.000073000 	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
    1   0.000017000   0.000011000 		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                                  		" Get the list of files
    1                 0.000002000 		if empty(lscmd)
    1   0.000118000   0.000005000 			if !ctrlp#igncwd(s:dyncwd)
    1   0.055189000   0.000011000 				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
    1                 0.000000000 			en
                                  		el
                                  			sil! cal ctrlp#progress('Indexing...')
                                  			try | cal s:UserCmd(lscmd)
                                  			cat | retu [] | endt
    1                 0.000001000 		en
                                  		" Remove base directory
    1   0.000033000   0.000004000 		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
    1                 0.000001000 		if len(g:ctrlp_allfiles) <= s:compare_lim
    1   0.000374000   0.000059000 			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
    1                 0.000000000 		en
    1   0.005710000   0.000005000 		cal s:writecache(cafile)
    1                 0.000006000 		let catime = getftime(cafile)
    1                 0.000000000 	el
    1                 0.000008000 		let catime = getftime(cafile)
    1                 0.000012000 		if !( exists('s:initcwd') && s:initcwd == s:dyncwd ) || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                                  			let s:initcwd = s:dyncwd
                                  			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
    1                 0.000001000 		en
    2                 0.000000000 	en
    2                 0.000018000 	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
    2                 0.000001000 	retu g:ctrlp_allfiles

FUNCTION  ale_linters#vim#vinter#HandleOutput()
    Defined: ~/.vim/bundle/ale/ale_linters/vim/vinter.vim:24
Called 107 times
Total time:   0.002367000
 Self time:   0.002367000

count     total (s)      self (s)
  107                 0.000159000     try
  107                 0.001223000         let l:errors = json_decode(a:lines[0])
                                      catch
                                          return []
  107                 0.000039000     endtry
                                  
  107                 0.000290000     if !has_key(l:errors, 'summary')|| l:errors['summary']['offense_count'] == 0|| empty(l:errors['files'])
   93                 0.000041000         return []
   14                 0.000004000     endif
                                  
   14                 0.000011000     let l:output = []
                                  
   52                 0.000041000     for l:error in l:errors['files'][0]['offenses']
   38                 0.000045000         let l:start_col = l:error['location']['column'] + 0
   38                 0.000179000         call add(l:output, {   'lnum': l:error['location']['line'] + 0,   'col': l:start_col,   'end_col': l:start_col + l:error['location']['length'] - 1,   'code': l:error['cop_name'],   'text': l:error['message'],   'type': 'E'})
   52                 0.000019000     endfor
                                  
   14                 0.000009000     return l:output

FUNCTION  <SNR>86_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:44
Called 3771 times
Total time:   1.452791000
 Self time:   1.341597000

count     total (s)      self (s)
 3771                 0.028205000   if !exists("w:matchparen_ids")
   46                 0.000168000     let w:matchparen_ids = []
 3771                 0.004565000   endif
                                    " Remove any previous match.
 3771   0.112282000   0.023259000   call s:Remove_Matches()
                                  
                                    " Avoid that we remove the popup menu.
                                    " Return when there are no colors (looks like the cursor jumps).
 3771                 0.032879000   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                      return
 3771                 0.003276000   endif
                                  
                                    " Get the character under the cursor and check if it's in 'matchpairs'.
 3771                 0.019338000   let c_lnum = line('.')
 3771                 0.015075000   let c_col = col('.')
 3771                 0.007040000   let before = 0
                                  
 3771                 0.016775000   let text = getline(c_lnum)
 3771                 0.033845000   let c_before = text->strpart(0, c_col - 1)->slice(-1)
 3771                 0.022885000   let c = text->strpart(c_col - 1)->slice(0, 1)
 3771                 0.096695000   let plist = split(&matchpairs, '.\zs[:,]')
 3771                 0.020990000   let i = index(plist, c)
 3771                 0.007198000   if i < 0
                                      " not found, in Insert mode try character before the cursor
 3521                 0.023333000     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  786                 0.002622000       let before = strlen(c_before)
  786                 0.001284000       let c = c_before
  786                 0.002189000       let i = index(plist, c)
 3521                 0.003563000     endif
 3521                 0.005818000     if i < 0
                                        " not found, nothing to do
 3500                 0.006406000       return
   21                 0.000013000     endif
  271                 0.000321000   endif
                                  
                                    " Figure out the arguments for searchpairpos().
  271                 0.000617000   if i % 2 == 0
   48                 0.000106000     let s_flags = 'nW'
   48                 0.000232000     let c2 = plist[i + 1]
  223                 0.000328000   else
  223                 0.000476000     let s_flags = 'nbW'
  223                 0.000443000     let c2 = c
  223                 0.000903000     let c = plist[i - 1]
  271                 0.000251000   endif
  271                 0.000703000   if c == '['
   20                 0.000042000     let c = '\['
   20                 0.000037000     let c2 = '\]'
  271                 0.000230000   endif
                                  
                                    " Find the match.  When it was just before the cursor move it there for a
                                    " moment.
  271                 0.000446000   if before > 0
   21                 0.000099000     let has_getcurpos = exists("*getcurpos")
   21                 0.000026000     if has_getcurpos
                                        " getcurpos() is more efficient but doesn't exist before 7.4.313.
   21                 0.000065000       let save_cursor = getcurpos()
                                      else
                                        let save_cursor = winsaveview()
   21                 0.000015000     endif
   21                 0.000085000     call cursor(c_lnum, c_col - before)
  271                 0.000311000   endif
                                  
  271                 0.002847000   if !has("syntax") || !exists("g:syntax_on")
                                      let s_skip = "0"
  271                 0.000236000   else
                                      " Build an expression that detects whether the current cursor position is
                                      " in certain syntax types (string, comment, etc.), for use as
                                      " searchpairpos()'s skip argument.
                                      " We match "escape" for special items, such as lispEscapeSpecial, and
                                      " match "symbol" for lispBarSymbol.
  271                 0.002026000     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                      " If executing the expression determines that the cursor is currently in
                                      " one of the syntax types, then we want searchpairpos() to find the pair
                                      " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                      " outside of the syntax types and s_skip should keep its value so we skip
                                      " any matching pair inside the syntax types.
                                      " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  271                 0.000522000     try
  271   0.336232000   0.328456000       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                      catch /^Vim\%((\a\+)\)\=:E363/
                                        " We won't find anything, so skip searching, should keep Vim responsive.
                                        return
  271                 0.000501000     endtry
  271                 0.000207000   endif
                                  
                                    " Limit the search to lines visible in the window.
  271                 0.002174000   let stoplinebottom = line('w$')
  271                 0.001057000   let stoplinetop = line('w0')
  271                 0.000504000   if i % 2 == 0
   48                 0.000098000     let stopline = stoplinebottom
  223                 0.000197000   else
  223                 0.000483000     let stopline = stoplinetop
  271                 0.000207000   endif
                                  
                                    " Limit the search time to 300 msec to avoid a hang on very long lines.
                                    " This fails when a timeout is not supported.
  271                 0.001238000   if mode() == 'i' || mode() == 'R'
   98                 0.000652000     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  173                 0.000141000   else
  173                 0.001529000     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  271                 0.000224000   endif
  271                 0.000267000   try
  271   0.491318000   0.476923000     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                                    catch /E118/
                                      " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                      " a long time on closed folds and long lines.
                                      " The "viewable" variables give a range in which we can scroll while
                                      " keeping the cursor at the same position.
                                      " adjustedScrolloff accounts for very large numbers of scrolloff.
                                      let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                      let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                      let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                      " one of these stoplines will be adjusted below, but the current values are
                                      " minimal boundaries within the current window
                                      if i % 2 == 0
                                        if has("byte_offset") && has("syntax_items") && &smc > 0
                                  	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                                  	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                        else
                                  	let stopline = min([bottom_viewable, c_lnum + 100])
                                        endif
                                        let stoplinebottom = stopline
                                      else
                                        if has("byte_offset") && has("syntax_items") && &smc > 0
                                  	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                                  	let stopline = max([top_viewable, byte2line(stopbyte)])
                                        else
                                  	let stopline = max([top_viewable, c_lnum - 100])
                                        endif
                                        let stoplinetop = stopline
                                      endif
                                      let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  271                 0.000393000   endtry
                                  
  271                 0.000438000   if before > 0
   21                 0.000026000     if has_getcurpos
   21                 0.000086000       call setpos('.', save_cursor)
                                      else
                                        call winrestview(save_cursor)
   21                 0.000007000     endif
  271                 0.000182000   endif
                                  
                                    " If a match is found setup match highlighting.
  271                 0.000959000   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  260                 0.000512000     if s:has_matchaddpos
  260                 0.009758000       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                      else
                                        exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                        call add(w:matchparen_ids, 3)
  260                 0.000211000     endif
  260                 0.000580000     let w:paren_hl_on = 1
  271                 0.000187000   endif

FUNCTION  149()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim:278
Called 22 times
Total time:   0.011946000
 Self time:   0.007834000

count     total (s)      self (s)
                                  
                                      " Construct a path specification such that globpath() will return
                                      " relative pathnames, if possible.
   22   0.002914000   0.000915000     if self.path.str() ==# getcwd()
   10                 0.000019000         let l:pathSpec = ','
   12                 0.000009000     else
   12   0.002501000   0.000545000         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                                  
   12   0.000115000   0.000039000         if nerdtree#runningWindows()
                                              let l:pathSpec = substitute(l:pathSpec, "\\[\\(.*\\]\\)", "[[]\\1", "g")
   12                 0.000009000         endif
                                  
                                          " On Windows, the drive letter may be removed by "fnamemodify()".
   12   0.000132000   0.000051000         if nerdtree#runningWindows() && l:pathSpec[0] == nerdtree#slash()
                                              let l:pathSpec = self.path.drive . l:pathSpec
   12                 0.000009000         endif
   22                 0.000015000     endif
                                  
   22                 0.000030000     let l:globList = []
                                  
                                      " See ':h version7.txt' and ':h version8.txt' for details on the
                                      " development of the glob() and globpath() functions.
   22                 0.000070000     if v:version > 704 || (v:version ==# 704 && has('patch654'))
   22                 0.004201000         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                      elseif v:version ==# 704 && has('patch279')
                                          let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                      elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
                                          let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                          let l:globList = split(l:globString, "\n")
                                      else
                                          let l:globString = globpath(l:pathSpec, a:pattern)
                                          let l:globList = split(l:globString, "\n")
   22                 0.000017000     endif
                                  
                                      " If a:all is false, filter '.' and '..' from the output.
   22                 0.000023000     if !a:all
   11                 0.000017000         let l:toRemove = []
                                  
   22                 0.000035000         for l:file in l:globList
   22                 0.000067000             let l:tail = fnamemodify(l:file, ':t')
                                  
                                              " If l:file has a trailing slash, then its :tail will be ''. Use
                                              " :h to drop the slash and the empty string after it; then use :t
                                              " to get the directory name.
   22                 0.000030000             if l:tail ==# ''
                                                  let l:tail = fnamemodify(l:file, ':h:t')
   22                 0.000014000             endif
                                  
   22                 0.000043000             if l:tail ==# '.' || l:tail ==# '..'
   22                 0.000067000                 call add(l:toRemove, l:file)
   22                 0.000051000                 if len(l:toRemove) ==# 2
   11                 0.000009000                     break
   11                 0.000010000                 endif
   11                 0.000007000             endif
   22                 0.000024000         endfor
                                  
   33                 0.000041000         for l:file in l:toRemove
   22                 0.000103000             call remove(l:globList, index(l:globList, l:file))
   33                 0.000022000         endfor
   22                 0.000014000     endif
                                  
   22                 0.000029000     return l:globList

FUNCTION  <SNR>34_HighlightCodeBlock()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/buffer.vim:308
Called 50 times
Total time:   0.057888000
 Self time:   0.057888000

count     total (s)      self (s)
   50                 0.000029000   var lang: string = lang_arg
   50                 0.000105000   if lang ==# 'js'
                                      lang = 'javascript'
                                    elseif lang ==# 'ts'
                                      lang = 'typescript'
                                    elseif lang ==# 'py'
                                      lang = 'python'
                                    endif
                                  
   50                 0.015388000   var syntax_file: string = findfile('syntax/' .. lang .. '.vim', &runtimepath)
   50                 0.000059000   if !syntax_file->empty()
   50                 0.000180000     if index(b:added_syntaxes, '@' .. lang) == -1
    1                 0.000023000       if exists('b:current_syntax')
                                          unlet b:current_syntax
                                        endif
    1                 0.039403000       execute $'syntax include @{lang} syntax/{lang}.vim'
                                  
    1                 0.000003000       add(b:added_syntaxes, '@' .. lang)
    1                 0.000000000     endif
                                      # Define syntax region for this specific code block
   50                 0.000283000     var cmd: string = $'syntax region CopilotCode_{lang}_{block_id}'
   50                 0.000150000     cmd ..= ' start=/\%' .. (start_line + 1) .. 'l/'
   50                 0.000128000     cmd ..= ' end=/\%' .. (end_line + 1) .. 'l/'
   50                 0.000081000     cmd ..= ' contains=@' .. lang
   50                 0.001735000     execute cmd
   50                 0.000006000   endif

FUNCTION  <SNR>101_NonCommentedMatch()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1172
Called 13 times
Total time:   0.001320000
 Self time:   0.001320000

count     total (s)      self (s)
                                      # Could happen if there is no code above us, and we're not on the 1st line.
                                      # In that case, `PrevCodeLine()` returns `{lnum: 0, line: ''}`.
   13                 0.000003000     if line.lnum == 0
                                          return false
                                      endif
                                  
                                      # Technically, that's wrong.  A  line might start with a range  and end with a
                                      # line continuation symbol.  But it's unlikely.  And it's useful to assume the
                                      # opposite because it  prevents us from conflating a mark  with an operator or
                                      # the start of a list:
                                      #
                                      #              not a comparison operator
                                      #              v
                                      #     :'< mark <
                                      #     :'< mark [
                                      #              ^
                                      #              not the start of a list
   13                 0.000035000     if line.text =~ RANGE_AT_SOL
                                          return false
                                      endif
                                  
                                      #                    that's not an arithmetic operator
                                      #                    v
                                      #     catch /pattern /
                                      #
                                      # When `/` is used as a pattern delimiter, it's always present twice.
                                      # And  usually, the  first occurrence  is  in the  middle of  a sequence  of
                                      # non-whitespace characters.  If we can find  such a `/`, we assume that the
                                      # trailing `/` is not an operator.
                                      # Warning: Here, don't use a too complex pattern.{{{
                                      #
                                      # In particular, avoid backreferences.
                                      # For example, this would be too costly:
                                      #
                                      #     if line.text =~ $'\%(\S*\({PATTERN_DELIMITER}\)\S\+\|\S\+\({PATTERN_DELIMITER}\)\S*\)'
                                      #             .. $'\s\+\1{END_OF_COMMAND}'
                                      #
                                      # Sometimes, it could even give `E363`.
                                      #}}}
   13                 0.000201000     var delim: string = line.text
                                          ->matchstr($'\s\+\zs{PATTERN_DELIMITER}\ze{END_OF_COMMAND}')
   13                 0.000002000     if !delim->empty()
                                          delim = $'\V{delim}\m'
                                          if line.text =~ $'\%(\S*{delim}\S\+\|\S\+{delim}\S*\)\s\+{delim}{END_OF_COMMAND}'
                                              return false
                                          endif
                                      endif
                                      # TODO: We might still miss some corner cases:{{{
                                      #
                                      #                          conflated with arithmetic division
                                      #                          v
                                      #     substitute/pat / rep /
                                      #         echo
                                      #     ^--^
                                      #      ✘
                                      #
                                      # A better way to handle all these corner cases, would be to inspect the top
                                      # of the syntax stack:
                                      #
                                      #     :echo synID('.', col('.'), v:false)->synIDattr('name')
                                      #
                                      # Unfortunately, the legacy syntax plugin is not accurate enough.
                                      # For example, it doesn't highlight a slash as an operator.
                                      # }}}
                                  
                                      # `%` at the end of a line is tricky.
                                      # It might be the modulo operator or the current file (e.g. `edit %`).
                                      # Let's assume it's the latter.
   13                 0.000048000     if line.text =~ $'%{END_OF_COMMAND}'
                                          return false
                                      endif
                                  
   13                 0.000369000     if line.text =~ TRICKY_COMMANDS
                                          return false
                                      endif
                                  
   13                 0.000004000     var pos: list<number> = getcurpos()
   13                 0.000008000     cursor(line.lnum, 1)
   13                 0.000619000     var match_lnum: number = search(pat, 'cnW', line.lnum, TIMEOUT, (): bool => InCommentOrString())
   13                 0.000008000     setpos('.', pos)
                                      return match_lnum > 0

FUNCTION  VimFtpluginUndo()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/ftplugin/vim.vim:20
Called 4 times
Total time:   0.000497000
 Self time:   0.000497000

count     total (s)      self (s)
    4                 0.000296000     setl fo< isk< com< tw< commentstring< include< define<
    4                 0.000020000     if exists('b:did_add_maps')
    4                 0.000034000       silent! nunmap <buffer> [[
    4                 0.000018000       silent! vunmap <buffer> [[
    4                 0.000008000       silent! nunmap <buffer> ]]
    4                 0.000009000       silent! vunmap <buffer> ]]
    4                 0.000009000       silent! nunmap <buffer> []
    4                 0.000007000       silent! vunmap <buffer> []
    4                 0.000008000       silent! nunmap <buffer> ][
    4                 0.000007000       silent! vunmap <buffer> ][
    4                 0.000017000       silent! nunmap <buffer> ]"
    4                 0.000008000       silent! vunmap <buffer> ]"
    4                 0.000008000       silent! nunmap <buffer> ["
    4                 0.000006000       silent! vunmap <buffer> ["
    4                 0.000004000     endif
    4                 0.000018000     unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps

FUNCTION  <SNR>86_Remove_Matches()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:202
Called 4071 times
Total time:   0.096055000
 Self time:   0.096055000

count     total (s)      self (s)
 4071                 0.021183000   if exists('w:paren_hl_on') && w:paren_hl_on
  520                 0.002355000     while !empty(w:matchparen_ids)
  260                 0.002686000       silent! call remove(w:matchparen_ids, 0)->matchdelete()
  520                 0.000861000     endwhile
  260                 0.000727000     let w:paren_hl_on = 0
 4071                 0.003740000   endif

FUNCTION  <SNR>167_unmarksigns()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1659
Called 6 times
Total time:   0.000070000
 Self time:   0.000032000

count     total (s)      self (s)
    6   0.000063000   0.000025000 	if !s:dosigns() | retu | en
                                  	for key in keys(s:marked)
                                  		exe 'sign unplace' key 'buffer='.s:bufnr
                                  	endfo

FUNCTION  <SNR>120_build_command()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 101 times
Total time:   0.000605000
 Self time:   0.000605000

count     total (s)      self (s)
  101                 0.000244000   if has('unix')
  101                 0.000233000     return ['sh', '-c', a:cmd]
                                    endif
                                  
                                    if has('win32')
                                      return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                                    endif
                                  
                                    throw 'unknown os'

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:235
Called 93 times
Total time:   0.020041000
 Self time:   0.001659000

count     total (s)      self (s)
   93                 0.000098000   let modified_lines = []
  304                 0.000225000   for hunk in a:hunks
  211   0.019181000   0.000799000     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
  304                 0.000131000   endfor
   93                 0.000065000   return modified_lines

FUNCTION  <SNR>161_action()
    Defined: ~/.vim/bundle/vader.vim/autoload/vader/window.vim:169
Called 2 times
Total time:   0.000203000
 Self time:   0.000203000

count     total (s)      self (s)
    2                 0.000024000   if has_key(b:vader_data, a:line)
                                      let data = b:vader_data[a:line]
                                      if has_key(data, 'expect')
                                        tabnew
                                        call s:scratch(data.type, data.expect, '[Vader-expected]')
                                  
                                        vertical botright new
                                        call s:scratch(data.type, data.got, '[Vader-got]')
                                  
                                        redraw
                                        echo "Press 'q' to close"
                                      endif
    2                 0.000002000   else
    2                 0.000098000     execute "normal! \<CR>"
    2                 0.000002000   endif

FUNCTION  ctrlp#setdir()
    Defined: ~/.vim/bundle/ctrlp.vim/autoload/ctrlp.vim:1589
Called 2 times
Total time:   0.000347000
 Self time:   0.000255000

count     total (s)      self (s)
    2                 0.000004000 	let cmd = a:0 ? a:1 : 'lc!'
    2   0.000257000   0.000165000 	sil! exe cmd s:fnesc(a:path, 'c')
    2                 0.000084000 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]

FUNCTION  <SNR>101_AtStartOfBracketBlock()
    Defined: /opt/homebrew/Cellar/macvim/9.1.0727/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/vimindent.vim:1015
Called 3 times
Total time:   0.014477000
 Self time:   0.000064000

count     total (s)      self (s)
                                      # We  ignore bracket  blocks  while we're  indenting  a function  header
                                      # because  it makes  the logic  simpler.  It  might mean  that we  don't
                                      # indent correctly a  multiline bracket block inside  a function header,
                                      # but that's  a corner case for  which it doesn't seem  worth making the
                                      # code more complex.
    3                 0.000006000     if exists('b:vimindent')
                                              && !b:vimindent->has_key('is_BracketBlock')
                                          return false
                                      endif
                                  
    3                 0.000009000     var pos: list<number> = getcurpos()
    3                 0.000019000     cursor(line_A.lnum, [line_A.lnum, '$']->col())
                                  
    3   0.014424000   0.000011000     if SearchPair(OPENING_BRACKET, '', CLOSING_BRACKET, 'bcW', line_A.lnum) <= 0
    3                 0.000004000         setpos('.', pos)
                                          return false
                                      endif
                                      # Don't restore the cursor position.
                                      # It needs to be on a bracket for `CacheBracketBlock()` to work as intended.
                                  
                                      return line_A->EndsWithOpeningBracket()
                                          || line_A->EndsWithCommaOrDictKey()
                                          || line_A->EndsWithLambdaArrow()

FUNCTION  <SNR>33_HandleJobClose()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/api.vim:76
Called 4 times
Total time:   0.016785000
 Self time:   0.016077000

count     total (s)      self (s)
    4                 0.000168000   deletebufline(g:copilot_chat_active_buffer, '$')
    4                 0.000003000   var result = ''
    4                 0.000010000   for line in curl_output
 1264                 0.003010000     if line =~? '^data: {'
  629                 0.009093000       var json_completion = json_decode(strcharpart(line, 6))
  629                 0.000028000       try
  629                 0.000268000         var content = json_completion.choices[0].delta.content
  627                 0.000151000         if type(content) != type(v:null)
  625                 0.000552000           result ..= content
  625                 0.000026000         endif
    2                 0.000009000       catch
    2                 0.000001000         result ..= "\n"
  629                 0.000033000       endtry
  629                 0.000082000     elseif line =~? 'error'
                                        result ..= line
                                      endif
 1264                 0.000792000   endfor
                                  
    4                 0.000089000   var response = split(result, "\n")
    4                 0.000176000   var width = winwidth(0) - 2 - getwininfo(win_getid())[0].textoff
    4                 0.000003000   var separator = ' '
    4                 0.000013000   separator ..= repeat('━', width)
    4                 0.000006000   var response_start = line('$') + 1
                                  
    4   0.000181000   0.000037000   _buffer.AppendMessage(separator)
    4   0.000039000   0.000013000   _buffer.AppendMessage(response)
    4   0.000149000   0.000011000   _buffer.AddInputSeparator()
                                  
    4                 0.000002000   var wrap_width = width + 2
    4                 0.000000000   var softwrap_lines = 0
    4                 0.000003000   for line in response
   89                 0.000035000     if strwidth(line) > wrap_width
    6                 0.000009000       softwrap_lines += float2nr(ceil(strwidth(line) / wrap_width))
    6                 0.000000000     else
   83                 0.000006000       softwrap_lines += 1
   83                 0.000004000     endif
   89                 0.000011000   endfor
                                  
    4                 0.000002000   var total_response_length = softwrap_lines + 2
    4                 0.000003000   var height = winheight(0)
    4                 0.000003000   if total_response_length >= height
    2                 0.000255000     execute 'normal ' .. response_start .. 'Gzt'
    2                 0.000000000   else
    2   0.000550000   0.000150000     execute 'normal G'
    2                 0.000000000   endif
    4                 0.000010000   setcursorcharpos(0, 3)

FUNCTION  nerdtree#caseSensitiveFS()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim:222
Called 271 times
Total time:   0.002555000
 Self time:   0.001926000

count     total (s)      self (s)
  271   0.002422000   0.001793000     return g:NERDTreeCaseSensitiveFS == 1 ||((g:NERDTreeCaseSensitiveFS == 2 || g:NERDTreeCaseSensitiveFS == 3) &&nerdtree#osDefaultCaseSensitiveFS())

FUNCTION  <SNR>113_HandleExit()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:151
Called 107 times
Total time:   0.114139000
 Self time:   0.003285000

count     total (s)      self (s)
  107                 0.000238000     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                                  
  107                 0.000109000     if empty(l:buffer_info)
                                          return
  107                 0.000033000     endif
                                  
  107                 0.000107000     let l:linter = a:job_info.linter
  107                 0.000111000     let l:executable = a:job_info.executable
                                  
                                      " Remove this job from the list.
  107   0.000686000   0.000277000     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                                  
                                      " Stop here if we land in the handle for a job completing if we're in
                                      " a sandbox.
  107   0.001833000   0.000159000     if ale#util#InSandbox()
                                          return
  107                 0.000027000     endif
                                  
  107                 0.000359000     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                          call remove(a:output, -1)
  107                 0.000030000     endif
                                  
  107                 0.000038000     try
  107   0.003237000   0.000544000         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                      " Handle the function being unknown, or being deleted.
                                      catch /E700/
                                          let l:loclist = []
  107                 0.000029000     endtry
                                  
  107                 0.000141000     if type(l:loclist) isnot# v:t_list
                                          " we only expect the list type; don't pass anything else down to
                                          " `ale#engine#HandleLoclist` since it won't understand it
                                          let l:loclist = []
  107                 0.000025000     endif
                                  
  107   0.106371000   0.000293000     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 93 times
Total time:   0.003517000
 Self time:   0.000643000

count     total (s)      self (s)
   93   0.002015000   0.000365000   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   93   0.001462000   0.000238000   call s:reset_summary(a:bufnr)

FUNCTION  copilot_chat#config#CreateDataDir()
    Defined: ~/.vim/bundle/copilot-chat.vim/autoload/copilot_chat/config.vim:15
Called 1 time
Total time:   0.000011000
 Self time:   0.000011000

count     total (s)      self (s)
    1                 0.000009000   if !isdirectory(g:copilot_chat_data_dir)
                                      mkdir(g:copilot_chat_data_dir, 'p')
                                    endif

FUNCTIONS SORTED ON TOTAL TIME
count     total (s)      self (s)  function
    6   3.053036000                copilot_chat#api#Http()
    5   2.583967000   0.003870000  copilot_chat#api#FetchModels()
    4   2.272209000   1.174156000  copilot_chat#api#AsyncRequest()
    2   2.258042000   0.000000000  copilot_chat#SubmitMessage()
 3771   1.452791000   1.341597000  <SNR>86_Highlight_Matching_Pair()
  310   1.068198000   0.038709000  gitgutter#process_buffer()
  203   1.033988000   0.038274000  <SNR>106_Lint()
    3   0.861720000   0.000068000  copilot_chat#OpenChat()
  167   0.860619000   0.011431000  ale#engine#RunLinters()
  167   0.838600000   0.017574000  <SNR>113_GetLintFileValues()
   93   0.830309000   0.028936000  gitgutter#diff#run_diff()
  167   0.816015000   0.018289000  <SNR>113_RunLinters()
  167   0.716737000   0.006317000  <SNR>113_RunLinter()
   55   0.671602000   0.653060000  <SNR>167_BuildPrompt()
  289   0.644368000   0.018528000  ale#Queue()
  131   0.643202000   0.012306000  <SNR>113_RunIfExecutable()
  131   0.624638000   0.019943000  <SNR>113_RunJob()
  131   0.591703000   0.040275000  ale#command#Run()
   53   0.588925000   0.000238000  <SNR>167_PrtFocusMap()
   53   0.588687000   0.000623000  <SNR>167_PrtAdd()

FUNCTIONS SORTED ON SELF TIME
count     total (s)      self (s)  function
    6                 3.053036000  copilot_chat#api#Http()
 3771   1.452791000   1.341597000  <SNR>86_Highlight_Matching_Pair()
    4   2.272209000   1.174156000  copilot_chat#api#AsyncRequest()
   55   0.671602000   0.653060000  <SNR>167_BuildPrompt()
   93                 0.502379000  <SNR>122_write_buffer()
  131   0.361596000   0.352046000  ale#job#Start()
   40   0.375603000   0.306328000  <SNR>34_ApplyCodeBlockSyntaxImpl()
 6276                 0.300124000  <SNR>34_UpdateWaitingDots()
  101   0.243607000   0.233624000  gitgutter#async#execute()
 1856   0.320906000   0.228221000  ale#cursor#EchoCursorWarningWithDelay()
 2193   0.281922000   0.206871000  ale#ShouldDoNothing()
   11                 0.188234000  nerdtree#echo()
   55   0.180461000   0.167305000  <SNR>13_LoadFTPlugin()
  326   0.255807000   0.155481000  <SNR>48_addtomrufs()
 1811   0.466578000   0.137161000  ale#cursor#EchoCursorWarning()
  217   0.137662000   0.112562000  133()
   14   0.111462000   0.111169000  ctrlp#utils#writecache()
 4071                 0.096055000  <SNR>86_Remove_Matches()
 4104                 0.092108000  ale#Var()
  696                 0.087673000  <SNR>76_abs_path()

